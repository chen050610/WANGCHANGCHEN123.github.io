
<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8" />
    <title>JavaWeb | 哈哈哈哈哈哈哈重生之我是兵王</title>
    <meta name="author" content="chenw" />
    <meta name="description" content="description" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
	<canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
	<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
	<script src="/js/fireworks.min.js"></script>
	<canvas id="background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
	<script src="/js/background.min.js"></script>
	<div id="cursor"></div>
	<link rel="stylesheet" href="/css/cursor.min.css">
	<script src="/js/cursor.min.js"></script>
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>哈哈哈哈哈哈哈重生之我是兵王</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;哈哈哈哈哈哈哈重生之我是兵王</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>JavaWeb</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/4/9
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <p>摘要</p>
<span id="more"></span>

<p>内容</p>
<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><p><strong>Tomcat10</strong></p>
<pre><code>概述
    当前应用最广的javaweb服务器
</code></pre>
<p><strong>Tomcat的安装</strong></p>
<p>启动的程序</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409182153653.png" alt="image-20240409182153653"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409182306593.png" alt="image-20240409182306593"></p>
<p>这里面是关闭的脚本</p>
<p>解决乱码的问题</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409182506427.png" alt="image-20240409182506427"></p>
<p>换成GBK</p>
<p>这样就没有乱码的问题</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409182549021.png" alt="image-20240409182549021"></p>
<p><strong>Tomcat目录的解释</strong></p>
<p>配置在控制台启动</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409183429246.png" alt="image-20240409183429246"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409183441479.png" alt="image-20240409183441479"></p>
<p>注意这样配置完以后可以在</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409183514187.png" alt="image-20240409183514187"></p>
<p>这里面启动，但是 如果我们有很多版本的tomcat的话</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409183555360.png" alt="image-20240409183555360"></p>
<p>我在这里面启动的话也是启用的之前的环境变量的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409183611535.png" alt="image-20240409183611535"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409183815033.png" alt="image-20240409183815033"></p>
<p>用于配置启动的端口和</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409183858080.png" alt="image-20240409183858080"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409184029699.png" alt="image-20240409184029699"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409184107210.png" alt="image-20240409184107210"></p>
<p>我们的项目放在webapps</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409184133869.png" alt="image-20240409184133869"></p>
<p>日志文件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409184217666.png" alt="image-20240409184217666"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409184253632.png" alt="image-20240409184253632"></p>
<pre><code>work主要用于jsp的技术
</code></pre>
<p><strong>WEB项目的标准结构</strong></p>
<p>一般的目录结构</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409184735710.png" alt="image-20240409184735710"></p>
<pre><code>WEB-INF目录
    这下面的资源是受保护的资源，是不可以通过浏览器访问的资源
    一般的该目录下的文件为
    class文件，一般存放，我们我们写的java代码经过编译以后的class文件
    lib目录，第三方的jar往这里面放
    web.xml,当前项目的配置文件
</code></pre>
<p>​	</p>
<p><strong>Tomcat部署项目的方式</strong></p>
<ul>
<li>放在webapps目录下</li>
<li>或者在tomcat的conf下创建Catalina&#x2F;localhost目录，并且在该目录下准备xml文件,使用配置文件的方式告诉项目的文件在哪里，配置文件的名字最好还是和项目的名字保持一致</li>
</ul>
<pre><code class="xml">&lt;Context path=&quot;/path&quot; docBase=&quot;项目的路径&quot;&gt;//前面是路径后面是项目的访问路径
</code></pre>
<p>对应的规则</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409185930918.png" alt="image-20240409185930918"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409190216537.png" alt="image-20240409190216537"></p>
<p>这里是管理页面</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409190232342.png" alt="image-20240409190232342"></p>
<p>我们需要进行登录，这个账号和密码需要配置</p>
<p>在这个文件里</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409190709792.png" alt="image-20240409190709792"></p>
<p>添加</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409190737829.png" alt="image-20240409190737829"></p>
<p>这样就可以登录了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409190800542.png" alt="image-20240409190800542"></p>
<p>还有一个host-manager</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409190913323.png" alt="image-20240409190913323"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409191348619.png" alt="image-20240409191348619"></p>
<p>访问这个需要配置</p>
<pre><code class="xml">              &lt;role rolename=&quot;admin-gui&quot;/&gt;
            &lt;user username=&quot;admin&quot; password=&quot;admin&quot; roles=&quot;admin-gui&quot;/&gt;
</code></pre>
<p><strong>IDEA关联Tomcat</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409205105112.png" alt="image-20240409205105112"></p>
<pre><code>1.建立tomcat和idea的关联
2.使用idea创建一个javaweb工程，在web工程中开发代码
3.使用idea将工程构建成一个可以发布的app
4.使用idea将构建好的app部署在tomcat里面，启动运行
</code></pre>
<p>关闭项目，打开所有设置</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409205600200.png" alt="image-20240409205600200"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409205642137.png" alt="image-20240409205642137"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409205725022.png" alt="image-20240409205725022"></p>
<ul>
<li>创建web工程</li>
</ul>
<p>创建的项目</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409210258527.png" alt="image-20240409210258527"></p>
<p>添加tomcat的依赖</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409210734501.png" alt="image-20240409210734501"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409210753026.png" alt="image-20240409210753026"></p>
<pre><code>在这里面添加tomcat的依赖
</code></pre>
<p>然后，这样我们的工程这个就是5.0，一定按上面的操作</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409210850217.png" alt="image-20240409210850217"></p>
<p>生成了web目录</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409211006418.png" alt="image-20240409211006418"></p>
<pre><code>这样我们的java项目就是javaweb的项目
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409211056040.png" alt="image-20240409211056040"></p>
<pre><code>js，css的代码放在web的里面
src下方面放的是java的代码
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409212155609.png" alt="image-20240409212155609"></p>
<p>在这里构建</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409212238126.png" alt="image-20240409212238126"></p>
<p>然后</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409212307488.png" alt="image-20240409212307488"></p>
<p>这个我们可以获取部署在tomcat的上面的项目</p>
<p>然后怎么向tomcat里面方？</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409212608088.png" alt="image-20240409212608088"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409212616202.png" alt="image-20240409212616202"></p>
<p>选择tomcat</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409212655232.png" alt="image-20240409212655232"></p>
<pre><code>下面是访问的路径
</code></pre>
<p>IDEA是怎么使用tomcat运行项目</p>
<pre><code> 运行的时候发现，tomcat的webapps里面的目录下并没有
 也没有配置文件，那么怎么实现的
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409213421480.png" alt="image-20240409213421480"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409213617906.png" alt="image-20240409213617906"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409215139099.png" alt="image-20240409215139099"></p>
<p><strong>Servlet</strong></p>
<pre><code>动态资源和静态资源
</code></pre>
<ul>
<li><p>静态资源</p>
<pre><code>无需在程序运行是通过代码生成的资源，在程序运行之前就写好的资源，例如html,css,img，音频文件和视频文件
</code></pre>
</li>
<li><p>动态资源</p>
<pre><code>需要程序运行是通过代码运行生成的资源，在程序运行的之前无法确定的数据，运行时动态生成的
</code></pre>
</li>
</ul>
<p><strong>Servlet的简介</strong></p>
<p>如果是静态资源</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409220318487.png" alt="image-20240409220318487"></p>
<p>如果是资源的话</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409220407034.png" alt="image-20240409220407034"></p>
<pre><code>servlet就是动态资源
</code></pre>
<pre><code>不是所有的JAVA类都能用于处理客户端的请求，能处理客户端请求并作出响应的一套技术的标准就是Servlet
Servlet是运行在服务器端的，所以servlet必须在web项目中开发并且在tomcat这样的服务器容器中运行
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409221731775.png" alt="image-20240409221731775"></p>
<pre><code>当浏览器请求响应的路径，请求就会发送给tomcat，tomcat会将请求的报文转为HttpServletRequest对象，这个对象里包含 请求的所有的信息
然后找到对应的路径对对应的service，
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409222207277.png" alt="image-20240409222207277"></p>
<p><strong>实例</strong></p>
<pre><code>向客户端发送一个Servlet发送请求，携带username，如果用户名是”hhh“,回应no,其他的yes
</code></pre>
<p>servlet需要实现，下面这些接口，我们只需要service即可，所以我们可以继承与实现servlet的类</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409223227620.png" alt="image-20240409223227620"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409223349001.png" alt="image-20240409223349001"></p>
<p>然后记住我们重写的是</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409223441821.png" alt="image-20240409223441821"></p>
<pre><code>总的过程
1.创建javaweb项目，同时将tomcat添加为当前项目的依赖
2.重写service的方法
3.在service中定义业务处理代码
4.在webxml里配置servlet对用的请求映路径
</code></pre>
<pre><code class="xml">    &lt;servlet&gt;
        &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;wei.chenw.servlet.User&lt;/servlet-class&gt;
    &lt;/servlet&gt;
</code></pre>
<pre><code>在这里
    tomcat根据servlet-name匹配过来的路径，如果符合的话，servlet-class这个是类的全路径，tomcat根据反射来实例这个方法，然后调用这里面的service
    
    servlet-name  //用于关联映射路径的
    servlet-class //告诉Tomcat对应实例的化的servlet类
</code></pre>
<pre><code class="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;wei.chenw.servlet.User&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/user&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<pre><code>上面就可以匹配路径了
</code></pre>
<p>然后编辑运行的信息</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409225405936.png" alt="image-20240409225405936"></p>
<p>我们要运行的项目</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240409225428789.png" alt="image-20240409225428789"></p>
<pre><code>提醒一下
    字符串的比较一定使用equals的方法
</code></pre>
<p>wei.chenw.servlet.User</p>
<pre><code class="java">package wei.chenw.servlet;

import jakarta.servlet.*;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.io.PrintWriter;

public class User extends HttpServlet &#123;
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        //从req里获取请求中的任何信息
        //getParameter根据参数名获取参数值，无论是get还是post请求
        String username = req.getParameter(&quot;username&quot;);
        //处理业务的代码

        String  info = &quot;yes&quot;;
        if (&quot;hhh&quot;.equals(username))&#123;
            info = &quot;no&quot;;
        &#125;
        //将要响应的数据放在response
        //getWriter该方法返回是一个向响应体中打印字符的打印流
        PrintWriter writer = resp.getWriter();
        writer.write(info);

        //
    &#125;
&#125;
</code></pre>
<p>web.xml</p>
<pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;
         version=&quot;5.0&quot;&gt;
    &lt;!--
    1.配置Servlet类，并器一个别名  servlet-class是类的全路径，servlet-name是别名

    --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;wei.chenw.servlet.User&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/user&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<p>index.html</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;登录&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;form action=&quot;user&quot; method=&quot;get&quot;&gt;
    &lt;span&gt;用户名&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;校验&quot;&gt;
&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code>Servlet开发中遇见的问题
1.servlet-api.jar 导入的问题
2.Content-type 响应头问题
    MINE类型响应头，告诉客户端是什么样的响应类型，客户端以此类型决定用什么方式解析
    在conf/web.xml的里面记录了几乎所有文件类型的对应的MINE类型
</code></pre>
<p>我们业务操作的地方，必须要间接的实现Servlet接口，这个不是java的内置类，</p>
<pre><code class="java">public class User extends HttpServlet
</code></pre>
<p>这个jar包在这个位置</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240410122634367.png" alt="image-20240410122634367"></p>
<p>在web.xml就规定了类型，看文件的后缀名</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240410123541815.png" alt="image-20240410123541815"></p>
<p>但是当我们访问的&#x2F;user，不是以响应的结果没有设置，默认是以html解析那怎么指定</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240410124122989.png" alt="image-20240410124122989"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240410124448986.png" alt="image-20240410124448986"></p>
<p>之前我们写在配置文件里路径匹配的规则</p>
<p>之前在web.xml里面写</p>
<pre><code class="java">&lt;servlet&gt;
    &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;wei.chenw.servlet.User&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/user&lt;/url-pattern&gt;
&lt;/servlet-mapping
</code></pre>
<p>还有一种方法，可以不用使用注解</p>
<pre><code class="java">@WebServlet(&quot;/s1&quot;)
public class User extends HttpServlet &#123;
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        //从req里获取请求中的任何信息
        //getParameter根据参数名获取参数值，无论是get还是post请求
        String username = req.getParameter(&quot;username&quot;);
        //处理业务的代码

        String  info = &quot;yes&quot;;
        if (&quot;hhh&quot;.equals(username))&#123;
            info = &quot;no&quot;;
        &#125;
        //将要响应的数据放在response
        //getWriter该方法返回是一个向响应体中打印字符的打印流
        resp.setHeader(&quot;Content-Type&quot;,&quot;text/html&quot;);
        PrintWriter writer = resp.getWriter();
        writer.write(info);
        //
    &#125;
&#125;
</code></pre>
<p>这样也可以实现</p>
<pre><code>注意注解和配置文件的不要都写这样就会产生冲突
</code></pre>
<p><strong>Servlet的生命周期</strong></p>
<pre><code>servlet是servlet对象创建的，servlet的创建和销毁都是由tomcat调用的，
</code></pre>
<pre><code class="java">package wei.chenw.servlet;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;






/*
*1.实例化  构造器
* 2.初始化  init
* 3.接受请求 发送服务 服务  service
* 4.销毁  destroy
*
*
*
* */
@WebServlet(&quot;/servletLife&quot;)
public class ServletLifeCycle extends HttpServlet &#123;
    public ServletLifeCycle()&#123;
        System.out.println(&quot;constructor&quot;);
    &#125;
    public void init()&#123;
        System.out.println(&quot;初始化&quot;);
    &#125;
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        System.out.println(&quot;service&quot;);
    &#125;
    public void destroy()&#123;
        System.out.println(&quot;destroy&quot;);
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240411102023960.png" alt="image-20240411102023960"></p>
<p>当我们关闭服务的时候就会destroy</p>
<pre><code>Servlet是单例的，就是只有一个servlet对象
</code></pre>
<p>当有好几个客户端访问的化，访问的都是同一个的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240411102420236.png" alt="image-20240411102420236"></p>
<pre><code>所以service方法尽量不要修改成员变量 在并发请求的里面 就会引发线程的安全问题，那么有人说加锁解决，这样就会出现性能的问题
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240411102627828.png" alt="image-20240411102627828"></p>
<pre><code>当我们的第一个线程操作的时候，第二个线程必须等待他执行完以后才能在执行
</code></pre>
<p><strong>默认的Servlet的初始化是在请求的时候，那怎么样才能实现在创建servlet的时候就实现构造函数和初始化，这样需要设置注解的另外的一个属性</strong></p>
<pre><code class="java">@WebServlet(value = &quot;/servletLife&quot;,loadOnStartup = -1)
//日过这里面的是-1的话，这个servlet的实例，只能在访问的后面才能实例
///其他的正整数 含义是tomcat在启动的时候，实例化servlet的顺序，数字越小越先实例化，如果冲突了，辉仔顶协调启动的顺序
</code></pre>
<p>或者在</p>
<pre><code class="xml">&lt;!--    &lt;servlet&gt;--&gt;
&lt;!--        &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;--&gt;
&lt;!--        &lt;servlet-class&gt;wei.chenw.servlet.User&lt;/servlet-class&gt;--&gt;
&lt;!--        &lt;load-on-startup&gt;-1&lt;/load-on-startup&gt;--&gt;
&lt;!--    &lt;/servlet&gt;--&gt;

&lt;!--    &lt;servlet-mapping&gt;--&gt;
&lt;!--        &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;--&gt;
&lt;!--        &lt;url-pattern&gt;/user&lt;/url-pattern&gt;--&gt;
&lt;!--    &lt;/servlet-mapping&gt;--&gt;
</code></pre>
<p>设置动态的以后，这样就可以在tomcat启动的时候就实例初始化servlet</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240411103753455.png" alt="image-20240411103753455"></p>
<p>之前的conf的目录下也有一个web.xml</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240411104312194.png" alt="image-20240411104312194"></p>
<pre><code>一般把相同每个项目目录配置一样的写在web.xml,
</code></pre>
<p><strong>defalut-servlet</strong></p>
<p>在tomcat的配置文件里面，</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240411105354069.png" alt="image-20240411105354069"></p>
<p>对应的映射</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240411105455031.png" alt="image-20240411105455031"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240411105606684.png" alt="image-20240411105606684"></p>
<pre><code>这个defaultservlet的操作流程是这样的，当我们访问的是静态资源的时候，就会去servlet的里面的路径如匹配，如果没有对应的，就会去defaultsrvlet的对象的里面，然后再通过io流，读取要访问的静态资源，然后再通过这个serlet对象的的response回复给客户端
</code></pre>
<pre><code>总的来说静态资源都是通过defaultservlet进行加载的



在SpringMVC 的时候使用servlet的时候这个defaultServlet 就会失效，这样访问静态资源就会失败
</code></pre>
<p><strong>Servlet继承结构</strong></p>
<p>servlet的顶级接口</p>
<pre><code class="java">public interface Servlet &#123;
    void init(ServletConfig var1) throws ServletException;
//getServletConfig  获取ServletConfig对象
    ServletConfig getServletConfig();

    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;
//getServletInfo返回Servlet字符串的描述信息的方法
    String getServletInfo();
    //Servlet在回收前，由tomcat调用的销毁，用于做资源的释放空间
    void destroy();
&#125;
</code></pre>
<p><strong>GenericServlet</strong></p>
<pre><code>实现了servlet的接口
</code></pre>
<pre><code class="java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package jakarta.servlet;

import java.io.IOException;
import java.io.Serializable;
import java.util.Enumeration;

public abstract class GenericServlet implements Servlet, ServletConfig, Serializable &#123;
    private static final long serialVersionUID = 1L;
    private transient ServletConfig config;

    public GenericServlet() &#123;
    &#125;

    public void destroy() &#123;
    &#125;

    public String getInitParameter(String name) &#123;
        return this.getServletConfig().getInitParameter(name);
    &#125;

    public Enumeration&lt;String&gt; getInitParameterNames() &#123;
        return this.getServletConfig().getInitParameterNames();
    &#125;

    public ServletConfig getServletConfig() &#123;
        return this.config;
    &#125;

    public ServletContext getServletContext() &#123;
        return this.getServletConfig().getServletContext();
    &#125;

    public String getServletInfo() &#123;
        return &quot;&quot;;
    &#125;
//tomcat 在调用init的方法的时候。会读取配置信息进入一个ServletConfig
    public void init(ServletConfig config) throws ServletException &#123;
        this.config = config;
        this.init();
    &#125;

    public void init() throws ServletException &#123;
    &#125;

    public void log(String message) &#123;
        ServletContext var10000 = this.getServletContext();
        String var10001 = this.getServletName();
        var10000.log(var10001 + &quot;: &quot; + message);
    &#125;

    public void log(String message, Throwable t) &#123;
        this.getServletContext().log(this.getServletName() + &quot;: &quot; + message, t);
    &#125;

    public abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;

    public String getServletName() &#123;
        return this.config.getServletName();
    &#125;
&#125;
</code></pre>
<p>HttpServlet 抽象类 侧重除了service方法处理</p>
<pre><code class="java">protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
    //获取请求的方式
    String method = req.getMethod();
    long lastModified;
    //根据请求方式判断调用对用的do方法
    if (method.equals(&quot;GET&quot;)) &#123;
        lastModified = this.getLastModified(req);
        if (lastModified == -1L) &#123;
            this.doGet(req, resp);
        &#125; else &#123;
            long ifModifiedSince;
            try &#123;
                ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);
            &#125; catch (IllegalArgumentException var9) &#123;
                ifModifiedSince = -1L;
            &#125;

            if (ifModifiedSince &lt; lastModified / 1000L * 1000L) &#123;
                this.maybeSetLastModified(resp, lastModified);
                this.doGet(req, resp);
            &#125; else &#123;
                resp.setStatus(304);
            &#125;
        &#125;
    &#125; else if (method.equals(&quot;HEAD&quot;)) &#123;
        lastModified = this.getLastModified(req);
        this.maybeSetLastModified(resp, lastModified);
        this.doHead(req, resp);
    &#125; else if (method.equals(&quot;POST&quot;)) &#123;
        this.doPost(req, resp);
    &#125; else if (method.equals(&quot;PUT&quot;)) &#123;
        this.doPut(req, resp);
    &#125; else if (method.equals(&quot;DELETE&quot;)) &#123;
        this.doDelete(req, resp);
    &#125; else if (method.equals(&quot;OPTIONS&quot;)) &#123;
        this.doOptions(req, resp);
    &#125; else if (method.equals(&quot;TRACE&quot;)) &#123;
        this.doTrace(req, resp);
    &#125; else &#123;
        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);
        Object[] errArgs = new Object[]&#123;method&#125;;
        errMsg = MessageFormat.format(errMsg, errArgs);
        resp.sendError(501, errMsg);
    &#125;

&#125;
</code></pre>
<p><strong>ServletConfig-ServletContext</strong></p>
<pre><code>概述
 给servlet提供初始配置信息的一种对象
</code></pre>
<p>在配置文件的里面写配置信息，在这里使用keyvalue的形式</p>
<pre><code class="xml">        &lt;init-param&gt;
            &lt;param-name&gt;key&lt;/param-name&gt;
            &lt;param-value&gt;value&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;key1&lt;/param-name&gt;
            &lt;param-value&gt;value&lt;/param-value&gt;
        &lt;/init-param&gt;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240411204205862.png" alt="image-20240411204205862"></p>
<pre><code>当tomcat读取到这个配置文件的时候，会将配置解析，然后形成一个Servlet的对象，然后，将这个对象传入init的方法里面
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240411204433973.png" alt="image-20240411204433973"></p>
<pre><code>我们还可以获取config对象
</code></pre>
<p>我们在配置里面配置的信息在通过这样可以读取的到</p>
<pre><code class="java">package wei_Servlet;


import jakarta.servlet.ServletConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.util.Enumeration;

public class Servlet1 extends HttpServlet &#123;
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        ServletConfig servletConfig = this.getServletConfig();
        //获取
        //根据参数名获取参数的值
        String key1 = servletConfig.getInitParameter(&quot;key1&quot;);
        System.out.println(key1);
        //获取所有参数的名字   Enumeration就是intertor
        Enumeration&lt;String&gt; initParameterNames = servletConfig.getInitParameterNames();
//hasMoreElements判断是否有一个参数
//        nextElement取出下一个元素   向下移动游标
        while (initParameterNames.hasMoreElements())&#123;
            String s = initParameterNames.nextElement();
            System.out.println(s);
            System.out.println(s+servletConfig.getInitParameter(s));
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code>Enumeration是类似于intertor的
</code></pre>
<pre><code>注意每一个的servlet都是独自的配置信息
</code></pre>
<pre><code>ServletConfig的使用并不多，
</code></pre>
<p>或者使用注解的方法进行配置</p>
<pre><code class="java">@WebServlet(value = &quot;/demo&quot;,
        initParams = &#123;@WebInitParam(name=&quot;key&quot;,value = &quot;value&quot;),@WebInitParam(name=&quot;key1&quot;,value = &quot;value&quot;)&#125;
)
</code></pre>
<p><strong>ServletContext</strong></p>
<p>之前的servletconfig是为单个的servlet配置参数，但是这个servletContext是为全部的servlet的提供配置	</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240411210629214.png" alt="image-20240411210629214"></p>
<pre><code>非常重要
    所有的servlet都共享一个配置信息
    servletComtext是单例的
</code></pre>
<p>这三种都可以获取context的方法的</p>
<pre><code class="jav">//两=三种获取context的方法,通过这两种方法

ServletConfig servletConfig = this.getServletConfig();
ServletContext servletContext1 = servletConfig.getServletContext();

ServletContext servletContext2 = req.getServletContext();

ServletContext servletContext = this.getServletContext();
</code></pre>
<p>获取属性值的方法和之前的config对象是一样的</p>
<pre><code class="java">package wei_Servlet;

import jakarta.servlet.ServletConfig;
import jakarta.servlet.ServletContext;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebInitParam;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.util.Enumeration;

@WebServlet(value = &quot;/user&quot;)
public class Servlet2 extends HttpServlet &#123;
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;

        //两=三种获取context的方法,通过这两种方法

        ServletConfig servletConfig = this.getServletConfig();
        ServletContext servletContext1 = servletConfig.getServletContext();

        ServletContext servletContext2 = req.getServletContext();

        ServletContext servletContext = this.getServletContext();

        //获取参数
        String username = servletContext1.getInitParameter(&quot;username&quot;);
        System.out.println(username);
        //获取参数名
        Enumeration&lt;String&gt; initParameterNames = servletContext.getInitParameterNames();
        while (initParameterNames.hasMoreElements())&#123;
            String s = initParameterNames.nextElement();
            System.out.println(s+&quot;=&quot;+servletConfig.getInitParameter(s));
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240411225413648.png" alt="image-20240411225413648"></p>
<p><strong>Servlet其他重要的API</strong></p>
<p>在写入文件的时候</p>
<pre><code class="java">        //这里路径怎么写才能指向要写入的文件夹
        String path = &quot;&quot;;
//        FileOutputStream fos = new FileOutputStream(path+&#39;a.txt&#39;)
</code></pre>
<p>在我们项目构建玩以后应该是在out下的文件下保存</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240411225946314.png" alt="image-20240411225946314"></p>
<p>而不是当前的目录结构那应该怎能么办？</p>
<p>这里面我们就可以使用到servlet的api</p>
<p><strong>getRealPath</strong></p>
<p>使用</p>
<pre><code class="java">//获取一个指向项目的部署位置下的某个文件真实的路径的api
String path = servletContext.getRealPath(&quot;upload/a.txt&quot;);
System.out.println(path);
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240412164408398.png" alt="image-20240412164408398"></p>
<p>就是我们项目当前环境的真实路径</p>
<p><strong>getContextPath</strong></p>
<p>获取项目的根路径</p>
<pre><code class="java">        String contextPath = servletContext.getContextPath();
        System.out.println(contextPath);
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240412164811447.png" alt="image-20240412164811447"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240412164819187.png" alt="image-20240412164819187"></p>
<p><strong>域对象</strong></p>
<pre><code>一些储存数据和传递数据的对象，传递的数据不同的范围。就成为不同的域
就是数据储存和传递
</code></pre>
<pre><code>ServletContext代表应用，所以servletContext域成为应用域，是webapp里面最大的域，可以在本应用中实现数据共享和传递
</code></pre>
<p>就比如说<img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240412165427007.png" alt="image-20240412165427007"></p>
<pre><code>这两个之间传递数据
    我们就可以把数据放在域对象里面，然后有需要的去读就可以了
</code></pre>
<pre><code>域对象的API
setAttribute(String key ,Object value);
Object getAttribute(String key)
void removeArribute(String key)
</code></pre>
<pre><code class="java">        ServletContext servletContext = this.getServletContext();
        //增加数据
        servletContext.setAttribute(&quot;key&quot;,&quot;value&quot;);
        //修改数据
        servletContext.setAttribute(&quot;key&quot;,&quot;value1&quot;);
        //获取
        Object key = servletContext.getAttribute(&quot;key&quot;);
        String key1 = (String)servletContext.getAttribute(&quot;key&quot;);
        System.out.println(key);
        System.out.println(key1);

        //移除
        servletContext.removeAttribute(&quot;key&quot;);
</code></pre>
<p>这是在一个的Servlet里面操作</p>
<p>在其他的servlet对象里面我们就可以读取的到</p>
<pre><code class="java">ServletContext servletContext = this.getServletContext();
String attribute =(String) servletContext.getAttribute(&quot;key&quot;);
System.out.println(attribute);
</code></pre>
<pre><code>context是最大的域
</code></pre>
<p><strong>HttpsrvletRequest</strong></p>
<pre><code>HttpsrvletRequest是一个接口，他的父接口ServletRequest
HttpsrvletRequest是tomcat将请求报文转换封装的对象	在tomcat调用service方法传入
</code></pre>
<pre><code class="java">常见的api
StringBuffer getRequestURL();  获取客户端请求的url
String getRequestURI();  获取客户端请求的项目的具体资源
int getServerPort();		获取客户端发送请求
int getLocalPort();   		获取本应用所在容器的端口
int getRomotePort();		获取客户端程序的接口
String getScheme();		获取请求的协议
String getProtocol();		获取请求的协议和版本号
String getMethod();			获取请求的方法
</code></pre>
<p>获取请求头的API</p>
<pre><code class="java">String getHeader(String HeaderName);		//根据名字获取
Enumeration&lt;String&gt; getHeaderNames();  //获取所有请求头的信息
</code></pre>
<pre><code class="java">例如
        System.out.println(req.getRequestURL());  //http://localhost:8080/demo/user3
        System.out.println(req.getRequestURI());  ///demo/user3
        System.out.println(req.getServerPort()); //8080，如果中间有代理的话，就不一样了 
        System.out.println(req.getLocalPort());  //8080
        System.out.println(req.getRemotePort());  //42284
        System.out.println(req.getScheme());  //http
        System.out.println(req.getProtocol()); //HTTP/1.1
        System.out.println(req.getMethod()); //GET
</code></pre>
<pre><code class="java">        Enumeration&lt;String&gt; headerNames = req.getHeaderNames();
        while (headerNames.hasMoreElements())&#123;
            String s = headerNames.nextElement();
            System.out.println(s+req.getHeader(s));
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240412193649411.png" alt="image-20240412193649411"></p>
<p>获取请求参数的API</p>
<pre><code class="java">String getParameter(String parameterName);
String[] getparameterValues(String parameterName);
Enumeration getparameterNames(); 
Map&lt;String String[]&gt;getParaneterMap();  //获取所有参数的键值对集合
BufferReader getReader() throws IOException;   //获取读取请求体的字节输入流
ServletInputStream getInputStream() throws IOException;  //获取读取请求体的字节输入流
int getcontentLength()  //获取请求体的长度的字节数
</code></pre>
<p>例如</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240412195756940.png" alt="image-20240412195756940"></p>
<pre><code class="java">        String username = req.getParameter(&quot;username&quot;);
        System.out.println(username); //root
        String password = req.getParameter(&quot;password&quot;);
        System.out.println(password);
        String[] hobbies = req.getParameterValues(&quot;hobby&quot;);
        for (String hobby : hobbies) &#123;
            System.out.println(hobby);
        &#125;
</code></pre>
<p>例如</p>
<pre><code class="java">        //接受请求的参数,获取单个的参数的值
        String username = req.getParameter(&quot;username&quot;);
        System.out.println(username); //root
        String password = req.getParameter(&quot;password&quot;);
        System.out.println(password); //root
        String[] hobbies = req.getParameterValues(&quot;hobby&quot;);
        System.out.println(Arrays.toString(hobbies)); //[1, 2, 3]
        Enumeration&lt;String&gt; parameterNames = req.getParameterNames();
        while (parameterNames.hasMoreElements())&#123;
            String s = parameterNames.nextElement();
            String[] parameterValues = req.getParameterValues(s);
            //if数组的长度大于一说明有两个以上的说明该属性有两个以上的值
            if (parameterValues.length&gt;1)&#123;
                System.out.println(s+&quot;=&quot;+Arrays.toString(parameterValues));  //hobby=[1, 2, 3]
            &#125; else &#123;
                System.out.println(s+&quot;=&quot;+parameterValues[0]); //password=root   username=root
            &#125; 
        &#125;
</code></pre>
<p>或者转为Map</p>
<pre><code class="java">        Map&lt;String, String[]&gt; parameterMap = req.getParameterMap();
        for (Map.Entry&lt;String, String[]&gt; stringEntry : parameterMap.entrySet()) &#123;
            String key = stringEntry.getKey();
            String[] value = stringEntry.getValue();
            if (value.length&gt;1)&#123;
                System.out.println(key+&quot;=&quot;+Arrays.toString(value));
            &#125; else &#123;
                System.out.println(key+&quot;=&quot;+value[0]);
            &#125;
            /*
            *   username=root
                password=root
                hobby=[1, 2, 3]
            * */
</code></pre>
<pre><code>注意上面的API的POST请求也是可以使用的，上面的都会获取key=value的参数
那么如何获取JSON的数据或者文件

getReader();
</code></pre>
<pre><code class="java">            //JSON串的
            BufferedReader reader = req.getReader();

            //重请求体读取二进制,文件的话
            ServletInputStream inputStream = req.getInputStream();
</code></pre>
<p>获取servlet的映射路径</p>
<pre><code class="java">            String servletPath = req.getServletPath();
</code></pre>
<p><strong>HttpServletResponse</strong></p>
<pre><code>响应的对象
    会转换成响应报文
</code></pre>
<ul>
<li>设置相应行相关</li>
</ul>
<pre><code class="java">void setStatus(int code);
</code></pre>
<ul>
<li>设置响应头相关</li>
</ul>
<pre><code class="java">void setHeader(String headerNames,String value);
void setContentType(String contextType);
</code></pre>
<ul>
<li>设置响应体相关</li>
</ul>
<pre><code class="java">PrintWriter  getWriter() throws IOException;//想响应体放入信息的字符输入流
servletOutputStream getOuputStream();  //向响应体放入信息的字节输入流
void setContentLength(int length);  //设置响应体的字节长度，其实就是设置在context-length响应头
</code></pre>
<ul>
<li>其他的APi</li>
</ul>
<pre><code class="java">void sendError(int code,String msssage)  //向客户端响应错误信息的方法，需要指定响应码和响应信息
void addCookie(Cookie cookie);  //向响应体添加cookie
void setCharacterEncodeing(String encoding);//设置响应的编码
</code></pre>
<p>例如</p>
<pre><code class="java">resp.setStatus(405);   //状态码
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240412203952137.png" alt="image-20240412203952137"></p>
<pre><code class="java">        resp.setHeader(&quot;wang&quot;,&quot;chen&quot;);
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240412204240676.png" alt="image-20240412204240676"></p>
<pre><code class="java">        //设置响应行
        resp.setStatus(200);   //状态码
        resp.setHeader(&quot;wang&quot;,&quot;chen&quot;);
        resp.setContentType(&quot;text/html&quot;);
        //设置响应体的内容
        PrintWriter writer = resp.getWriter();
        String info = &quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;;
        int len = info.getBytes().length;
        resp.setContentLength(len);
        writer.write(info);
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240412205023522.png" alt="image-20240412205023522"></p>
<p>向响应体放字节流</p>
<pre><code class="java">        ServletOutputStream outputStream = resp.getOutputStream();
</code></pre>
<p><strong>请求转发和响应重定向</strong></p>
<pre><code>概念
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240412210001302.png" alt="image-20240412210001302"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240412213004949.png" alt="image-20240412213004949"></p>
<p>当我们请求servlet1的时候将请求转发到servlet2，这样把给servlet1的req和resp给了sevlet2 </p>
<p>例如</p>
<pre><code class="java">
@WebServlet(&quot;/user1&quot;)
public class Servlet1 extends HttpServlet &#123;
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        //
        System.out.println(&quot;service1开始了&quot;);
        //转发
        //getRequestDispatcher获取请求转发器,参数时映射的相对的路径
        RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;user2&quot;);
        //让转发器做出转发,转发请求响应
        requestDispatcher.forward(req,resp);
    &#125;
&#125;
</code></pre>
<pre><code class="java">@WebServlet(&quot;/user2&quot;)
public class Servlet2 extends HttpServlet &#123;
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        System.out.println(&quot;servlet2执行&quot;);
    &#125;
&#125;
</code></pre>
<p>这样当我们访问user1的时候，转发到servlet2，调用service方法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240412220130204.png" alt="image-20240412220130204"></p>
<pre><code>转发器是通过HttpServletRequest实现的
转发请求是服务器的内部行为，对客户端时屏蔽的
客户端只产生一次请求 服务器只产生一对request和response
客户端的地址栏不变
请求的参数是可以继续传递的
目标资源可以是动态资源，也可以是静态资源，也可以是在web-inf下资源
注意请求转发只在当前项目下寻找，不可以转发到外步的资源，例如https://www.baidu
</code></pre>
<p>转发 的请求也可以获取到参数</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240412220901689.png" alt="image-20240412220901689"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240412220912313.png" alt="image-20240412220912313"></p>
<p>也可以转发给视图资源</p>
<pre><code class="java">        RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;a.html&quot;);
        requestDispatcher.forward(req,resp)
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240412221337733.png" alt="image-20240412221337733"></p>
<p>请求的时候，地址没有改变</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240412221350542.png" alt="image-20240412221350542"></p>
<p><strong>转发还可以转发到web-inf下面，之前说是受保护的，客户端访问不到</strong></p>
<pre><code class="java">        RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;WEB-INF/b.html&quot;);
        requestDispatcher.forward(req,resp);
</code></pre>
<p><img src="/JavaWeb.assets/image-20240412221625082.png" alt="image-20240412221625082"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240412221640654.png" alt="image-20240412221640654"></p>
<p><strong>响应重定向</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413084749530.png" alt="image-20240413084749530"></p>
<pre><code>当我们访问servlet1的时候，会响应302状态码，和location重定向的地址，然后发给客户端，然后客户端继续向服务器请求，请求重定向的地址
</code></pre>
<p>例如</p>
<pre><code class="java">package wei_Servlet;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;


@WebServlet(&quot;/servlet1&quot;)
public class Servleta extends HttpServlet &#123;
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        System.out.println(&quot;servlet1接收到了请求&quot;);
        System.out.println(&quot;______________________________________________&quot;);


//        响应重定向.设置响应状态码和响应的地址
        resp.sendRedirect(&quot;servlet2&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package wei_Servlet;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;


@WebServlet(&quot;/servlet2&quot;)
public class Servletb extends HttpServlet &#123;
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        System.out.println(&quot;servlet2接收到请求&quot;);
    &#125;
&#125;
</code></pre>
<p>这样当我们访问servlet1的时候就会重定向到servlet2</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413085559747.png" alt="image-20240413085559747"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413085640493.png" alt="image-20240413085640493"></p>
<pre><code>重定向的特点
1.是通过resp对象实现的
2.相应重定向是在服务端提示下，客户端的行为
3.客户端的地址栏会发生改变，同时客户端至少产生两次请求
4.请求产生多次就会有多个req的对象，此时的请求中的参数不能继续传递，所以参数是接受不到的
5.目标资源可以是视图资源 
6.目标资源不可以是wen-inf下的资源
7.可以重定向到外部资源
</code></pre>
<p><strong>重点</strong></p>
<pre><code>同样能够实现页面的跳转，有限使用响应重定向
</code></pre>
<p><strong>web乱码和路径问题</strong></p>
<pre><code>乱码的原因
数据的编码和解码使用的不是同一个字符集
使用不支持的某种语言文字的字符集
</code></pre>
<p>为什么英文不乱吗，</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413090547861.png" alt="image-20240413090547861"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413090704245.png" alt="image-20240413090704245"></p>
<p>如果GBK的话</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413090752840.png" alt="image-20240413090752840"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413090800322.png" alt="image-20240413090800322"></p>
<p>乱码</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413091049624.png" alt="image-20240413091049624"></p>
<p>系统的窗口的字符集使用的是GBK</p>
<p>现在我的tomcat的日志窗口还有乱码</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413091312607.png" alt="image-20240413091312607"></p>
<p>在logging.proprties的里面可以修改</p>
<p><img src="/JavaWeb.assets/image-20240413091754324.png" alt="image-20240413091754324"></p>
<p>都改为GBK</p>
<p>这样就解决了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413091908662.png" alt="image-20240413091908662"></p>
<p>还有一中的乱码原因</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413092048931.png" alt="image-20240413092048931"></p>
<pre><code>这个java文件编译成class文件用utf-8，但是jvm使用别的字符集加载，这样就会乱码
</code></pre>
<p><strong>GET请求乱码</strong></p>
<p>我们设置编码GBK</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413123720857.png" alt="image-20240413123720857"></p>
<p>然后再获取</p>
<pre><code class="java">package wei_Servlet;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;


@WebServlet(&quot;/user&quot;)
public class User extends HttpServlet &#123;
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        String username = req.getParameter(&quot;username&quot;);
        System.out.println(username);
    &#125;
&#125;
</code></pre>
<p>当我们的值为中文的时候，就会报错</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413123830133.png" alt="image-20240413123830133"></p>
<p>出现问题的原因</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413124009193.png" alt="image-20240413124009193"></p>
<pre><code>我们请求的时候?username=%CD%F5%B2%FD%B3%BF，这个%是每个字节的分隔，里面的是二进制转为16进制的形式，请求的时候，根据GBK转为二进制，然后再解析的时候，我们默认使用utf-8解码
</code></pre>
<p>我们设置tomcat的url解码的字符集</p>
<p>添加这一行，这样uri里面的username参数就会以GBK解码</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413124450833.png" alt="image-20240413124450833"></p>
<p><strong>POST请求的乱码</strong></p>
<pre><code>之前再配置的URIEncoding解决的是参数是再get的里面以url传递的
所以这个再post请求是无用的
设置请求体的解码使用的字符集
</code></pre>
<pre><code class="java">设置解析请求体的解析格式
req.setCharacterEncoding();
</code></pre>
<p><strong>响应乱码</strong></p>
<pre><code class="java">        resp.getWriter().write(&quot;你好&quot;);
</code></pre>
<p>这样会出现乱码</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413125303359.png" alt="image-20240413125303359"></p>
<pre><code>因为tomcat默认的使用的字符集使用的是utf-8
    响应体  你好（再tomcat里面响应的默认编码的字符集是UTF-8），但是客户端不知道使用utf-8解码，浏览器饥结合语言环境使用GBK解码了，这样导致乱码了，两种解决方法
</code></pre>
<ul>
<li><p>设置响应体的编码字符集，这是后端适应前端进行编码，这种方法不建议，因为访问的环境不同，</p>
<pre><code class="java">        resp.setCharacterEncoding(&quot;GBK&quot;);
</code></pre>
</li>
</ul>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413130342129.png" alt="image-20240413130342129"></p>
<ul>
<li>设置浏览器的解析字符集，这样设置客户端解码的方式和服务端的编码方法一样</li>
</ul>
<pre><code class="java">        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        resp.getWriter().write(&quot;你好&quot;);
//设置响应体的编码，一定要和服务端编码方法一样
</code></pre>
<p>所以我们最好一起写</p>
<pre><code class="java">resp.setCharacterEncoding(&quot;UTF-8&quot;);
resp.setContentType(&quot;text/html;charset=utf-8&quot;);
resp.getWriter().write(&quot;你好&quot;);
</code></pre>
<p>这样就可以保证响应体的内容以utf-8进行编码，浏览器再以utf-8进行解码</p>
<p><strong>路径的问题</strong></p>
<ul>
<li>相对路径</li>
</ul>
<pre><code>相对路径的规则
以当前路径所在路出发去寻找目标资源
相对路径不以/开头
再file协议下，使用的是磁盘路径
再http协议下，使用的是url路径
相对路径可以使用./表示当前资源所在 路径，也可以省略不写、、
使用../代表上一级路径
</code></pre>
<ul>
<li>绝对路径</li>
</ul>
<pre><code>规则是使用一个固定的路径作为出发点去寻找，和当前的资源路径没有关系
需要/开头
再绝对路径不要以./或者../
不同的协议和项目，绝对路径的基础位置可能要不同
</code></pre>
<pre><code>应用的场景
前端href
</code></pre>
<p>如果这么写的话</p>
<pre><code class="html">    &lt;base href=&quot;/demo/&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;img src=&quot;static/img/logo.png&quot; alt=&quot;&quot;&gt;
</code></pre>
<p>最后拼接的是，这样编程绝对路径了</p>
<pre><code>/demo/static/img/logo.png
</code></pre>
<p><strong>响应重定向和请求转发的路径问题</strong></p>
<p>相对路径</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413144447942.png" alt="image-20240413144447942"></p>
<p>原理是这样的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413144628944.png" alt="image-20240413144628944"></p>
<p>如果</p>
<p>我的路径是这样的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413144702372.png" alt="image-20240413144702372"></p>
<p>重定向这里，这样就需要更改下 了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413144731195.png" alt="image-20240413144731195"></p>
<p>这样就可以了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413144825358.png" alt="image-20240413144825358"></p>
<p>上面是相对路径，如果是绝对路径的话</p>
<pre><code class="java">        /*
        *   http://localhost:8080
        * http://localhost:8080/demo/servlet2
        * */
        resp.sendRedirect(&quot;/demo/servlet2&quot;);
</code></pre>
<p>因为我配置的上下文路径为，所以需要</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413145103181.png" alt="image-20240413145103181"></p>
<p><strong>不设置项目的上下文</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413145500274.png" alt="image-20240413145500274"></p>
<p><strong>MVC架构模式</strong></p>
<pre><code>是软件架构工程的一种软件架构模式，他把软件分为模式，视图，控制器的三个部分，用一种业务逻辑，数据，界面，界面分离的方式组织代码，及那该业务逻辑聚集在一个部分，在改进和个性化定制界面和用户的交互的同时，不需要重写编写业务逻辑
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413150000167.png" alt="image-20240413150000167"></p>
<pre><code>高聚合低耦合
开闭原则。当我们增加代码，尽量不会修改，而是在基础上增加
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413150449350.png" alt="image-20240413150449350"></p>
<p>比如购物的逻辑</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240413150943537.png" alt="image-20240413150943537"></p>
<p><strong>项目搭建</strong></p>
<p><strong>日程管理</strong></p>
<p>数据库的准备</p>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 哈哈哈哈哈哈哈重生之我是兵王
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;chenw
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
