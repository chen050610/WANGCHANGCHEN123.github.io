
<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8" />
    <title>SSM框架 | 哈哈哈哈哈哈哈重生之我是兵王</title>
    <meta name="author" content="chenw" />
    <meta name="description" content="description" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
	<canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
	<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
	<script src="/js/fireworks.min.js"></script>
	<canvas id="background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
	<script src="/js/background.min.js"></script>
	<div id="cursor"></div>
	<link rel="stylesheet" href="/css/cursor.min.css">
	<script src="/js/cursor.min.js"></script>
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>哈哈哈哈哈哈哈重生之我是兵王</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;哈哈哈哈哈哈哈重生之我是兵王</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>SSM框架</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/4/20
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/chenw/" style="color: #00bcd4">chenw</a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/SSM%E5%AD%A6%E4%B9%A0/" style="color: #ffa2c4">SSM学习</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p>摘要</p>
<span id="more"></span>

<p>内容</p>
<h1 id="SSM框架"><a href="#SSM框架" class="headerlink" title="SSM框架"></a>SSM框架</h1><p>课程的学习路线</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240420223535106.png" alt="image-20240420223535106"></p>
<p><strong>SpringFramework</strong></p>
<pre><code>SSM框架
    SpringMVC
    Spring
    MyBaits
</code></pre>
<p><strong>SpringFramework</strong></p>
<pre><code>广义的spring泛指Spring Framework为基础的Spring技术栈
 如
     Spring Framework
    Spring MVC
    SpringBoot	
    Spring Cloud
    Spring Data等
    
</code></pre>
<p><strong>广义的 Spring：Spring 技术栈</strong>（全家桶）</p>
<p>广义上的 Spring 泛指以 Spring Framework 为基础的 Spring 技术栈。</p>
<p>经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。</p>
<p><strong>狭义的 Spring：Spring Framework</strong>（基础框架）</p>
<p>狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。</p>
<p>Spring Framework（Spring框架）是一个开源的应用程序框架，由SpringSource公司开发，最初是为了解决企业级开发中各种常见问题而创建的。它提供了很多功能，例如：依赖注入（Dependency Injection）、面向切面编程（AOP）、声明式事务管理（TX）等。其主要目标是使企业级应用程序的开发变得更加简单和快速，并且Spring框架被广泛应用于Java企业开发领域。</p>
<p>Spring全家桶的其他框架都是以SpringFramework框架为基础！</p>
<p><strong>SpringFramework框架结构图</strong>：</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png" alt="img"></p>
<table>
<thead>
<tr>
<th>功能模块</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Core Container</td>
<td>核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。</td>
</tr>
<tr>
<td>AOP&amp;Aspects</td>
<td>面向切面编程</td>
</tr>
<tr>
<td>TX</td>
<td>声明式事务管理。</td>
</tr>
<tr>
<td>Spring MVC</td>
<td>提供了面向Web应用程序的集成功能。</td>
</tr>
</tbody></table>
<p><strong>SpringFramework 主要优势</strong></p>
<ol>
<li>丰富的生态系统：Spring 生态系统非常丰富，支持许多模块和库，如 Spring Boot、Spring Security、Spring Cloud 等等，可以帮助开发人员快速构建高可靠性的企业应用程序。</li>
<li>模块化的设计：框架组件之间的松散耦合和模块化设计使得 Spring Framework 具有良好的可重用性、可扩展性和可维护性。开发人员可以轻松地选择自己需要的模块，根据自己的需求进行开发。</li>
<li>简化 Java 开发：Spring Framework 简化了 Java 开发，提供了各种工具和 API，可以降低开发复杂度和学习成本。同时，Spring Framework 支持各种应用场景，包括 Web 应用程序、RESTful API、消息传递、批处理等等。</li>
<li>不断创新和发展：Spring Framework 开发团队一直在不断创新和发展，保持与最新技术的接轨，为开发人员提供更加先进和优秀的工具和框架。</li>
</ol>
<p>  因此，这些优点使得 Spring Framework 成为了一个稳定、可靠、且创新的框架，为企业级 Java 开发提供了一站式的解决方案。</p>
<p>  Spring 使创建 Java 企业应用程序变得容易。它提供了在企业环境中采用 Java 语言所需的一切，支持 Groovy 和 Kotlin 作为 JVM 上的替代语言，并且可以根据应用程序的需求灵活地创建多种架构。从Spring Framework 6.0.6开始，Spring 需要 Java 17+。</p>
<p><strong>Core Container</strong></p>
<p><strong>Spring IoC容器和核心概念</strong></p>
<ul>
<li><p>组件和组件管理的概念</p>
<p>之前的三层架构  control-service-dao</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png" alt="img"></p>
</li>
</ul>
<p>上面的整个业务就是各种组件搭建而成的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png" alt="img"></p>
<p>如果实现这样的功能就好了</p>
<ul>
<li>有人替我们创建组件的对象</li>
<li>有人帮我们保存组件的对象</li>
<li>有人帮助我们自动组装</li>
<li>有人替我们管理事务</li>
<li>有人协助我们整合其他框架</li>
</ul>
<p>所以这个 <strong>core Container</strong>就能充当这个功能</p>
<p><strong>Spring充当组件管理角色（IoC）</strong></p>
<p>组件可以完全交给Spring 框架进行管理，Spring框架替代了程序员原有的new对象和对象属性赋值动作等！</p>
<p>Spring具体的组件管理动作包含：</p>
<ul>
<li>组件对象实例化</li>
<li>组件属性属性赋值</li>
<li>组件对象之间引用</li>
<li>组件对象存活周期管理</li>
<li>……</li>
</ul>
<p>我们只需要编写元数据（配置文件）告知Spring 管理哪些类组件和他们的关系即可！</p>
<p>注意：组件是映射到应用程序中所有可重用组件的Java对象，应该是可复用的功能对象！</p>
<ul>
<li>组件一定是对象</li>
<li>对象不一定是组件</li>
</ul>
<p>综上所述，Spring 充当一个组件容器，创建、管理、存储组件，减少了我们的编码压力，让我们更加专注进行业务编写！</p>
<ul>
<li>组件就是可以复用的java对象</li>
</ul>
<p><strong>优点</strong></p>
<pre><code>1. 降低了组件之间的耦合性：Spring IoC容器通过依赖注入机制，将组件之间的依赖关系削弱，减少了程序组件之间的耦合性，使得组件更加松散地耦合。
2. 提高了代码的可重用性和可维护性：将组件的实例化过程、依赖关系的管理等功能交给Spring IoC容器处理，使得组件代码更加模块化、可重用、更易于维护。
3. 方便了配置和管理：Spring IoC容器通过XML文件或者注解，轻松的对组件进行配置和管理，使得组件的切换、替换等操作更加的方便和快捷。
4. 交给Spring管理的对象（组件），方可享受Spring框架的其他功能（AOP,声明事务管理）等
</code></pre>
<p><strong>Spring IoC容器和容器的实现</strong></p>
<p>普通的容器</p>
<blockquote>
<p>普通容器只能用来存储，没有更多功能。</p>
</blockquote>
<p>程序中的普通容器</p>
<ul>
<li>数组</li>
<li>集合：List</li>
<li>集合：Set</li>
</ul>
<p>复杂容器</p>
<p>  生活中的复杂容器  <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img003.6f9c041c.png"></p>
<blockquote>
<p>政府管理我们的一生，生老病死都和政府有关。</p>
</blockquote>
<p>  程序中的复杂容器</p>
<p>  Servlet 容器能够管理 Servlet(init,service,destroy)、Filter、Listener 这样的组件的一生，所以它是一个复杂容器。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>时机</th>
<th>次数</th>
</tr>
</thead>
<tbody><tr>
<td>创建对象</td>
<td>默认情况：接收到第一次请求  修改启动顺序后：Web应用启动过程中</td>
<td>一次</td>
</tr>
<tr>
<td>初始化操作</td>
<td>创建对象之后</td>
<td>一次</td>
</tr>
<tr>
<td>处理请求</td>
<td>接收到请求</td>
<td>多次</td>
</tr>
<tr>
<td>销毁操作</td>
<td>Web应用卸载之前</td>
<td>一次</td>
</tr>
</tbody></table>
<p>我们即将要学习的 SpringIoC 容器也是一个复杂容器。它们不仅要负责创建组件的对象、存储组件的对象，还要负责调用组件的方法让它们工作，最终在特定情况下销毁组件。</p>
<p>总结：Spring管理组件的容器，就是一个复杂容器，不仅存储组件，也可以管理组件之间依赖关系，并且创建和销毁组件等！</p>
<p>Spring IoC 容器，负责实例化、配置和组装 bean（组件）。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。配置元数据以 XML、Java 注解或 Java 代码形式表现。它允许表达组成应用程序的组件以及这些组件之间丰富的相互依赖关系。</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<p>上图显示了 Spring 容器工作原理的高级视图。应用程序类与配置元数据相结合，您拥有完全配置且可执行的系统或应用程序。</p>
<p><strong>SpringIoC容器具体接口和实现类</strong></p>
<p><strong>SpringIoc容器接口</strong>： </p>
<p><code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！</p>
<p><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。它扩展了以下功能：</p>
<ul>
<li>更容易与 Spring 的 AOP 功能集成</li>
<li>消息资源处理（用于国际化）</li>
<li>特定于应用程序给予此接口实现，例如Web 应用程序的 <code>WebApplicationContext</code></li>
</ul>
<p>简而言之， <code>BeanFactory</code> 提供了配置框架和基本功能，而 <code>ApplicationContext</code> 添加了更多特定于企业的功能。 <code>ApplicationContext</code> 是 <code>BeanFactory</code> 的完整超集！</p>
<p><strong>ApplicationContext容器实现类</strong>：</p>
<p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img004.f6680aef.png"></p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>ClassPathXmlApplicationContext</td>
<td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>FileSystemXmlApplicationContext</td>
<td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>AnnotationConfigApplicationContext</td>
<td>通过读取Java配置类创建 IOC 容器对象</td>
</tr>
<tr>
<td>WebApplicationContext</td>
<td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td>
</tr>
</tbody></table>
<p>总的来说是这样的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421104631981.png" alt="image-20240421104631981"></p>
<p><strong>SpringIoC容器管理配置方式</strong></p>
<p>Spring IoC 容器使用多种形式的配置元数据。此配置元数据表示您作为应用程序开发人员如何告诉 Spring 容器实例化、配置和组装应用程序中的对象。</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<p>Spring框架提供了多种配置方式：XML配置方式、注解方式和Java配置类方式</p>
<ol>
<li>XML配置方式：是Spring框架最早的配置方式之一，通过在XML文件中定义Bean及其依赖关系、Bean的作用域等信息，让Spring IoC容器来管理Bean之间的依赖关系。该方式从Spring框架的第一版开始提供支持。</li>
<li>注解方式：从Spring 2.5版本开始提供支持，可以通过在Bean类上使用注解来代替XML配置文件中的配置信息。通过在Bean类上加上相应的注解（如@Component, @Service, @Autowired等），将Bean注册到Spring IoC容器中，这样Spring IoC容器就可以管理这些Bean之间的依赖关系。</li>
<li><strong>Java配置类</strong>方式：从Spring 3.0版本开始提供支持，通过Java类来定义Bean、Bean之间的依赖关系和配置信息，从而代替XML配置文件的方式。Java配置类是一种使用Java编写配置信息的方式，通过@Configuration、@Bean等注解来实现Bean和依赖关系的配置。</li>
</ol>
<p>为了迎合当下开发环境，我们将以<strong>配置类+注解方式</strong>为主进行讲解！</p>
<p><strong>Spring IoC &#x2F; DI概念总结</strong></p>
<ul>
<li><p><strong>IoC容器</strong></p>
<p>Spring IoC 容器，负责实例化、配置和组装 bean（组件）核心容器。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。</p>
</li>
<li><p><strong>IoC（Inversion of Control）控制反转</strong></p>
<p>IoC 主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由 IoC 容器来创建和管理，即控制权由应用程序转移到 IoC 容器中，也就是“反转”了控制权。这种方式基本上是通过依赖查找的方式来实现的，即 IoC 容器维护着构成应用程序的对象，并负责创建这些对象。</p>
</li>
<li><p><strong>DI (Dependency Injection) 依赖注入</strong></p>
<p>DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，DI 是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter 方法注入和接口注入。</p>
</li>
</ul>
<p> <strong>Spring IoC &#x2F; DI 实现步骤</strong></p>
<blockquote>
<p>我们总结下，组件交给Spring IoC容器管理，并且获取和使用的基本步骤！</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421113253180.png" alt="image-20240421113253180"></p>
</blockquote>
<ol>
<li><p><strong>配置元数据（配置）</strong></p>
<p> 配置元数据，既是编写交给SpringIoC容器管理组件的信息，配置方式有三种。</p>
<p> 基于 XML 的配置元数据的基本结构：</p>
<p> &lt;bean id&#x3D;”…” [1] class&#x3D;”…” [2]&gt;</p>
</li>
</ol>
<pre><code>&lt;!-- collaborators and configuration for this bean go here --&gt;
</code></pre>
  </bean>

<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!-- 此处要添加一些约束，配置文件的标签并不是随意命名 --&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

  &lt;bean id=&quot;...&quot; [1] class=&quot;...&quot; [2]&gt;  
    &lt;!-- collaborators and configuration for this bean go here --&gt;
  &lt;/bean&gt;

  &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;
    &lt;!-- collaborators and configuration for this bean go here --&gt;
  &lt;/bean&gt;
  &lt;!-- more bean definitions go here --&gt;
&lt;/beans&gt;
</code></pre>
<pre><code>  Spring IoC 容器管理一个或多个组件。这些 组件是使用你提供给容器的配置元数据（例如，以 XML `&lt;bean/&gt;` 定义的形式）创建的。

  &lt;bean /&gt; 标签 == 组件信息声明

  - `id` 属性是标识单个 Bean 定义的字符串。
  - `class` 属性定义 Bean 的类型并使用完全限定的类名。
</code></pre>
<ol start="2">
<li><p><strong>实例化IoC容器</strong></p>
<p> 提供给 <code>ApplicationContext</code> 构造函数的位置路径是资源字符串地址，允许容器从各种外部资源（如本地文件系统、Java <code>CLASSPATH</code> 等）加载配置元数据。</p>
<p> 我们应该选择一个合适的容器实现类，进行IoC容器的实例化工作：</p>
</li>
</ol>
<pre><code class="Java">//实例化ioc容器,读取外部配置文件,最终会在容器内进行ioc和di动作
ApplicationContext context = 
           new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);
</code></pre>
<ol start="3">
<li><p><strong>获取Bean（组件）</strong></p>
<p> <code>ApplicationContext</code> 是一个高级工厂的接口，能够维护不同 bean 及其依赖项的注册表。通过使用方法 <code>T getBean(String name, Class&lt;T&gt; requiredType)</code> ，您可以检索 bean 的实例。</p>
<p> 允许读取 Bean 定义并访问它们，如以下示例所示：</p>
</li>
</ol>
<pre><code class="Java">//创建ioc容器对象，指定配置文件，ioc也开始实例组件对象
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);
//获取ioc容器的组件对象
PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class);
//使用组件对象
List&lt;String&gt; userList = service.getUsernameList();
</code></pre>
<p><strong>基于XML的方式配置组件的管理</strong></p>
<p><strong>组件（Bean）信息声明配置（IoC）</strong></p>
<ol>
<li><p>目标</p>
<p> Spring IoC 容器管理一个或多个 bean。这些 Bean 是使用您提供给容器的配置元数据创建的（例如，以 XML <code>&lt;bean/&gt;</code> 定义的形式）。</p>
<p> 我们学习，如何通过定义XML配置文件，声明组件类信息，交给 Spring 的 IoC 容器进行组件管理！</p>
</li>
<li><p>思路</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img006.c8bae859.png"></p>
</li>
<li><p>准备项目</p>
<ol>
<li><p>创建maven工程（spring-ioc-xml-01）</p>
</li>
<li><p>导入SpringIoC相关依赖</p>
<p> pom.xml</p>
</li>
</ol>
</li>
</ol>
<pre><code class="XML">&lt;dependencies&gt;
    &lt;!--spring context依赖--&gt;
    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;6.0.6&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--junit5测试--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ol start="4">
<li><p>基于无参数构造函数</p>
<blockquote>
<p>当通过构造函数方法创建一个 bean（组件对象） 时，所有普通类都可以由 Spring 使用并与之兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。只需指定 Bean 类信息就足够了。但是，默认情况下，我们需要一个默认（空）构造函数。</p>
</blockquote>
<ol>
<li>准备组件类</li>
</ol>
</li>
</ol>
<pre><code class="Java">package com.atguigu.ioc;


public class HappyComponent &#123;

    //默认包含无参数构造函数

    public void doWork() &#123;
        System.out.println(&quot;HappyComponent.doWork&quot;);
    &#125;
&#125;
</code></pre>
<pre><code>  2. xml配置文件编写

      创建携带spring约束的xml配置文件
</code></pre>
<p>​<br>​          编写配置文件：<br>​<br>​          文件：resources&#x2F;spring-bean-01.xml</p>
<pre><code class="Java">&lt;!-- 实验一 [重要]创建bean --&gt;
&lt;bean id=&quot;happyComponent&quot; class=&quot;com.atguigu.ioc.HappyComponent&quot;/&gt;
</code></pre>
<pre><code>      - bean标签：通过配置bean标签告诉IOC容器需要创建对象的组件信息
      - id属性：bean的唯一标识,方便后期获取Bean！
      - class属性：组件类的全限定符！
      - 注意：要求当前组件类必须包含无参数构造函数！
</code></pre>
<ol start="5">
<li><p>基于静态工厂方法实例化</p>
<blockquote>
<p>除了使用构造函数实例化对象，还有一类是通过工厂模式实例化对象。接下来我们讲解如何定义使用静态工厂方法创建Bean的配置 ！</p>
</blockquote>
<ol>
<li>准备组件类</li>
</ol>
</li>
</ol>
<pre><code class="Java">public class ClientService &#123;
  private static ClientService clientService = new ClientService();
  private ClientService() &#123;&#125;

  public static ClientService createInstance() &#123;
  
    return clientService;
  &#125;
&#125;
</code></pre>
<pre><code>  2. xml配置文件编写

      文件：resources/spring-bean-01.xml
</code></pre>
<pre><code class="XML">&lt;bean id=&quot;clientService&quot;
  class=&quot;examples.ClientService&quot;
  factory-method=&quot;createInstance&quot;/&gt;
</code></pre>
<pre><code>      - class属性：指定工厂类的全限定符！
      - factory-method: 指定静态工厂方法，注意，该方法必须是static方法。
</code></pre>
<ol start="6">
<li><p>基于实例工厂方法实例化</p>
<blockquote>
<p>接下来我们讲解下如何定义使用实例工厂方法创建Bean的配置 ！</p>
</blockquote>
<ol>
<li>准备组建类</li>
</ol>
</li>
</ol>
<pre><code class="Java">package com.chenw.ioc_01;

public class DefaultServiceLocator &#123;

  private static ClientServiceImpl clientService = new ClientServiceImpl();

  public ClientServiceImpl createClientServiceInstance() &#123;
    return clientService;
  &#125;
&#125;
</code></pre>
<pre><code>  2. xml配置文件编写

      文件：resources/spring-bean-01.xml
</code></pre>
<pre><code class="XML">&lt;!-- 将工厂类进行ioc配置 --&gt;
&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;
&lt;/bean&gt;

&lt;!-- 根据工厂对象的实例工厂方法进行实例化组件对象 --&gt;
&lt;bean id=&quot;clientService&quot;
  factory-bean=&quot;serviceLocator&quot;
  factory-method=&quot;createClientServiceInstance&quot;/&gt;
</code></pre>
<pre><code>      - factory-bean属性：指定当前容器中工厂Bean 的名称。
      - factory-method:  指定实例工厂方法名。注意，实例方法必须是非static的！
</code></pre>
<ol start="7">
<li><p>图解IoC配置流程</p>
<p> <img src="https://secure2.wostatic.cn/static/mpqqiD6Bmbno45SpRwBNom/image.png?auth_key=1713670560-duArnWPbh3N648zpywt4TQ-0-a9a4e362a86ac845b548422894d84630"></p>
</li>
</ol>
<p><strong>组件之间的依赖注入的配置</strong></p>
<ol>
<li><p>目标</p>
<p> 通过配置文件,实现IoC容器中Bean之间的引用（依赖注入DI配置）。</p>
<p> 主要涉及注入场景：基于构造函数的依赖注入和基于 Setter 的依赖注入。</p>
</li>
<li><p>思路</p>
<p> <img src="https://secure2.wostatic.cn/static/opfLAb8XnCZDyPMm9BuiMc/image.png?auth_key=1713684087-bBRYsMKzN7SHz6zStP3DJ1-0-641ac1f4b0398f3884e4e5df5caa7e78"></p>
</li>
<li><p>基于构造函数的依赖注入（单个构造参数）</p>
<ol>
<li><p>介绍</p>
<p> 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。</p>
<p> 下面的示例演示一个只能通过构造函数注入进行依赖项注入的类！</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public class UserDao &#123;
&#125;


public class UserService &#123;
    
    private UserDao userDao;

    public UserService(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code>3. 编写配置文件

    文件：resources/spring-02.xml
</code></pre>
<pre><code class="XML">        &lt;!--引用和被引用的组件 必须全部在ioc容器--&gt;
    &lt;!--单个构造函数的注入--&gt;
    &lt;!--将他们呢都存放在ioc容器的--&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.chenw.ioc_02.UserDao&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.chenw.ioc_02.UserService&quot;&gt;
        &lt;!--这个参数作为构造函数参数传值的设置
        value   是直接的属性值,例如 String name = &quot;二狗子&quot; int age = 18
        ref   引用其他的bean bean的id值
        --&gt;
        &lt;constructor-arg  ref=&quot;userDao&quot; /&gt;
    &lt;/bean&gt;
</code></pre>
<pre><code>    - constructor-arg标签：可以引用构造参数 ref引用其他bean的标识。
</code></pre>
<ol start="4">
<li>基于构造函数的依赖注入（多构造参数解析）<ol>
<li><p>介绍</p>
<p> 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。</p>
<p> 下面的示例演示通过构造函数注入多个参数，参数包含其他bean和基本数据类型！</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public class UserDao &#123;
&#125;


public class UserService &#123;
    
    private UserDao userDao;
    
    private int age;
    
    private String name;

    public UserService(int age , String name ,UserDao userDao) &#123;
        this.userDao = userDao;
        this.age = age;
        this.name = name;
    &#125;
&#125;
</code></pre>
<pre><code>3. 编写配置文件
</code></pre>
<pre><code class="XML">&lt;!-- 场景1: 多参数，可以按照相应构造函数的顺序注入数据 --&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.chenw.ioc_02.UserDao&quot;/&gt;
    &lt;bean id=&quot;userService2&quot; class=&quot;com.chenw.ioc_02.UserService2&quot;&gt;
        &lt;!--第一种收按照顺序写 --&gt;
        &lt;constructor-arg    value=&quot;18&quot;/&gt;
        &lt;constructor-arg    value=&quot;二狗子&quot;/&gt;
        &lt;constructor-arg    ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;

&lt;!-- 场景2: 多参数，可以按照相应构造函数的参数的名字注入数据 --&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.chenw.ioc_02.UserDao&quot;/&gt;
    &lt;bean id=&quot;userService2&quot; class=&quot;com.chenw.ioc_02.UserService2&quot;&gt;
        &lt;!-- --&gt;
        &lt;constructor-arg  name=&quot;age&quot;  value=&quot;18&quot;/&gt;
        &lt;constructor-arg  name=&quot;name&quot;  value=&quot;二狗子&quot;/&gt;
        &lt;constructor-arg name=&quot;userDao&quot;   ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;

&lt;!-- 场景3: 多参数，可以按照相应构造函数的角标注入数据 
           index从0开始 构造函数(0,1,2....)
--&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.chenw.ioc_02.UserDao&quot;/&gt;
    &lt;bean id=&quot;userService2&quot; class=&quot;com.chenw.ioc_02.UserService2&quot;&gt;
        &lt;!-- --&gt;
        &lt;constructor-arg  index=&quot;0&quot;  value=&quot;18&quot;/&gt;
        &lt;constructor-arg  index=&quot;1&quot;  value=&quot;二狗子&quot;/&gt;
        &lt;constructor-arg index=&quot;2&quot;   ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<pre><code>    - constructor-arg标签：指定构造参数和对应的值
    - constructor-arg标签：name属性指定参数名、index属性指定参数角标、value属性指定普通属性值
</code></pre>
<ol start="5">
<li><strong>基于Setter方法依赖注入</strong><ol>
<li><p>介绍</p>
<p> 开发中，除了构造函数注入（DI）更多的使用的Setter方法进行注入！</p>
<p> 下面的示例演示一个只能使用纯 setter 注入进行依赖项注入的类。</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public Class MovieFinder&#123;

&#125;

public class SimpleMovieLister &#123;

  private MovieFinder movieFinder;
  
  private String movieName;

  public void setMovieFinder(MovieFinder movieFinder) &#123;
    this.movieFinder = movieFinder;
  &#125;
  
  public void setMovieName(String movieName)&#123;
    this.movieName = movieName;
  &#125;

  // business logic that actually uses the injected MovieFinder is omitted...
&#125;
</code></pre>
<pre><code>3. 编写配置文件
</code></pre>
<pre><code class="XML">    &lt;!--3.触发setter方法进行注入--&gt;
    &lt;bean id=&quot;movieFinder&quot; class=&quot;com.chenw.ioc_02.MovieFinder&quot;/&gt;
    &lt;bean id=&quot;simpleMovieLister&quot; class=&quot;com.chenw.ioc_02.SimpleMovieLister&quot;&gt;
        &lt;!--name -&gt; 属性名 （setter方法的 去掉setter方法的set并且首字母小写的值）
           例如
           setMovieFinder  -&gt;  movieFinder

           ref和value二选一和之前的使用一样

           这个本质的是找的set方法，不是找的属性
           --&gt;
        &lt;property name=&quot;movieFinder&quot; ref=&quot;movieFinder&quot;/&gt;
        &lt;property name=&quot;movieName&quot; value=&quot;消失的她&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<pre><code>    - property标签： 可以给setter方法对应的属性赋值
    - property 标签： name属性代表**set方法标识**、ref代表引用bean的标识id、value属性代表基本属性值
</code></pre>
<p><strong>总结：</strong></p>
<p>  依赖注入（DI）包含引用类型和基本数据类型，同时注入的方式也有多种！主流的注入方式为setter方法注入和构造函数注入，两种注入语法都需要掌握！</p>
<p>  需要特别注意：引用其他bean，使用ref属性。直接注入基本类型值，使用value属性。</p>
<h4 id="4-2-2-实验二：-组件（Bean）依赖注入配置（DI）"><a href="#4-2-2-实验二：-组件（Bean）依赖注入配置（DI）" class="headerlink" title="4.2.2 实验二： 组件（Bean）依赖注入配置（DI）"></a>4.2.2 实验二： 组件（Bean）依赖注入配置（DI）</h4><ol>
<li><p>目标</p>
<p> 通过配置文件,实现IoC容器中Bean之间的引用（依赖注入DI配置）。</p>
<p> 主要涉及注入场景：基于构造函数的依赖注入和基于 Setter 的依赖注入。</p>
</li>
<li><p>思路</p>
<p> <img src="https://secure2.wostatic.cn/static/opfLAb8XnCZDyPMm9BuiMc/image.png?auth_key=1713684087-bBRYsMKzN7SHz6zStP3DJ1-0-641ac1f4b0398f3884e4e5df5caa7e78"></p>
</li>
<li><p>基于构造函数的依赖注入（单个构造参数）</p>
<ol>
<li><p>介绍</p>
<p> 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。</p>
<p> 下面的示例演示一个只能通过构造函数注入进行依赖项注入的类！</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public class UserDao &#123;
&#125;


public class UserService &#123;
    
    private UserDao userDao;

    public UserService(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code>  3. 编写配置文件

      文件：resources/spring-02.xml
</code></pre>
<pre><code class="XML">&lt;beans&gt;
  &lt;!-- 引用类bean声明 --&gt;
  &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt;
   &lt;!-- 构造函数引用 --&gt;
    &lt;constructor-arg ref=&quot;userDao&quot;/&gt;
  &lt;/bean&gt;
  &lt;!-- 被引用类bean声明 --&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code>      - constructor-arg标签：可以引用构造参数 ref引用其他bean的标识。
</code></pre>
<ol start="4">
<li>基于构造函数的依赖注入（多构造参数解析）<ol>
<li><p>介绍</p>
<p> 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。</p>
<p> 下面的示例演示通过构造函数注入多个参数，参数包含其他bean和基本数据类型！</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public class UserDao &#123;
&#125;


public class UserService &#123;
    
    private UserDao userDao;
    
    private int age;
    
    private String name;

    public UserService(int age , String name ,UserDao userDao) &#123;
        this.userDao = userDao;
        this.age = age;
        this.name = name;
    &#125;
&#125;
</code></pre>
<pre><code>  3. 编写配置文件
</code></pre>
<pre><code class="XML">&lt;!-- 场景1: 多参数，可以按照相应构造函数的顺序注入数据 --&gt;
&lt;beans&gt;
  &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt;
    &lt;!-- value直接注入基本类型值 --&gt;
    &lt;constructor-arg  value=&quot;18&quot;/&gt;
    &lt;constructor-arg  value=&quot;赵伟风&quot;/&gt;
    
    &lt;constructor-arg  ref=&quot;userDao&quot;/&gt;
  &lt;/bean&gt;
  &lt;!-- 被引用类bean声明 --&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;
&lt;/beans&gt;


&lt;!-- 场景2: 多参数，可以按照相应构造函数的名称注入数据 --&gt;
&lt;beans&gt;
  &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt;
    &lt;!-- value直接注入基本类型值 --&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;赵伟风&quot;/&gt;
    &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;constructor-arg name=&quot;age&quot;  value=&quot;18&quot;/&gt;
  &lt;/bean&gt;
  &lt;!-- 被引用类bean声明 --&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;
&lt;/beans&gt;

&lt;!-- 场景2: 多参数，可以按照相应构造函数的角标注入数据 
           index从0开始 构造函数(0,1,2....)
--&gt;
&lt;beans&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt;
    &lt;!-- value直接注入基本类型值 --&gt;
    &lt;constructor-arg index=&quot;1&quot; value=&quot;赵伟风&quot;/&gt;
    &lt;constructor-arg index=&quot;2&quot; ref=&quot;userDao&quot;/&gt;
    &lt;constructor-arg index=&quot;0&quot;  value=&quot;18&quot;/&gt;
  &lt;/bean&gt;
  &lt;!-- 被引用类bean声明 --&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code>      - constructor-arg标签：指定构造参数和对应的值
      - constructor-arg标签：name属性指定参数名、index属性指定参数角标、value属性指定普通属性值
</code></pre>
<ol start="5">
<li><strong>基于Setter方法依赖注入</strong><ol>
<li><p>介绍</p>
<p> 开发中，除了构造函数注入（DI）更多的使用的Setter方法进行注入！</p>
<p> 下面的示例演示一个只能使用纯 setter 注入进行依赖项注入的类。</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public Class MovieFinder&#123;

&#125;

public class SimpleMovieLister &#123;

  private MovieFinder movieFinder;
  
  private String movieName;

  public void setMovieFinder(MovieFinder movieFinder) &#123;
    this.movieFinder = movieFinder;
  &#125;
  
  public void setMovieName(String movieName)&#123;
    this.movieName = movieName;
  &#125;

  // business logic that actually uses the injected MovieFinder is omitted...
&#125;
</code></pre>
<pre><code>  3. 编写配置文件
</code></pre>
<pre><code class="XML">&lt;bean id=&quot;simpleMovieLister&quot; class=&quot;examples.SimpleMovieLister&quot;&gt;
  &lt;!-- setter方法，注入movieFinder对象的标识id
       name = 属性名  ref = 引用bean的id值
   --&gt;
  &lt;property name=&quot;movieFinder&quot; ref=&quot;movieFinder&quot; /&gt;

  &lt;!-- setter方法，注入基本数据类型movieName
       name = 属性名 value= 基本类型值
   --&gt;
  &lt;property name=&quot;movieName&quot; value=&quot;消失的她&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;movieFinder&quot; class=&quot;examples.MovieFinder&quot;/&gt;
</code></pre>
<pre><code>      - property标签： 可以给setter方法对应的属性赋值
      - property 标签： name属性代表**set方法标识**、ref代表引用bean的标识id、value属性代表基本属性值
</code></pre>
<p>  <strong>总结：</strong></p>
<pre><code>依赖注入（DI）包含引用类型和基本数据类型，同时注入的方式也有多种！主流的注入方式为setter方法注入和构造函数注入，两种注入语法都需要掌握！

需要特别注意：引用其他bean，使用ref属性。直接注入基本类型值，使用value属性。
</code></pre>
<p> <strong>IoC容器创建和使用</strong></p>
<ol>
<li><p>介绍</p>
<p> 上面的实验只是讲解了如何在XML格式的配置文件编写IoC和DI配置！</p>
<p> 如图：</p>
<p> <img src="https://secure2.wostatic.cn/static/ngQZT7qhVfAzTxrr2oX1ny/image.png?auth_key=1713686158-sbfHvbb8SRsw7s3ZkFgXtY-0-f2d76343dcd8e0eff2fb9205ed5498ca"></p>
<p> 想要配置文件中声明组件类信息真正的进行实例化成Bean对象和形成Bean之间的引用关系，我们需要声明IoC容器对象，读取配置文件，实例化组件和关系维护的过程都是在IoC容器中实现的！</p>
</li>
<li><p>容器实例化</p>
</li>
</ol>
<pre><code class="Java">//方式1:实例化并且指定配置文件
//参数：String...locations 传入一个或者多个配置文件
ApplicationContext context = 
           new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);
           
//方式2:先实例化，再指定配置文件，最后刷新容器触发Bean实例化动作 [springmvc源码和contextLoadListener源码方式]  
ApplicationContext context = 
           new ClassPathXmlApplicationContext();   
//设置配置配置文件,方法参数为可变参数,可以设置一个或者多个配置
iocContainer1.setConfigLocations(&quot;services.xml&quot;, &quot;daos.xml&quot;);
//后配置的文件,需要调用refresh方法,触发刷新配置
iocContainer1.refresh();           
</code></pre>
<ol start="3">
<li>​	对象读取</li>
</ol>
<pre><code class="Java">//方式1: 根据id获取
//没有指定类型,返回为Object,需要类型转化!
HappyComponent happyComponent = 
        (HappyComponent) iocContainer.getBean(&quot;bean的id标识&quot;);
        
//使用组件对象        
happyComponent.doWork();

//方式2: 根据类型获取
//根据类型获取,但是要求,同类型(当前类,或者之类,或者接口的实现类)只能有一个对象交给IoC容器管理
//配置两个或者以上出现: org.springframework.beans.factory.NoUniqueBeanDefinitionException 问题
HappyComponent happyComponent = iocContainer.getBean(HappyComponent.class);
happyComponent.doWork();

//方式3: 根据id和类型获取
HappyComponent happyComponent = iocContainer.getBean(&quot;bean的id标识&quot;, HappyComponent.class);
happyComponent.doWork();

根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，
只要返回的是true就可以认定为和类型匹配，能够获取到。
</code></pre>
<p>演示</p>
<pre><code class="java">package com.chenw.test;

import com.chenw.ioc_03.HappyComponent;
import org.junit.jupiter.api.Test;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringIoCTest &#123;
    /*
    * 如何创建ioc容器并且读取配置文件
    * */
    public void createIoC()&#123;
        //创建容器，选择合适的容器实现
        /*
        *接口
        * BeanFactory
        *   ApplicationContext
        * 实现类
        *   直接通过构造函数实例化
        *   ClassPathXmlApplicationContext
        *   FileSystemXmlApplicationContext
        *   AnnotationConfigApplicationContext
        *   WebApplicationContext
        *
        * */
        //构造函数（string...配置文件）可以写一个或者多个，推荐
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-03.xml&quot;);
        //先创建
        ClassPathXmlApplicationContext applicationContext1 = new ClassPathXmlApplicationContext();
        //外部配置文件的配置
        applicationContext1.setConfigLocations(&quot;spring-03.xml&quot;);
        //调用ioc和di的流程
        applicationContext1.refresh();


    &#125;
    /*
    *   如何在Ioc容器中获取组件Bean
    * */
    @Test
    public void getBeanFromIoC()&#123;
        //1.创建容器
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext();
        applicationContext.setConfigLocations(&quot;spring-03.xml&quot;);
        applicationContext.refresh();

        //2.读取ioc容器的组件
        //方案1:根据bean的id获取 返回值为object,这种需要强转不推荐
        HappyComponent happyComponent = (HappyComponent)applicationContext.getBean(&quot;happyComponent&quot;);
        //方案2:根据bean的id和类型获取
        HappyComponent happyComponent1 = applicationContext.getBean(&quot;happyComponent&quot;, HappyComponent.class);
        //方案3:直接根据类型获取
        HappyComponent bean = applicationContext.getBean(HappyComponent.class);
        happyComponent.doWork();  //HappyComponent.doWork
        happyComponent1.doWork(); //HappyComponent.doWork
        bean.doWork();   //HappyComponent.doWor

        //而且创建的都是同一个对象
        System.out.println(happyComponent1==happyComponent); //true
        System.out.println(happyComponent1==bean); //true
    &#125;

&#125;
</code></pre>
<pre><code class="xml">注意第三中方法，通过类的类对象作为参数可能出现一些问题 
如果下面这样，这样第三种方法就会出错
    &lt;bean id=&quot;happyComponent&quot; class=&quot;com.chenw.ioc_03.HappyComponent&quot;/&gt;
    &lt;bean id=&quot;happyComponent1&quot; class=&quot;com.chenw.ioc_03.HappyComponent&quot;/&gt;
</code></pre>
<pre><code class="java">还有一个注意点
第三中方法，如果该类实现一个接口吗，下面这些操作也是可行的，因为参数的判断是通过 instanceof
    例如
    package com.chenw.ioc_03;

public interface A &#123;
    void doWork();
&#125;

实现
package com.chenw.ioc_03;


public class HappyComponent implements A &#123;

    //默认包含无参数构造函数

    public void doWork() &#123;
        System.out.println(&quot;HappyComponent.doWork&quot;);
    &#125;
&#125;

配置
    &lt;bean id=&quot;happyComponent&quot; class=&quot;com.chenw.ioc_03.HappyComponent&quot;/&gt;
测试类
            A bean = applicationContext.getBean(A.class);
            bean.doWork();   //HappyComponent.doWork
</code></pre>
<p><strong>组件(bean)的作用域和周期方法的配置</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421165645730.png" alt="image-20240421165645730"></p>
<pre><code>我们可以组件类里面声明周期方法，然后通过配置文件告诉容器
</code></pre>
<ol>
<li>组件周期方法配置<ol>
<li><p>周期方法概念</p>
<p> 我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！</p>
<p> 类似于Servlet的init&#x2F;destroy方法,我们可以在周期方法完成初始化和释放资源等工作。</p>
</li>
<li><p>周期方法声明</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">package com.chenw.ioc_04;

public class JavaBean &#123;
    /*
    * 必须public 必须是void返回值 必须是无参数的
    * 命名是随意的的
    *
    * */
    public void init()&#123;
        System.out.println(&quot;javaBean.init&quot;);
    &#125;
    public void clear()&#123;
        System.out.println(&quot;JavaBean,clear&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">3. 周期方法配置
    &lt;bean id=&quot;javaBean&quot; class=&quot;com.chenw.ioc_04.JavaBean&quot; init-method=&quot;init&quot; destroy-method=&quot;clear&quot;/&gt;
</code></pre>
<pre><code class="xml">&lt;beans&gt;
  &lt;bean id=&quot;beanOne&quot; class=&quot;examples.BeanOne&quot; init-method=&quot;init&quot; /&gt;
  &lt;bean id=&quot;beanTwo&quot; class=&quot;examples.BeanTwo&quot; destroy-method=&quot;cleanup&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<p>例如</p>
<p>上面配置玩以后</p>
<pre><code class="java">    @Test
    public void Test_o4()&#123;
        //但我们创建ioc容器的时候 就会对组件实例化 ，然后就会调用初始化方法
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring_04.xml&quot;);
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421171007793.png" alt="image-20240421171007793"></p>
<p>怎么调用销毁呢？</p>
<pre><code class="java">    @Test
    public void Test_o4()&#123;
        //但我们创建ioc容器的时候 就会对组件实例化 ，然后就会调用初始化方法
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring_04.xml&quot;);

        //怎么调用销毁的方法呢？
        //当我们代码执行玩以后，ioc直接就会释放掉，没有机会去调用组件的销毁方法
        // 需要手动销毁ioc
        applicationContext.close();
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421171336304.png" alt="image-20240421171336304"></p>
<p>2.组件作用域配置</p>
<ol>
<li><p>Bean作用域概念</p>
<p> <code>&lt;bean</code> 标签声明Bean，只是将Bean的信息配置给SpringIoC容器！</p>
<p> 在IoC容器中，这些<code>&lt;bean</code>标签对应的信息转成Spring内部 <code>BeanDefinition</code> 对象，<code>BeanDefinition</code> 对象内，包含定义的信息（id,class,属性等等）！</p>
<p> 这意味着，<code>BeanDefinition</code>与<code>类</code>概念一样，SpringIoC容器可以可以根据<code>BeanDefinition</code>对象反射创建多个Bean对象实例。</p>
<p> 具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！</p>
<p> 例如，当我们写配置的时候默认的在BeanDefinition的scope为单列，就只会创建对象，如果是多例的话，每当我们获取对象的时候，获取就可能不是同一个对象</p>
<p> 如下</p>
<pre><code class="xml">    &lt;!--声明组件信息！默认就是单例模式  --&gt;
    &lt;bean id=&quot;javaBean2&quot; class=&quot;com.chenw.ioc_04.JavaBean2&quot;/&gt;
</code></pre>
<pre><code class="java">JavaBean2 javaBean2 = applicationContext.getBean(&quot;javaBean2&quot;, JavaBean2.class);
JavaBean2 javaBean21 = applicationContext.getBean(&quot;javaBean2&quot;, JavaBean2.class);
System.out.println(javaBean21 == javaBean2);  //true
</code></pre>
<p> 这就说明这个就是单例，在我们容器创建的时候实例对象</p>
<p> <strong>多例</strong></p>
<pre><code class="xml">&lt;!-- scope=&quot;prototype&quot; 这样获取的就是多例，每次获取就会创建一个新的对象 --&gt;
&lt;bean id=&quot;javaBean2&quot; class=&quot;com.chenw.ioc_04.JavaBean2&quot; scope=&quot;prototype&quot;/&gt;
</code></pre>
<pre><code class="java">JavaBean2 javaBean2 = applicationContext.getBean(&quot;javaBean2&quot;, JavaBean2.class);
JavaBean2 javaBean21 = applicationContext.getBean(&quot;javaBean2&quot;, JavaBean2.class);
System.out.println(javaBean21 == javaBean2);  //false
</code></pre>
<p> 上面就是多例，在获取bean的时候实例对象</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421173834085.png" alt="image-20240421173834085"></p>
</li>
<li><p>作用域可选值</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>在 IOC 容器中，这个 bean 的对象始终为单实例</td>
<td>IOC 容器初始化时</td>
<td>是</td>
</tr>
<tr>
<td>prototype</td>
<td>这个 bean 在 IOC 容器中有多个实例</td>
<td>获取 bean 时</td>
<td>否</td>
</tr>
</tbody></table>
<pre><code>    如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）：
</code></pre>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>request</td>
<td>请求范围内有效的实例</td>
<td>每次请求</td>
<td>否</td>
</tr>
<tr>
<td>session</td>
<td>会话范围内有效的实例</td>
<td>每次会话</td>
<td>否</td>
</tr>
</tbody></table>
<pre><code>3. 作用域配置

    配置scope范围
</code></pre>
<pre><code class="XML">&lt;!--bean的作用域 
    准备两个引用关系的组件类即可！！
--&gt;
&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;
&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;
&lt;bean id=&quot;happyMachine8&quot; scope=&quot;prototype&quot; class=&quot;com.atguigu.ioc.HappyMachine&quot;&gt;
    &lt;property name=&quot;machineName&quot; value=&quot;happyMachine&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;happyComponent8&quot; scope=&quot;singleton&quot; class=&quot;com.atguigu.ioc.HappyComponent&quot;&gt;
    &lt;property name=&quot;componentName&quot; value=&quot;happyComponent&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code>4. 作用域测试
</code></pre>
<pre><code class="Java">@Test
public void testExperiment08()  &#123;
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(&quot;配置文件名&quot;);

    HappyMachine bean = iocContainer.getBean(HappyMachine.class);
    HappyMachine bean1 = iocContainer.getBean(HappyMachine.class);
    //多例对比 false
    System.out.println(bean == bean1);

    HappyComponent bean2 = iocContainer.getBean(HappyComponent.class);
    HappyComponent bean3 = iocContainer.getBean(HappyComponent.class);
    //单例对比 true
    System.out.println(bean2 == bean3);
&#125;
</code></pre>
<p><strong>FactoryBean特性和使用</strong></p>
<pre><code>对于复杂bean的创建
</code></pre>
<p>​	<img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421175849476.png" alt="image-20240421175849476"></p>
<ol>
<li><p>FactoryBean简介</p>
<p> <code>FactoryBean</code> 接口是Spring IoC容器实例化逻辑的可插拔性点。</p>
<p> 用于配置复杂的Bean对象，可以将创建过程存储在<code>FactoryBean</code> 的getObject方法！</p>
<p> <code>FactoryBean&lt;T&gt;</code> 接口提供三种方法：</p>
<ul>
<li><p><code>T getObject()</code>: </p>
<p>  返回此工厂创建的对象的实例。该返回值会被存储到IoC容器！</p>
</li>
<li><p><code>boolean isSingleton()</code>: </p>
<p>  如果此 <code>FactoryBean</code> 返回单例，则返回 <code>true</code> ，否则返回 <code>false</code> 。此方法的默认实现返回 <code>true</code> （注意，lombok插件使用，可能影响效果）。</p>
</li>
<li><p><code>Class&lt;?&gt; getObjectType()</code>: 返回 <code>getObject()</code> 方法返回的对象类型，如果事先不知道类型，则返回 <code>null</code> 。</p>
</li>
</ul>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png">
 </p>
</li>
<li><p>FactoryBean使用场景</p>
<ol>
<li>代理类的创建</li>
<li>第三方框架整合</li>
<li>复杂对象实例化等</li>
</ol>
</li>
<li><p>Factorybean应用</p>
</li>
</ol>
<pre><code class="java">package com.chenw.ioc_05;

public class JavaBean &#123;
    private String name;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
</code></pre>
<ol>
<li>准备FactoryBean实现类</li>
</ol>
<pre><code class="Java">package com.chenw.ioc_05;

import org.springframework.beans.factory.FactoryBean;



/*
* 实现FactoryBean的接口
* 这个的泛型就是我们需要造出来的对象
* */
public class JavaBeanFactoryBean implements FactoryBean&lt;JavaBean&gt; &#123;
    @Override
    public JavaBean getObject() throws Exception &#123;
        //使用自己的方法实例化对象就行了
        JavaBean javaBean = new JavaBean();
        return javaBean;
    &#125;

    @Override
    public Class&lt;?&gt; getObjectType() &#123;
        return JavaBean.class;
    &#125;
&#125;
</code></pre>
<pre><code>2. 配置FactoryBean实现类
</code></pre>
<pre><code class="XML">    &lt;!--
        id 就是为getObject方法返回对象的值
        Class  factoryBean标准话工厂类

    --&gt;
    &lt;bean id=&quot;javaBean&quot; class=&quot;com.chenw.ioc_05.JavaBeanFactoryBean&quot;&gt;&lt;/bean&gt;
</code></pre>
<pre><code>3. 测试读取FactoryBean和FactoryBean.getObject对象
</code></pre>
<pre><code class="Java">    /*
    *   读取使用factoryBean 工厂配置组件对象
    * */
    @Test
    public void test_05()&#123;
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-05.xml&quot;);
        JavaBean javaBean = applicationContext.getBean(&quot;javaBean&quot;, JavaBean.class);
        javaBean.setName(&quot;王昌晨&quot;);
        System.out.println(javaBean.getName()); //王昌晨
    &#125;
</code></pre>
<ul>
<li><p>注意我们也可以获取工厂的对象，工厂bean的id值为&amp;+id值</p>
<p>例如</p>
<pre><code class="java">/*
* TODO:FactoryBean也会加入工厂，名字&amp;id
* */
Object bean = applicationContext.getBean(&quot;&amp;javaBean&quot;);
System.out.println(bean);//com.chenw.ioc_05.JavaBeanFactoryBean@3738449f
</code></pre>
</li>
</ul>
<p>4.FactoryBean和BeanFactory区别</p>
<p>**FactoryBean **是 Spring 中一种特殊的 bean，可以在 getObject() 工厂方法自定义的逻辑创建Bean！是一种能够生产其他 Bean 的 Bean。FactoryBean 在容器启动时被创建，而在实际使用时则是通过调用 getObject() 方法来得到其所生产的 Bean。因此，FactoryBean 可以自定义任何所需的初始化逻辑，生产出一些定制化的 bean。</p>
<p>一般情况下，整合第三方框架，都是通过定义FactoryBean实现！！！</p>
<p><strong>BeanFactory</strong> 是 Spring 框架的基础，其作为一个顶级接口定义了容器的基本行为，例如管理 bean 的生命周期、配置文件的加载和解析、bean 的装配和依赖注入等。BeanFactory 接口提供了访问 bean 的方式，例如 getBean() 方法获取指定的 bean 实例。它可以从不同的来源（例如 Mysql 数据库、XML 文件、Java 配置类等）获取 bean 定义，并将其转换为 bean 实例。同时，BeanFactory 还包含很多子类（例如，ApplicationContext 接口）提供了额外的强大功能。</p>
<p>总的来说，FactoryBean 和 BeanFactory 的区别主要在于前者是用于创建 bean 的接口，它提供了更加灵活的初始化定制功能，而后者是用于管理 bean 的框架基础接口，提供了基本的容器功能和 bean 生命周期管理。</p>
<p>还有一个注意点</p>
<p>如果我们想要在xml配置set方法设置，给我的name属性赋值</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421183500442.png" alt="image-20240421183500442"></p>
<p>切记不可以直接这样，这样就会直接给我们的bean工厂的name赋值，而不是加工的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421183554888.png" alt="image-20240421183554888"></p>
<p>但是我们可以这么写在工厂的里面，这样工厂像一个桥梁</p>
<pre><code class="java">package com.chenw.ioc_05;

import org.springframework.beans.factory.FactoryBean;



/*
* 实现FactoryBean的接口
* 这个的泛型就是我们需要造出来的对象
* */
public class JavaBeanFactoryBean implements FactoryBean&lt;JavaBean&gt; &#123;
    private String name;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public JavaBean getObject() throws Exception &#123;
        //使用自己的方法实例化对象就行了
        JavaBean javaBean = new JavaBean();
        javaBean.setName(name);
        return javaBean;
    &#125;

    @Override
    public Class&lt;?&gt; getObjectType() &#123;
        return JavaBean.class;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">&lt;bean id=&quot;javaBean&quot; class=&quot;com.chenw.ioc_05.JavaBeanFactoryBean&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;chenw&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>或者直接调用方法赋值</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421183855851.png" alt="image-20240421183855851"></p>
<p><strong>基于XML方式整合的三层架构组件</strong></p>
<ol>
<li><p>需求分析</p>
<p> 搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用XML方式进行组件管理！</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
</li>
<li><p>数据库准备</p>
</li>
</ol>
<pre><code class="Java">create database studb;

use studb;

CREATE TABLE students (
  id INT PRIMARY KEY,
  name VARCHAR(50) NOT NULL,
  gender VARCHAR(10) NOT NULL,
  age INT,
  class VARCHAR(50)
);

INSERT INTO students (id, name, gender, age, class)
VALUES
  (1, &#39;张三&#39;, &#39;男&#39;, 20, &#39;高中一班&#39;),
  (2, &#39;李四&#39;, &#39;男&#39;, 19, &#39;高中二班&#39;),
  (3, &#39;王五&#39;, &#39;女&#39;, 18, &#39;高中一班&#39;),
  (4, &#39;赵六&#39;, &#39;女&#39;, 20, &#39;高中三班&#39;),
  (5, &#39;刘七&#39;, &#39;男&#39;, 19, &#39;高中二班&#39;),
  (6, &#39;陈八&#39;, &#39;女&#39;, 18, &#39;高中一班&#39;),
  (7, &#39;杨九&#39;, &#39;男&#39;, 20, &#39;高中三班&#39;),
  (8, &#39;吴十&#39;, &#39;男&#39;, 19, &#39;高中二班&#39;);
</code></pre>
<ol>
<li>项目准备<ol>
<li><p>项目创建</p>
<p> spring-xml-practice-02</p>
</li>
<li><p>依赖导入</p>
</li>
</ol>
</li>
</ol>
<pre><code class="XML">&lt;dependencies&gt;
      &lt;!--spring context依赖--&gt;
      &lt;!--当你引入SpringContext依赖之后，表示将Spring的基础依赖引入了--&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
          &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
          &lt;version&gt;6.0.6&lt;/version&gt;
      &lt;/dependency&gt;

      &lt;!-- 数据库驱动和连接池--&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;mysql&lt;/groupId&gt;
          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
          &lt;version&gt;8.0.25&lt;/version&gt;
      &lt;/dependency&gt;

      &lt;dependency&gt;
          &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
          &lt;artifactId&gt;druid&lt;/artifactId&gt;
          &lt;version&gt;1.2.8&lt;/version&gt;
      &lt;/dependency&gt;

      &lt;!-- spring-jdbc --&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
          &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
          &lt;version&gt;6.0.6&lt;/version&gt;
      &lt;/dependency&gt;

&lt;/dependencies&gt; 
</code></pre>
<pre><code>3. 实体类准备
</code></pre>
<pre><code class="Java">public class Student &#123;

    private Integer id;
    private String name;
    private String gender;
    private Integer age;
    private String classes;

    public Integer getId() &#123;
        return id;
    &#125;

    public void setId(Integer id) &#123;
        this.id = id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getGender() &#123;
        return gender;
    &#125;

    public void setGender(String gender) &#123;
        this.gender = gender;
    &#125;

    public Integer getAge() &#123;
        return age;
    &#125;

    public void setAge(Integer age) &#123;
        this.age = age;
    &#125;

    public String getClasses() &#123;
        return classes;
    &#125;

    public void setClasses(String classes) &#123;
        this.classes = classes;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, gender=&#39;&quot; + gender + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, classes=&#39;&quot; + classes + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<ol start="2">
<li><p>JdbcTemplate技术讲解</p>
<blockquote>
<p>为了在特定领域帮助我们简化代码，Spring 封装了很多 『Template』形式的模板类。例如：RedisTemplate、RestTemplate 等等，包括我们今天要学习的 JdbcTemplate。</p>
</blockquote>
<p> jdbcTemplate的基本使用</p>
<pre><code class="java">package com.chenw.jdbc;

import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class jdbcTemplateTest &#123;
    public void testForJava()&#123;
        /*
        * jdbcTemplate  简化了数据库的curd 不提供连续持等操作
        * DruidDataSource  负责连接的创建和数据库驱动的注册
        *   所以DruidDataSource赋值给jdbcTemplate
        * */
        //1.实例对象
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        //2.调用方法
//        jdbcTemplate.update();     //DDL  DML   DCL ...非查询语句
//        jdbcTemplate.queryForObject();  //DQL 查询单个语句
//        jdbcTemplate.query()  //DQL查询集合
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl(&quot;jdbc:mysql:///studb&quot;);
        dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;root&quot;);
        //参数是连接池对象
        jdbcTemplate.setDataSource(dataSource);
    &#125;
&#125;
</code></pre>
<p> 上面时使用java代码实现，如何使用ioc管理呢？</p>
<p> 下面的操作在配置文件完成上面的操作</p>
<pre><code class="xml">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource &quot;&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///studb&quot;/&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
&lt;/bean&gt;
&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p> 但是一般的这个数据库的配置信息这样写不太好，所最好写一个配置文件</p>
<p> jdbc.properties</p>
<p> 提取数据库连接信息</p>
</li>
</ol>
<pre><code class=".properties">atguigu.url=jdbc:mysql://localhost:3306/studb
atguigu.driver=com.mysql.cj.jdbc.Driver
atguigu.username=root
atguigu.password=root
</code></pre>
<pre><code>springioc配置文件
</code></pre>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd 
       http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;


    &lt;!--读取外部的配置文件 .properties -&gt;  value = $&#123;&#125;--&gt;
    &lt;!--需要这，注意这里面的classpath是类路径的意思，而且只能支持properties的文件--&gt;
    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;chenw.url&#125;&quot;/&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;chenw.driver&#125;&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;chenw.username&#125;&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;chenw.password&#125;&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;	
    
&lt;/beans&gt;
</code></pre>
<pre><code>基于jdbcTemplate的CRUD使用
</code></pre>
<pre><code class="Java">package com.chenw.jdbc;

import com.alibaba.druid.pool.DruidDataSource;
import com.chenw.pojo.Student;
import org.junit.jupiter.api.Test;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

public class jdbcTemplateTest &#123;
    public void testForJava()&#123;
        /*
        * jdbcTemplate  简化了数据库的curd 不提供连续持等操作
        * DruidDataSource  负责连接的创建和数据库驱动的注册
        *   所以DruidDataSource赋值给jdbcTemplate
        * */
        //1.实例对象
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        //2.调用方法
//        jdbcTemplate.update();     //DDL  DML   DCL ...非查询语句
//        jdbcTemplate.queryForObject();  //DQL 查询单个语句
//        jdbcTemplate.query()  //DQL查询集合
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl(&quot;jdbc:mysql:///studb&quot;);
        dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;root&quot;);
        //参数是连接池对象
        jdbcTemplate.setDataSource(dataSource);
    &#125;

    /*
    * TODO 通过ioc容器读取配置的jdbcTemplate的组件
    * */
    @Test
    public void testForIoC()&#123;

        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-01.xml&quot;);
        JdbcTemplate jdbcTemplate = applicationContext.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
        //插入删除修改
        String sql = &quot;insert into students (id,name,gender,age,class) values (?,?,?,?,?)&quot;;
        /*
        * 参数1，sql语句
        * 参数二，占位符的值
        * 返回值是影响的行数
        * */
        int rows = jdbcTemplate.update(sql, 10,&quot;王昌晨&quot;, &quot;男&quot;, 18, &quot;三年二班&quot;);
        System.out.println(rows);


        //查询单条数据，返回实体对象
        sql = &quot;select  * from students where id = ?&quot;;
        /*
        * 参数一sql语句 可以使用占位符
        * 参数2 RowMapper 列名和属性名的映射器接口,里面的泛型是实体类对象
        * 参数3 Object ...params 占位符参数
        * 返回值 rowMapper指定的参数
        * */
//        Student student = jdbcTemplate.queryForObject(sql, new RowMapper&lt;Student&gt;() &#123;
//            @Override
//            public Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123;
//                //rs代表结果集
//                //rowNum 行数
//                //rs获取列的值 赋值给尸体类对象
//                Student student1 = new Student();
//                student1.setId(rs.getInt(&quot;id&quot;));
//                student1.setName(rs.getString(&quot;name&quot;));
//                student1.setGender(rs.getString(&quot;gender&quot;));
//                student1.setClasses(rs.getString(&quot;class&quot;));
//                return student1;
//            &#125;
//        &#125;, 1);
//        然后缓冲lamda表达式
        Student student = jdbcTemplate.queryForObject(sql, ( rs,     rowNum)-&gt;&#123;
                //rs代表结果集
                //rowNum 行数
                //rs获取列的值 赋值给尸体类对象
                Student student1 = new Student();
                student1.setId(rs.getInt(&quot;id&quot;));
                student1.setName(rs.getString(&quot;name&quot;));
                student1.setGender(rs.getString(&quot;gender&quot;));
                student1.setClasses(rs.getString(&quot;class&quot;));
                return student1;
            &#125;, 1);
        System.out.println(student);


        //查询所有的数据
        sql = &quot;select id ,name,gender,age,class as classes  from students&quot;;
        //注意这个BeanPropertyRowMapper，就自动实现映射，注意列名和实体类的属性名要一致，不一致的需要起别名
        List&lt;Student&gt; query = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;Student&gt;(Student.class), null);
        System.out.println(query);
    &#125;
&#125;
</code></pre>
<p>3.三层架构搭建和实现</p>
<ol>
<li>持久层</li>
</ol>
<pre><code class="Java">//接口
public interface StudentDao &#123;

    /**
     * 查询全部学生数据
     * @return
     */
    List&lt;Student&gt; queryAll();
&#125;

//实现类
public class StudentDaoImpl implements StudentDao &#123;

    private JdbcTemplate jdbcTemplate;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;

    /**
     * 查询全部学生数据
     * @return
     */
    @Override
    public List&lt;Student&gt; queryAll() &#123;

        String sql = &quot;select id , name , age , gender , class as classes from students ;&quot;;

        /*
          query可以返回集合!
          BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可
         */
        List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class));

        return studentList;
   &#125;
&#125;
</code></pre>
<pre><code>2. 业务层
</code></pre>
<pre><code class="Java">//接口
public interface StudentService &#123;

    /**
     * 查询全部学员业务
     * @return
     */
    List&lt;Student&gt; findAll();

&#125;

//实现类
public class StudentServiceImpl  implements StudentService &#123;
    
    private StudentDao studentDao;

    public void setStudentDao(StudentDao studentDao) &#123;
        this.studentDao = studentDao;
    &#125;

    /**
     * 查询全部学员业务
     * @return
     */
    @Override
    public List&lt;Student&gt; findAll() &#123;
        
        List&lt;Student&gt; studentList =  studentDao.queryAll();
        
        return studentList;
    &#125;
&#125;
</code></pre>
<pre><code>3. 表述层
</code></pre>
<pre><code class="Java">public class StudentController &#123;
    
    private StudentService studentService;

    public void setStudentService(StudentService studentService) &#123;
        this.studentService = studentService;
    &#125;
    
    public void  findAll()&#123;
       List&lt;Student&gt; studentList =  studentService.findAll();
        System.out.println(&quot;studentList = &quot; + studentList);
    &#125;
&#125;
</code></pre>
<ol start="4">
<li>三层架构IoC配置</li>
</ol>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;
    &lt;!--druid--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;chenw.url&#125;&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;chenw.username&#125;&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;chenw.password&#125;&quot;/&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;chenw.driver&#125;&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--jdbcTemplate--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--dao 配置注入 di jdbcTemplate--&gt;
    &lt;bean id=&quot;studentDao&quot; class=&quot;com.chenw.dao.Imp.StudentDaoImpl&quot;&gt;
        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--service 配置注入 di dao--&gt;
    &lt;bean id=&quot;studentServiceImp&quot; class=&quot;com.chenw.service.Imp.StudentServiceImp&quot;&gt;
        &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--controller 配置注入 di service--&gt;
    &lt;bean id=&quot;studentController&quot; class=&quot;com.chenw.controller.StudentController&quot;&gt;
        &lt;property name=&quot;studentService&quot; ref=&quot;studentServiceImp&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ol start="5">
<li>运行测试</li>
</ol>
<pre><code class="Java">    /*
    * 从ioc容器里面获取controller并且调用业务！内部都是ioc
    * */
    @Test
    public void testQueryAll()&#123;
        //创建ioc容器
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-02.xml&quot;);
        //获取组件对象
        StudentController bean = applicationContext.getBean(StudentController.class);
        //使用组件对象
        bean.findAll();
        //关闭容器
        applicationContext.close();
    &#125;
</code></pre>
<p>结果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421211218635.png" alt="image-20240421211218635"></p>
<p>6.XMLIoC方式问题总结</p>
<ol>
<li>注入的属性必须添加setter方法、代码结构乱！</li>
<li>配置文件和Java代码分离、编写不是很方便！</li>
<li>XML配置文件解析效率低</li>
</ol>
<p><strong>Bean注解标记和扫描 (IoC)</strong></p>
<ol>
<li><p><strong>注解理解</strong></p>
<p> 和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。</p>
<p> 本质上：所有一切的操作都是 Java 代码来完成的，XML 和注解只是告诉框架中的 Java 代码如何执行。</p>
<p> 举例：元旦联欢会要布置教室，蓝色的地方贴上元旦快乐四个字，红色的地方贴上拉花，黄色的地方贴上气球。</p>
<p> <img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img015.a6b65329.png"></p>
<p> 班长做了所有标记，同学们来完成具体工作。墙上的标记相当于我们在代码中使用的注解，后面同学们做的工作，相当于框架的具体操作。</p>
</li>
<li><p><strong>扫描理解</strong></p>
<p> Spring 为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注解进行后续操作。</p>
</li>
<li><p><strong>准备Spring项目和组件</strong></p>
<ol>
<li>准备项目pom.xml</li>
</ol>
</li>
</ol>
<pre><code class="XML">&lt;dependencies&gt;
    &lt;!--spring context依赖--&gt;
    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;6.0.6&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!--junit5测试--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code>  2. 准备组件类

      普通组件
</code></pre>
<pre><code class="Java">/**
 * projectName: com.atguigu.components
 *
 * description: 普通的组件
 */
public class CommonComponent &#123;
&#125;
</code></pre>
<pre><code>      Controller组件
</code></pre>
<pre><code class="Java">/**
 * projectName: com.atguigu.components
 *
 * description: controller类型组件
 */
public class XxxController &#123;
&#125;
</code></pre>
<pre><code>      Service组件
</code></pre>
<pre><code class="Java">/**
 * projectName: com.atguigu.components
 *
 * description: service类型组件
 */
public class XxxService &#123;
&#125;
</code></pre>
<pre><code>      Dao组件
</code></pre>
<pre><code class="Java">/**
 * projectName: com.atguigu.components
 *
 * description: dao类型组件
 */
public class XxxDao &#123;
&#125;
</code></pre>
<ol start="4">
<li><strong>组件添加标记注解</strong><ol>
<li><p>组件标记注解和区别</p>
<p> Spring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。</p>
<ul>
<li>注意:添加注解默认的id为类的开头小写</li>
</ul>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。</td>
</tr>
<tr>
<td>@Repository</td>
<td>该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
<tr>
<td>@Service</td>
<td>该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
<tr>
<td>@Controller</td>
<td>该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
</tbody></table>
<p>​<br>​          通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是在@Component注解的基础上起了三个新的名字。<br>​<br>​          对于Spring使用IOC容器管理这些组件来说没有区别，也就是语法层面没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。<br>​<br>​          注意：虽然它们本质上一样，但是为了代码的可读性、程序结构严谨！我们肯定不能随便胡乱标记。<br>​      2. 使用注解标记<br>​<br>​          普通组件</p>
<pre><code class="Java">/**
 * projectName: com.atguigu.components
 *
 * description: 普通的组件
 */
@Component
public class CommonComponent &#123;
&#125;
</code></pre>
<pre><code>      Controller组件
</code></pre>
<pre><code class="Java">/**
 * projectName: com.atguigu.components
 *
 * description: controller类型组件
 */
@Controller
public class XxxController &#123;
&#125;
</code></pre>
<pre><code>      Service组件
</code></pre>
<pre><code class="Java">/**
 * projectName: com.atguigu.components
 *
 * description: service类型组件
 */
@Service
public class XxxService &#123;
&#125;
</code></pre>
<pre><code>      Dao组件
</code></pre>
<pre><code class="Java">/**
 * projectName: com.atguigu.components
 *
 * description: dao类型组件
 */
@Repository
public class XxxDao &#123;
&#125;
</code></pre>
<ol start="5">
<li><p><strong>配置文件确定扫描范围</strong></p>
<p> 情况1：基本扫描配置</p>
</li>
</ol>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 配置自动扫描的包 --&gt;
    &lt;!-- 1.包要精准,提高性能!
         2.会扫描指定的包和子包内容
         3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等
    --&gt;
    &lt;context:component-scan base-package=&quot;com.chenw.ioc_01&quot;/&gt;
  
&lt;/beans&gt;
</code></pre>
<pre><code>  情况2：指定排除组件
</code></pre>
<pre><code class="XML">&lt;!-- 情况三：指定不扫描的组件 --&gt;
    &lt;context:component-scan base-package=&quot;com.chenw.ioc_01&quot;&gt;
        &lt;!--排序com.chenw.ioc_01下面的Repository的注解--&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot;/&gt;
        &lt;!--排序com.chenw.ioc_01下面的Service的注解--&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;/&gt;
    &lt;/context:component-scan&gt;
</code></pre>
<pre><code>  情况3：指定扫描组件
</code></pre>
<pre><code class="XML">&lt;!-- 情况四：仅扫描指定的组件 --&gt;
&lt;!-- 仅扫描 = 关闭默认规则 + 追加规则 --&gt;
&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;
    &lt;!--
        指定包下面的哪些注解是生效的
        注意
            因为base-package是指定包下面的所有的注解都生效，use-default-filters是指定这个包下面的注解都不生效
    --&gt;
    &lt;context:component-scan base-package=&quot;com.chenw.ioc_01&quot; use-default-filters=&quot;false&quot;&gt;
        &lt;!--上面的包的注解都失效了，才能指定哪些的注解生效--&gt;
        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot;/&gt;
    &lt;/context:component-scan&gt;
</code></pre>
<ol start="6">
<li><p><strong>组件BeanName问题</strong></p>
<p> 在我们使用 XML 方式管理 bean 的时候，每个 bean 都有一个唯一标识——id 属性的值，便于在其他地方引用。现在使用注解后，每个组件仍然应该有一个唯一标识。</p>
<p> 默认情况：</p>
<p> 类名首字母小写就是 bean 的 id。例如：SoldierController 类对应的 bean 的 id 就是 soldierController。</p>
<p> 使用value属性指定：</p>
</li>
</ol>
<pre><code class="Java">@Controller(value = &quot;tianDog&quot;)
public class SoldierController &#123;
&#125;
</code></pre>
<pre><code>  当注解中只设置一个属性时，value属性的属性名可以省略：
</code></pre>
<pre><code class="Java">@Service(&quot;smallDog&quot;)
public class SoldierService &#123;
&#125;
</code></pre>
<ol start="7">
<li><strong>总结</strong><ol>
<li>注解方式IoC只是标记哪些类要被Spring管理</li>
<li>最终，我们还需要XML方式或者后面讲解Java配置类方式指定注解生效的包</li>
<li><strong>现阶段配置方式为 注解 （标记）+ XML（扫描）</strong></li>
</ol>
</li>
</ol>
<p><strong>组件(Bean)作用域和周期方法注解</strong></p>
<ol>
<li>组件周期方法配置<ol>
<li><p>周期方法概念</p>
<p> 我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！</p>
<p> 类似于Servlet的init&#x2F;destroy方法,我们可以在周期方法完成初始化和释放资源等工作。</p>
</li>
<li><p>周期方法声明</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public class BeanOne &#123;
  //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表
  @PostConstruct  //注解制指定初始化方法
  public void init() &#123;
    // 初始化逻辑
  &#125;
&#125;

public class BeanTwo &#123;
  @PreDestroy //注解指定销毁方法
  public void cleanup() &#123;
    // 释放资源逻辑
  &#125;
&#125;
</code></pre>
<ol start="2">
<li>组件作用域配置<ol>
<li><p>Bean作用域概念</p>
<p> <code>&lt;bean</code> 标签声明Bean，只是将Bean的信息配置给SpringIoC容器！</p>
<p> 在IoC容器中，这些<code>&lt;bean</code>标签对应的信息转成Spring内部 <code>BeanDefinition</code> 对象，<code>BeanDefinition</code> 对象内，包含定义的信息（id,class,属性等等）！</p>
<p> 这意味着，<code>BeanDefinition</code>与<code>类</code>概念一样，SpringIoC容器可以可以根据<code>BeanDefinition</code>对象反射创建多个Bean对象实例。</p>
<p> 具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！</p>
</li>
<li><p>作用域可选值</p>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>在 IOC 容器中，这个 bean 的对象始终为单实例</td>
<td>IOC 容器初始化时</td>
<td>是</td>
</tr>
<tr>
<td>prototype</td>
<td>这个 bean 在 IOC 容器中有多个实例</td>
<td>获取 bean 时</td>
<td>否</td>
</tr>
</tbody></table>
<pre><code>    如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）：
</code></pre>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>request</td>
<td>请求范围内有效的实例</td>
<td>每次请求</td>
<td>否</td>
</tr>
<tr>
<td>session</td>
<td>会话范围内有效的实例</td>
<td>每次会话</td>
<td>否</td>
</tr>
</tbody></table>
<pre><code>3. 作用域配置
</code></pre>
<pre><code class="Java">package com.chenw.ioc_02;


import org.springframework.beans.factory.annotation.Configurable;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;


@Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON)  //默认的单列
@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE)  //多例模式
@Component
public class JavaBean &#123;
    /*
    * 周期方法名字随意，
    * 但是还是之前的要求，方法没有返回值，没有参数
    * */
    @PostConstruct
    public void init()&#123;
        System.out.println(&quot;init start&quot;);

    &#125;
    @PreDestroy
    public void destroy()&#123;
        System.out.println(&quot;destroy start&quot;);
    &#125;
&#125;
</code></pre>
<p>测试</p>
<pre><code class="java">    @Test
    public void testIoC_02()&#123;
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-02.xml&quot;);
        JavaBean javaBean = applicationContext.getBean(&quot;javaBean&quot;, JavaBean.class);
        JavaBean javaBean1 = applicationContext.getBean(&quot;javaBean&quot;, JavaBean.class);
        System.out.println(javaBean1 == javaBean);
        applicationContext.close();
        /*
        * 	init start
            init start
            false
        * */
    &#125;
</code></pre>
<pre><code>注意这里面没有调用周期方法destroy的方法，是因为多例不会调用
</code></pre>
<p><strong>基于注解的注入(引入类型的自动装配)</strong></p>
<ol>
<li><strong>设定场景</strong><ul>
<li><p>SoldierController 需要 SoldierService</p>
</li>
<li><p>SoldierService 需要 SoldierDao</p>
<p>同时在各个组件中声明要调用的方法。</p>
</li>
<li><p>SoldierController中声明方法</p>
</li>
</ul>
</li>
</ol>
<pre><code class="Java">import org.springframework.stereotype.Controller;

@Controller(value = &quot;tianDog&quot;)
public class SoldierController &#123;

    private SoldierService soldierService;

    public void getMessage() &#123;
        soldierService.getMessage();
    &#125;

&#125;
</code></pre>
<pre><code>- SoldierService中声明方法
</code></pre>
<pre><code class="Java">@Service(&quot;smallDog&quot;)
public class SoldierService &#123;

    private SoldierDao soldierDao;

    public void getMessage() &#123;
        soldierDao.getMessage();
    &#125;
&#125;
</code></pre>
<pre><code>- SoldierDao中声明方法
</code></pre>
<pre><code class="Java">@Repository
public class SoldierDao &#123;

    public void getMessage() &#123;
        System.out.print(&quot;I am a soldier&quot;);
    &#125;

&#125;
</code></pre>
<ol start="2">
<li><strong>自动装配实现</strong><ol>
<li><p>前提</p>
<p> 参与自动装配的组件（需要装配、被装配）全部都必须在IoC容器中。</p>
<p> 注意：不区分IoC的方式！XML和注解都可以！</p>
</li>
<li><p>@Autowired注解</p>
<p> 在成员变量上直接标记@Autowired注解即可，不需要提供setXxx()方法。以后我们在项目中的正式用法就是这样。</p>
</li>
<li><p>给Controller装配Service</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">@Controller(value = &quot;tianDog&quot;)
public class SoldierController &#123;
    
    @Autowired
    private SoldierService soldierService;
    
    public void getMessage() &#123;
        soldierService.getMessage();
    &#125;
    
&#125;
</code></pre>
<pre><code>4. 给Service装配Dao
</code></pre>
<pre><code class="Java">@Service(&quot;smallDog&quot;)
public class SoldierService &#123;
    
    @Autowired
    private SoldierDao soldierDao;
    
    public void getMessage() &#123;
        soldierDao.getMessage();
    &#125;
&#125;
</code></pre>
<ol start="3">
<li><strong>@Autowired注解细节</strong><ol>
<li>标记位置<ol>
<li><p>成员变量</p>
<p> <strong>这是最主要的使用方式！</strong></p>
<p> <strong>与xml进行bean ref引用不同，他不需要有set方法！</strong></p>
<p> <strong>所以这是直接属性进行赋值操作，不像之前的xml配置方式，通过set等方法实现</strong></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">@Service(&quot;smallDog&quot;)
public class SoldierService &#123;
    
    @Autowired
    private SoldierDao soldierDao;
    
    public void getMessage() &#123;
        soldierDao.getMessage();
    &#125;
&#125;
</code></pre>
<pre><code>    2. 构造器
</code></pre>
<pre><code class="Java">@Controller(value = &quot;tianDog&quot;)
public class SoldierController &#123;
    
    private SoldierService soldierService;
    
    @Autowired
    public SoldierController(SoldierService soldierService) &#123;
        this.soldierService = soldierService;
    &#125;
    ……
</code></pre>
<pre><code>    3. setXxx()方法
</code></pre>
<pre><code class="Java">@Controller(value = &quot;tianDog&quot;)
public class SoldierController &#123;

    private SoldierService soldierService;

    @Autowired
    public void setSoldierService(SoldierService soldierService) &#123;
        this.soldierService = soldierService;
    &#125;
    ……
</code></pre>
<ol start="2">
<li>工作流程</li>
</ol>
<p>​    <img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img018.2ff0ae09.png"></p>
<ul>
<li>首先根据所需要的组件类型到 IOC 容器中查找<ul>
<li>能够找到唯一的 bean：直接执行装配</li>
<li>如果完全找不到匹配这个类型的 bean：装配失败</li>
<li>和所需类型匹配的 bean 不止一个<ul>
<li>没有 @Qualifier 注解：根据 @Autowired 标记位置成员变量的变量名作为 bean 的 id 进行匹配<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
<li>使用 @Qualifier 注解：根据 @Qualifier 注解中指定的名称作为 bean 的id进行匹配<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="Java">@Controller(value = &quot;tianDog&quot;)
public class SoldierController &#123;
    
    @Autowired
    @Qualifier(value = &quot;maomiService222&quot;)
    // 根据面向接口编程思想，使用接口类型引入Service组件
    private ISoldierService soldierService;
</code></pre>
<ol start="4">
<li><p><strong>佛系装配</strong></p>
<p> 给 @Autowired 注解设置 required &#x3D; false 属性表示：能装就装，装不上就不装。但是实际开发时，基本上所有需要装配组件的地方都是必须装配的，用不上这个属性</p>
</li>
</ol>
<pre><code class="java">@Controller(value = &quot;tianDog&quot;)
public class SoldierController &#123;

    // 给@Autowired注解设置required = false属性表示：能装就装，装不上就不装
    @Autowired(required = false)
    private ISoldierService soldierService;
</code></pre>
<p>还有一种情况，对应多个的情况</p>
<p>例如</p>
<pre><code class="java">controller层有一个的定义的一个接口的成员变量，UserService
    他的下面有两个实现类
@Service
public class NewUserService implements UserService &#123;
    @Override
    public String show() &#123;
        return &quot;UserServiceImpl show&quot;;
    &#125;
&#125;
@Service
public class UserServiceImpl implements UserService &#123;
    @Override
    public String show() &#123;
        return &quot;UserServiceImpl show&quot;;
    &#125;
&#125;
上面都添加注解，而且没有指定名字，这样自动装配，就会出错	
</code></pre>
<pre><code class="java">public class UserController &#123;
    /*
    * @Autowired相当于&lt;property userService -&gt; 对应类型的bean装配&gt;
    //自动装配注解（DI）:1.ioc容器里面查找符合类型的组件的对象 2.设置给当前的属性（di）
    * */
    @Autowired
    private UserService userService;

    public void setUserService(UserService userService) &#123;
        this.userService = userService;
    &#125;

    @Test
    public void show()&#123;
        //调用业务层的show
        System.out.println(userService.show());
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240422111659141.png" alt="image-20240422111659141"></p>
<p>这样就会出错</p>
<pre><code>解决的方法
    1.成员属性名指定@AutoWired的时候，默认的会根据成员的属性名作为bean的id去查找
</code></pre>
<p>例如</p>
<p>我们的属性的名字为</p>
<pre><code>newUserService这样就会寻找id为newUserServicebean的bean
</code></pre>
<pre><code class="java">package com.chenw.ioc_03;


import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

@Controller
public class UserController &#123;
    /*
    * @Autowired相当于&lt;property userService -&gt; 对应类型的bean装配&gt;
    //自动装配注解（DI）:1.ioc容器里面查找符合类型的组件的对象 2.设置给当前的属性（di）
    * */
    @Autowired
    private UserService newUserService;

    public void setUserService(UserService userService) &#123;
        this.newUserService = userService;
    &#125;

    @Test
    public void show()&#123;
        //调用业务层的show
        System.out.println(newUserService.show());
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.chenw.ioc_03;


import org.springframework.stereotype.Service;

@Service
public class NewUserService implements UserService &#123;
    @Override
    public String show() &#123;
        return &quot;NewUserService show&quot;;
    &#125;
&#125;
</code></pre>
<p>再来测试</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240422112302142.png" alt="image-20240422112302142"></p>
<pre><code>解决方法2,注解
    @Qualifier，使用该注解指定Bean的id，不能单独使用必须配合autowired
</code></pre>
<pre><code class="java">@Autowired()
@Qualifier(&quot;userServiceImpl&quot;)
private UserService newUserService;

public void setUserService(UserService userService) &#123;
    this.newUserService = userService;
&#125;
</code></pre>
<p>测试</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240422115010462.png" alt="image-20240422115010462"></p>
<p>上面需要两个注解联合使用，</p>
<p>下面的Resource注解将他们的功能整合到一起,就直接实现找到对应id的bean然后实现自动装配</p>
<pre><code class="java">@Autowired(required = true) + @Qualifier(&quot;userServiceImpl&quot;)  = @Source(name=&quot;userServiceImpl&quot;)
</code></pre>
<ol start="5">
<li><p><strong>扩展JSR-250注解@Resource</strong></p>
<ul>
<li><p>理解JSR系列注解</p>
<p>  JSR（Java Specification Requests）是Java平台标准化进程中的一种技术规范，而JSR注解是其中一部分重要的内容。按照JSR的分类以及注解语义的不同，可以将JSR注解分为不同的系列，主要有以下几个系列：</p>
<ol>
<li>JSR-175: 这个JSR是Java SE 5引入的，是Java注解最早的规范化版本，Java SE 5后的版本中都包含该JSR中定义的注解。主要包括以下几种标准注解：</li>
</ol>
<ul>
<li><code>@Deprecated</code>: 标识一个程序元素（如类、方法或字段）已过时，并且在将来的版本中可能会被删除。</li>
<li><code>@Override</code>: 标识一个方法重写了父类中的方法。</li>
<li><code>@SuppressWarnings</code>: 抑制编译时产生的警告消息。</li>
<li><code>@SafeVarargs</code>: 标识一个有安全性警告的可变参数方法。</li>
<li><code>@FunctionalInterface</code>: 标识一个接口只有一个抽象方法，可以作为lambda表达式的目标。</li>
</ul>
<ol>
<li>JSR-250: 这个JSR主要用于在Java EE 5中定义一些支持注解。该JSR主要定义了一些用于进行对象管理的注解，包括：</li>
</ol>
<ul>
<li><code>@Resource</code>: 标识一个需要注入的资源，是实现Java EE组件之间依赖关系的一种方式。</li>
<li><code>@PostConstruct</code>: 标识一个方法作为初始化方法。</li>
<li><code>@PreDestroy</code>: 标识一个方法作为销毁方法。</li>
<li><code>@Resource.AuthenticationType</code>: 标识注入的资源的身份验证类型。</li>
<li><code>@Resource.AuthenticationType</code>: 标识注入的资源的默认名称。</li>
</ul>
<ol>
<li>JSR-269: 这个JSR主要是Java SE 6中引入的一种支持编译时元数据处理的框架，即使用注解来处理Java源文件。该JSR定义了一些可以用注解标记的注解处理器，用于生成一些元数据，常用的注解有：</li>
</ol>
<ul>
<li><code>@SupportedAnnotationTypes</code>: 标识注解处理器所处理的注解类型。</li>
<li><code>@SupportedSourceVersion</code>: 标识注解处理器支持的Java源码版本。</li>
</ul>
<ol>
<li>JSR-330: 该JSR主要为Java应用程序定义了一个依赖注入的标准，即Java依赖注入标准（javax.inject）。在此规范中定义了多种注解，包括：</li>
</ol>
<ul>
<li><code>@Named</code>: 标识一个被依赖注入的组件的名称。</li>
<li><code>@Inject</code>: 标识一个需要被注入的依赖组件。</li>
<li><code>@Singleton</code>: 标识一个组件的生命周期只有一个唯一的实例。</li>
</ul>
<ol>
<li>JSR-250: 这个JSR主要是Java EE 5中定义一些支持注解。该JSR包含了一些支持注解，可以用于对Java EE组件进行管理，包括：</li>
</ol>
<ul>
<li><code>@RolesAllowed</code>: 标识授权角色</li>
<li><code>@PermitAll</code>: 标识一个活动无需进行身份验证。</li>
<li><code>@DenyAll</code>: 标识不提供针对该方法的访问控制。</li>
<li><code>@DeclareRoles</code>: 声明安全角色。</li>
</ul>
<p>  但是你要理解JSR是Java提供的<strong>技术规范</strong>，也就是说，他只是规定了注解和注解的含义，<strong>JSR并不是直接提供特定的实现</strong>，而是提供标准和指导方针，由第三方框架（Spring）和库来实现和提供对应的功能。</p>
</li>
<li><p>JSR-250 @Resource注解</p>
<p>  @Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？</p>
<ul>
<li>@Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。)</li>
<li>@Autowired注解是Spring框架自己的。</li>
<li><strong>@Resource注解默认根据Bean名称装配，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型装配。</strong></li>
<li><strong>@Autowired注解默认根据类型装配，如果想根据名称装配，需要配合@Qualifier注解一起用。</strong></li>
<li>@Resource注解用在属性上、setter方法上。</li>
<li>@Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。</li>
</ul>
<p>  @Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【<strong>高于JDK11或低于JDK8需要引入以下依赖</strong>】</p>
</li>
</ul>
</li>
</ol>
<pre><code class="XML">&lt;dependency&gt;
    &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;
    &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;
    &lt;version&gt;2.1.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code>- @Resource使用
</code></pre>
<pre><code class="Java">@Controller
public class XxxController &#123;
    /**
     * 1. 如果没有指定name,先根据属性名查找IoC中组件xxxService
     * 2. 如果没有指定name,并且属性名没有对应的组件,会根据属性类型查找
     * 3. 可以指定name名称查找!  @Resource(name=&#39;test&#39;) == @Autowired + @Qualifier(value=&#39;test&#39;)
     */
    @Resource
    private XxxService xxxService;

    //@Resource(name = &quot;指定beanName&quot;)
    //private XxxService xxxService;

    public void show()&#123;
        System.out.println(&quot;XxxController.show&quot;);
        xxxService.show();
    &#125;
&#125;
</code></pre>
<p>注意resource是这个包</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240422120914997.png" alt="image-20240422120914997"></p>
<p><strong>赋值类型的属性赋值(使用注解)</strong></p>
<p><code>@Value</code> 通常用于注入外部化属性</p>
<p><strong>声明外部配置</strong></p>
<p>jdbc.properties</p>
<pre><code class="Java">jdbc.username=root
jdbc.password=root
</code></pre>
<p><strong>xml引入外部配置</strong></p>
<pre><code class="Java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;com.chenw.ioc_04&quot;/&gt;
        //引入外部的配置文件
    &lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>@Value注解读取配置</strong></p>
<pre><code class="java">package com.chenw.ioc_04;


import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class JavaBean &#123;

    //方案1直接赋值
    //方案2 注解赋值，通常一般是直接赋值，一般使用注解是读取外部的信息
    @Value(&quot;张三&quot;)
    private String name;
    @Value(&quot;$&#123;jdbc.username&#125;&quot;)
    private String username;
    @Value(&quot;$&#123;jdbc.password&#125;&quot;)
    private String password;
&#125;
</code></pre>
<p><strong>测试</strong></p>
<pre><code class="java">    @Test
    public void testIoC_04()&#123;
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-04.xml&quot;);
        com.chenw.ioc_04.JavaBean bean = applicationContext.getBean(com.chenw.ioc_04.JavaBean.class);
        System.out.println(bean);
    &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240422162441038.png" alt="image-20240422162441038"></p>
<p>注解那里还可以添加默认值</p>
<pre><code class="java">@Value(&quot;$&#123;jdbc.username:胡图图&#125;&quot;)
private String username;
</code></pre>
<pre><code>如果外部的配置文件的里面没有username的值，那么就会使用胡图图
</code></pre>
<pre><code>对于之前的第三方的jar包，我们不能再第三方jar包上面添加注解，需要使用XML的方式进行配置	 
</code></pre>
<p><strong>使用注解+XML的方式实现整合的三层架构</strong></p>
<ol>
<li>三层架构搭建和实现<ol>
<li>持久层</li>
</ol>
</li>
</ol>
<pre><code class="Java">package com.chenw.dao;

import com.chenw.pojo.Student;

import java.util.List;

public interface StudentDao &#123;
    List&lt;Student&gt; queryAll();
&#125;


//实现类
package com.chenw.dao.Impl;

import com.chenw.dao.StudentDao;
import com.chenw.pojo.Student;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Repository;

import java.util.List;


@Repository
public class StudentDaoImpl implements StudentDao &#123;
    @Autowired
    private JdbcTemplate jdbcTemplate;
    @Override
    public List&lt;Student&gt; queryAll() &#123;
        String sql = &quot;select id ,name , age ,gender,class as classes from students&quot;;
        List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class));
        return studentList;
    &#125;
&#125;

</code></pre>
<pre><code>2. 业务层
</code></pre>
<pre><code class="Java">//接口
package com.chenw.service;

import com.chenw.pojo.Student;

import java.util.List;

public interface StudentService &#123;

    /**
     * 查询全部学员业务
     * @return
     */
    List&lt;Student&gt; findAll();

&#125;

//实现类
import com.chenw.pojo.Student;
import com.chenw.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class StudentServiceImpl  implements StudentService &#123;

    @Autowired
    private StudentDao studentDao;

    /**
     * 查询全部学员业务
     * @return
     */
    @Override
    public List&lt;Student&gt; findAll() &#123;

        List&lt;Student&gt; studentList =  studentDao.queryAll();

        return studentList;
    &#125;
&#125;
</code></pre>
<pre><code>3. 表述层
</code></pre>
<pre><code class="Java">package com.chenw.controller;

import com.chenw.pojo.Student;
import com.chenw.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

import java.util.List;

@Controller
public class StudentController &#123;

    @Autowired
    private StudentService studentService;

    public void  findAll()&#123;
       List&lt;Student&gt; studentList =  studentService.findAll();
        System.out.println(&quot;studentList = &quot; + studentList);
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>三层架构IoC配置</li>
</ol>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!--将自己的类注解扫描--&gt;
    &lt;context:component-scan base-package=&quot;com.chenw&quot;/&gt;

    &lt;!--第三方的类依然使用bean标签配置--&gt;
    &lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;chenw.driver&#125;&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;chenw.username&#125;&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;chenw.password&#125;&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;chenw.url&#125;&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ol start="3">
<li>运行测试</li>
</ol>
<pre><code class="Java">    @Test
    public void test()&#123;
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        StudentController bean = applicationContext.getBean(StudentController.class);
        bean.findAll();
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240422171952627.png" alt="image-20240422171952627"></p>
<p>4.注解+XML IoC方式问题总结</p>
<ol>
<li>自定义类可以使用注解方式，但是第三方依赖的类依然使用XML方式！</li>
<li>XML格式解析效率低！</li>
</ol>
<p><strong>配置类完成完全的注解开发</strong></p>
<pre><code>之前我们使用注解，还需要XML配置文件进行辅助，但是使用配置类的方法以后，就可以不用写配置文件了
</code></pre>
<h4 id="4-4-1-完全注解开发理解"><a href="#4-4-1-完全注解开发理解" class="headerlink" title="4.4.1 完全注解开发理解"></a>4.4.1 完全注解开发理解</h4><p>  Spring 完全注解配置（Fully Annotation-based Configuration）是指通过 Java配置类 代码来配置 Spring 应用程序，使用注解来替代原本在 XML 配置文件中的配置。相对于 XML 配置，完全注解配置具有更强的类型安全性和更好的可读性。</p>
<p>  <strong>两种方式思维转化</strong>：</p>
<p>  <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<p><strong>配置类和扫描注解</strong></p>
<p><strong>xml+注解方式</strong></p>
<p>配置文件application.xml</p>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;


    &lt;!-- 配置自动扫描的包 --&gt;
    &lt;!-- 1.包要精准,提高性能!
         2.会扫描指定的包和子包内容
         3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等
    --&gt;
    &lt;context:component-scan base-package=&quot;com.atguigu.components&quot;/&gt;

    &lt;!-- 引入外部配置文件--&gt;
    &lt;context:property-placeholder location=&quot;application.properties&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<p>测试创建IoC容器</p>
<pre><code class="Java"> // xml方式配置文件使用ClassPathXmlApplicationContext容器读取
 ApplicationContext applicationContext =
                new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
</code></pre>
<p><strong>配置类+注解方式（完全注解方式）</strong></p>
<p>配置类</p>
<p>使用 @Configuration 注解将一个普通的类标记为 Spring 的配置类。</p>
<pre><code class="Java">import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;

//标注当前类是配置类，替代application.xml    
@Configuration
//使用注解读取外部配置，替代 &lt;context:property-placeholder标签，指定类路径下的配置文件
@PropertySource(&quot;classpath:application.properties&quot;)
//使用@ComponentScan注解,可以配置扫描包,替代&lt;context:component-scan标签
@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)
public class MyConfiguration &#123;
    
&#125;
</code></pre>
<p>测试创建IoC容器</p>
<pre><code class="Java">// AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象
ApplicationContext iocContainerAnnotation = 
new AnnotationConfigApplicationContext(MyConfiguration.class);
</code></pre>
<p>可以使用 no-arg 构造函数实例化 <code>AnnotationConfigApplicationContext</code> ，然后使用 <code>register()</code> 方法对其进行配置。此方法在以编程方式生成 <code>AnnotationConfigApplicationContext</code> 时特别有用。以下示例演示如何执行此操作：</p>
<pre><code class="Java">// AnnotationConfigApplicationContext-IOC容器对象
ApplicationContext iocContainerAnnotation = 
new AnnotationConfigApplicationContext();
//外部设置配置类
iocContainerAnnotation.register(MyConfiguration.class);
//刷新后方可生效！！
iocContainerAnnotation.refresh();
</code></pre>
<p><strong>总结：</strong></p>
<p>  @Configuration指定一个类为配置类，可以添加配置注解，替代配置xml文件</p>
<p>  @ComponentScan(basePackages &#x3D; {“包”,”包”}) 替代&lt;context:component-scan标签实现注解扫描</p>
<p>  @PropertySource(“classpath:配置文件地址”) 替代 &lt;context:property-placeholder标签</p>
<p>  配合IoC&#x2F;DI注解，可以进行完整注解开发！</p>
<p><strong>@Bean定义组件</strong></p>
<pre><code>如果是第三方类那应该怎么声明
</code></pre>
<p><strong>场景需求</strong>：将Druid连接池对象存储到IoC容器</p>
<p><strong>需求分析</strong>：第三方jar包的类，添加到ioc容器，无法使用@Component等相关注解！因为源码jar包内容为只读模式！</p>
<p><strong>xml方式实现</strong>：</p>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;


    &lt;!-- 引入外部属性文件 --&gt;
    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;

    &lt;!-- 实验六 [重要]给bean的属性赋值：引入外部属性文件 --&gt;
    &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p><strong>配置类方式实现</strong>：</p>
<p>  <code>@Bean</code> 注释用于指示方法实例化、配置和初始化要由 Spring IoC 容器管理的新对象。对于那些熟悉 Spring 的 <code>&lt;beans/&gt;</code> XML 配置的人来说， <code>@Bean</code> 注释与 <code>&lt;bean/&gt;</code> 元素起着相同的作用。</p>
<pre><code class="Java">package com.chenw.config;



/*
*
*   1.b包扫描注解配置类，代替XML配置文件
*   2.引用外部的配置文件
*   3.声明第三方依赖的bean组件
* */

import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;

/*
*1.添加configuration的注解
* 2.实现上面的功能注解
* */
@Configuration
@ComponentScan(&quot;com.chenw.ioc_01&quot;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
public class JavaConfiguration &#123;
    @Value(&quot;$&#123;chenw.url&#125;&quot;)
    private String url;
    @Value(&quot;$&#123;chenw.username&#125;&quot;)
    private String username;
    @Value(&quot;$&#123;chenw.password&#125;&quot;)
    private String password;
    @Value(&quot;$&#123;chenw.driver&#125;&quot;)
    private String driver;

    /*
    *   方法的返回值的类型 == bean组件的类型或则其他的接口和父类
    *   方法名字  = bean的id的标识
    *   在方法体实现自定义类的过程
    *   最后添加@Bean注解 真正的让配置类的方法创建的组件存储到ioc容器
    *
    * */
    @Bean
    public DruidDataSource dataSource()&#123;
        //具体实例化的方法
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        dataSource.setDriverClassName(driver);
        dataSource.setUrl(url);
        return dataSource;
    &#125;
    /*
    * 这个最后就相当于
    * &lt;bean id=&quot;dataSource&quot; class=&quot;DruidSource&quot;&gt;
        配置
    *   &lt;/bean&gt;
    * */
    //注意读取配置文件的可以写在形参列表
    @Bean
    public DataSource createDataSource(@Value(&quot;$&#123;jdbc.user&#125;&quot;) String username,
                                       @Value(&quot;$&#123;jdbc.password&#125;&quot;)String password,
                                       @Value(&quot;$&#123;jdbc.url&#125;&quot;)String url,
                                       @Value(&quot;$&#123;jdbc.driver&#125;&quot;)String driverClassName)&#123;
        //使用Java代码实例化
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        dataSource.setUrl(url);
        dataSource.setDriverClassName(driverClassName);
        //返回结果即可
        return dataSource;
    &#125;
&#125;
</code></pre>
<p><strong>@Bean组件的高级使用</strong></p>
<ol>
<li><p><strong>@Bean生成BeanName问题</strong></p>
<pre><code>默认的bean的id为方法的名字
可以指定在Bean注解里面的使用name或者value属性进行赋值，value可以进行省略
</code></pre>
<p> @Bean注解源码：</p>
</li>
</ol>
<pre><code class="Java">public @interface Bean &#123;
    //前两个注解可以指定Bean的标识
    @AliasFor(&quot;name&quot;)
    String[] value() default &#123;&#125;;
    @AliasFor(&quot;value&quot;)
    String[] name() default &#123;&#125;;
  
    //autowireCandidate 属性来指示该 Bean 是否候选用于自动装配。
    //autowireCandidate 属性默认值为 true，表示该 Bean 是一个默认的装配目标，
    //可被候选用于自动装配。如果将 autowireCandidate 属性设置为 false，则说明该 Bean 不是默认的装配目标，不会被候选用于自动装配。
    boolean autowireCandidate() default true;

    //指定初始化方法
    String initMethod() default &quot;&quot;;
    //指定销毁方法
    String destroyMethod() default &quot;(inferred)&quot;;
&#125;
</code></pre>
<pre><code>指定@Bean的名称：
</code></pre>
<pre><code class="Java">@Configuration
public class AppConfig &#123;

  @Bean(&quot;myThing&quot;) //指定名称
  public Thing thing() &#123;
    return new Thing();
  &#125;
&#125;
</code></pre>
<pre><code>`@Bean` 注释注释方法。使用此方法在指定为方法返回值的类型的 `ApplicationContext` 中注册 Bean 定义。缺省情况下，Bean 名称与方法名称相同。下面的示例演示 `@Bean` 方法声明：
</code></pre>
<pre><code class="Java">@Configuration
public class AppConfig &#123;

  @Bean
  public TransferServiceImpl transferService() &#123;
    return new TransferServiceImpl();
  &#125;
&#125;
</code></pre>
<pre><code>前面的配置完全等同于下面的Spring XML：
</code></pre>
<pre><code class="Java">&lt;beans&gt;
  &lt;bean id=&quot;transferService&quot; class=&quot;com.acme.TransferServiceImpl&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<ol start="2">
<li><p><strong>@Bean 初始化和销毁方法指定</strong></p>
<p> <code>@Bean</code> 注解支持指定任意初始化和销毁回调方法，非常类似于 Spring XML 在 <code>bean</code> 元素上的 <code>init-method</code> 和 <code>destroy-method</code> 属性，如以下示例所示：</p>
</li>
</ol>
<pre><code class="Java">public class BeanOne &#123;

  public void init() &#123;
    // initialization logic
  &#125;
&#125;

public class BeanTwo &#123;

  public void cleanup() &#123;
    // destruction logic
  &#125;
&#125;

@Configuration
public class AppConfig &#123;

  @Bean(initMethod = &quot;init&quot;)
  public BeanOne beanOne() &#123;
    return new BeanOne();
  &#125;

  @Bean(destroyMethod = &quot;cleanup&quot;)
  public BeanTwo beanTwo() &#123;
    return new BeanTwo();
  &#125;
&#125;
</code></pre>
<ol start="3">
<li><p><strong>@Bean Scope作用域</strong></p>
<p> 可以指定使用 <code>@Bean</code> 注释定义的 bean 应具有特定范围。您可以使用在 Bean 作用域部分中指定的任何标准作用域。</p>
<p> 默认作用域为 <code>singleton</code> ，但您可以使用 <code>@Scope</code> 注释覆盖此范围，如以下示例所示：</p>
</li>
</ol>
<pre><code class="Java">@Configuration
public class MyConfiguration &#123;

  @Bean
  @Scope(scopeName = CofigurableBeanFactory.SCOPE_SINGLETON)
  public Encryptor encryptor() &#123;
    // ...
  &#125;
&#125;
</code></pre>
<ol start="4">
<li><p><strong>@Bean方法之间依赖</strong></p>
<p> 例如</p>
<pre><code class="java">package com.chenw.config;



/*
*
*   1.b包扫描注解配置类，代替XML配置文件
*   2.引用外部的配置文件
*   3.声明第三方依赖的bean组件
* */

import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;

/*
*1.添加configuration的注解
* 2.实现上面的功能注解
* */
@Configuration
@ComponentScan(&quot;com.chenw.ioc_01&quot;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
public class JavaConfiguration &#123;
    @Value(&quot;$&#123;chenw.url&#125;&quot;)
    private String url;
    @Value(&quot;$&#123;chenw.username&#125;&quot;)
    private String username;
    @Value(&quot;$&#123;chenw.password&#125;&quot;)
    private String password;
    @Value(&quot;$&#123;chenw.driver&#125;&quot;)
    private String driver;

    /*
    *   方法的返回值的类型 == bean组件的类型或则其他的接口和父类
    *   方法名字  = bean的id的标识
    *   在方法体实现自定义类的过程
    *   最后添加@Bean注解 真正的让配置类的方法创建的组件存储到ioc容器
    *
    * */
    @Bean
    public DruidDataSource dataSource()&#123;
        //具体实例化的方法
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        dataSource.setDriverClassName(driver);
        dataSource.setUrl(url);
        return dataSource;
    &#125;

    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123;
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        //两种方法
        //1.如果引用的组件也是使用@Bean注解，直接调用可以  | 本质上看是方法，其实是从ioc引用组件 | 不推荐
//        jdbcTemplate.setDataSource(dataSource());
        //2.利用形参列表传值,在形参列表写上对应的引用，或者多个引用，ioc会自动完成装配
        /*
            可能出现两种情况
        *   1.如果没有引用的
                注意形参蚕食注入，要求需要必须有对应的类型的组件，如果没有抛异常
        *   2.如果存在多个
                可以使用形成你名称 == 你需要的bean的id
        * */
        jdbcTemplate.setDataSource(dataSource);
        return  jdbcTemplate;
    &#125;
&#125;
</code></pre>
</li>
</ol>
<p><strong>扩展@Import注解的使用</strong></p>
<p><code>@Import</code> 注释允许从另一个配置类加载 <code>@Bean</code> 定义，如以下示例所示：</p>
<pre><code class="Java">@Configuration
public class ConfigA &#123;

  @Bean
  public A a() &#123;
    return new A();
  &#125;
&#125;

@Configuration
@Import(ConfigA.class)
public class ConfigB &#123;

  @Bean
  public B b() &#123;
    return new B();
  &#125;
&#125;
</code></pre>
<p>现在，在实例化上下文时不需要同时指定 <code>ConfigA.class</code> 和 <code>ConfigB.class</code> ，只需显式提供 <code>ConfigB</code> ，如以下示例所示：</p>
<pre><code class="Java">public static void main(String[] args) &#123;
  ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);

  // now both beans A and B will be available...
  A a = ctx.getBean(A.class);
  B b = ctx.getBean(B.class);
&#125;
</code></pre>
<p>此方法简化了容器实例化，因为只需要处理一个类，而不是要求您在构造期间记住可能大量的 <code>@Configuration</code> 类。</p>
<p><strong>基于注解和配置类的方式实现</strong></p>
<p>Dao层</p>
<pre><code class="java">接口
package com.chenw.dao;

import com.chenw.pojo.Student;

import java.util.List;

public interface StudentDao &#123;
    List&lt;Student&gt; queryAll();
&#125;
实现类
    
    
    
    
package com.chenw.dao.Impl;

import com.chenw.dao.StudentDao;
import com.chenw.pojo.Student;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;


@Repository
public class StudentDaoImpl implements StudentDao &#123;
    @Autowired
    private JdbcTemplate jdbcTemplate;
    @Override
    public List&lt;Student&gt; queryAll() &#123;
        String sql = &quot;select id ,name , age ,gender,class as classes from students&quot;;
        List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class));
        return studentList;
    &#125;
&#125;
</code></pre>
<p>service层</p>
<pre><code class="java">接口
package com.chenw.service;


import com.chenw.pojo.Student;

import java.util.List;

public interface StudentService &#123;

    /**
     * 查询全部学员业务
     * @return
     */
    List&lt;Student&gt; findAll();

&#125;



实现类
   package com.chenw.service.Impl;

import com.chenw.dao.StudentDao;
import com.chenw.pojo.Student;
import com.chenw.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class StudentServiceImpl  implements StudentService &#123;

    @Autowired
    private StudentDao studentDao;

    /**
     * 查询全部学员业务
     * @return
     */
    @Override
    public List&lt;Student&gt; findAll() &#123;

        List&lt;Student&gt; studentList =  studentDao.queryAll();

        return studentList;
    &#125;
&#125;
</code></pre>
<p>controller</p>
<pre><code class="java">package com.chenw.controller;

import com.chenw.pojo.Student;
import com.chenw.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

import java.util.List;

@Controller
public class StudentController &#123;

    @Autowired
    private StudentService studentService;

    public void  findAll()&#123;
       List&lt;Student&gt; studentList =  studentService.findAll();
        System.out.println(&quot;studentList = &quot; + studentList);
    &#125;
&#125;
</code></pre>
<p>配置类</p>
<pre><code class="java">package Config;


import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.jdbc.core.JdbcTemplate;

import javax.sql.DataSource;

@Configuration
@ComponentScan(&quot;com.chenw&quot;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
public class JavaConfig &#123;

    /**/
     @Bean
    public DruidDataSource dataSource(@Value(&quot;$&#123;chenw.username&#125;&quot; ) String username,
                                       @Value(&quot;$&#123;chenw.password&#125;&quot;)  String password,
                                      @Value(&quot;$&#123;chenw.url&#125;&quot;) String url,
                                      @Value(&quot;$&#123;chenw.driver&#125;&quot;) String driver
     )&#123;
         DruidDataSource dataSource = new DruidDataSource();
         dataSource.setUrl(url);
         dataSource.setPassword(password);
         dataSource.setDriverClassName(driver);
         dataSource.setUsername(username);
         return  dataSource;
     &#125;

     @Bean
     public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123;
         JdbcTemplate jdbcTemplate = new JdbcTemplate();
         jdbcTemplate.setDataSource(dataSource);
         return jdbcTemplate;
     &#125;
&#125;
</code></pre>
<p>测试</p>
<pre><code class="java">package com.chenw.test;

import Config.JavaConfig;
import com.chenw.controller.StudentController;
import org.junit.jupiter.api.Test;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class SpringTest &#123;
    @Test
    public void test()&#123;
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(JavaConfig.class);
        StudentController bean = applicationContext.getBean(StudentController.class);
        bean.findAll();
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240423104636325.png" alt="image-20240423104636325"></p>
<p><strong>总结</strong></p>
<p><strong>XML方式配置总结</strong></p>
<ol>
<li>所有内容写到xml格式配置文件中</li>
<li>声明bean通过&lt;bean标签</li>
<li>&lt;bean标签包含基本信息（id,class）和属性信息 &lt;property name value &#x2F; ref</li>
<li>引入外部的properties文件可以通过&lt;context:property-placeholder</li>
<li>IoC具体容器实现选择ClassPathXmlApplicationContext对象</li>
</ol>
<p><strong>XML+注解方式配置总结</strong></p>
<ol>
<li>注解负责标记IoC的类和进行属性装配</li>
<li>xml文件依然需要，需要通过&lt;context:component-scan标签指定注解范围</li>
<li>标记IoC注解：@Component,@Service,@Controller,@Repository </li>
<li>标记DI注解：@Autowired @Qualifier @Resource @Value</li>
<li>IoC具体容器实现选择ClassPathXmlApplicationContext对象</li>
</ol>
<p> <strong>完全注解方式配置总结</strong></p>
<ol>
<li>完全注解方式指的是去掉xml文件，使用配置类 + 注解实现</li>
<li>xml文件替换成使用@Configuration注解标记的类</li>
<li>标记IoC注解：@Component,@Service,@Controller,@Repository </li>
<li>标记DI注解：@Autowired @Qualifier @Resource @Value</li>
<li>&lt;context:component-scan标签指定注解范围使用@ComponentScan(basePackages &#x3D; {“com.atguigu.components”})替代</li>
<li>&lt;context:property-placeholder引入外部配置文件使用@PropertySource({“classpath:application.properties”,”classpath:jdbc.properties”})替代</li>
<li>&lt;bean 标签使用@Bean注解和方法实现</li>
<li>IoC具体容器实现选择AnnotationConfigApplicationContext对象</li>
</ol>
<p><strong>整合测试环境作用</strong></p>
<p>​	好处1：不需要自己创建IOC容器对象了</p>
<p>​	好处2：任何需要的bean都可以在测试类中直接享受自动装配</p>
<ol>
<li>导入相关依赖</li>
</ol>
<pre><code class="XML">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;6.0.6&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>整合测试注解使用</li>
</ol>
<pre><code class="java">package com.chenw.test;

import com.chenw.components.A;
import com.chenw.config.JavaConfig;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;


//@SpringJUnitConfig(locations = 指定xml文件， value = 指定配置类的)
@SpringJUnitConfig(value = JavaConfig.class)
public class SpringTest &#123;
    @Autowired
    private A a;
    @Test
    public void test()&#123;
        System.out.println(a);//com.chenw.components.A@b978d10
    &#125;

&#125;
</code></pre>
<p><strong>Spring AOP面向切面编程</strong></p>
<p>场景设定</p>
<ol>
<li><p>准备AOP项目</p>
<p> 项目名：spring-aop-annotation</p>
<p> pom.xml</p>
</li>
</ol>
<pre><code class="XML">&lt;dependencies&gt;
    &lt;!--spring context依赖--&gt;
    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;6.0.6&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!--junit5测试--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;


    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
        &lt;version&gt;6.0.6&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;
        &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;
        &lt;version&gt;2.1.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ol start="2">
<li>声明接口</li>
</ol>
<pre><code class="Java">/**
 *       + - * / 运算的标准接口!
 */
public interface Calculator &#123;
    
    int add(int i, int j);
    
    int sub(int i, int j);
    
    int mul(int i, int j);
    
    int div(int i, int j);
    
&#125;
</code></pre>
<ol start="3">
<li>接口实现</li>
</ol>
<pre><code class="Java">package com.atguigu.proxy;


/**
 * 实现计算接口,单纯添加 + - * / 实现! 掺杂其他功能!
 */
public class CalculatorPureImpl implements Calculator &#123;
    
    @Override
    public int add(int i, int j) &#123;
    
        int result = i + j;
    
        return result;
    &#125;
    
    @Override
    public int sub(int i, int j) &#123;
    
        int result = i - j;
    
        return result;
    &#125;
    
    @Override
    public int mul(int i, int j) &#123;
    
        int result = i * j;
    
        return result;
    &#125;
    
    @Override
    public int div(int i, int j) &#123;
    
        int result = i / j;
    
        return result;
    &#125;
&#125;
</code></pre>
<ol start="4">
<li><p>声明带日志接口实现</p>
<p> 新需求： 需要在每个方法中，添加控制台输出，输出参数和输出计算后的返回值！</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img002.f8e54219.png"></p>
</li>
</ol>
<pre><code class="Java">package com.atguigu.proxy;

/**
 * 在每个方法中,输出传入的参数和计算后的返回结果!
 */
public class CalculatorLogImpl implements Calculator &#123;
    
    @Override
    public int add(int i, int j) &#123;
    
        System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j);
        int result = i + j;
        System.out.println(&quot;方法内部 result = &quot; + result);
      
        return result;
    &#125;
    
    @Override
    public int sub(int i, int j) &#123;
    
        System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j);
    
        int result = i - j;
    
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    &#125;
    
    @Override
    public int mul(int i, int j) &#123;
    
        System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j);
    
        int result = i * j;
    
        System.out.println(&quot;方法内部 result = &quot; + result);
    
        return result;
    &#125;
    
    @Override
    public int div(int i, int j) &#123;
    
        System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j);
    
        int result = i / j;
    
        System.out.println(&quot;方法内部 result = &quot; + result);
        
        return result;
    &#125;
&#125;
</code></pre>
<ol start="5">
<li>代码问题分析<ol>
<li><p>代码缺陷</p>
<ul>
<li>对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力</li>
<li>附加功能代码重复，分散在各个业务功能方法中！冗余，且不方便统一维护！</li>
</ul>
</li>
<li><p>解决思路</p>
<p>   核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。</p>
<p>   将重复的代码统一提取，并且[[动态插入]]到每个业务方法！</p>
</li>
<li><p>技术困难</p>
<p> 解决问题的困难：提取重复附加功能代码到一个类中，可以实现</p>
<p> 但是如何将代码插入到各个方法中，我们不会，我们需要引用新技术！！！</p>
</li>
</ol>
</li>
</ol>
<p><strong>解决技术代理的问题</strong></p>
<pre><code>之前说过把重复操作的附加功能的代码提出来到一个单独的类，解耦合，然后动态插入，这样减少代码的使用还能解耦合，方便维护，代理模式就可以实现
</code></pre>
<ol>
<li><p><strong>代理模式</strong></p>
<p> 二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。</p>
<p> 无代理场景：</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img004.e76b3080.png"></p>
<p> 有代理场景：</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img005.74dd7746.png"></p>
<p> 生活中的代理：</p>
<ul>
<li>广告商找大明星拍广告需要经过经纪人</li>
<li>合作伙伴找大老板谈合作要约见面时间需要经过秘书</li>
<li>房产中介是买卖双方的代理</li>
<li>太监是大臣和皇上之间的代理</li>
</ul>
<p> 相关术语：</p>
<ul>
<li>代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。(中介)<ul>
<li>动词：指做代理这个动作，或这项工作</li>
<li>名词：扮演代理这个角色的类、对象、方法</li>
</ul>
</li>
<li>目标：<strong>被代理</strong>“套用”了核心逻辑代码的类、对象、方法。(房东)</li>
</ul>
<p> 代理在开发中实现的方式具体有两种：静态代理，[动态代理技术]</p>
</li>
<li><p><strong>静态代理</strong></p>
<p> 主动创建代理类：</p>
</li>
</ol>
<pre><code class="Java">public class CalculatorStaticProxy implements Calculator &#123;
    
    // 将被代理的目标对象声明为成员变量
    private Calculator target;
    
    public CalculatorStaticProxy(Calculator target) &#123;
        this.target = target;
    &#125;
    
    @Override
    public int add(int i, int j) &#123;
    
        // 附加功能由代理类中的代理方法来实现
        System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j);
    
        // 通过目标对象来实现核心业务逻辑
        int addResult = target.add(i, j);
    
        System.out.println(&quot;方法内部 result = &quot; + result);
    
        return addResult;
    &#125;
    ……
</code></pre>
<pre><code>静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。

提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。
</code></pre>
<ol start="3">
<li><p><strong>动态代理</strong></p>
<p> 动态代理技术分类</p>
<ul>
<li>JDK动态代理：JDK原生的实现方式，需要被代理的目标类必须<strong>实现接口</strong>！他会根据目标类的接口动态生成一个代理对象！代理对象和目标对象有相同的接口！（拜把子）</li>
<li>cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口！（认干爹）</li>
</ul>
<p> JDK动态代理技术实现（了解）</p>
<p>   <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img003.2fe524a2.png"></p>
<p>   代理工程：基于jdk代理技术，生成代理对象</p>
</li>
</ol>
<pre><code class="Java">public class ProxyFactory &#123;

    private Object target;

    public ProxyFactory(Object target) &#123;
        this.target = target;
    &#125;

    public Object getProxy()&#123;

        /**
         * newProxyInstance()：创建一个代理实例
         * 其中有三个参数：
         * 1、classLoader：加载动态生成的代理类的类加载器
         * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组
         * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法
         */
        ClassLoader classLoader = target.getClass().getClassLoader();
        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();
        InvocationHandler invocationHandler = new InvocationHandler() &#123;
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
                /**
                 * proxy：代理对象
                 * method：代理对象需要实现的方法，即其中需要重写的方法
                 * args：method所对应方法的参数
                 */
                Object result = null;
                try &#123;
                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，参数：&quot;+ Arrays.toString(args));
                    result = method.invoke(target, args);
                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，结果：&quot;+ result);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，异常：&quot;+e.getMessage());
                &#125; finally &#123;
                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，方法执行完毕&quot;);
                &#125;
                return result;
            &#125;
        &#125;;

        return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);
    &#125;
&#125;
</code></pre>
<pre><code>  测试代码：
</code></pre>
<pre><code class="Java">@Test
public void testDynamicProxy()&#123;
    ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl());
    Calculator proxy = (Calculator) factory.getProxy();
    proxy.div(1,0);
    //proxy.div(1,1);
&#125;

有一点需要记住
            Calculator proxy = (Calculator) factory.getProxy();这一个一定需要使用接口去接值，不能使用使用目标类去接值，因为它返回的是一个同一个接口的代理对象
</code></pre>
<ol start="4">
<li><p><strong>代理总结</strong></p>
<p> <strong>代理方式可以解决附加功能代码干扰核心代码和不方便统一维护的问题！</strong></p>
<p> 他主要是将附加功能代码提取到代理中执行，不干扰目标核心代码！</p>
<p> 但是我们也发现，无论使用静态代理和动态代理(jdk,cglib)，程序员的工作都比较繁琐！</p>
<p> 需要自己编写代理工厂等！</p>
<p> <strong>上面的代理的技术不用欸掌握，只是做了解</strong></p>
<p> 因为</p>
<pre><code>但是，提前剧透，我们在实际开发中，不需要编写代理代码，我们可以使用[Spring AOP]框架，

他会简化动态代理的实现！！！
</code></pre>
</li>
</ol>
<pre><code>AOP就是对代理的简化，也就是动态代理的简化
</code></pre>
<p><strong>面向切面编程思维（AOP）</strong></p>
<ol>
<li><p><strong>面向切面编程思想AOP</strong></p>
<p> AOP：Aspect Oriented Programming面向切面编程</p>
<p> AOP可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<p> AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p>
<p> 使用AOP，可以在不修改原来代码的基础上添加新功能。</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
</li>
<li><p><strong>AOP思想主要的应用场景</strong></p>
<p> AOP（面向切面编程）是一种编程范式，它通过将通用的横切关注点（如日志、事务、权限控制等）与业务逻辑分离，使得代码更加清晰、简洁、易于维护。AOP可以应用于各种场景，以下是一些常见的AOP应用场景：</p>
<ol>
<li>日志记录：在系统中记录日志是非常重要的，可以使用AOP来实现日志记录的功能，可以在方法执行前、执行后或异常抛出时记录日志。</li>
<li>事务处理：在数据库操作中使用事务可以保证数据的一致性，可以使用AOP来实现事务处理的功能，可以在方法开始前开启事务，在方法执行完毕后提交或回滚事务。</li>
<li>安全控制：在系统中包含某些需要安全控制的操作，如登录、修改密码、授权等，可以使用AOP来实现安全控制的功能。可以在方法执行前进行权限判断，如果用户没有权限，则抛出异常或转向到错误页面，以防止未经授权的访问。</li>
<li>性能监控：在系统运行过程中，有时需要对某些方法的性能进行监控，以找到系统的瓶颈并进行优化。可以使用AOP来实现性能监控的功能，可以在方法执行前记录时间戳，在方法执行完毕后计算方法执行时间并输出到日志中。</li>
<li>异常处理：系统中可能出现各种异常情况，如空指针异常、数据库连接异常等，可以使用AOP来实现异常处理的功能，在方法执行过程中，如果出现异常，则进行异常处理（如记录日志、发送邮件等）。</li>
<li>缓存控制：在系统中有些数据可以缓存起来以提高访问速度，可以使用AOP来实现缓存控制的功能，可以在方法执行前查询缓存中是否有数据，如果有则返回，否则执行方法并将方法返回值存入缓存中。</li>
<li>动态代理：AOP的实现方式之一是通过动态代理，可以代理某个类的所有方法，用于实现各种功能。</li>
</ol>
<p> 综上所述，AOP可以应用于各种场景，它的作用是将通用的横切关注点与业务逻辑分离，使得代码更加清晰、简洁、易于维护。</p>
</li>
<li><p><strong>AOP术语名词介绍</strong></p>
<p> 1-横切关注点</p>
<p> 从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。</p>
<p> 这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img007.9ad7afe5.png"></p>
<p> AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务、异常等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<p> 2-通知(增强)</p>
<p> 每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。</p>
<ul>
<li>前置通知：在被代理的目标方法前执行</li>
<li>返回通知：在被代理的目标方法成功结束后执行（<strong>寿终正寝</strong>）</li>
<li>异常通知：在被代理的目标方法异常结束后执行（<strong>死于非命</strong>）</li>
<li>后置通知：在被代理的目标方法最终结束后执行（<strong>盖棺定论</strong>）</li>
<li>环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</li>
</ul>
<p> <img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img008.ea600562.png"></p>
<p> 3-连接点 joinpoint</p>
<p> 这也是一个纯逻辑概念，不是语法定义的。</p>
<p> 指那些被拦截到的点。在 Spring 中，可以被动态代理拦截目标类的方法</p>
<p> <img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img010.5af189f7.png"></p>
<p> 4-切入点 pointcut</p>
<p> 定位连接点的方式，或者可以理解成被选中的连接点！</p>
<p> 是一个表达式，比如execution(* com.spring.service.impl.<em>.</em>(..))。符合条件的每个方法都是一个具体的连接点。</p>
<p> 5-切面 aspect</p>
<p> 切入点和通知的结合。是一个类。</p>
<p> <img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img009.a0b70cb3.png"></p>
<p> 6-目标 target</p>
<p> 被代理的目标对象。</p>
<p> 7-代理 proxy</p>
<p> 向目标对象应用通知之后创建的代理对象。</p>
<p> 8-织入 weave</p>
<p> 指把通知应用到目标上，生成代理对象的过程。可以在编译期织入，也可以在运行期织入，Spring采用后者。</p>
</li>
</ol>
<p>总的来说就是这样的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240423153840040.png" alt="image-20240423153840040"></p>
<p><strong>Spring AOP框架介绍和关系梳理</strong></p>
<ol>
<li>AOP一种区别于OOP的编程思维，用来完善和解决OOP的非核心代码冗余和不方便统一维护问题！</li>
<li>代理技术（动态代理|静态代理）是实现AOP思维编程的具体技术，但是自己使用动态代理实现代码比较繁琐！</li>
<li>Spring AOP框架，基于AOP编程思维，封装动态代理技术，简化动态代理技术实现的框架！SpringAOP内部帮助我们实现动态代理，我们只需写少量的配置，指定生效范围即可,即可完成面向切面思维编程的实现！</li>
</ol>
<p><strong>Spring AOP基于注解方式实现的细节</strong></p>
<p> <strong>Spring AOP底层技术组成</strong></p>
<p>  <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img006.84eb95b7.png"></p>
<ul>
<li>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。</li>
<li>cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。</li>
<li>AspectJ：早期的AOP实现的框架，<strong>SpringAOP借用了AspectJ中的AOP注解。所以我们还需要导入AspectJ的包，我们直接导入整合包spring-aspectj</strong></li>
</ul>
<p><strong>初步的实现</strong></p>
<ol>
<li>加入依赖</li>
<li><strong>实现的需求还是给计算的业务类，添加日志的功能</strong></li>
</ol>
<pre><code class="XML">&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
    &lt;version&gt;6.0.6&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
    &lt;version&gt;6.0.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>创建的测试的类</p>
<pre><code class="java">接口
package com.chenw.service;

public interface Calculator &#123;
    
    int add(int i, int j);
    
    int sub(int i, int j);
    
    int mul(int i, int j);
    
    int div(int i, int j);
    
&#125;
实现类
    package com.chenw.service.Impl;


import com.chenw.service.Calculator;
import org.springframework.stereotype.Component;

/**
 * 实现计算接口,单纯添加 + - * / 实现! 掺杂其他功能!
 */



/*
*
* aop -只针对ioc容器的对象 -》常见代理对象 -&gt; 代理对象储存到ioc容器的里面
*
* */
@Component
public class CalculatorPureImpl implements Calculator &#123;
    
    @Override
    public int add(int i, int j) &#123;
    
        int result = i + j;
    
        return result;
    &#125;
    
    @Override
    public int sub(int i, int j) &#123;
    
        int result = i - j;
    
        return result;
    &#125;
    
    @Override
    public int mul(int i, int j) &#123;
    
        int result = i * j;
    
        return result;
    &#125;
    
    @Override
    public int div(int i, int j) &#123;
    
        int result = i / j;
    
        return result;
    &#125;
&#125;
</code></pre>
<p>增强类</p>
<pre><code class="java">package com.chenw.advice;


import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

/*
*   增强类的内部可以存增强代码
*   定义储存增强代码
*       具体定义几个，是根据我们插入的位置决定
*       使用注解配置，指定插入目标方法的位置
*           前置  @Before
*           后置  @AfterReturning
*           异常  @AfterThrowing
*           最后  @After
*           环绕  @Around
*           例如 目标类的结构
*           try &#123;
*                   前置
*                   目标方法执行
*                   后置
*               &#125; catch()&#123;
*                           异常
*                          &#125; finally &#123;
*                                       最后
*                                      &#125;
*
*           3. 配置切点表达式
*           4.增强类也要放到ioc容器，
*                   加入ioc容器 @Component
*                   配置切面 @Aspectj = 切点 + 增强
*           5.开启aspectj注解的支持
* */
@Component
@Aspect
public class LogAdvice &#123;
    @Before(&quot;execution(* com.chenw.service.Impl.*.*(..))&quot;)
    public void start()&#123;
        System.out.println(&quot;方法开始了&quot;);
    &#125;
    @After(&quot;execution(* com.chenw.service.Impl.*.*(..))&quot;)
    public void after()&#123;
        System.out.println(&quot;方法结束了&quot;);
    &#125;
    @AfterThrowing(&quot;execution(* com.chenw.service.Impl.*.*(..))&quot;)
    public void error()&#123;
        System.out.println(&quot;方法出错了&quot;);
    &#125;
&#125;
</code></pre>
<p>配置类</p>
<pre><code class="java">package com.chenw.config;


import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@ComponentScan(&quot;com.chenw&quot;)

/*
*   在配置类开启aop注解的支持
*   等同于配置文件的
*   &lt;aop:aspectj-autoproxy/&gt;
* */
@EnableAspectJAutoProxy
public class JavaConfig &#123;
&#125;
</code></pre>
<p>如果使用XML配置文件的方式实现的话</p>
<pre><code class="xml">    &lt;context:component-scan base-package=&quot;com.chenw&quot;/&gt;
    &lt;!--在配置文件的里面开启aop的z注解支持--&gt;
    &lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">package com.chenw.test;


import com.chenw.config.JavaConfig;
import com.chenw.service.Calculator;
import com.chenw.service.Impl.CalculatorPureImpl;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;

@SpringJUnitConfig(value = JavaConfig.class)
public class SpringAopTest &#123;
    //oop - 代理 - jdk - 接口 -代理类 -代理对象和目标对象,是实现同一个接口的，而不是相同的对象或者继承，所以需要只当类型为接口
    @Autowired
    private Calculator calculator;

    @Test
    public void test()&#123;
        int add = calculator.add(1, 1);
        System.out.println(add);
    &#125;
&#125;
</code></pre>
<p>实现的结果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240423163637110.png" alt="image-20240423163637110"></p>
<p><strong>获取通知的细节信息</strong></p>
<ol>
<li><p><strong>JointPoint接口</strong></p>
<p> 需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参。</p>
<ul>
<li>要点1：JoinPoint 接口通过 getSignature() 方法获取目标方法的签名（方法声明时的完整信息）</li>
<li>要点2：通过目标方法签名对象获取方法名</li>
<li>要点3：通过 JoinPoint 对象获取外界调用目标方法时传入的实参列表组成的数组</li>
</ul>
</li>
</ol>
<pre><code class="Java">// @Before注解标记前置通知方法
// value属性：切入点表达式，告诉Spring当前通知方法要套用到哪个目标方法上
// 在前置通知方法形参位置声明一个JoinPoint类型的参数，Spring就会将这个对象传入
// 根据JoinPoint对象就可以获取目标方法名称、实际参数列表
@Before(value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;)
public void printLogBeforeCore(JoinPoint joinPoint) &#123;
    
    // 1.通过JoinPoint对象获取目标方法签名对象
    // 方法的签名：一个方法的全部声明信息
    Signature signature = joinPoint.getSignature();
    
    // 2.通过方法的签名对象获取目标方法的详细信息
    String methodName = signature.getName();
    System.out.println(&quot;methodName = &quot; + methodName);
    
    int modifiers = signature.getModifiers();
    System.out.println(&quot;modifiers = &quot; + modifiers);
    
    String declaringTypeName = signature.getDeclaringTypeName();
    System.out.println(&quot;declaringTypeName = &quot; + declaringTypeName);
    
    // 3.通过JoinPoint对象获取外界调用目标方法时传入的实参列表
    Object[] args = joinPoint.getArgs();
    
    // 4.由于数组直接打印看不到具体数据，所以转换为List集合
    List&lt;Object&gt; argList = Arrays.asList(args);
    
    System.out.println(&quot;[AOP前置通知] &quot; + methodName + &quot;方法开始了，参数列表：&quot; + argList);
&#125;
</code></pre>
<ol start="2">
<li><p><strong>方法返回值</strong></p>
<p> 在返回通知中，通过**@AfterReturning**注解的returning属性获取目标方法的返回值！</p>
</li>
</ol>
<pre><code class="Java">// @AfterReturning注解标记返回通知方法
// 在返回通知中获取目标方法返回值分两步：
// 第一步：在@AfterReturning注解中通过returning属性设置一个名称
// 第二步：使用returning属性设置的名称在通知方法中声明一个对应的形参
@AfterReturning(
        value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;,
        returning = &quot;targetMethodReturnValue&quot;
)
public void printLogAfterCoreSuccess(JoinPoint joinPoint, Object targetMethodReturnValue) &#123;
    
    String methodName = joinPoint.getSignature().getName();
    
    System.out.println(&quot;[AOP返回通知] &quot;+methodName+&quot;方法成功结束了，返回值是：&quot; + targetMethodReturnValue);
&#125;
</code></pre>
<ol start="3">
<li><p><strong>异常对象捕捉</strong></p>
<p> 在异常通知中，通过@AfterThrowing注解的throwing属性获取目标方法抛出的异常对象</p>
</li>
</ol>
<pre><code class="Java">// @AfterThrowing注解标记异常通知方法
// 在异常通知中获取目标方法抛出的异常分两步：
// 第一步：在@AfterThrowing注解中声明一个throwing属性设定形参名称
// 第二步：使用throwing属性指定的名称在通知方法声明形参，Spring会将目标方法抛出的异常对象从这里传给我们
@AfterThrowing(
        value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;,
        throwing = &quot;targetMethodException&quot;
)
public void printLogAfterCoreException(JoinPoint joinPoint, Throwable targetMethodException) &#123;
    
    String methodName = joinPoint.getSignature().getName();
    
    System.out.println(&quot;[AOP异常通知] &quot;+methodName+&quot;方法抛异常了，异常类型是：&quot; + targetMethodException.getClass().getName());
&#125;
</code></pre>
<p>例如</p>
<pre><code class="java">package com.chenw.advice;


import org.aopalliance.intercept.Joinpoint;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

import java.lang.reflect.Modifier;


/*
*   定义四个增强的方法，获取目标方法的信息，返回值，异常对象
*
* */
@Aspect
@Component
public class MyAdvice &#123;
    /*
    *   表达式里面第一个的 * 代表不考虑返回值和访问修饰符
    *   com..Impl 中间的..是跳过
    *   第一个的.*可以这个包下面的任意类
    *   第二个.*代表任意额方法
    *   最后的(..)意思是忽略参数
    *  TODO:增强方法中获取目标方法的信息
    *       1.全部增强方法中,获取目标方法的信息(方法名,参数，访问修饰符，所属类的信息)
    *               在方法的形参的里面添加 Joinpoint joinpoint     导入的包import org.aspectj.lang.JoinPoint;
    *               Joinpoint包含目标方法的信息
    *       2.返回的结果 -@Afterreturning
    *               (Object result)行参指定接收返回的结果
    *                @AfterReturning(value = &quot;execution(* com..Impl.*.*(..))&quot;,returning = &quot;result&quot;)
    *       3.获取异常的信息 -@AfterThrowing
    *                  形参(throwing = &quot;throwable&quot;)指定接收的异常信息
    *                   @AfterThrowing(value = &quot;execution(* com..Impl.*.*(..))&quot;,throwing = &quot;throwable&quot;)
    *                   加上指定的形参的名字
    * */
    @Before(&quot;execution(* com..Impl.*.*(..))&quot;)
    public void start(JoinPoint joinpoint)&#123;
        //获取方法属于的类的信息 getTarget获取类的对象
        String simpleName = joinpoint.getTarget().getClass().getSimpleName(); //获取类的名称
        ////获取访问修饰符
        int modifiers = joinpoint.getSignature().getModifiers();
        String s = Modifier.toString(modifiers);
        //获取目标方法的名字
        String name = joinpoint.getSignature().getName();
        //获取参数列表
        Object[] args = joinpoint.getArgs();//获取目标的参数
    &#125;

    @After(&quot;execution(* com..Impl.*.*(..))&quot;)
    public void after(JoinPoint joinpoint)&#123;

    &#125;
    @AfterThrowing(value = &quot;execution(* com..Impl.*.*(..))&quot;,throwing = &quot;throwable&quot;)
    public void afterThrowing(JoinPoint joinpoint,Throwable throwable)&#123;

    &#125;
    /*
    * 获取返回的参数
    *       需要指定第二个参数
    *       returning参数指定接受返回值的变量
    * */
    @AfterReturning(value = &quot;execution(* com..Impl.*.*(..))&quot;,returning = &quot;result&quot;)
    public void afterReturning(JoinPoint joinpoint,Object result)   &#123;

    &#125;
&#125;
</code></pre>
<p><strong>切点表达式的语法</strong></p>
<ol>
<li><p><strong>切点表达式作用</strong></p>
<p> AOP切点表达式（Pointcut Expression）是一种用于指定切点的语言，它可以通过定义匹配规则，来选择需要被切入的目标对象。</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img028.cb7f2153.png"></p>
</li>
<li><p><strong>切点表达式语法</strong></p>
<p> 切点表达式总结</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img011.dde1a79a.png"></p>
<p> 语法细节</p>
<ul>
<li>第一位：execution( ) 固定开头</li>
<li>第二位：方法访问修饰符</li>
</ul>
</li>
</ol>
<pre><code class="Java">public private 直接描述对应修饰符即可
</code></pre>
<pre><code>- 第三位：方法返回值
</code></pre>
<pre><code class="Java">int String void 直接描述返回值类型
</code></pre>
<pre><code>    注意：

    特殊情况 不考虑 访问修饰符和返回值

      execution(* * ) 这是错误语法
      要考虑就都考虑所以一个*就代表修师傅和返回值都是任意的
      execution(*) == 你只要考虑返回值 或者 不考虑访问修饰符 相当于全部不考虑了
- 第四位：指定包的地址
</code></pre>
<pre><code class="Java"> 固定的包: com.atguigu.api | service | dao
 单层的任意命名: com.atguigu.*  = com.atguigu.api  com.atguigu.dao  * = 任意一层的任意命名
 任意层任意命名: com.. = com.atguigu.api.erdaye com.a.a.a.a.a.a.a  ..任意层,任意命名 用在包上!
 注意: ..不能用作包开头   public int .. 错误语法  com..
 找到任何包下: *..
</code></pre>
<pre><code>- 第五位：指定类名称
</code></pre>
<pre><code class="Java">固定名称: UserService
任意类名: *
部分任意: com..service.impl.*Impl //以Impl结尾的类 
任意包任意类: *..*
</code></pre>
<pre><code>- 第六位：指定方法名称
</code></pre>
<pre><code class="Java">语法和类名一致
任意访问修饰符,任意类的任意方法: * *..*.*
</code></pre>
<pre><code>- 第七位：方法参数
</code></pre>
<pre><code class="Java">第七位: 方法的参数描述
       具体值: (String,int) != (int,String) 没有参数 ()
       模糊值: 任意参数 有 或者 没有 (..)  ..任意参数的意识
       部分具体和模糊:
         第一个参数是字符串的方法 (String..)
         最后一个参数是字符串 (..String)
         字符串开头,int结尾 (String..int)
         包含int类型(..int..)
</code></pre>
<ol start="3">
<li><strong>切点表达式案例</strong></li>
</ol>
<pre><code class="Java">1.查询某包某类下，访问修饰符是公有，返回值是int的全部方法
        execution(public int com.chenw.service.Impl.CalculatorPureImpl.*(..))
2.查询某包下类中第一个参数是String的方法
        &quot;execution(* com.chenw.service.Impl.*(String..))&quot;
3.查询全部包下，无参数的方法！
        &quot;execution(* *..*.*())&quot;
4.查询com包下，以int参数类型结尾的方法
        &quot;execution(* com..*.*(..int))&quot;
5.查询指定包下，Service开头类的私有返回值int的无参数方法
        execution(private int com.chenw.service.Impl.Service*.*())
</code></pre>
<p><strong>重用(提取)切点表达式</strong></p>
<ol>
<li>重用切点表达式优点</li>
</ol>
<pre><code class="Java"> // @Before注解：声明当前方法是前置通知方法
// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上
@Before(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)
public void printLogBeforeCore() &#123;
    System.out.println(&quot;[AOP前置通知] 方法开始了&quot;);
&#125;

@AfterReturning(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)
public void printLogAfterSuccess() &#123;
    System.out.println(&quot;[AOP返回通知] 方法成功返回了&quot;);
&#125;

@AfterThrowing(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)
public void printLogAfterException() &#123;
    System.out.println(&quot;[AOP异常通知] 方法抛异常了&quot;);
&#125;

@After(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)
public void printLogFinallyEnd() &#123;
    System.out.println(&quot;[AOP后置通知] 方法最终结束了&quot;);
&#125;
</code></pre>
<pre><code>上面案例，是我们之前编写切点表达式的方式，发现， 所有增强方法的切点表达式相同！

出现了冗余，如果需要切换也不方便统一维护！

我们可以将切点提取，在增强上进行引用即可！
</code></pre>
<ol start="2">
<li><p>同一类内部引用</p>
<p> 提取</p>
</li>
</ol>
<pre><code class="Java">// 切入点表达式重用
@Pointcut(&quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int)))&quot;)
public void declarPointCut() &#123;&#125;
</code></pre>
<pre><code>注意：提取切点注解使用@Pointcut(切点表达式) ， 需要添加到一个无参数无返回值方法上即可！

引用
</code></pre>
<pre><code class="Java">@Before(value = &quot;declarPointCut()&quot;)
public void printLogBeforeCoreOperation(JoinPoint joinPoint) &#123;
</code></pre>
<ol start="3">
<li><p>不同类中引用</p>
<p> 不同类在引用切点，只需要添加类的全限定符+方法名即可！</p>
</li>
</ol>
<pre><code class="Java">    @Before(&quot;com.chenw.pointcut.MyPointCut.fc()&quot;)
    public void start(JoinPoint joinpoint)&#123;
    &#125;
</code></pre>
<ol start="4">
<li><p>切点统一管理</p>
<p> 建议：将切点表达式统一存储到一个类中进行集中管理和维护！</p>
</li>
</ol>
<pre><code class="Java">package com.chenw.pointcut;


import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

@Component
@Aspect

/*
* 这个类里面只存放切点
* */
public class MyPointCut &#123;

    @Pointcut(&quot;execution(* com..Impl.*.*(..))&quot;)
    public void fc()&#123;&#125;

    @Pointcut(&quot;execution(* com..Imp.*.*(..))&quot;)
    public void fc1()&#123;&#125;
&#125;
</code></pre>
<p><strong>环绕通知</strong></p>
<pre><code>之前介绍前四种
    前置
    后置
    异常
    最后
环绕
    环绕允许我们自定义位置
    例如下面，这样就可以自定义
</code></pre>
<pre><code class="java">package com.chenw.advice;


import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class TxAroundAdvice &#123;
    /*
    *   TODO:环绕通知需要你在通知中，定义目标方法的执行
    *   proceedingJoinPoint目标方法(获取目标方法信息,多了一个执行方法)
    *   返回值 目标方法的返回值
    * */
    @Around(&quot;com.chenw.advice.MyAdvice.pc()&quot;)
    public  Object transaction(ProceedingJoinPoint proceedingJoinPoint)&#123;
//        保证目标方法被执行,有参数需要传递参数，没有参数就不用传递了
        Object[] args = proceedingJoinPoint.getArgs();
        Object result = null;
        try &#123;
            //在这里面添加增强代码
            System.out.println(&quot;开启事物&quot;);
            result = proceedingJoinPoint.proceed(args);
            System.out.println(&quot;结束事物&quot;);
        &#125; catch (Throwable e) &#123;
            System.out.println(&quot;事物回滚&quot;);
            throw new RuntimeException(e);
        &#125;
        return  result;
    &#125;
&#125;
</code></pre>
<p><strong>切面的优先级</strong></p>
<p>相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。</p>
<ul>
<li>优先级高的切面：外面</li>
<li>优先级低的切面：里面</li>
</ul>
<p>使用 @Order 注解可以控制切面的优先级：</p>
<ul>
<li>@Order(较小的数)：优先级高</li>
<li>@Order(较大的数)：优先级低</li>
</ul>
<p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img012.b353bc56.png"></p>
<p>实际意义</p>
<p>实际开发时，如果有多个切面嵌套的情况，要慎重考虑。例如：如果事务切面优先级高，那么在缓存中命中数据的情况下，事务切面的操作都浪费了。</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img013.53c41dc7.png"></p>
<p>此时应该将缓存切面的优先级提高，在事务操作之前先检查缓存中是否存在目标数据。</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img014.ee4ed40a.png"></p>
<p>例如在两个增强类里</p>
<pre><code class="java">@Component
@Aspect
@Order(10)
public class TxAdvice &#123;
    @Pointcut(&quot;execution(* com..Impl.*.*(..))&quot;)
    public void pc()&#123;&#125;
    @Before(&quot;pc()&quot;)
    public void begin()&#123;
        System.out.println(&quot;开启事物&quot;);
    &#125;
    @AfterReturning(&quot;pc()&quot;)
    public void commit()&#123;
        System.out.println(&quot;事物提交&quot;);
    &#125;
    @AfterThrowing(&quot;pc()&quot;)
    public void rollback()&#123;
        System.out.println(&quot;事物回滚&quot;);
    &#125;
&#125;



@Component
@Aspect
@Order(20)
public class LogAdvice &#123;
    @Before(&quot;execution(* com.chenw.service.Impl.*.*(..))&quot;)
    public void start()&#123;
        System.out.println(&quot;方法开始了&quot;);
    &#125;
    @After(&quot;execution(* com.chenw.service.Impl.*.*(..))&quot;)
    public void after()&#123;
        System.out.println(&quot;方法结束了&quot;);
    &#125;
    @AfterThrowing(&quot;execution(* com.chenw.service.Impl.*.*(..))&quot;)
    public void error()&#123;
        System.out.println(&quot;方法出错了&quot;);
    &#125;
&#125;
</code></pre>
<p>测试</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240423194145021.png" alt="image-20240423194145021"></p>
<pre><code>优先级高的事务，限制性前置通知，后置通知后执行
</code></pre>
<p><strong>CGLib动态代理生效</strong></p>
<pre><code>之前说过
    如果该类有接口的话，spring aoc底层就会使用JDK动态代理，如果没有的话，底层使用的是CGLib代理
</code></pre>
<p>如果目标类没有实现接口</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240423200504202.png" alt="image-20240423200504202"></p>
<p>这里面需要去接值</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240423200529934.png" alt="image-20240423200529934"></p>
<p>执行结果依然是可以的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240423200559043.png" alt="image-20240423200559043"></p>
<p><strong>使用总结</strong></p>
<pre><code class="java">使用总结：

  a.  如果目标类有接口,选择使用jdk动态代理

  b.  如果目标类没有接口,选择cglib动态代理

  c.  如果有接口,接口接值

  d.  如果没有接口,类进行接值
</code></pre>
<p><strong>Spring AOP基于XML方式实现</strong></p>
<ol>
<li><p>准备工作</p>
<p> 加入依赖</p>
<p> 和基于注解的 AOP 时一样。</p>
<p> 准备代码</p>
<p> 把测试基于注解功能时的Java类复制到新module中，去除所有注解。</p>
</li>
<li><p>配置Spring配置文件</p>
</li>
</ol>
<pre><code class="XML">&lt;!-- 配置目标类的bean --&gt;
&lt;bean id=&quot;calculatorPure&quot; class=&quot;com.atguigu.aop.imp.CalculatorPureImpl&quot;/&gt;
    
&lt;!-- 配置切面类的bean --&gt;
&lt;bean id=&quot;logAspect&quot; class=&quot;com.atguigu.aop.aspect.LogAspect&quot;/&gt;
    
&lt;!-- 配置AOP --&gt;
&lt;aop:config&gt;
    
    &lt;!-- 配置切入点表达式 --&gt;
    &lt;aop:pointcut id=&quot;logPointCut&quot; expression=&quot;execution(* *..*.*(..))&quot;/&gt;
    
    &lt;!-- aop:aspect标签：配置切面 --&gt;
    &lt;!-- ref属性：关联切面类的bean --&gt;
    &lt;aop:aspect ref=&quot;logAspect&quot;&gt;
        &lt;!-- aop:before标签：配置前置通知 --&gt;
        &lt;!-- method属性：指定前置通知的方法名 --&gt;
        &lt;!-- pointcut-ref属性：引用切入点表达式 --&gt;
        &lt;aop:before method=&quot;printLogBeforeCore&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;
    
        &lt;!-- aop:after-returning标签：配置返回通知 --&gt;
        &lt;!-- returning属性：指定通知方法中用来接收目标方法返回值的参数名 --&gt;
        &lt;aop:after-returning
                method=&quot;printLogAfterCoreSuccess&quot;
                pointcut-ref=&quot;logPointCut&quot;
                returning=&quot;targetMethodReturnValue&quot;/&gt;
    
        &lt;!-- aop:after-throwing标签：配置异常通知 --&gt;
        &lt;!-- throwing属性：指定通知方法中用来接收目标方法抛出异常的异常对象的参数名 --&gt;
        &lt;aop:after-throwing
                method=&quot;printLogAfterCoreException&quot;
                pointcut-ref=&quot;logPointCut&quot;
                throwing=&quot;targetMethodException&quot;/&gt;
    
        &lt;!-- aop:after标签：配置后置通知 --&gt;
        &lt;aop:after method=&quot;printLogCoreFinallyEnd&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;
    
        &lt;!-- aop:around标签：配置环绕通知 --&gt;
        &lt;!--&lt;aop:around method=&quot;……&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;--&gt;
    &lt;/aop:aspect&gt;
    
&lt;/aop:config&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="Java">@SpringJUnitConfig(locations = &quot;classpath:spring-aop.xml&quot;)
public class AopTest &#123;

    @Autowired
    private Calculator calculator;

    @Test
    public void testCalculator()&#123;
        System.out.println(calculator);
        calculator.add(1,1);
    &#125;
&#125;
</code></pre>
<p><strong>Spring声明式事物</strong></p>
<p><strong>编程式事务</strong></p>
<p>  编程式事务是指手动编写程序来管理事务，即通过编写代码的方式直接控制事务的提交和回滚。在 Java 中，通常使用事务管理器(如 Spring 中的 <code>PlatformTransactionManager</code>)来实现编程式事务。</p>
<p>  编程式事务的主要优点是灵活性高，可以按照自己的需求来控制事务的粒度、模式等等。但是，编写大量的事务控制代码容易出现问题，对代码的可读性和可维护性有一定影响。</p>
<pre><code class="Java">Connection conn = ...;
  
try &#123;
    // 开启事务：关闭事务的自动提交
    conn.setAutoCommit(false);
    // 核心操作
    // 业务代码
    // 提交事务
    conn.commit();
  
&#125;catch(Exception e)&#123;
  
    // 回滚事务
    conn.rollBack();
  
&#125;finally&#123;
  
    // 释放数据库连接
    conn.close();
  
&#125;
</code></pre>
<p>  编程式的实现方式存在缺陷：</p>
<ul>
<li>细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。</li>
<li>代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。</li>
</ul>
<p><strong>声明式事务</strong></p>
<p>  声明式事务是指使用注解或 XML 配置的方式来控制事务的提交和回滚。</p>
<p>  开发者只需要添加配置即可， 具体事务的实现由第三方框架实现，避免我们直接进行事务操作！</p>
<p>  使用声明式事务可以将事务的控制和业务逻辑分离开来，提高代码的可读性和可维护性。</p>
<p>  区别：</p>
<ul>
<li>编程式事务需要手动编写代码来管理事务</li>
<li>而声明式事务可以通过配置文件或注解来控制事务。</li>
</ul>
<p><strong>Spring事务管理器</strong></p>
<ol>
<li><p>Spring声明式事务对应依赖</p>
<ul>
<li>spring-tx: 包含声明式事务实现的基本规范（事务管理器规范接口和事务增强等等）</li>
<li>spring-jdbc: 包含DataSource方式事务管理器实现类DataSourceTransactionManager</li>
<li>spring-orm: 包含其他持久层框架的事务管理器实现类例如：Hibernate&#x2F;Jpa等</li>
</ul>
</li>
<li><p>Spring声明式事务对应事务管理器接口</p>
<p> <img src="https://secure2.wostatic.cn/static/cTpSy6E9Vzq4H8i1x7MLEf/image.png?auth_key=1714005756-umnHbDAKH7o75FxSKBENSn-0-6f35268ca292ab76450f7b1fc16ba011"></p>
<p> 我们现在要使用的事务管理器是org.springframework.jdbc.datasource.DataSourceTransactionManager，将来整合 JDBC方式、JdbcTemplate方式、Mybatis方式的事务实现！</p>
<p> DataSourceTransactionManager类中的主要方法：</p>
<ul>
<li>doBegin()：开启事务</li>
<li>doSuspend()：挂起事务</li>
<li>doResume()：恢复挂起的事务</li>
<li>doCommit()：提交事务</li>
<li>doRollback()：回滚事务</li>
</ul>
</li>
</ol>
<p><strong>基于注解声明式事物</strong></p>
<ol>
<li>准备项目</li>
</ol>
<pre><code class="XML">&lt;dependencies&gt;
  &lt;!--spring context依赖--&gt;
  &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
      &lt;version&gt;6.0.6&lt;/version&gt;
  &lt;/dependency&gt;

  &lt;!--junit5测试--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
      &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
      &lt;version&gt;5.3.1&lt;/version&gt;
  &lt;/dependency&gt;


  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
      &lt;version&gt;6.0.6&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;

  &lt;dependency&gt;
      &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;
      &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;
      &lt;version&gt;2.1.1&lt;/version&gt;
  &lt;/dependency&gt;

  &lt;!-- 数据库驱动 和 连接池--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;version&gt;8.0.25&lt;/version&gt;
  &lt;/dependency&gt;

  &lt;dependency&gt;
      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
      &lt;artifactId&gt;druid&lt;/artifactId&gt;
      &lt;version&gt;1.2.8&lt;/version&gt;
  &lt;/dependency&gt;

  &lt;!-- spring-jdbc --&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
      &lt;version&gt;6.0.6&lt;/version&gt;
  &lt;/dependency&gt;

  &lt;!-- 声明式事务依赖--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
      &lt;version&gt;6.0.6&lt;/version&gt;
  &lt;/dependency&gt;


  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
      &lt;version&gt;6.0.6&lt;/version&gt;
  &lt;/dependency&gt;

  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
      &lt;version&gt;6.0.6&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ol start="2">
<li><p>外部配置文件</p>
<p> jdbc.properties</p>
</li>
</ol>
<pre><code class=".properties">atguigu.url=jdbc:mysql://localhost:3306/studb
atguigu.driver=com.mysql.cj.jdbc.Driver
atguigu.username=root
atguigu.password=root
</code></pre>
<ol start="3">
<li>spring配置文件</li>
</ol>
<pre><code class="Java">@Configuration
@ComponentScan(&quot;com.atguigu&quot;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
public class JavaConfig &#123;

    @Value(&quot;$&#123;atguigu.driver&#125;&quot;)
    private String driver;
    @Value(&quot;$&#123;atguigu.url&#125;&quot;)
    private String url;
    @Value(&quot;$&#123;atguigu.username&#125;&quot;)
    private String username;
    @Value(&quot;$&#123;atguigu.password&#125;&quot;)
    private String password;



    //druid连接池
    @Bean
    public DataSource dataSource()&#123;
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName(driver);
        dataSource.setUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    &#125;


    @Bean
    //jdbcTemplate
    public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123;
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        jdbcTemplate.setDataSource(dataSource);
        return jdbcTemplate;
    &#125;

&#125;
</code></pre>
<ol start="4">
<li><p>准备dao&#x2F;service层</p>
<p> dao</p>
</li>
</ol>
<pre><code class="Java">@Repository
public class StudentDao &#123;
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    public void updateNameById(String name,Integer id)&#123;
        String sql = &quot;update students set name = ? where id = ? ;&quot;;
        int rows = jdbcTemplate.update(sql, name, id);
    &#125;

    public void updateAgeById(Integer age,Integer id)&#123;
        String sql = &quot;update students set age = ? where id = ? ;&quot;;
        jdbcTemplate.update(sql,age,id);
    &#125;
&#125;
</code></pre>
<pre><code>service
</code></pre>
<pre><code class="Java">@Service
public class StudentService &#123;
    
    @Autowired
    private StudentDao studentDao;
    
    public void changeInfo()&#123;
        studentDao.updateAgeById(100,1);
        System.out.println(&quot;-----------&quot;);
        studentDao.updateNameById(&quot;test1&quot;,1);
    &#125;
&#125;
</code></pre>
<ol start="5">
<li>测试环境搭建</li>
</ol>
<pre><code class="Java">/**
 * projectName: com.atguigu.test
 *
 * description:
 */
@SpringJUnitConfig(JavaConfig.class)
public class TxTest &#123;

    @Autowired
    private StudentService studentService;

    @Test
    public void  testTx()&#123;
        studentService.changeInfo();
    &#125;
&#125;
</code></pre>
<p><strong>基本事物控制</strong></p>
<ol>
<li><p>配置事务管理器</p>
<p> 数据库相关的配置</p>
</li>
</ol>
<pre><code class="Java">package com.chenw.config;


import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.*;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.TransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import javax.sql.DataSource;

@Configuration
@ComponentScan(&quot;com.chenw&quot;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
/*开启aspect的注解的支持*/
@EnableAspectJAutoProxy
/*开启事物注解的支持*/
@EnableTransactionManagement
public class JavaConfig &#123;
    @Bean
    public DruidDataSource dataSource(@Value(&quot;$&#123;chenw.username&#125;&quot;) String username,@Value(&quot;$&#123;chenw.password&#125;&quot;) String password,
                                      @Value(&quot;$&#123;chenw.url&#125;&quot;) String url,@Value(&quot;$&#123;chenw.driver&#125;&quot;) String driver

    )&#123;
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        dataSource.setDriverClassName(driver);
        dataSource.setUrl(url);
        return dataSource;
    &#125;

    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123;
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        jdbcTemplate.setDataSource(dataSource);
        return  jdbcTemplate;
    &#125;
    @Bean
    public TransactionManager transactionManager(DataSource dataSource)&#123;
        /*
        *   内部要进行的事物的操作，基于的连接池
        * */
        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
        //需要连接池对象
        dataSourceTransactionManager.setDataSource(dataSource);
        return  dataSourceTransactionManager;
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>使用声明事务注解@Transactional</li>
</ol>
<pre><code class="Java">package com.chenw.service;

import com.chenw.dao.StudentDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class StudentService &#123;
    
    @Autowired
    private StudentDao studentDao;

    /*
    *   添加事物
    *       @Transactional
    *        位置: 方法或者类上
    *       方法:当前的方法有事物
    *       类上:类下的所有方法都有事物
    *
    * */
    @Transactional
    public void changeInfo()&#123;
        studentDao.updateAgeById(100,1);
        System.out.println(&quot;-----------&quot;);
        studentDao.updateNameById(&quot;test1&quot;,1);
    &#125;
&#125;
</code></pre>
<pre><code>经过上面配置以后changeInfo这个方法就有事物了
    我们可以测试一下
    在 studentDao.updateAgeById(100,1);和 studentDao.updateNameById(&quot;test1&quot;,1);中间制造错误
    如果是有事物的话，第一句和第二句都会事物回滚，都执行不了
    但是没有事物的话，第一句依旧式执行成功的，但是第二句是失败的
</code></pre>
<pre><code class="java">    @Transactional
    public void changeInfo()&#123;
        studentDao.updateAgeById(88,1);
        int i = 1/0;
        System.out.println(&quot;-----------&quot;);
        studentDao.updateNameById(&quot;test2&quot;,1);
    &#125;
</code></pre>
<pre><code>测试晚数据都没有改变
</code></pre>
<p><strong>事务属性</strong></p>
<p><strong>只读</strong></p>
<ol>
<li><p>只读介绍</p>
<p> 对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。</p>
</li>
<li><p>设置方式</p>
</li>
</ol>
<pre><code class="Java">// readOnly = true把当前事务设置为只读 默认是false!
@Transactional(readOnly = true)
</code></pre>
<ol start="3">
<li><p>针对DML动作设置只读模式</p>
<p> 会抛出下面异常：</p>
<p> Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed</p>
</li>
<li><p>@Transactional注解放在类上</p>
<ol>
<li><p>生效原则</p>
<p> 如果一个类中每一个方法上都使用了 @Transactional 注解，那么就可以将 @Transactional 注解提取到类上。反过来说：@Transactional 注解在类级别标记，会影响到类中的每一个方法。同时，类级别标记的 @Transactional 注解中设置的事务属性也会延续影响到方法执行时的事务属性。除非在方法上又设置了 @Transactional 注解。</p>
<p> 对一个方法来说，离它最近的 @Transactional 注解中的事务属性设置生效。</p>
</li>
<li><p>用法举例</p>
<p> 在类级别@Transactional注解中设置只读，这样类中所有的查询方法都不需要设置@Transactional注解了。因为对查询操作来说，其他属性通常不需要设置，所以使用公共设置即可。</p>
<p> 然后在这个基础上，对增删改方法设置@Transactional注解 readOnly 属性为 false。</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">@Service
@Transactional(readOnly = true)
public class EmpService &#123;
    
    // 为了便于核对数据库操作结果，不要修改同一条记录
    @Transactional(readOnly = false)
    public void updateTwice(……) &#123;
    ……
    &#125;
    
    // readOnly = true把当前事务设置为只读
    // @Transactional(readOnly = true)
    public String getEmpName(Integer empId) &#123;
    ……
    &#125;
    
&#125;
</code></pre>
<p><strong>超时时间</strong></p>
<ol>
<li><p>需求</p>
<p> 事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。</p>
<p> 此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。</p>
<p> 概括来说就是一句话：超时回滚，释放资源。</p>
</li>
<li><p>设置超时时间</p>
</li>
</ol>
<pre><code class="Java">@Service
public class StudentService &#123;

    @Autowired
    private StudentDao studentDao;

    /**
     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!
     */
    @Transactional(readOnly = false,timeout = 3)
    public void changeInfo()&#123;
        studentDao.updateAgeById(100,1);
        //休眠4秒,等待方法超时!
        try &#123;
            Thread.sleep(4000);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
        studentDao.updateNameById(&quot;test1&quot;,1);
    &#125;
&#125;
</code></pre>
<ol start="3">
<li><p>测试超时效果</p>
<p> 执行抛出事务超时异常</p>
</li>
</ol>
<pre><code class="Java">org.springframework.transaction.TransactionTimedOutException: Transaction timed out: deadline was Wed May 24 09:10:43 IRKT 2023

  at org.springframework.transaction.support.ResourceHolderSupport.checkTransactionTimeout(ResourceHolderSupport.java:155)
  at org.springframework.transaction.support.ResourceHolderSupport.getTimeToLiveInMillis(ResourceHolderSupport.java:144)
  at org.springframework.transaction.support.ResourceHolderSupport.getTimeToLiveInSeconds(ResourceHolderSupport.java:128)
  at org.springframework.jdbc.datasource.DataSourceUtils.applyTimeout(DataSourceUtils.java:341)
  at org.springframework.jdbc.core.JdbcTemplate.applyStatementSettings(JdbcTemplate.java:1467)
</code></pre>
<p><strong>事务异常</strong></p>
<ol>
<li><p>默认情况</p>
<p> 默认只针对运行时异常回滚，编译时异常不回滚。情景模拟代码如下：</p>
</li>
</ol>
<pre><code class="Java">@Service
public class StudentService &#123;

    @Autowired
    private StudentDao studentDao;

    /**
     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!
     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!
     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!
     */
    @Transactional(readOnly = false,timeout = 3)
    public void changeInfo() throws FileNotFoundException &#123;
        studentDao.updateAgeById(100,1);
        //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! 
        new FileInputStream(&quot;xxxx&quot;);
        studentDao.updateNameById(&quot;test1&quot;,1);
    &#125;
&#125;
</code></pre>
<ol start="2">
<li><p>设置回滚异常</p>
<p> rollbackFor属性：指定哪些异常类才会回滚,默认是 RuntimeException and Error 异常方可回滚!</p>
</li>
</ol>
<pre><code class="Java">/**
 * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!
 * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!
 * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!
 */
@Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class)
public void changeInfo() throws FileNotFoundException &#123;
    studentDao.updateAgeById(100,1);
    //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! 
    new FileInputStream(&quot;xxxx&quot;);
    studentDao.updateNameById(&quot;test1&quot;,1);
&#125;
</code></pre>
<ol start="3">
<li><p>设置不回滚的异常</p>
<p> 在默认设置和已有设置的基础上，再指定一个异常类型，碰到它不回滚。</p>
<p> noRollbackFor属性：指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</p>
</li>
</ol>
<pre><code class="Java">@Service
public class StudentService &#123;

    @Autowired
    private StudentDao studentDao;

    /**
     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!
     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!
     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!
     */
    @Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class,noRollbackFor = FileNotFoundException.class)
    public void changeInfo() throws FileNotFoundException &#123;
        studentDao.updateAgeById(100,1);
        //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!
        new FileInputStream(&quot;xxxx&quot;);
        studentDao.updateNameById(&quot;test1&quot;,1);
    &#125;
&#125;
</code></pre>
<p><strong>事务隔离等级</strong></p>
<ol>
<li><p>事务隔离级别</p>
<p> 数据库事务的隔离级别是指在多个事务并发执行时，数据库系统为了保证数据一致性所遵循的规定。常见的隔离级别包括：</p>
<ol>
<li><p>读未提交（Read Uncommitted）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用。</p>
<pre><code>脏读是一个事务读取一个事务未提交的数据，这个可能读取是不准确的，如果另外ige事务发生错误，造成回滚
    后面两个读取的都是正常的数据，但是后面两个不符合原则
不可重复读 是一个事务读取一个事务的提交的修改的数据
幻读 一个事务读取另外一个事务的插入的数据
</code></pre>
</li>
<li><p>读已提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读。</p>
</li>
<li><p>可重复读（Repeatable Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题。</p>
</li>
<li><p>串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。</p>
</li>
</ol>
<p> 不同的隔离级别适用于不同的场景，需要根据实际业务需求进行选择和调整。MYSQL默认的等级是第三个
 </p>
</li>
<li><p>事务隔离级别设置</p>
</li>
</ol>
<pre><code class="Java">package com.atguigu.service;

import com.atguigu.dao.StudentDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;

import java.io.FileInputStream;
import java.io.FileNotFoundException;

/**
 * projectName: com.atguigu.service
 */
@Service
public class StudentService &#123;

    @Autowired
    private StudentDao studentDao;

    /**
     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!
     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!
     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!
     * isolation = 设置事务的隔离级别,mysql默认是repeatable read!
     */
    @Transactional(readOnly = false,
                   timeout = 3,
                   rollbackFor = Exception.class,
                   noRollbackFor = FileNotFoundException.class,
                   isolation = Isolation.REPEATABLE_READ)
    public void changeInfo() throws FileNotFoundException &#123;
        studentDao.updateAgeById(100,1);
        //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!
        new FileInputStream(&quot;xxxx&quot;);
        studentDao.updateNameById(&quot;test1&quot;,1);
    &#125;
&#125;
</code></pre>
<p><strong>事务传播行为</strong></p>
<pre><code>当我们在一个事务里面调用另外一个事务的方法，那么这两个事务是合并还是独立
事务传播行为设置到子事务
</code></pre>
<ol>
<li><p>事务传播行为要研究的问题</p>
<p> <img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img012.faac2cb7.png"></p>
<p> 举例代码：</p>
</li>
</ol>
<pre><code class="Java">@Transactional
public void MethodA()&#123;
    // ...
    MethodB();
    // ...
&#125;

//在被调用的子方法中设置传播行为，代表如何处理调用的事务！ 是加入，还是新事务等！
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void MethodB()&#123;
    // ...
&#125;
</code></pre>
<ol start="2">
<li><p>propagation属性</p>
<p> @Transactional 注解通过 propagation 属性设置事务的传播行为。它的默认值是：</p>
</li>
</ol>
<pre><code class="Java">Propagation propagation() default Propagation.REQUIRED;
</code></pre>
<pre><code>propagation 属性的可选值由 org.springframework.transaction.annotation.Propagation 枚举类提供：
</code></pre>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED  默认值</td>
<td>如果父方法有事务，就加入，如果没有就新建自己独立！</td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>不管父方法是否有事务，我都新建事务，都是独立的！</td>
</tr>
</tbody></table>
<ol start="3">
<li>测试<ol>
<li>声明两个业务方法</li>
</ol>
</li>
</ol>
<pre><code class="Java">@Service
public class StudentService &#123;
    /**
     * 声明两个独立修改数据库的事务业务方法
     */
    @Transactional(propagation = Propagation.REQUIRED)
    public void changeAge()&#123;
        studentDao.updateAgeById(99,1);
    &#125;

    @Transactional(propagation = Propagation.REQUIRED)
    public void changeName()&#123;
        studentDao.updateNameById(&quot;test2&quot;,1);
        int i = 1/0;
    &#125;

&#125;
这样的话，我们加入到的父事务有事务的话，默认就会加入父事务一起
其中changeName，发生回滚，这个方法也执行不了，推荐的使用默认值
</code></pre>
<pre><code>2. 声明一个整合业务方法
</code></pre>
<pre><code class="Java">@Service
public class TopService &#123;

    @Autowired
    private StudentService studentService;

    @Transactional
    public void  topService()&#123;
        studentService.changeAge();
        studentService.changeName();
    &#125;
&#125;
</code></pre>
<pre><code>3. 添加传播行为测试
</code></pre>
<pre><code class="Java">@SpringJUnitConfig(classes = AppConfig.class)
public class TxTest &#123;
    @Autowired
    private TopService topService;
    @Test
    public void  testTx() throws FileNotFoundException &#123;
        topService.topService();
    &#125;
&#125;
</code></pre>
<pre><code>**注意：**
  在同一个类中，对于@Transactional注解的方法调用，事务传播行为不会生效。这是因为Spring框架中使用代理模式实现了事务机制，在同一个类中的方法调用并不经过代理，而是通过对象的方法调用，因此@Transactional注解的设置不会被代理捕获，也就不会产生任何事务传播行为的效果。
</code></pre>
<ol start="4">
<li>其他传播行为值（了解）<ol>
<li>Propagation.REQUIRED：如果当前存在事务，则加入当前事务，否则创建一个新事务。</li>
<li>Propagation.REQUIRES_NEW：创建一个新事务，并在新事务中执行。如果当前存在事务，则挂起当前事务，即使新事务抛出异常，也不会影响当前事务。</li>
<li>Propagation.NESTED：如果当前存在事务，则在该事务中嵌套一个新事务，如果没有事务，则与Propagation.REQUIRED一样。</li>
<li>Propagation.SUPPORTS：如果当前存在事务，则加入该事务，否则以非事务方式执行。</li>
<li>Propagation.NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，挂起该事务。</li>
<li>Propagation.MANDATORY：必须在一个已有的事务中执行，否则抛出异常。</li>
<li>Propagation.NEVER：必须在没有事务的情况下执行，否则抛出异常。</li>
</ol>
</li>
</ol>
<p><strong>Spring框架的总结</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>核心点</td>
<td>掌握目标</td>
</tr>
<tr>
<td>spring框架理解</td>
<td>spring家族和spring framework框架</td>
</tr>
<tr>
<td>spring核心功能</td>
<td>ioc&#x2F;di , aop , tx</td>
</tr>
<tr>
<td>spring ioc &#x2F; di</td>
<td>组件管理、ioc容器、ioc&#x2F;di , 三种配置方式</td>
</tr>
<tr>
<td>spring aop</td>
<td>aop和aop框架和代理技术、基于注解的aop配置</td>
</tr>
<tr>
<td>spring tx</td>
<td>声明式和编程式事务、动态事务管理器、事务注解、属性</td>
</tr>
</tbody></table>
<p><strong>MyBatis实践：提高持久层数据处理效率</strong></p>
<h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>  <a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p>
<p>  MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github。</p>
<p>  MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<p>  <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<blockquote>
<p>社区会持续更新开源项目，版本会不断变化，我们不必每个小版本都追，关注重大更新的大版本升级即可。</p>
</blockquote>
<p><strong>持久层框架对比</strong></p>
<ul>
<li>JDBC<ul>
<li>SQL 夹杂在Java代码中耦合度高，导致硬编码内伤</li>
<li>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见</li>
<li>代码冗长，开发效率低</li>
</ul>
</li>
<li>Hibernate 和 JPA<ul>
<li>操作简便，开发效率高</li>
<li>程序中的长难复杂 SQL 需要绕过框架</li>
<li>内部自动生成的 SQL，不容易做特殊优化</li>
<li>基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。</li>
<li>反射操作太多，导致数据库性能下降</li>
</ul>
</li>
<li>MyBatis<ul>
<li>轻量级，性能出色</li>
<li>SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据</li>
<li>开发效率稍逊于 Hibernate，但是完全能够接收</li>
</ul>
</li>
</ul>
<p>开发效率：Hibernate&gt;Mybatis&gt;JDBC</p>
<p>运行效率：JDBC&gt;Mybatis&gt;Hibernate</p>
<p><strong>快速入门</strong></p>
<ol>
<li>准备数据模型</li>
</ol>
<pre><code class="SQL">CREATE DATABASE `mybatis-example`;

USE `mybatis-example`;

CREATE TABLE `t_emp`(
  emp_id INT AUTO_INCREMENT,
  emp_name CHAR(100),
  emp_salary DOUBLE(10,5),
  PRIMARY KEY(emp_id)
);

INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;tom&quot;,200.33);
INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;jerry&quot;,666.66);
INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;andy&quot;,777.77);
</code></pre>
<ol start="2">
<li>项目搭建和准备<ol>
<li><p>项目搭建</p>
<p> <img src="https://secure2.wostatic.cn/static/vF2ubwBhNSqJE4ZkVSeTxL/image.png?auth_key=1714012482-ehkJHPRVthJMTmABkoiLC8-0-8a8043b28438552e0b16b03711e02f87"></p>
</li>
<li><p>依赖导入</p>
<p> pom.xml</p>
</li>
</ol>
</li>
</ol>
<pre><code class="XML">&lt;dependencies&gt;
  &lt;!-- mybatis依赖 --&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
      &lt;version&gt;3.5.11&lt;/version&gt;
  &lt;/dependency&gt;

  &lt;!-- MySQL驱动 mybatis底层依赖jdbc驱动实现,本次不需要导入连接池,mybatis自带! --&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;version&gt;8.0.25&lt;/version&gt;
  &lt;/dependency&gt;

  &lt;!--junit5测试--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
      &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
      &lt;version&gt;5.3.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code>3. 实体类准备
</code></pre>
<pre><code class="Java">public class Employee &#123;

    private Integer empId;

    private String empName;

    private Double empSalary;
    
    //getter | setter
&#125;
</code></pre>
<ol start="3">
<li><p>准备Mapper接口和MapperXML文件</p>
<p> MyBatis 框架下，SQL语句编写位置发生改变，从原来的Java类，改成<strong>XML</strong>或者注解定义！</p>
<p> 推荐在XML文件中编写SQL语句，让用户能更专注于 SQL 代码，不用关注其他的JDBC代码。</p>
<p> 如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码！！</p>
<p> 一般编写SQL语句的文件命名：XxxMapper.xml  Xxx一般取表名！！</p>
<p> Mybatis 中的 Mapper 接口相当于以前的 Dao。但是区别在于，Mapper 仅仅只是建接口即可，我们不需要提供实现类，具体的SQL写到对应的Mapper文件，该用法的思路如下图所示：</p>
<p> <img src="https://secure2.wostatic.cn/static/bkCL19U4AA9SGMm4kuRXT3/image.png?auth_key=1714012482-emki4Gn9rWTmJVmgmEQfVo-0-af664ab48bad063bc17095c36e2f9f36"></p>
<ol>
<li><p>定义mapper接口</p>
<p> 包：com.chenw.mapper</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">package com.chenw.mapper;

import com.chenw.pojo.Employee;

public interface EmployeeMapper &#123;
    /*
    * 根据id查询员工的数据
    * */
    Employee queryById(Integer id);

    /*
    * 通过id删除
    * */
    int deleteById(Integer id);
&#125;
</code></pre>
<pre><code>2. 定义mapper xml

    位置： resources/mappers/EmployeeMapper.xml
</code></pre>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;
&lt;mapper namespace=&quot;com.chenw.mapper.EmployeeMapper&quot;&gt;

    &lt;!-- 查询使用 select标签
            id = 方法名
            resultType = 返回值类型
            标签内编写SQL语句
            注意:Mapper接口里面方法不可以重载，因为mapper无法识别
     --&gt;
    &lt;select id=&quot;queryById&quot; resultType=&quot;com.chenw.pojo.Employee&quot;&gt;
        &lt;!-- #&#123;id&#125;代表动态传入的参数,并且进行赋值!后面详细讲解 --&gt;
        select emp_id empId,emp_name empName, emp_salary empSalary from
        t_emp where emp_id = #&#123;id&#125;
    &lt;/select&gt;
    &lt;delete id=&quot;deleteById&quot; &gt;
        delete from t_emp where emp_id=#&#123;id&#125;
    &lt;/delete&gt;

&lt;/mapper&gt;
</code></pre>
<pre><code>    **注意：**
      - 方法名和SQL的id一致
      - 方法返回值和resultType一致
      - 方法的参数和SQL的参数一致
      - 接口的全类名和映射配置文件的名称空间一致
</code></pre>
<ol start="4">
<li><p>准备MyBatis配置文件</p>
<p> mybatis框架配置文件： 数据库连接信息，性能配置，mapper.xml配置等！</p>
<p> 习惯上命名为 mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合 Spring 之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。</p>
</li>
</ol>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;

    &lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;!-- Mybatis的内置的事务管理器 --&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;!-- 配置数据源 --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;!-- 建立数据库连接的具体信息 --&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;mappers&gt;
        &lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt;
        &lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt;
        &lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt;
        &lt;!--    对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt;
        &lt;mapper resource=&quot;mappers/EmployeeMapper.xml&quot;/&gt;
    &lt;/mappers&gt;

&lt;/configuration&gt;
</code></pre>
<ol start="5">
<li>运行和测试</li>
</ol>
<pre><code class="Java">package com.chenw.test;

import com.chenw.mapper.EmployeeMapper;
import com.chenw.pojo.Employee;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.io.InputStream;

public class MybatisTest &#123;
    /*
    * TODO:通过Mybatis的api进行方法的调用
    * */
    @Test
    public void test_01() throws IOException &#123;
        //1.读取外部的配置文件（mybatis-config.xml）
        InputStream ips = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
        //2.创建sqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(ips);
        //3.根据sqlSessionFactory创建sqlSession(每次业务创建一个，用完释放掉)
        SqlSession sqlSession = sqlSessionFactory.openSession();
        //4.获取接口的代理对象(代理技术) //调用代理对象的方法，就会找mapper接口的方法
        EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);
        Employee employee = mapper.queryById(1);
        System.out.println(employee);
        //5.提交事务（非DQL）和释放资源,因为是查询语句不需要事务提交也可以
        sqlSession.commit();
        sqlSession.close();
    &#125;
&#125;
</code></pre>
<pre><code>说明：

- SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）
- SqlSessionFactory：是“生产”SqlSession的“工厂”。
- 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。
</code></pre>
<ol start="6">
<li><p>SqlSession和HttpSession区别</p>
<ul>
<li>HttpSession：工作在Web服务器上，属于表述层。<ul>
<li>代表浏览器和Web服务器之间的会话。</li>
</ul>
</li>
<li>SqlSession：不依赖Web服务器，属于持久化层。<ul>
<li>代表Java程序和数据库之间的会话。</li>
</ul>
</li>
</ul>
<p> <img src="https://secure2.wostatic.cn/static/xb7Pyrm8YMF3qK6c7Jr5R3/image.png?auth_key=1714012482-9mwAd4aP17ycQq2hcDhLZF-0-c93bdd1fe1e6c5a58d706fb7fb0dca31"></p>
</li>
</ol>
<p><strong>Ibatis的原理</strong></p>
<pre><code>之前的iBatis对数据库操作存在一些的问题
 但是不像Mybatis不要接口
</code></pre>
<p>配置文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;
&lt;!--使用Mybatis的老版本Ibatis的方法实现操作
        1.不需要写接口
        2.直接创建mapper.xml文件内部编写sql语句
        3.namespace没有任何的要求，随意声明字符串就可以
        4.在内部通过crud标签声明SQL语句即可

--&gt;
&lt;mapper namespace=&quot;chenw&quot;&gt;
&lt;!----&gt;
    &lt;select id=&quot;chenw&quot; resultType=&quot;com.chenw.pojo.Student&quot;&gt;
        select * from student where sid = #&#123;id&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>配置</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;

    &lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;!-- Mybatis的内置的事务管理器 --&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;!-- 配置数据源 --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;!-- 建立数据库连接的具体信息 --&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;mappers&gt;
        &lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt;
        &lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt;
        &lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt;
        &lt;!--    对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt;
        &lt;mapper resource=&quot;mappers/EmployeeMapper.xml&quot;/&gt;
        &lt;mapper resource=&quot;mappers/StudentMapper.xml&quot;/&gt;
    &lt;/mappers&gt;

&lt;/configuration&gt;
</code></pre>
<pre><code class="java">在调用的时候
        /*
        * 直接使用sqlSesion提供的curd方法进行查询
        *       1.里面的参数
        *           第一个参数是配置文件的里的对应方法配置的id,可以使用命名空间+id 就是配置里面的
        *               namespace+id
        *           第二个参数是sql语句的传入的参数
        * 原理就是查找对应的sql语句的标签 ，然后执行
        * */
        Student student =(Student) sqlSession.selectOne(&quot;chenw.chenw&quot;, 1);
        System.out.println(student);
        //5.提交事务（非DQL）和释放资源,因为是查询语句不需要事务提交也可以
        sqlSession.commit();
        sqlSession.close();
</code></pre>
<p><strong>Mybatis的基本使用</strong></p>
<p><strong>向sql语句传参</strong></p>
<p><strong>Mybatis的日志输出</strong></p>
<p>配置文件</p>
<pre><code class="xml">&lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt;
&lt;environments default=&quot;development&quot;&gt;
    &lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt;
    &lt;environment id=&quot;development&quot;&gt;
        &lt;!-- Mybatis的内置的事务管理器 --&gt;
        &lt;transactionManager type=&quot;JDBC&quot;/&gt;
        &lt;!-- 配置数据源 --&gt;
        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;!-- 建立数据库连接的具体信息 --&gt;
            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
        &lt;/dataSource&gt;
    &lt;/environment&gt;
    &lt;!--我们可以配置多个环境，最后只能生效一个--&gt;
    &lt;environment id=&quot;test&quot;&gt;
        &lt;!-- Mybatis的内置的事务管理器 --&gt;
        &lt;transactionManager type=&quot;JDBC&quot;/&gt;
        &lt;!-- 配置数据源 --&gt;
        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;!-- 建立数据库连接的具体信息 --&gt;
            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
        &lt;/dataSource&gt;
    &lt;/environment&gt;
&lt;/environments&gt;
</code></pre>
<pre><code>environments代表不同的环境，下面的environment是代表单个的环境，environments的default指定生效的环境
transactionManager type=&quot;JDBC&quot; 代表使用JDCBC的事务管理器，如果MANAGED，这个配置相当于什么也没做，从不会提交或回滚一个连接
dataSource type=&quot;POOLED&quot; 代表使用连接池，UNPOOLED代表每次查询都会打开关闭连接，是mybatis帮助我们维护一个池，下面就是配置连接池的配置，后面我们将使用druid的连接池，而不是用默认的
</code></pre>
<pre><code class="xml">            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;!-- 建立数据库连接的具体信息 --&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
</code></pre>
<pre><code class="xml">    &lt;mappers&gt;
        &lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt;
        &lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt;
        &lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt;
        &lt;!--    对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt;
        &lt;mapper resource=&quot;mappers/EmployeeMapper.xml&quot;/&gt;
        &lt;mapper resource=&quot;mappers/StudentMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
</code></pre>
<p><strong>配置日志输出的功能</strong></p>
<h4 id="2-1-1-mybatis日志输出配置"><a href="#2-1-1-mybatis日志输出配置" class="headerlink" title="2.1.1 mybatis日志输出配置"></a>2.1.1 <strong>mybatis日志输出配置</strong></h4><p>  mybatis配置文件设计标签和顶层结构如下：</p>
<ul>
<li>configuration（配置）<ul>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#properties">properties（属性）</a></li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">settings（设置）</a></li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">typeAliases（类型别名）</a></li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a></li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#environments">environments（环境配置）</a><ul>
<li>environment（环境变量）<ul>
<li>transactionManager（事务管理器）</li>
<li>dataSource（数据源）</li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a></li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">mappers（映射器）</a></li>
</ul>
</li>
</ul>
<p>  我们可以在mybatis的配置文件使用<strong>settings标签</strong>设置，输出运过程SQL日志！</p>
<p>  通过查看日志，我们可以判定#{} 和 ${}的输出效果！</p>
<p>  settings设置项：</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240425123033598.png" alt="image-20240425123033598"></p>
<p>  日志配置：</p>
<pre><code class="XML">&lt;settings&gt;
  &lt;!-- SLF4J 选择slf4j输出！开启日志输出使用system进行控制台进行输出 --&gt;
  &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<p>这样在输出的时候就会有日志</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240425123318244.png" alt="image-20240425123318244"></p>
<p><strong>#{}和${}的区</strong>别</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;chenw.mapper.EmployeeMapper&quot;&gt;

    &lt;!--
        sql语句两种传值
            #&#123;&#125;:占位符+赋值 ：先变成 emp_id = ？ 然后在赋值，防止注入攻击
            $&#123;&#125;：直接字符串拼接  容易被sql攻击

            但是#&#123;&#125;也是有缺点的，
                #&#123;&#125;只能给值的位置赋值。不能赋值给sql语句的组成部分（表名，列名，sql关键字）
                但是$&#123;&#125;是可以的
    --&gt;
    &lt;select id=&quot;queryById&quot; resultType=&quot;chenw.pojo.Employee&quot;&gt;
        select emp_id as empId , emp_name as empName ,emp_salary as empSalary
        from t_emp where emp_id = #&#123;id&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p><strong>数据输入</strong></p>
<p><img src="https://api.wolai.com/v1/proxy/image?src=http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img005.ebd8c6a3.png&spaceId=fqkGyHKKxSnzkhVZnoSxhC&userId=&image_process=resize,w_851" alt="img"></p>
<p>这里数据输入具体是指上层方法（例如Service方法）调用Mapper接口时，数据传入的形式。</p>
<ul>
<li>简单类型：只包含一个值的数据类型（单值的）<ul>
<li>基本数据类型：int、byte、short、double、……</li>
<li>基本数据类型的包装类型：Integer、Character、Double、……</li>
<li>字符串类型：String</li>
</ul>
</li>
<li>复杂类型：包含多个值的数据类型（实体，map类型的等）<ul>
<li>实体类类型：Employee、Department、……</li>
<li>集合类型：List、Set、Map、……</li>
<li>数组类型：int[]、String[]、……</li>
<li>复合类型：List<Employee>、实体类中包含集合……</li>
</ul>
</li>
</ul>
<p><strong>单个简单类型型参数</strong></p>
<pre><code class="java">/*
*   根据id删除员工的信息
*   */
int deleteById(Integer id);


/*
*   根据工资查询员工信息
* */

List&lt;Employee&gt; queryBySalary(Double salary);
</code></pre>
<pre><code class="java">    &lt;!--
        场景1，传入的是单个的简单的类型 key随便写 默认就是取这个值,一般情况下推荐使用参数的名字,这样更好的识别
        场景2，传入的是实体类对象 #&#123;key&#125; key是属性名字
    --&gt;
    &lt;delete id=&quot;deleteById&quot;&gt;
         delete from t_emp where emp_id = #&#123;id&#125;
    &lt;/delete&gt;
    &lt;select id=&quot;queryBySalary&quot; resultType=&quot;chenw.pojo.Employee&quot;&gt;
        select emp_id as empId , emp_name as empName ,emp_salary as empSalary
        from t_emp where emp_salary = #&#123;salary&#125;
    &lt;/select&gt;
</code></pre>
<p><strong>零散的简单类型数据</strong></p>
<p>  零散的多个简单类型参数，如果没有特殊处理，那么Mybatis无法识别自定义名称：</p>
<p>  <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<p>  Mapper接口中抽象方法的声明</p>
<pre><code class="Java">int updateEmployee(@Param(&quot;empId&quot;) Integer empId,@Param(&quot;empSalary&quot;) Double empSalary);
</code></pre>
<p>  SQL语句</p>
<pre><code class="XML">&lt;update id=&quot;updateEmployee&quot;&gt;
  update t_emp set emp_salary=#&#123;empSalary&#125; where emp_id=#&#123;empId&#125;
&lt;/update&gt;
</code></pre>
<p>  对应关系</p>
<p>  <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img007.976da128.png"></p>
<p><strong>或者使用myBatis的默认机制</strong></p>
<p>args args0 ….形参左到右依次对应,或者是param1.。。。这个方法是从1开始<br>例如</p>
<pre><code class="java">
    List&lt;Employee&gt; queryByNameAndSalary(String name, String salary)



    &lt;select id=&quot;queryByNameAndSalary&quot; resultType=&quot;chenw.pojo.Employee&quot;&gt;
            select emp_id as empId ,emp_name as empName ,emp_salary as empSalary
            from t_emp where emp_name = #&#123;arg0&#125; and emp_salary=#&#123;arg1&#125;
    &lt;/select&gt;
</code></pre>
<p><strong>Map类型参数</strong></p>
<p>  Mapper接口中抽象方法的声明</p>
<pre><code class="Java">int updateEmployeeByMap(Map&lt;String, Object&gt; paramMap);
</code></pre>
<p>  SQL语句</p>
<pre><code class="XML">    &lt;!--
        传入map指定key的值
            map的key等于和传入实体类一样
     --&gt;

&lt;update id=&quot;updateEmployeeByMap&quot;&gt;

  update t_emp set emp_salary=#&#123;empSalaryKey&#125; where emp_id=#&#123;empIdKey&#125;

&lt;/update&gt;
</code></pre>
<p>  junit测试</p>
<pre><code class="Java">private SqlSession session;
//junit5会在每一个@Test方法前执行@BeforeEach方法
@BeforeEach
public void init() throws IOException &#123;
    session = new SqlSessionFactoryBuilder()
            .build(
                    Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;))
            .openSession();
&#125;

@Test
public void testUpdateEmpNameByMap() &#123;
  EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);
  Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;();
  paramMap.put(&quot;empSalaryKey&quot;, 999.99);
  paramMap.put(&quot;empIdKey&quot;, 5);
  int result = mapper.updateEmployeeByMap(paramMap);
  log.info(&quot;result = &quot; + result);
&#125;

//junit5会在每一个@Test方法后执行@@AfterEach方法
@AfterEach
public void clear() &#123;
    session.commit();
    session.close();
&#125;
</code></pre>
<p>  <strong>对应关系</strong></p>
<p>  #{}中写Map中的key</p>
<p>  <strong>使用场景</strong></p>
<p>  有很多零散的参数需要传递，但是没有对应的实体类类型可以使用。使用@Param注解一个一个传入又太麻烦了。所以都封装到Map中。</p>
<p><strong>数据输出</strong></p>
<p><strong>输出概述</strong></p>
<p>  数据输出总体上有两种形式：</p>
<ul>
<li>增删改操作返回的受影响行数：直接使用 int 或 long 类型接收即可</li>
<li>查询操作的查询结果</li>
</ul>
<p>  我们需要做的是，指定查询的输出数据类型即可！</p>
<p>  并且插入场景下，实现主键数据回显示！</p>
<p><strong>单个简单类型</strong></p>
<p>  Mapper接口中的抽象方法</p>
<pre><code class="Java">int selectEmpCount();
</code></pre>
<p>  SQL语句</p>
<pre><code class="XML">&lt;select id=&quot;selectEmpCount&quot; resultType=&quot;int&quot;&gt;
  select count(*) from t_emp
&lt;/select&gt;
</code></pre>
<blockquote>
<p>Mybatis 内部给常用的数据类型设定了很多别名。 以 int 类型为例，可以写的名称有：int、integer、Integer、java.lang.Integer、Int、INT、INTEGER 等等。</p>
</blockquote>
<p>  junit测试</p>
<pre><code class="Java">@Test

public void testEmpCount() &#123;

  EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);

  int count = employeeMapper.selectEmpCount();

  log.info(&quot;count = &quot; + count);

&#125;
</code></pre>
<p>  <strong>细节解释：</strong></p>
<pre><code>select标签，通过resultType指定查询返回值类型！

resultType = &quot;全限定符 ｜ 别名 ｜ 如果是返回集合类型，写范型类型即可&quot;
</code></pre>
<p>  别名问题：</p>
<pre><code>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：
</code></pre>
<pre><code class="XML">&lt;typeAliases&gt;
  &lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt;
  &lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<pre><code>当这样配置时，`Blog` 可以用在任何使用 `domain.blog.Blog` 的地方。

也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：
</code></pre>
<pre><code class="XML">&lt;typeAliases&gt; 
    &lt;package name=&quot;domain.blog&quot;/&gt; 
&lt;/typeAliases&gt;
</code></pre>
<pre><code>每一个在包 `domain.blog` 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 `domain.blog.Author` 的别名为 `author`；若有注解，则别名为其注解值。见下面的例子：
</code></pre>
<pre><code class="Java">@Alias(&quot;author&quot;)
public class Author &#123;
    ...
&#125;
</code></pre>
<pre><code>下面是Mybatis为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。
        一般基本数据类型的别名是前面加上_
        包装类型的数据类型是第一个字母小写
</code></pre>
<table>
<thead>
<tr>
<th>别名</th>
<th>映射的类型</th>
</tr>
</thead>
<tbody><tr>
<td>_byte</td>
<td>byte</td>
</tr>
<tr>
<td>_char (since 3.5.10)</td>
<td>char</td>
</tr>
<tr>
<td>_character (since 3.5.10)</td>
<td>char</td>
</tr>
<tr>
<td>_long</td>
<td>long</td>
</tr>
<tr>
<td>_short</td>
<td>short</td>
</tr>
<tr>
<td>_int</td>
<td>int</td>
</tr>
<tr>
<td>_integer</td>
<td>int</td>
</tr>
<tr>
<td>_double</td>
<td>double</td>
</tr>
<tr>
<td>_float</td>
<td>float</td>
</tr>
<tr>
<td>_boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>char (since 3.5.10)</td>
<td>Character</td>
</tr>
<tr>
<td>character (since 3.5.10)</td>
<td>Character</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>integer</td>
<td>Integer</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>date</td>
<td>Date</td>
</tr>
<tr>
<td>decimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>bigdecimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>biginteger</td>
<td>BigInteger</td>
</tr>
<tr>
<td>object</td>
<td>Object</td>
</tr>
<tr>
<td>object[]</td>
<td>Object[]</td>
</tr>
<tr>
<td>map</td>
<td>Map</td>
</tr>
<tr>
<td>hashmap</td>
<td>HashMap</td>
</tr>
<tr>
<td>list</td>
<td>List</td>
</tr>
<tr>
<td>arraylist</td>
<td>ArrayList</td>
</tr>
<tr>
<td>collection</td>
<td>Collection</td>
</tr>
</tbody></table>
<p><strong>设置数据库名称和实体类属性值的自动映射</strong></p>
<pre><code>在数据库里面的都是 用_ 进行设置，但是在实体类使用驼峰命名
    如果需要查询保存在实体类需要在sql语句里面使用as语句
    更简单可以是使用映射
    
</code></pre>
<pre><code>mapUnderscoreToCamelCase
    是否开始驼峰命名自动映射，即从经典数据库列名A_CoLUMN映射到经典Java属性名aClumn
</code></pre>
<p><strong>返回Map类型</strong></p>
<p>  适用于SQL查询返回的各个字段综合起来并不和任何一个现有的实体类对应，没法封装到实体类对象中。能够封装成实体类类型的，就不使用Map类型。</p>
<p>  Mapper接口的抽象方法</p>
<pre><code class="Java">Map&lt;String,Object&gt; selectEmpNameAndMaxSalary();
</code></pre>
<p>  SQL语句</p>
<pre><code class="XML">&lt;!-- Map&lt;String,Object&gt; selectEmpNameAndMaxSalary(); --&gt;
&lt;!-- 返回工资最高的员工的姓名和他的工资 --&gt;
&lt;select id=&quot;selectEmpNameAndMaxSalary&quot; resultType=&quot;map&quot;&gt;
  SELECT
    emp_name 员工姓名,
    emp_salary 员工工资,
    (SELECT AVG(emp_salary) FROM t_emp) 部门平均工资
  FROM t_emp WHERE emp_salary=(
    SELECT MAX(emp_salary) FROM t_emp
  )
&lt;/select&gt;
</code></pre>
<p>  junit测试</p>
<pre><code class="Java">@Test
public void testQueryEmpNameAndSalary() &#123;

  EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);

  Map&lt;String, Object&gt; resultMap = employeeMapper.selectEmpNameAndMaxSalary();

  Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet = resultMap.entrySet();

  for (Map.Entry&lt;String, Object&gt; entry : entrySet) &#123;

    String key = entry.getKey();

    Object value = entry.getValue();

    log.info(key + &quot;=&quot; + value);

  &#125;
&#125;
</code></pre>
<p><strong>返回List类型</strong></p>
<p>  查询结果返回多个实体类对象，希望把多个实体类对象放在List集合中返回。此时不需要任何特殊处理，在resultType属性中还是设置实体类类型即可。</p>
<pre><code>如果是返回的类型的是集合,resultType里面的写的是泛型的类型，而不是string的类型
</code></pre>
<p>  Mapper接口中抽象方法</p>
<pre><code class="Java">List&lt;Employee&gt; selectAll();
</code></pre>
<p>  SQL语句</p>
<pre><code class="XML">&lt;!-- List&lt;Employee&gt; selectAll(); --&gt;
&lt;select id=&quot;selectAll&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;
  select emp_id empId,emp_name empName,emp_salary empSalary
  from t_emp
&lt;/select&gt;
</code></pre>
<p>  junit测试</p>
<pre><code class="Java">@Test
public void testSelectAll() &#123;
  EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);
  List&lt;Employee&gt; employeeList = employeeMapper.selectAll();
  for (Employee employee : employeeList) &#123;
    log.info(&quot;employee = &quot; + employee);
  &#125;
&#125;
</code></pre>
<p><strong>返回主键值</strong></p>
<pre><code>我们在执行DML语句回显操作的主键
</code></pre>
<ol>
<li><p><strong>自增长类型主键</strong></p>
<p> Mapper接口中的抽象方法</p>
</li>
</ol>
<pre><code class="Java">int insertEmployee(Employee employee);
</code></pre>
<pre><code>SQL语句
</code></pre>
<pre><code class="XML">&lt;!-- int insertEmployee(Employee employee); --&gt;
&lt;!-- useGeneratedKeys属性字面意思就是“使用生成的主键” --&gt;
&lt;!-- keyProperty属性可以指定主键在实体类对象中对应的属性名，Mybatis会将拿到的主键值存入这个属性 --&gt;
&lt;insert id=&quot;insertEmployee&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;empId&quot;&gt;
  insert into t_emp(emp_name,emp_salary)
  values(#&#123;empName&#125;,#&#123;empSalary&#125;)
&lt;/insert&gt;
</code></pre>
<pre><code>junit测试
</code></pre>
<pre><code class="Java">@Test
public void testSaveEmp() &#123;
  EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);
  Employee employee = new Employee();
  employee.setEmpName(&quot;john&quot;);
  employee.setEmpSalary(666.66);
  employeeMapper.insertEmployee(employee);
  log.info(&quot;employee.getEmpId() = &quot; + employee.getEmpId());
&#125;
</code></pre>
<pre><code>注意

Mybatis是将自增主键的值设置到实体类对象中，而不是以Mapper接口方法返回值的形式返回。
</code></pre>
<ol start="2">
<li><p><strong>非自增长类型主键</strong></p>
<p> 而对于不支持自增型主键的数据库（例如 Oracle）或者字符串类型主键，则可以使用 selectKey 子元素：selectKey 元素将会首先运行，id 会被设置，然后插入语句会被调用！</p>
<p> 使用 <code>selectKey</code> 帮助插入UUID作为字符串类型主键示例：</p>
</li>
</ol>
<pre><code class="XML">&lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt;
    &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;java.lang.String&quot;
        order=&quot;BEFORE&quot;&gt;
        SELECT UUID() as id
    &lt;/selectKey&gt;
    INSERT INTO user (id, username, password) 
    VALUES (
        #&#123;id&#125;,
        #&#123;username&#125;,
        #&#123;password&#125;
    )
&lt;/insert&gt;
</code></pre>
<p>在上例中，我们定义了一个 <code>insertUser</code> 的插入语句来将 <code>User</code> 对象插入到 <code>user</code> 表中。我们使用 <code>selectKey</code> 来查询 UUID 并设置到 <code>id</code> 字段中。</p>
<p>通过 <code>keyProperty</code> 属性来指定查询到的 UUID 赋值给对象中的 <code>id</code> 属性，而 <code>resultType</code> 属性指定了 UUID 的类型为 <code>java.lang.String</code>。</p>
<p>需要注意的是，我们将 <code>selectKey</code> 放在了插入语句的前面，这是因为 MySQL 在 <code>insert</code> 语句中只支持一个 <code>select</code> 子句，而 <code>selectKey</code> 中查询 UUID 的语句就是一个 <code>select</code> 子句，因此我们需要将其放在前面。</p>
<p>最后，在将 <code>User</code> 对象插入到 <code>user</code> 表中时，我们直接使用对象中的 <code>id</code> 属性来插入主键值。</p>
<p>使用这种方式，我们可以方便地插入 UUID 作为字符串类型主键。当然，还有其他插入方式可以使用，如使用Java代码生成UUID并在类中显式设置值等。需要根据具体应用场景和需求选择合适的插入方式。</p>
<p>注意我们在执行DML的语句的时候</p>
<p>在最后一定要,提交事务，因为Mybatis默认开启事务</p>
<pre><code class="java">sqlSession.commit()
</code></pre>
<pre><code>sqlSessionFactory.openSession()创建sqlSession对象的时候，默认会开启事物
</code></pre>
<p>或者我们</p>
<pre><code class="java">sqlSessionFactory.openSession(true)//这样就默认开启事物并且自动提交事物
</code></pre>
<p><strong>非自增长的主键再说一下</strong></p>
<pre><code>如果我们的主键设置为字符串这样主键就自增不了，所以主键的值需要我们自己进行维护
</code></pre>
<p>没有的话，需要我们自己设置</p>
<pre><code class="java">InputStream ips = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
SqlSessionFactory build = new SqlSessionFactoryBuilder().build(ips);
SqlSession sqlSession = build.openSession(true);
TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class);
Teacher teacher = new Teacher();
teacher.settName(&quot;王昌晨&quot;);
String replace = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
teacher.settId(replace);
int i = mapper.insertTeacher(teacher);
System.out.println(&quot;i=&quot;+i);//i=1
sqlSession.close();
</code></pre>
<p>在配置完以后</p>
<pre><code class="xml">&lt;insert id=&quot;insertTeacher&quot;&gt;
    &lt;!--插入之前，先指定生成一个sql语句，生成一个主键值--&gt;
    &lt;!--
        order代表是在sql语句之前执行还是之后执行
        resultType返回值的类型
        keyProperty = 给哪个值进行赋值
        下面就相当于这样的代码
                String replace = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
                teacher.settId(replace);
    --&gt;
    &lt;selectKey order=&quot;BEFORE&quot; resultType=&quot;string&quot; keyProperty=&quot;tId&quot;&gt;
        select replace(UUID(),&#39;-&#39;,&#39;&#39;);
    &lt;/selectKey&gt;
    insert into teacher (t_id,t_name) values (#&#123;tId&#125;,#&#123;tName&#125;);
&lt;/insert&gt;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240426233811068.png" alt="image-20240426233811068"></p>
<p><strong>实体类属性和数据库字段的对应关系</strong></p>
<ol>
<li><p>别名对应</p>
<p> 将字段的别名设置成和实体类属性一致。</p>
</li>
</ol>
<pre><code class="XML">&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;
&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;
&lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;

  &lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符 --&gt;
  &lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt;
  select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;maomi&#125;

&lt;/select&gt;
</code></pre>
<pre><code>&gt; 关于实体类属性的约定：
</code></pre>
<p>getXxx()方法、setXxx()方法把方法名中的get或set去掉，首字母小写。<br>2. 全局配置自动识别驼峰式命名规则</p>
<pre><code>在Mybatis全局配置文件加入如下配置：
</code></pre>
<pre><code class="XML">&lt;!-- 使用settings对Mybatis全局进行设置 --&gt;
&lt;settings&gt;

  &lt;!-- 将xxx_xxx这样的列名自动映射到xxXxx这样驼峰式命名的属性名 --&gt;
  &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;

&lt;/settings&gt;
</code></pre>
<pre><code>SQL语句中可以不使用别名
</code></pre>
<pre><code class="XML">&lt;!-- Employee selectEmployee(Integer empId); --&gt;
&lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;

  select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;

&lt;/select&gt;
</code></pre>
<ol start="3">
<li><p>使用resultMap</p>
<p> 使用resultMap标签定义对应关系，再在后面的SQL语句中引用这个对应关系</p>
</li>
</ol>
<pre><code class="XML">&lt;!-- 专门声明一个resultMap设定column到property之间的对应关系 --&gt;
&lt;resultMap id=&quot;selectEmployeeByRMResultMap&quot; type=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;

  &lt;!-- 使用id标签设置主键列和主键属性之间的对应关系 --&gt;
  &lt;!-- column属性用于指定字段名；property属性用于指定Java实体类属性名 --&gt;
  &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;/&gt;

  &lt;!-- 使用result标签设置普通字段和Java实体类属性之间的关系 --&gt;
  &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;/&gt;

  &lt;result column=&quot;emp_salary&quot; property=&quot;empSalary&quot;/&gt;

&lt;/resultMap&gt;

&lt;!-- Employee selectEmployeeByRM(Integer empId); --&gt;
&lt;select id=&quot;selectEmployeeByRM&quot; resultMap=&quot;selectEmployeeByRMResultMap&quot;&gt;

  select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;

&lt;/select&gt;
</code></pre>
<pre><code class="xml">&lt;!--
    别名和属性名字不一样的时候
        方案1：别名 select t_id tId
        方案2：开启驼峰映射
        方案3：resultMap自定义映射
        resultType会按照规则自动映射 按照 是否开启驼峰式映射，自己映射属性和别名：但是只能映射一层结构，
        Order实体类                            -数据库列名
            orderId                                 order_id
            orderName                               order_name
                orderItem还是一个实体类对象            item_id
                    itemId这样深层次的无法映射
    --&gt;
&lt;!--
        id标识，可以让下面的resultType进行引用
        type，返回的值的类型 全限定符或者别名
            id是主键的映射关系
            result是普通列的映射关系
--&gt;
&lt;resultMap id=&quot;tMap&quot; type=&quot;com.chenw.pojo.Teacher&quot;&gt;
    &lt;id column=&quot;t_id&quot; property=&quot;tId&quot;&gt;&lt;/id&gt;
    &lt;result column=&quot;t_name&quot; property=&quot;tName&quot;&gt;&lt;/result&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;queryById&quot; resultType=&quot;tMap&quot;&gt;
    select * from teacher where t_id = #&#123;&#125;
&lt;/select&gt;
</code></pre>
<p><strong>curd的练习</strong></p>
<ol>
<li><p>准备数据库数据</p>
<p> 首先，我们需要准备一张名为 <code>user</code> 的表。该表包含字段 id（主键）、username、password。创建SQL如下：</p>
</li>
</ol>
<pre><code class="SQL">CREATE TABLE `user` (
  `id` INT(11) NOT NULL AUTO_INCREMENT,
  `username` VARCHAR(50) NOT NULL,
  `password` VARCHAR(50) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
</code></pre>
<ol start="2">
<li><p>实体类准备</p>
<p> 接下来，我们需要定义一个实体类 <code>User</code>，来对应 user 表的一行数据。</p>
</li>
</ol>
<pre><code class="SQL">@Data //lombok
public class User &#123;
  private Integer id;
  private String username;
  private String password;
&#125;
</code></pre>
<ol start="3">
<li><p>Mapper接口定义</p>
<p> 定义一个 Mapper 接口 <code>UserMapper</code>，并在其中添加 user 表的增、删、改、查方法。</p>
</li>
</ol>
<pre><code class="Java">public interface UserMapper &#123;
  
  int insert(User user);

  int update(User user);

  int delete(Integer id);

  User selectById(Integer id);

  List&lt;User&gt; selectAll();
&#125;
</code></pre>
<ol start="4">
<li><p>MapperXML编写</p>
<p> 在 resources &#x2F;mappers目录下创建一个名为 <code>UserMapper.xml</code> 的 XML 文件，包含与 Mapper 接口中相同的五个 SQL 语句，并在其中，将查询结果映射到 <code>User</code> 实体中。</p>
</li>
</ol>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;
&lt;mapper namespace=&quot;com.atguigu.mapper.UserMapper&quot;&gt;
  &lt;!-- 定义一个插入语句，并获取主键值 --&gt;
  &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
    INSERT INTO user(username, password)
                VALUES(#&#123;username&#125;, #&#123;password&#125;)
  &lt;/insert&gt;
  
  &lt;update id=&quot;update&quot;&gt;
    UPDATE user SET username=#&#123;username&#125;, password=#&#123;password&#125;
    WHERE id=#&#123;id&#125;
  &lt;/update&gt;
  
  &lt;delete id=&quot;delete&quot;&gt;
    DELETE FROM user WHERE id=#&#123;id&#125;
  &lt;/delete&gt;
  &lt;!-- resultType使用user别名，稍后需要配置！--&gt;
  &lt;select id=&quot;selectById&quot; resultType=&quot;user&quot;&gt;
    SELECT id, username, password FROM user WHERE id=#&#123;id&#125;
  &lt;/select&gt;
  
  &lt;!-- resultType返回值类型为集合，所以只写范型即可！ --&gt;
  &lt;select id=&quot;selectAll&quot; resultType=&quot;user&quot;&gt;
    SELECT id, username, password FROM user
  &lt;/select&gt;
  
&lt;/mapper&gt;
</code></pre>
<ol start="5">
<li><p>MyBatis配置文件</p>
<p> 位置：resources: mybatis-config.xml</p>
</li>
</ol>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;

    &lt;settings&gt;
        &lt;!-- 开启驼峰式映射--&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
        &lt;!-- 开启logback日志输出--&gt;
        &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt;
    &lt;/settings&gt;

    &lt;typeAliases&gt;
        &lt;!-- 给实体类起别名 --&gt;
        &lt;package name=&quot;com.atguigu.pojo&quot;/&gt;
    &lt;/typeAliases&gt;

    &lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;!-- Mybatis的内置的事务管理器 --&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;!-- 配置数据源 --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;!-- 建立数据库连接的具体信息 --&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;mappers&gt;
        &lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt;
        &lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt;
        &lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt;
        &lt;!--    对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt;
        &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt;
    &lt;/mappers&gt;

&lt;/configuration&gt;
</code></pre>
<ol start="6">
<li>效果测试</li>
</ol>
<pre><code class="Java">package com.atguigu.test;

import com.atguigu.mapper.UserMapper;
import com.atguigu.pojo.User;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.util.List;

/**
 * projectName: com.atguigu.test
 */
public class MyBatisTest &#123;

    private SqlSession session;
    // junit会在每一个@Test方法前执行@BeforeEach方法

    @BeforeEach
    public void init() throws IOException &#123;
        session = new SqlSessionFactoryBuilder()
                .build(
                        Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;))
                .openSession();
    &#125;

    @Test
    public void createTest() &#123;
        User user = new User();
        user.setUsername(&quot;admin&quot;);
        user.setPassword(&quot;123456&quot;);
        UserMapper userMapper = session.getMapper(UserMapper.class);
        userMapper.insert(user);
        System.out.println(user);
    &#125;

    @Test
    public void updateTest() &#123;
        UserMapper userMapper = session.getMapper(UserMapper.class);
        User user = userMapper.selectById(1);
        user.setUsername(&quot;root&quot;);
        user.setPassword(&quot;111111&quot;);
        userMapper.update(user);
        user = userMapper.selectById(1);
        System.out.println(user);
    &#125;

    @Test
    public void deleteTest() &#123;
        UserMapper userMapper = session.getMapper(UserMapper.class);
        userMapper.delete(1);
        User user = userMapper.selectById(1);
        System.out.println(&quot;user = &quot; + user);
    &#125;

    @Test
    public void selectByIdTest() &#123;
        UserMapper userMapper = session.getMapper(UserMapper.class);
        User user = userMapper.selectById(1);
        System.out.println(&quot;user = &quot; + user);
    &#125;

    @Test
    public void selectAllTest() &#123;
        UserMapper userMapper = session.getMapper(UserMapper.class);
        List&lt;User&gt; userList = userMapper.selectAll();
        System.out.println(&quot;userList = &quot; + userList);
    &#125;

    // junit会在每一个@Test方法后执行@@AfterEach方法
    @AfterEach
    public void clear() &#123;
        session.commit();
        session.close();
    &#125;
&#125;
</code></pre>
<p><strong>mapperXML总结</strong></p>
<p>MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。</p>
<p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：</p>
<ul>
<li><code>insert</code> – 映射插入语句。</li>
<li><code>update</code> – 映射更新语句。</li>
<li><code>delete</code> – 映射删除语句。</li>
<li><code>select</code> – 映射查询语句。</li>
</ul>
<p><strong>select标签：</strong></p>
<p>  MyBatis 在查询和结果映射做了相当多的改进。一个简单查询的 select 元素是非常简单：</p>
<pre><code class="XML">&lt;select id=&quot;selectPerson&quot; 
resultType=&quot;hashmap&quot; resultMap=&quot;自定义结构&quot;&gt; SELECT * FROM PERSON WHERE ID = #&#123;id&#125; &lt;/select&gt;
</code></pre>
<p>  这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。</p>
<p>  注意参数符号：#{id}  ${key}</p>
<p>  MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p>
<pre><code class="Java">// 近似的 JDBC 代码，非 MyBatis 代码...
String selectPerson = &quot;SELECT * FROM PERSON WHERE ID=?&quot;;
PreparedStatement ps = conn.prepareStatement(selectPerson);
ps.setInt(1,id);
</code></pre>
<p>  select 元素允许你配置很多属性来配置每条语句的行为细节：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td>
</tr>
<tr>
<td><code>resultType</code></td>
<td>期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。</td>
</tr>
<tr>
<td><code>resultMap</code></td>
<td>对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。</td>
</tr>
<tr>
<td><code>timeout</code></td>
<td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td>
</tr>
<tr>
<td><code>statementType</code></td>
<td>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td>
</tr>
</tbody></table>
<p><strong>insert, update 和 delete标签：</strong></p>
<p>  数据变更语句 insert，update 和 delete 的实现非常接近：</p>
<pre><code class="XML">&lt;insert
  id=&quot;insertAuthor&quot;
  statementType=&quot;PREPARED&quot;
  keyProperty=&quot;&quot;
  keyColumn=&quot;&quot;
  useGeneratedKeys=&quot;&quot;
  timeout=&quot;20&quot;&gt;

&lt;update
  id=&quot;updateAuthor&quot;
  statementType=&quot;PREPARED&quot;
  timeout=&quot;20&quot;&gt;

&lt;delete
  id=&quot;deleteAuthor&quot;
  statementType=&quot;PREPARED&quot;
  timeout=&quot;20&quot;&gt;
</code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td>
</tr>
<tr>
<td><code>timeout</code></td>
<td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td>
</tr>
<tr>
<td><code>statementType</code></td>
<td>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td>
</tr>
<tr>
<td><code>useGeneratedKeys</code></td>
<td>（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</td>
</tr>
<tr>
<td><code>keyProperty</code></td>
<td>（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（<code>unset</code>）。如果生成列不止一个，可以用逗号分隔多个属性名称。</td>
</tr>
<tr>
<td><code>keyColumn</code></td>
<td>（仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。</td>
</tr>
</tbody></table>
<p><strong>Mybatis的多表查询</strong></p>
<p><strong>多表映射概念</strong></p>
<ul>
<li><p>对一 ： 夫妻一方对应另一方，订单对应用户都是对一关系</p>
<p>  实体类设计：对一关系下，类中只要包含单个对方对象类型属性即可！</p>
<p>  例如：</p>
</li>
</ul>
<pre><code class="Java">public class Customer &#123;

  private Integer customerId;
  private String customerName;

&#125;

public class Order &#123;

  private Integer orderId;
  private String orderName;
  private Customer customer;// 体现的是对一的关系

&#125;  
</code></pre>
<ul>
<li><p>对多: 用户对应的订单，讲师对应的学生或者学生对应的讲师都是对多关系：</p>
<p>  实体类设计：对多关系下，类中只要包含对方类型集合属性即可！</p>
</li>
</ul>
<pre><code class="Java">public class Customer &#123;

  private Integer customerId;
  private String customerName;
  private List&lt;Order&gt; orderList;// 体现的是对多的关系
&#125;

public class Order &#123;

  private Integer orderId;
  private String orderName;
  private Customer customer;// 体现的是对一的关系
  
&#125;

//查询客户和客户对应的订单集合  不要管!
</code></pre>
<ol>
<li><p><strong>实体类设计方案</strong></p>
<p> 多表关系回顾：（双向查看）</p>
<ul>
<li><p>一对一</p>
<p>  夫妻关系，人和身份证号</p>
</li>
<li><p>一对多| 多对一</p>
<p>  用户和用户的订单，锁和钥匙</p>
</li>
<li><p>多对多</p>
<p>  老师和学生，部门和员工</p>
</li>
</ul>
<p> 实体类设计关系(查询)：（单向查看）</p>
<ul>
<li><p>对一 ： 夫妻一方对应另一方，订单对应用户都是对一关系</p>
<p>  实体类设计：对一关系下，类中只要包含单个对方对象类型属性即可！</p>
<p>  例如：</p>
</li>
</ul>
</li>
</ol>
<pre><code class="Java">public class Customer &#123;

  private Integer customerId;
  private String customerName;

&#125;

public class Order &#123;

  private Integer orderId;
  private String orderName;
  private Customer customer;// 体现的是对一的关系

&#125;  
</code></pre>
<pre><code>- 对多: 用户对应的订单，讲师对应的学生或者学生对应的讲师都是对多关系：

    实体类设计：对多关系下，类中只要包含对方类型集合属性即可！
</code></pre>
<pre><code class="Java">public class Customer &#123;

  private Integer customerId;
  private String customerName;
  private List&lt;Order&gt; orderList;// 体现的是对多的关系
&#125;

public class Order &#123;

  private Integer orderId;
  private String orderName;
  private Customer customer;// 体现的是对一的关系
  
&#125;

//查询客户和客户对应的订单集合  不要管!
</code></pre>
<pre><code>多表结果实体类设计小技巧：

  对一，属性中包含对方对象

  对多，属性中包含对方对象集合

  只有真实发生多表查询时，才需要设计和修改实体类，否则不提前设计和修改实体类！

  无论多少张表联查，实体类设计都是两两考虑!

  在查询映射的时候，只需要关注本次查询相关的属性！例如：查询订单和对应的客户，就不要关注客户中的订单集合！
</code></pre>
<ol start="2">
<li><p><strong>多表映射案例准备</strong></p>
<p> 数据库：</p>
</li>
</ol>
<pre><code class="SQL">CREATE TABLE `t_customer` (`customer_id` INT NOT NULL AUTO_INCREMENT, `customer_name` CHAR(100), PRIMARY KEY (`customer_id`) );

CREATE TABLE `t_order` ( `order_id` INT NOT NULL AUTO_INCREMENT, `order_name` CHAR(100), `customer_id` INT, PRIMARY KEY (`order_id`) ); 

INSERT INTO `t_customer` (`customer_name`) VALUES (&#39;c01&#39;);

INSERT INTO `t_order` (`order_name`, `customer_id`) VALUES (&#39;o1&#39;, &#39;1&#39;);
INSERT INTO `t_order` (`order_name`, `customer_id`) VALUES (&#39;o2&#39;, &#39;1&#39;);
INSERT INTO `t_order` (`order_name`, `customer_id`) VALUES (&#39;o3&#39;, &#39;1&#39;); 
</code></pre>
<pre><code>实际开发时，一般在开发过程中，不给数据库表设置外键约束。
</code></pre>
<p>原因是避免调试不方便。<br>一般是功能开发完成，再加外键约束检查是否有bug。</p>
<p>​    </p>
<pre><code>实体类设计：

稍后会进行订单关联客户查询，也会进行客户关联订单查询，所以在这先练习设计
</code></pre>
<pre><code class="Java">@Data
public class Customer &#123;

  private Integer customerId;
  private String customerName;
  private List&lt;Order&gt; orderList;// 体现的是对多的关系
  
&#125;  

@Data
public class Order &#123;
  private Integer orderId;
  private String orderName;
  private Customer customer;// 体现的是对一的关系
  
&#125;  
</code></pre>
<p><strong>对一映射</strong></p>
<ol>
<li><p>需求说明</p>
<p> 根据ID查询订单，以及订单关联的用户的信息！</p>
</li>
<li><p>OrderMapper接口</p>
</li>
</ol>
<pre><code class="Java">public interface OrderMapper &#123;
  Order selectOrderWithCustomer(Integer orderId);
&#125;
</code></pre>
<ol start="3">
<li>OrderMapper.xml配置文件</li>
</ol>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.chenw.mapper.OrderMapper&quot;&gt;

    &lt;!--自定义映射关系，定义嵌套的对象的映射关系--&gt;
    &lt;resultMap id=&quot;orderMap&quot; type=&quot;com.chenw.pojo.Order&quot;&gt;
        &lt;id column=&quot;order_id&quot; property=&quot;orderId&quot;&gt;&lt;/id&gt;
        &lt;result column=&quot;order_name&quot; property=&quot;orderName&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;customer_id&quot;  property=&quot;customerId&quot;&gt;&lt;/result&gt;
        &lt;!--给对象属性赋值--&gt;&lt;!--
            property是赋值的对象的属性名字
            javaType对象类型
        --&gt;
        &lt;association property=&quot;customer&quot; javaType=&quot;com.chenw.pojo.Customer&quot;&gt;
            &lt;id column=&quot;customer_id&quot; property=&quot;customerId&quot;&gt;&lt;/id&gt;
            &lt;result column=&quot;customer_name&quot; property=&quot;customerName&quot;&gt;&lt;/result&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;queryOrderById&quot; resultMap=&quot;orderMap&quot;&gt;
        select * from t_order tor join t_customer tur on tor.customer_id = tur.customer_id where tor.order_id = #&#123;id&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>customer的类</p>
<pre><code class="java">package com.chenw.pojo;


import lombok.Data;

@Data
public class Customer &#123;
    private Integer customerId;
    private String customerName;
&#125;
</code></pre>
<p>order的类</p>
<pre><code class="java">package com.chenw.pojo;


import lombok.Data;

@Data
public class Order &#123;
    private Integer orderId;
    private String orderName;
    private Integer customerId;
    private Customer customer;
&#125;
</code></pre>
<ol start="4">
<li>Mybatis全局注册Mapper文件</li>
</ol>
<pre><code class="XML">&lt;!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 --&gt;
&lt;mappers&gt;

  &lt;!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 --&gt;
  &lt;mapper resource=&quot;mappers/OrderMapper.xml&quot;/&gt;

&lt;/mappers&gt;
</code></pre>
<ol start="5">
<li>junit测试程序</li>
</ol>
<pre><code class="Java">@Slf4j
public class MyBatisTest &#123;

    private SqlSession session;
    // junit会在每一个@Test方法前执行@BeforeEach方法

    @BeforeEach
    public void init() throws IOException &#123;
        session = new SqlSessionFactoryBuilder()
                .build(
                        Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;))
                .openSession();
    &#125;

    @Test
    public void testRelationshipToOne() &#123;
    
      OrderMapper orderMapper = session.getMapper(OrderMapper.class);
      // 查询Order对象，检查是否同时查询了关联的Customer对象
      Order order = orderMapper.selectOrderWithCustomer(2);
      log.info(&quot;order = &quot; + order);
    
    &#125;

    // junit会在每一个@Test方法后执行@@AfterEach方法
    @AfterEach
    public void clear() &#123;
        session.commit();
        session.close();
    &#125;
&#125;
</code></pre>
<ol start="6">
<li><p>关键词</p>
<p> 在“对一”关联关系中，我们的配置比较多，但是关键词就只有：<strong>association</strong>和<strong>javaType</strong></p>
</li>
</ol>
<p><strong>对多映射</strong></p>
<p>例如</p>
<p>customer实体类</p>
<pre><code class="java">package com.chenw.pojo;


import lombok.Data;

import java.util.List;

@Data
public class Customer &#123;
    private Integer customerId;
    private String customerName;
    /*
    *   一个客户多个订单
    *   对多装集合
    * */
    private List&lt;Order&gt; orderList;
&#125;
</code></pre>
<p>配置文件</p>
<pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.chenw.mapper.CustomerMapper&quot;&gt;
    
    &lt;resultMap id=&quot;customerMap&quot; type=&quot;com.chenw.pojo.Customer&quot;&gt;
        &lt;id column=&quot;customer_id&quot; property=&quot;customerId&quot;&gt;&lt;/id&gt;
        &lt;result column=&quot;customer_name&quot; property=&quot;customerName&quot;&gt;&lt;/result&gt;
        &lt;!--
            &lt;association property=   javaType    给对一的对象属性赋值
        --&gt;
        &lt;!--
            给集合属性赋值
            orderList 集合属性名
            ofType 集合的泛型
        --&gt;
        &lt;collection property=&quot;orderList&quot; ofType=&quot;com.chenw.pojo.Order&quot;&gt;
            &lt;id column=&quot;order_id&quot; property=&quot;orderId&quot;&gt;&lt;/id&gt;
            &lt;result column=&quot;order_name&quot; property=&quot;orderName&quot;&gt;&lt;/result&gt;
            &lt;result column=&quot;customer_id&quot; property=&quot;customerId&quot;&gt;&lt;/result&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    
    &lt;select id=&quot;queryList&quot; resultMap=&quot;customerMap&quot;&gt;
        select * from t_order tor join t_customer tur on tor.customer_id = tur.customer_id
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>order实体类</p>
<pre><code class="java">package com.chenw.pojo;


import lombok.Data;

@Data
public class Order &#123;
    private Integer orderId;
    private String orderName;
    private Integer customerId;
    private Customer customer;
&#125;
</code></pre>
<p>map接口</p>
<pre><code class="java">public interface CustomerMapper &#123;
    /*
    *   TODO:查询所有客户信息以及客户对应的订单信息
    * */

    List&lt;Customer&gt; queryList();
&#125;
</code></pre>
<p><strong>多表映射的总结</strong></p>
<p><strong>多表映射的优化</strong></p>
<table>
<thead>
<tr>
<th>setting属性</th>
<th>属性含义</th>
<th>可选值</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>autoMappingBehavior</td>
<td>指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。</td>
<td>NONE, PARTIAL, FULL</td>
<td>PARTIAL</td>
</tr>
</tbody></table>
<pre><code>默认的情况下
    resultMap会自动映射单层的result标签【列名和属性名相同，或者开启驼峰式命名的映射】
    嵌套的association | collection	 不会自动映射result的标签和列名和属性名
</code></pre>
<p>我们可以将autoMappingBehavior设置为full,进行多表resultMap映射的时候，可以省略符合列和属性命名映射规则（列名&#x3D;属性名，或者开启驼峰映射也可以自定映射）的result标签！</p>
<p>修改mybati-sconfig.xml:</p>
<pre><code class="XML">&lt;!--开启resultMap自动映射 --&gt;
&lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt;
&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
</code></pre>
<p>修改teacherMapper.xml</p>
<pre><code class="XML">&lt;resultMap id=&quot;teacherMap&quot; type=&quot;teacher&quot;&gt;
    &lt;id property=&quot;tId&quot; column=&quot;t_id&quot; /&gt;
    &lt;!-- 开启自动映射,并且开启驼峰式支持!可以省略 result!--&gt;
&lt;!--        &lt;result property=&quot;tName&quot; column=&quot;t_name&quot; /&gt;--&gt;
    &lt;collection property=&quot;students&quot; ofType=&quot;student&quot; &gt;
        &lt;id property=&quot;sId&quot; column=&quot;s_id&quot; /&gt;
&lt;!--            &lt;result property=&quot;sName&quot; column=&quot;s_name&quot; /&gt;--&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;
</code></pre>
<p>总结</p>
<table>
<thead>
<tr>
<th>关联关系</th>
<th>配置项关键词</th>
<th>所在配置文件和具体位置</th>
</tr>
</thead>
<tbody><tr>
<td>对一</td>
<td>association标签&#x2F;javaType属性&#x2F;property属性</td>
<td>Mapper配置文件中的resultMap标签内</td>
</tr>
<tr>
<td>对多</td>
<td>collection标签&#x2F;ofType属性&#x2F;property属性</td>
<td>Mapper配置文件中的resultMap标签内</td>
</tr>
</tbody></table>
<p><strong>动态sql语句</strong></p>
<p><strong>动态语句需求和简介</strong></p>
<p>  经常遇到很多按照很多查询条件进行查询的情况，比如智联招聘的职位搜索等。其中经常出现很多条件不取值的情况，在后台应该如何完成最终的SQL语句呢？</p>
<p>  <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<p>  动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p>
<p>  使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。</p>
<p>  如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。</p>
<p><strong>if和where标签</strong></p>
<p>  使用动态 SQL 最常见情景是根据条件包含 where  &#x2F; if 子句的一部分。比如：</p>
<pre><code class="XML">&lt;!-- List&lt;Employee&gt; selectEmployeeByCondition(Employee employee); --&gt;
&lt;select id=&quot;selectEmployeeByCondition&quot; resultType=&quot;employee&quot;&gt;
    select emp_id,emp_name,emp_salary from t_emp
    &lt;!-- where标签会自动去掉“标签体内前面多余的and/or” --&gt;
    &lt;where&gt;
        &lt;!-- 使用if标签，让我们可以有选择的加入SQL语句的片段。这个SQL语句片段是否要加入整个SQL语句，就看if标签判断的结果是否为true --&gt;
        &lt;!-- 在if标签的test属性中，可以访问实体类的属性，不可以访问数据库表的字段 --&gt;
        &lt;if test=&quot;empName != null&quot;&gt;
            &lt;!-- 在if标签内部，需要访问接口的参数时还是正常写#&#123;&#125; --&gt;
            or emp_name=#&#123;empName&#125;
        &lt;/if&gt;
        &lt;if test=&quot;empSalary &amp;gt; 2000&quot;&gt;
            or emp_salary&gt;#&#123;empSalary&#125;
        &lt;/if&gt;
        &lt;!--
         第一种情况：所有条件都满足 WHERE emp_name=? or emp_salary&gt;?
         第二种情况：部分条件满足 WHERE emp_salary&gt;?
         第三种情况：所有条件都不满足 没有where子句
         --&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.chenw.mapper.EmployeeMapper&quot;&gt;

    &lt;!--
        现在有一个要求
            List&lt;Employee&gt; query(@Param(&quot;name&quot;)String name,@Param(&quot;salary&quot;) Double salary);
            如果参数传入我才有这个对应的sql语句，例如有name没有薪水 select * from t_emp where emp_name = #&#123;name
            where
            if 判断传入的参数，最终是否添加语句
            test属性 内部进行比较运算，最终为true将标签内的sql语句进行拼接
                                        false 不拼接标签内部的语句

             问题，如果第一个不满足第二个满足怎么办
             这杨拼接起来的变成
                select * from t_emp where and emp_salary = #&#123;salary&#125;
             还有都不满足
                select * from t_emp where
              where标签就可以解决这个问题
                1.自动添加where关键字 where内部有一个任何的一个的if满足 ，自动添加where关键字，不满足去掉where
                2.自动去掉多余的and 和 or 关键字
    --&gt;
    &lt;select id=&quot;query&quot; resultType=&quot;com.chenw.pojo.Employee&quot;&gt;
        select * from t_emp
        &lt;where&gt;
            &lt;if test=&quot;name!=null&quot;&gt;
                emp_name = #&#123;name&#125;
            &lt;/if&gt;
            &lt;if test=&quot;salary != null&quot;&gt;
                and emp_salary = #&#123;salary&#125;
            &lt;/if&gt;
        &lt;/where&gt;

    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>测试</p>
<pre><code class="java">package com.chenw.test;

import com.chenw.mapper.EmployeeMapper;
import com.chenw.pojo.Employee;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.util.List;

public class MybatisTest &#123;
    private SqlSession sqlSession;
    @BeforeEach
    public void init() throws IOException &#123;
        sqlSession  = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)).openSession(true);
    &#125;

    @Test
    public void test()&#123;
        EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);
        List&lt;Employee&gt; tom = mapper.query(null, 200.33);
        System.out.println(tom);
    &#125;


    @AfterEach
    public  void clean()&#123;
        sqlSession.close();
    &#125;
&#125;
</code></pre>
<p>结果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240427110444339.png" alt="image-20240427110444339"></p>
<p><strong>set关键字</strong></p>
<pre><code class="XML">&lt;!-- void updateEmployeeDynamic(Employee employee) --&gt;
&lt;update id=&quot;updateEmployeeDynamic&quot;&gt;
    update t_emp
    &lt;!-- set emp_name=#&#123;empName&#125;,emp_salary=#&#123;empSalary&#125; --&gt;
    &lt;!-- 使用set标签动态管理set子句，并且动态去掉两端多余的逗号 --&gt;
    &lt;set&gt;
        &lt;if test=&quot;empName != null&quot;&gt;
            emp_name=#&#123;empName&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;empSalary &amp;lt; 3000&quot;&gt;
            emp_salary=#&#123;empSalary&#125;,
        &lt;/if&gt;
    &lt;/set&gt;
    where emp_id=#&#123;empId&#125;
    &lt;!--
         第一种情况：所有条件都满足 SET emp_name=?, emp_salary=?
         第二种情况：部分条件满足 SET emp_salary=?
         第三种情况：所有条件都不满足 update t_emp where emp_id=?
            没有set子句的update语句会导致SQL语法错误
     --&gt;
&lt;/update&gt;
</code></pre>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.chenw.mapper.EmployeeMapper&quot;&gt;

    &lt;!--
        现在有一个要求
            List&lt;Employee&gt; query(@Param(&quot;name&quot;)String name,@Param(&quot;salary&quot;) Double salary);
            如果参数传入我才有这个对应的sql语句，例如有name没有薪水 select * from t_emp where emp_name = #&#123;name
            where
            if 判断传入的参数，最终是否添加语句
            test属性 内部进行比较运算，最终为true将标签内的sql语句进行拼接
                                        false 不拼接标签内部的语句

             问题，如果第一个不满足第二个满足怎么办
             这杨拼接起来的变成
                select * from t_emp where and emp_salary = #&#123;salary&#125;
             还有都不满足
                select * from t_emp where
              where标签就可以解决这个问题
                1.自动添加where关键字 where内部有一个任何的一个的if满足 ，自动添加where关键字，不满足去掉where
                2.自动去掉多余的and 和 or 关键字
    --&gt;
    &lt;select id=&quot;query&quot; resultType=&quot;com.chenw.pojo.Employee&quot;&gt;
        select * from t_emp
        &lt;where&gt;
            &lt;if test=&quot;name!=null&quot;&gt;
                emp_name = #&#123;name&#125;
            &lt;/if&gt;
            &lt;if test=&quot;salary != null&quot;&gt;
                and emp_salary = #&#123;salary&#125;
            &lt;/if&gt;
        &lt;/where&gt;

    &lt;/select&gt;


    &lt;!--
        如果还是使用if的话              update t_emp set
                                    &lt;if test=&quot;empName!=null&quot;&gt;
                                            emp_name = #&#123;empName&#125; ,
                                    &lt;/if&gt;
                                    &lt;if test=&quot;empSalary!=null&quot;&gt;
                                            emp_salary = #&#123;empSalary&#125;
                                     &lt;/if&gt;
                                     where  emp_id = #&#123;empId&#125;

                                     出现的问题
                                     第一个满足，第二个不满足的话 多了一个,
                                     都不满足 语法错误
                                     解决使用set标签
                                        作用
                                            1.自动去掉多余的,多余的逗号
                                            2.自动添加set关键字
                                            但是不能解决最后一个问题，所以必须至少传一个值


    --&gt;
    &lt;update id=&quot;update&quot;&gt;
        update t_emp
        &lt;set&gt;
            &lt;if test=&quot;empName!=null&quot;&gt;
                emp_name = #&#123;empName&#125; ,
            &lt;/if&gt;
            &lt;if test=&quot;empSalary!=null&quot;&gt;
                emp_salary = #&#123;empSalary&#125;
            &lt;/if&gt;
            where  emp_id = #&#123;empId&#125;
        &lt;/set&gt;
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre>
<p><strong>trim标签</strong></p>
<p>使用trim标签控制条件部分两端是否包含某些字符</p>
<ul>
<li>prefix属性：指定要动态添加的前缀</li>
<li>suffix属性：指定要动态添加的后缀</li>
<li>prefixOverrides属性：指定要动态去掉的前缀，使用“|”分隔有可能的多个值</li>
<li>suffixOverrides属性：指定要动态去掉的后缀，使用“|”分隔有可能的多个值</li>
</ul>
<pre><code class="XML">&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByTrim(Employee employee) --&gt;
&lt;select id=&quot;selectEmployeeByConditionByTrim&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;
    select emp_id,emp_name,emp_age,emp_salary,emp_gender
    from t_emp
    
    &lt;!-- prefix属性指定要动态添加的前缀 --&gt;
    &lt;!-- suffix属性指定要动态添加的后缀 --&gt;
    &lt;!-- prefixOverrides属性指定要动态去掉的前缀，使用“|”分隔有可能的多个值 --&gt;
    &lt;!-- suffixOverrides属性指定要动态去掉的后缀，使用“|”分隔有可能的多个值 --&gt;
    &lt;!-- 当前例子用where标签实现更简洁，但是trim标签更灵活，可以用在任何有需要的地方 --&gt;
    &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and|or&quot;&gt;
        &lt;if test=&quot;empName != null&quot;&gt;
            emp_name=#&#123;empName&#125; and
        &lt;/if&gt;
        &lt;if test=&quot;empSalary &amp;gt; 3000&quot;&gt;
            emp_salary&gt;#&#123;empSalary&#125; and
        &lt;/if&gt;
        &lt;if test=&quot;empAge &amp;lt;= 20&quot;&gt;
            emp_age=#&#123;empAge&#125; or
        &lt;/if&gt;
        &lt;if test=&quot;empGender==&#39;male&#39;&quot;&gt;
            emp_gender=#&#123;empGender&#125;
        &lt;/if&gt;
    &lt;/trim&gt;
&lt;/select&gt;
</code></pre>
<p><strong>choose&#x2F;when&#x2F;otherwise标签</strong></p>
<p>  在多个分支条件中，仅执行一个。</p>
<ul>
<li>从上到下依次执行条件判断</li>
<li>遇到的第一个满足条件的分支会被采纳</li>
<li>被采纳分支后面的分支都将不被考虑</li>
<li>如果所有的when分支都不满足，那么就执行otherwise分支</li>
</ul>
<pre><code class="XML">&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByChoose(Employee employee) --&gt;
&lt;select id=&quot;selectEmployeeByConditionByChoose&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;
    select emp_id,emp_name,emp_salary from t_emp
    where
    &lt;choose&gt;
        &lt;when test=&quot;empName != null&quot;&gt;emp_name=#&#123;empName&#125;&lt;/when&gt;
        &lt;when test=&quot;empSalary &amp;lt; 3000&quot;&gt;emp_salary &amp;lt; 3000&lt;/when&gt;
        &lt;otherwise&gt;1=1&lt;/otherwise&gt;
    &lt;/choose&gt;
    
    &lt;!--
     第一种情况：第一个when满足条件 where emp_name=?
     第二种情况：第二个when满足条件 where emp_salary &lt; 3000
     第三种情况：两个when都不满足 where 1=1 执行了otherwise
     --&gt;
&lt;/select&gt;
</code></pre>
<p><strong>forEach标签</strong></p>
<p><strong>基本用法</strong></p>
<p>用批量插入举例</p>
<pre><code class="XML">&lt;!--
    collection属性：要遍历的集合
    item属性：遍历集合的过程中能得到每一个具体对象，在item属性中设置一个名字，将来通过这个名字引用遍历出来的对象
    separator属性：指定当foreach标签的标签体重复拼接字符串时，各个标签体字符串之间的分隔符
    open属性：指定整个循环把字符串拼好后，字符串整体的前面要添加的字符串
    close属性：指定整个循环把字符串拼好后，字符串整体的后面要添加的字符串
    index属性：这里起一个名字，便于后面引用
        遍历List集合，这里能够得到List集合的索引值
        遍历Map集合，这里能够得到Map集合的key
 --&gt;
&lt;foreach collection=&quot;empList&quot; item=&quot;emp&quot; separator=&quot;,&quot; open=&quot;values&quot; index=&quot;myIndex&quot;&gt;
    &lt;!-- 在foreach标签内部如果需要引用遍历得到的具体的一个对象，需要使用item属性声明的名称 --&gt;
    (#&#123;emp.empName&#125;,#&#123;myIndex&#125;,#&#123;emp.empSalary&#125;,#&#123;emp.empGender&#125;)
&lt;/foreach&gt;
</code></pre>
<p><strong>批量更新时需要注意</strong></p>
<p>上面批量插入的例子本质上是一条SQL语句，而实现批量更新则需要多条SQL语句拼起来，用分号分开。也就是一次性发送多条SQL语句让数据库执行。此时需要在数据库连接信息的URL地址中设置：</p>
<pre><code class=".properties">atguigu.dev.url=jdbc:mysql:///mybatis-example?allowMultiQueries=true
</code></pre>
<p>对应的foreach标签如下：</p>
<pre><code class="XML">&lt;!-- int updateEmployeeBatch(@Param(&quot;empList&quot;) List&lt;Employee&gt; empList) --&gt;
&lt;update id=&quot;updateEmployeeBatch&quot;&gt;
    &lt;foreach collection=&quot;empList&quot; item=&quot;emp&quot; separator=&quot;;&quot;&gt;
        update t_emp set emp_name=#&#123;emp.empName&#125; where emp_id=#&#123;emp.empId&#125;
    &lt;/foreach&gt;
&lt;/update&gt;
</code></pre>
<p><strong>关于foreach标签的collection属性</strong></p>
<p>如果没有给接口中List类型的参数使用@Param注解指定一个具体的名字，那么在collection属性中默认可以使用collection或list来引用这个list集合。这一点可以通过异常信息看出来：</p>
<pre><code class="XML">Parameter &#39;empList&#39; not found. Available parameters are [arg0, collection, list]
</code></pre>
<p>在实际开发中，为了避免隐晦的表达造成一定的误会，建议使用@Param注解明确声明变量的名称，然后在foreach标签的collection属性中按照@Param注解指定的名称来引用传入的参数。</p>
<p>foreach标签的基本使用</p>
<pre><code class="java">接口
    /*
    *           根据id进行批量查询
    * */

    List&lt;Employee&gt; queryBatch(@Param(&quot;ids&quot;) List&lt;Integer&gt; ids);
</code></pre>
<p>配置文件</p>
<pre><code class="xml">    &lt;select id=&quot;queryBatch&quot; resultType=&quot;com.chenw.pojo.Employee&quot;&gt;
        select  * from t_emp where emp_id in
        &lt;!--
            collection便利的集合，需要写刚才使用@Param指定的别名,或者使用arg0
            open 遍历之前需要添加的字符串
            close 结束之前添加的字符串
            separator每次遍历的分隔符号
            item 获取每一个便利项目的
        --&gt;
        &lt;foreach collection=&quot;ids&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot; item=&quot;id&quot;&gt;
            #&#123;id&#125;
        &lt;/foreach&gt;
    &lt;/select&gt;
&lt;!--    上面就变成下面的这样，如果ids集合的值为&#123;1,2,3&#125;
        select  * from t_emp where emp_id in (1,,2,3)
        这样实现遍历的效果
    --&gt;
</code></pre>
<p>例如</p>
<pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.chenw.mapper.EmployeeMapper&quot;&gt;

    &lt;!--
        现在有一个要求
            List&lt;Employee&gt; query(@Param(&quot;name&quot;)String name,@Param(&quot;salary&quot;) Double salary);
            如果参数传入我才有这个对应的sql语句，例如有name没有薪水 select * from t_emp where emp_name = #&#123;name
            where
            if 判断传入的参数，最终是否添加语句
            test属性 内部进行比较运算，最终为true将标签内的sql语句进行拼接
                                        false 不拼接标签内部的语句

             问题，如果第一个不满足第二个满足怎么办
             这杨拼接起来的变成
                select * from t_emp where and emp_salary = #&#123;salary&#125;
             还有都不满足
                select * from t_emp where
              where标签就可以解决这个问题
                1.自动添加where关键字 where内部有一个任何的一个的if满足 ，自动添加where关键字，不满足去掉where
                2.自动去掉多余的and 和 or 关键字
    --&gt;
    &lt;select id=&quot;query&quot; resultType=&quot;com.chenw.pojo.Employee&quot;&gt;
        select * from t_emp
        &lt;where&gt;
            &lt;if test=&quot;name!=null&quot;&gt;
                emp_name = #&#123;name&#125;
            &lt;/if&gt;
            &lt;if test=&quot;salary != null&quot;&gt;
                and emp_salary = #&#123;salary&#125;
            &lt;/if&gt;
        &lt;/where&gt;

    &lt;/select&gt;


    &lt;!--
        如果还是使用if的话              update t_emp set
                                    &lt;if test=&quot;empName!=null&quot;&gt;
                                            emp_name = #&#123;empName&#125; ,
                                    &lt;/if&gt;
                                    &lt;if test=&quot;empSalary!=null&quot;&gt;
                                            emp_salary = #&#123;empSalary&#125;
                                     &lt;/if&gt;
                                     where  emp_id = #&#123;empId&#125;

                                     出现的问题
                                     第一个满足，第二个不满足的话 多了一个,
                                     都不满足 语法错误
                                     解决使用set标签
                                        作用
                                            1.自动去掉多余的,多余的逗号
                                            2.自动添加set关键字
                                            但是不能解决最后一个问题，所以必须至少传一个值


    --&gt;
    &lt;update id=&quot;update&quot;&gt;
        update t_emp
        &lt;set&gt;
            &lt;if test=&quot;empName!=null&quot;&gt;
                emp_name = #&#123;empName&#125; ,
            &lt;/if&gt;
            &lt;if test=&quot;empSalary!=null&quot;&gt;
                emp_salary = #&#123;empSalary&#125;
            &lt;/if&gt;
            where  emp_id = #&#123;empId&#125;
        &lt;/set&gt;
    &lt;/update&gt;

    &lt;select id=&quot;queryBatch&quot; resultType=&quot;com.chenw.pojo.Employee&quot;&gt;
        select  * from t_emp where emp_id in
        &lt;!--
            collection便利的集合，需要写刚才使用@Param指定的别名,或者使用arg0
            open 遍历之前需要添加的字符串
            close 结束之前添加的字符串
            separator每次遍历的分隔符号
            item 获取每一个便利项目的
        --&gt;
        &lt;foreach collection=&quot;ids&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot; item=&quot;id&quot;&gt;
            #&#123;id&#125;
        &lt;/foreach&gt;
    &lt;/select&gt;
&lt;!--    上面就变成下面的这样，如果ids集合的值为&#123;1,2,3&#125;
        select  * from t_emp where emp_id in (1,,2,3)
        这样实现遍历的效果
    --&gt;

    &lt;delete id=&quot;deleteBatch&quot;&gt;
        delete from t_emp where emp_id in
        &lt;foreach collection=&quot;ids&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot; item=&quot;id&quot;&gt;
            #&#123;id&#125;
        &lt;/foreach&gt;
    &lt;/delete&gt;

    &lt;!--

        批量的插入
    --&gt;
    &lt;insert id=&quot;insertBatch&quot; &gt;
        insert into t_emp (emp_name,emp_salary) values (),(),()
        &lt;foreach collection=&quot;list&quot;  separator=&quot;,&quot; item=&quot;employee&quot;&gt;
            (#&#123;employee.empName&#125;,#&#123;employee.empSalary&#125;)
        &lt;/foreach&gt;
    &lt;/insert&gt;
    &lt;!--
        批量的更新
        进行整体的遍历
        如果一个标签设置多个语句，需要设置允许指定多个语句
        在配置文件的url里面记性指定
        jdbc:mysql://localhost:3306/mybatis-example?allowMultiQueries=true
    --&gt;
    &lt;update id=&quot;updateBatch&quot;&gt;
        &lt;foreach collection=&quot;list&quot;  item=&quot;employee&quot;&gt;
            update t_emp set emp_name = #&#123;employee.empName&#125; , emp_salary = #&#123;employee.empSalary&#125;
            where emp_id = #&#123;employee.empId&#125;;
        &lt;/foreach&gt;
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre>
<p><strong>sql片段</strong></p>
<p>  <strong>抽取重复的SQL片段</strong></p>
<pre><code class="XML">&lt;!-- 使用sql标签抽取重复出现的SQL片段 --&gt;
&lt;sql id=&quot;mySelectSql&quot;&gt;
    select emp_id,emp_name,emp_age,emp_salary,emp_gender from t_emp
&lt;/sql&gt;
</code></pre>
<p>  引用已抽取的SQL片段</p>
<pre><code class="XML">&lt;!-- 使用include标签引用声明的SQL片段 --&gt;
&lt;include refid=&quot;mySelectSql&quot;/&gt;
</code></pre>
<p><strong>MyBatis的高级扩展</strong></p>
<h3 id="5-1-Mapper批量映射优化"><a href="#5-1-Mapper批量映射优化" class="headerlink" title="5.1 Mapper批量映射优化"></a>5.1 Mapper批量映射优化</h3><ol>
<li><p>需求</p>
<p> Mapper 配置文件很多时，在全局配置文件中一个一个注册太麻烦，希望有一个办法能够一劳永逸。</p>
</li>
<li><p>配置方式</p>
<p> Mybatis 允许在指定 Mapper 映射文件时，只指定其所在的包</p>
</li>
</ol>
<pre><code class="XML">&lt;mappers&gt;
    &lt;package name=&quot;com.atguigu.mapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<pre><code>  此时这个包下的所有 Mapper 配置文件将被自动加载、注册，比较方便。
</code></pre>
<ol start="3">
<li>资源创建要求</li>
</ol>
<ul>
<li>Mapper 接口和 Mapper 配置文件名称一致<ul>
<li>Mapper 接口：EmployeeMapper.java</li>
<li>Mapper 配置文件：EmployeeMapper.xml</li>
</ul>
</li>
<li>Mapper 配置文件放在 Mapper 接口所在的包内<ul>
<li><p>可以将mapperxml文件放在mapper接口所在的包！</p>
</li>
<li><p>可以在sources下创建mapper接口包一致的文件夹结构存放mapperxml文件</p>
<p>  <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<p>  <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
</li>
</ul>
</li>
</ul>
<p><strong>插件机制和分页插件PageHelper</strong></p>
<p><strong>插件机制和PageHelper插件介绍</strong></p>
<p>  MyBatis 对插件进行了标准化的设计，并提供了一套可扩展的插件机制。插件可以在用于语句执行过程中进行拦截，并允许通过自定义处理程序来拦截和修改 SQL 语句、映射语句的结果等。</p>
<p>  具体来说，MyBatis 的插件机制包括以下三个组件：</p>
<ol>
<li><code>Interceptor</code>（拦截器）：定义一个拦截方法 <code>intercept</code>，该方法在执行 SQL 语句、执行查询、查询结果的映射时会被调用。</li>
<li><code>Invocation</code>（调用）：实际上是对被拦截的方法的封装，封装了 <code>Object target</code>、<code>Method method</code> 和 <code>Object[] args</code> 这三个字段。</li>
<li><code>InterceptorChain</code>（拦截器链）：对所有的拦截器进行管理，包括将所有的 Interceptor 链接成一条链，并在执行 SQL 语句时按顺序调用。</li>
</ol>
<p>  插件的开发非常简单，只需要实现 Interceptor 接口，并使用注解 <code>@Intercepts</code> 来标注需要拦截的对象和方法，然后在 MyBatis 的配置文件中添加插件即可。</p>
<p>  PageHelper 是 MyBatis 中比较著名的分页插件，它提供了多种分页方式（例如 MySQL 和 Oracle 分页方式），支持多种数据库，并且使用非常简单。下面就介绍一下 PageHelper 的使用方式。</p>
<p>  <a target="_blank" rel="noopener" href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%B9%E8%A8%80">https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md#如何配置数据库方言</a></p>
<p><strong>分页插件的使用</strong></p>
<ol>
<li>pom.xml引入依赖</li>
</ol>
<pre><code class="XML">&lt;dependency&gt;
    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
    &lt;version&gt;5.1.11&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li><p>mybatis-config.xml配置分页插件</p>
<p> 在 MyBatis 的配置文件中添加 PageHelper 的插件：</p>
</li>
</ol>
<pre><code class="XML">&lt;plugins&gt;
    &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;
        &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>
<pre><code>其中，`com.github.pagehelper.PageInterceptor` 是 PageHelper 插件的名称，`dialect` 属性用于指定数据库类型（支持多种数据库）
</code></pre>
<ol start="3">
<li><p>页插件使用</p>
<p> 在查询方法中使用分页：</p>
</li>
</ol>
<pre><code class="Java">@Test
public void testTeacherRelationshipToMulti() &#123;

    TeacherMapper teacherMapper = session.getMapper(TeacherMapper.class);

    PageHelper.startPage(1,2);
    // 查询Customer对象同时将关联的Order集合查询出来
    List&lt;Teacher&gt; allTeachers = teacherMapper.findAllTeachers();
//
    PageInfo&lt;Teacher&gt; pageInfo = new PageInfo&lt;&gt;(allTeachers);

    System.out.println(&quot;pageInfo = &quot; + pageInfo);
    long total = pageInfo.getTotal(); // 获取总记录数
    System.out.println(&quot;total = &quot; + total);
    int pages = pageInfo.getPages();  // 获取总页数
    System.out.println(&quot;pages = &quot; + pages);
    int pageNum = pageInfo.getPageNum(); // 获取当前页码
    System.out.println(&quot;pageNum = &quot; + pageNum);
    int pageSize = pageInfo.getPageSize(); // 获取每页显示记录数
    System.out.println(&quot;pageSize = &quot; + pageSize);
    List&lt;Teacher&gt; teachers = pageInfo.getList(); //获取查询页的数据集合
    System.out.println(&quot;teachers = &quot; + teachers);
    teachers.forEach(System.out::println);

&#125;
</code></pre>
<p> <strong>逆向工程和MybatisX插件</strong></p>
<p><strong>ORM思维介绍</strong></p>
<p>  ORM（Object-Relational Mapping，对象-关系映射）是一种将数据库和面向对象编程语言中的对象之间进行转换的技术。它将对象和关系数据库的概念进行映射，最后我们就可以通过方法调用进行数据库操作!!</p>
<p>  最终: <strong>让我们可以使用面向对象思维进行数据库操作！！！</strong></p>
<p>  <strong>ORM 框架通常有半自动和全自动两种方式。</strong></p>
<ul>
<li>半自动 ORM 通常需要程序员手动编写 SQL 语句或者配置文件，将实体类和数据表进行映射，还需要手动将查询的结果集转换成实体对象。</li>
<li>全自动 ORM 则是将实体类和数据表进行自动映射，使用 API 进行数据库操作时，ORM 框架会自动执行 SQL 语句并将查询结果转换成实体对象，程序员无需再手动编写 SQL 语句和转换代码。</li>
</ul>
<p>  <strong>下面是半自动和全自动 ORM 框架的区别：</strong></p>
<ol>
<li>映射方式：半自动 ORM 框架需要程序员手动指定实体类和数据表之间的映射关系，通常使用 XML 文件或注解方式来指定；全自动 ORM 框架则可以自动进行实体类和数据表的映射，无需手动干预。</li>
<li>查询方式：半自动 ORM 框架通常需要程序员手动编写 SQL 语句并将查询结果集转换成实体对象；全自动 ORM 框架可以自动组装 SQL 语句、执行查询操作，并将查询结果转换成实体对象。</li>
<li>性能：由于半自动 ORM 框架需要手动编写 SQL 语句，因此程序员必须对 SQL 语句和数据库的底层知识有一定的了解，才能编写高效的 SQL 语句；而全自动 ORM 框架通过自动优化生成的 SQL 语句来提高性能，程序员无需进行优化。</li>
<li>学习成本：半自动 ORM 框架需要程序员手动编写 SQL 语句和映射配置，要求程序员具备较高的数据库和 SQL 知识；全自动 ORM 框架可以自动生成 SQL 语句和映射配置，程序员无需了解过多的数据库和 SQL 知识。</li>
</ol>
<p>  常见的半自动 ORM 框架包括 MyBatis 等；常见的全自动 ORM 框架包括 Hibernate、Spring Data JPA、MyBatis-Plus 等。</p>
<p><strong>逆向工程</strong></p>
<pre><code>  MyBatis 的逆向工程是一种自动化生成持久层代码和映射文件的工具，它可以根据数据库表结构和设置的参数生成对应的实体类、Mapper.xml 文件、Mapper 接口等代码文件，简化了开发者手动生成的过程。逆向工程使开发者可以快速地构建起 DAO 层，并快速上手进行业务开发。
</code></pre>
<p>   MyBatis 的逆向工程有两种方式：通过 MyBatis Generator 插件实现和通过 Maven 插件实现。无论是哪种方式，逆向工程一般需要指定一些配置参数，例如数据库连接 URL、用户名、密码、要生成的表名、生成的文件路径等等。<br>   总的来说，MyBatis 的逆向工程为程序员提供了一种方便快捷的方式，能够快速地生成持久层代码和映射文件，是半自动 ORM 思维像全自动发展的过程，提高程序员的开发效率。</p>
<p>  <strong>注意：逆向工程只能生成单表crud的操作，多表查询依然需要我们自己编写！</strong></p>
<p><strong>逆向工程插件MyBatisX使用</strong></p>
<pre><code> MyBatisX 是一个 MyBatis 的代码生成插件，可以通过简单的配置和操作快速生成 MyBatis Mapper、pojo 类和 Mapper.xml 文件。下面是使用 MyBatisX 插件实现逆向工程的步骤：
</code></pre>
<ol>
<li><p>安装插件：</p>
<p> 在 IntelliJ IDEA 中打开插件市场，搜索 MyBatisX 并安装。</p>
</li>
<li><p>使用 IntelliJ IDEA连接数据库</p>
<ul>
<li><p>连接数据库</p>
<p>  <img src="https://secure2.wostatic.cn/static/suwzNwsHMPdWwco8fMRTai/image.png?auth_key=1714194294-vsXaRtoFCYY2ni4Ya8SZdt-0-c246044602e8632f3a718fdb1a48ade6"></p>
</li>
<li><p>填写信息</p>
<p>  <img src="https://secure2.wostatic.cn/static/qEua8K6S4s7wFd9YZ4Xbcm/image.png?auth_key=1714194294-kYMHwHW6SF6jxmAQj5MW1m-0-3b80b3a83bb026e560048aba7e2af2f4"></p>
</li>
<li><p>展示库表</p>
<p>  <img src="https://secure2.wostatic.cn/static/kUoGo2UYu5JNLf3BnxZWXL/image.png?auth_key=1714194294-qzjPGhJG5tB3vtQ4bDDnA3-0-36f0fa0b2b44a669cdb729fd1c9e9171"></p>
</li>
<li><p>逆向工程使用</p>
<p>  <img src="https://secure2.wostatic.cn/static/s6LMYQtxCLAQ86ScJS5Kam/image.png?auth_key=1714194294-m1KJ2goYR1ZYA4AVUL2rzG-0-e450f4f3dbceed41734de6e9c9f65e3f"></p>
<p>  <img src="https://secure2.wostatic.cn/static/nt2dnyzG5K9NkQBpb1BJ2E/image.png?auth_key=1714194294-hqfsmCQNJxj2azZUTrQTKP-0-e9fd433e20a7856fea35193da92676c1"></p>
<p>  <img src="https://secure2.wostatic.cn/static/5x6sMk4hWDScuAifL2HuJX/image.png?auth_key=1714194294-5BwYAce3YtzUCRT7CcGrhZ-0-68241163a5807411ab6d0d1e626b4f73"></p>
</li>
</ul>
</li>
<li><p>查看生成结果</p>
<p> <img src="https://secure2.wostatic.cn/static/59Kv1MuiUawH6qVWQSV1Z1/image.png?auth_key=1714194294-7aEYj6ouFkj2prtzWJ9Y1B-0-2ed1217fb7a9bfa0d0cfba1449b52135"></p>
</li>
<li><p>逆向工程案例使用</p>
<p> 正常使用即可，自动生成单表的crud方法！</p>
</li>
</ol>
<pre><code class="Java">package com.atguigu.mapper;

import com.atguigu.pojo.User;

/**
* @author Jackiechan
* @description 针对表【user】的数据库操作Mapper
* @createDate 2023-06-02 16:55:32
* @Entity com.atguigu.pojo.User
*/
public interface UserMapper &#123;

    int deleteByPrimaryKey(Long id);

    int insert(User record);

    int insertSelective(User record);

    User selectByPrimaryKey(Long id);

    int updateByPrimaryKeySelective(User record);

    int updateByPrimaryKey(User record);

&#125;
</code></pre>
<p><strong>SpringMVC框架：构建高效表述层框架</strong></p>
<p><strong>简介和介绍</strong></p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/web/webmvc.html">https://docs.spring.io/spring-framework/reference/web/webmvc.html</a></p>
<p>Spring Web MVC是基于Servlet API构建的原始Web框架，从一开始就包含在Spring Framework中。正式名称“Spring Web MVC”来自其源模块的名称（ <code>spring-webmvc</code> ），但它通常被称为“Spring MVC”。</p>
<p>在控制层框架历经Strust、WebWork、Strust2等诸多产品的历代更迭之后，目前业界普遍选择了SpringMVC作为Java EE项目表述层开发的<strong>首选方案</strong>。之所以能做到这一点，是因为SpringMVC具备如下显著优势：</p>
<ul>
<li><strong>Spring 家族原生产品</strong>，与IOC容器等基础设施无缝对接</li>
<li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong></li>
<li><strong>代码清新简洁</strong>，大幅度提升开发效率</li>
<li>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可</li>
<li><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求</li>
</ul>
<p>原生Servlet API开发代码片段</p>
<pre><code class="Java">protected void doGet(HttpServletRequest request, HttpServletResponse response) 
                                                        throws ServletException, IOException &#123;  
    String userName = request.getParameter(&quot;userName&quot;);
    
    System.out.println(&quot;userName=&quot;+userName);
&#125;
</code></pre>
<p>基于SpringMVC开发代码片段</p>
<pre><code class="Java">@RequestMapping(&quot;/user/login&quot;)
public String login(@RequestParam(&quot;userName&quot;) String userName,Sting password)&#123;
    
    log.debug(&quot;userName=&quot;+userName);
    //调用业务即可
    
    return &quot;result&quot;;
&#125;
</code></pre>
<p><strong>主要的作用</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<p>SSM框架构建起单体项目的技术栈需求！其中的SpringMVC负责表述层（控制层）实现简化！</p>
<p>SpringMVC的作用主要覆盖的是表述层，例如：</p>
<ul>
<li>请求映射</li>
<li>数据输入</li>
<li>视图界面</li>
<li>请求分发</li>
<li>表单回显</li>
<li>会话控制</li>
<li>过滤拦截</li>
<li>异步交互</li>
<li>文件上传</li>
<li>文件下载</li>
<li>数据校验</li>
<li>类型转换</li>
<li>等等等</li>
</ul>
<p><strong>最终总结：</strong></p>
<ol>
<li>简化前端参数接收( 形参列表 )</li>
<li>简化后端数据响应(返回值)</li>
<li>以及其他……</li>
</ol>
<p><strong>核心组价和和调用流程理解</strong></p>
<p>Spring MVC与许多其他Web框架一样，是围绕前端控制器模式设计的，其中中央 <code>Servlet</code>  <code>DispatcherServlet</code> 做整体请求处理调度！</p>
<p>除了<code>DispatcherServlet</code>SpringMVC还会提供其他特殊的组件协作完成请求处理和响应呈现。</p>
<p><strong>SpringMVC处理请求流程：</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<p><strong>SpringMVC涉及组件理解：</strong></p>
<ol>
<li>DispatcherServlet :  SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发！[ CEO ]</li>
<li>HandlerMapping :  SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler！[秘书]</li>
<li>HandlerAdapter : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器！[经理]</li>
<li>Handler : handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果！[打工人]</li>
<li>ViewResovler : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的！[财务]</li>
</ol>
<p><strong>快速体验</strong></p>
<p>简单的实现</p>
<p>controller层</p>
<pre><code class="java">package com.chenw.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class HelloController &#123;

    //handlers

    /**
     * handler就是controller内部的具体方法
     * @RequestMapping(&quot;/springmvc/hello&quot;) 就是用来向handlerMapping中注册的方法注解!
     * @ResponseBody 代表向浏览器直接返回数据!不要找视图解析器
     */
    @RequestMapping(&quot;/springmvc/hello&quot;)
    @ResponseBody
    public String hello()&#123;
        System.out.println(&quot;HelloController.hello&quot;);
        return &quot;hello springmvc!!&quot;;
    &#125;
&#125;
</code></pre>
<p>配置MvcConfig</p>
<pre><code class="java">package com.chenw.config;


import org.springframework.beans.factory.annotation.Configurable;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;

/*
*   TODO:1.cotroller配置到ioc容器
*          2，handlerMapping handlerAdapter加入到ioc容器
* */
@Configurable
@ComponentScan(&quot;com.chenw.controller&quot;)
public class MvcConfig &#123;
    @Bean
    public RequestMappingHandlerMapping requestMappingHandlerMapping()&#123;
        return new RequestMappingHandlerMapping();
    &#125;
    @Bean
    public RequestMappingHandlerAdapter requestMappingHandlerAdapter()&#123;
        return new RequestMappingHandlerAdapter();
        
    &#125;
&#125;
</code></pre>
<p>初始化配置文件 </p>
<pre><code class="java">package com.chenw.config;

import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

/*
*   可以被web项目加载，初始化ioc容器，会设置dispatcherServlet的地址
* */
public class SpringMvcInit extends AbstractAnnotationConfigDispatcherServletInitializer &#123;
    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;
        return new Class[0];
    &#125;

    /*
    *   用来设置项目的配置类
    * */
    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;
        return new Class[]&#123;MvcConfig.class&#125;;
    &#125;
    /*
    * 用于配置springmvc内部自带的servlet的访问地址,因为要拦截所有的地址，所以使用/
    * */
    @Override
    protected String[] getServletMappings() &#123;
        return new String[]&#123;&quot;/&quot;&#125;;
    &#125;
&#125;
</code></pre>
<ol>
<li><p>体验场景需求</p>
<p> <img src="https://secure2.wostatic.cn/static/qgxZRg9rZ6DFA7t8guNqYn/image.png?auth_key=1714201059-6QXr2BHewFu35Zo2xJRnkj-0-ea3a869f91f76f81d9c2327eca2f31db"></p>
</li>
<li><p>配置分析</p>
<ol>
<li>DispatcherServlet，设置处理所有请求！</li>
<li>HandlerMapping,HandlerAdapter,Handler需要加入到IoC容器，供DS调用！</li>
<li>Handler自己声明（Controller）需要配置到HandlerMapping中供DS查找！</li>
</ol>
</li>
<li><p>准备项目</p>
<ol>
<li><p>创建项目</p>
<p> springmvc-base-quick</p>
<p> 注意：需要转成maven&#x2F;web程序！！</p>
</li>
<li><p>导入依赖</p>
</li>
</ol>
</li>
</ol>
<pre><code class="XML">&lt;properties&gt;
    &lt;spring.version&gt;6.0.6&lt;/spring.version&gt;
    &lt;servlet.api&gt;9.1.0&lt;/servlet.api&gt;
    &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;!-- springioc相关依赖  --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- web相关依赖  --&gt;
    &lt;!-- 在 pom.xml 中引入 Jakarta EE Web API 的依赖 --&gt;
    &lt;!--
        在 Spring Web MVC 6 中，Servlet API 迁移到了 Jakarta EE API，因此在配置 DispatcherServlet 时需要使用
         Jakarta EE 提供的相应类库和命名空间。错误信息 “‘org.springframework.web.servlet.DispatcherServlet’
         is not assignable to ‘javax.servlet.Servlet,jakarta.servlet.Servlet’” 表明你使用了旧版本的
         Servlet API，没有更新到 Jakarta EE 规范。
    --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;jakarta.platform&lt;/groupId&gt;
        &lt;artifactId&gt;jakarta.jakartaee-web-api&lt;/artifactId&gt;
        &lt;version&gt;$&#123;servlet.api&#125;&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- springwebmvc相关依赖  --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;

&lt;/dependencies&gt;
</code></pre>
<ol start="4">
<li>Controller声明</li>
</ol>
<pre><code class="Java">@Controller
public class HelloController &#123;

    //handlers

    /**
     * handler就是controller内部的具体方法
     * @RequestMapping(&quot;/springmvc/hello&quot;) 就是用来向handlerMapping中注册的方法注解!
     * @ResponseBody 代表向浏览器直接返回数据!
     */
    @RequestMapping(&quot;/springmvc/hello&quot;)
    @ResponseBody
    public String hello()&#123;
        System.out.println(&quot;HelloController.hello&quot;);
        return &quot;hello springmvc!!&quot;;
    &#125;
&#125;
</code></pre>
<ol start="5">
<li><p>Spring MVC核心组件配置类</p>
<blockquote>
<p>声明springmvc涉及组件信息的配置类</p>
</blockquote>
</li>
</ol>
<pre><code class="Java">//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]

//TODO: 导入handlerMapping和handlerAdapter的三种方式
 //1.自动导入handlerMapping和handlerAdapter [推荐]
 //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载
 //3.使用@Bean方式配置handlerMapper和handlerAdapter
@EnableWebMvc     
@Configuration
@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫
//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现
public class SpringMvcConfig implements WebMvcConfigurer &#123;

    @Bean
    public HandlerMapping handlerMapping()&#123;
        return new RequestMappingHandlerMapping();
    &#125;

    @Bean
    public HandlerAdapter handlerAdapter()&#123;
        return new RequestMappingHandlerAdapter();
    &#125;
    
&#125;
</code></pre>
<ol start="6">
<li><p>SpringMVC环境搭建</p>
<blockquote>
<p>对于使用基于 Java 的 Spring 配置的应用程序，建议这样做，如以下示例所示：</p>
</blockquote>
</li>
</ol>
<pre><code class="Java">//TODO: SpringMVC提供的接口,是替代web.xml的方案,更方便实现完全注解方式ssm处理!
//TODO: Springmvc框架会自动检查当前类的实现类,会自动加载 getRootConfigClasses / getServletConfigClasses 提供的配置类
//TODO: getServletMappings 返回的地址 设置DispatherServlet对应处理的地址
public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;

  /**
   * 指定service / mapper层的配置类
   */
  @Override
  protected Class&lt;?&gt;[] getRootConfigClasses() &#123;
    return null;
  &#125;

  /**
   * 指定springmvc的配置类
   * @return
   */
  @Override
  protected Class&lt;?&gt;[] getServletConfigClasses() &#123;
    return new Class&lt;?&gt;[] &#123; SpringMvcConfig.class &#125;;
  &#125;

  /**
   * 设置dispatcherServlet的处理路径!
   * 一般情况下为 / 代表处理所有请求!
   */
  @Override
  protected String[] getServletMappings() &#123;
    return new String[] &#123; &quot;/&quot; &#125;;
  &#125;
&#125;
</code></pre>
<ol start="7">
<li><p>启动测试</p>
<p> 注意： tomcat应该是10+版本！方可支持 Jakarta EE API!</p>
<p> <img src="https://secure2.wostatic.cn/static/iQSLu8VreeyFX913Ab3QQc/image.png?auth_key=1714201059-o2jkbdd7puKkNXZWcc1ab9-0-253af2820417e080c6e72b952ea38631"></p>
</li>
</ol>
<p><strong>springMVC接收数据</strong></p>
<p><strong>访问路径设置</strong></p>
<p>  @RequestMapping注解的作用就是将请求的 URL 地址和处理请求的方式（handler方法）关联起来，建立映射关系。</p>
<p>  SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的方法来处理这个请求。</p>
<ol>
<li><p><strong>精准路径匹配</strong></p>
<p> 在@RequestMapping注解指定 URL 地址时，不使用任何通配符，按照请求地址进行精确匹配。</p>
</li>
</ol>
<pre><code class="Java">@Controller
public class UserController &#123;

    /**
     * 精准设置访问地址 /user/login
     */
    @RequestMapping(value = &#123;&quot;/user/login&quot;&#125;)
    @ResponseBody
    public String login()&#123;
        System.out.println(&quot;UserController.login&quot;);
        return &quot;login success!!&quot;;
    &#125;

    /**
     * 精准设置访问地址 /user/register
     */
    @RequestMapping(value = &#123;&quot;/user/register&quot;&#125;)
    @ResponseBody
    public String register()&#123;
        System.out.println(&quot;UserController.register&quot;);
        return &quot;register success!!&quot;;
    &#125;
    
&#125;
</code></pre>
<ol start="2">
<li><p><strong>模糊路径匹配</strong></p>
<p> 在@RequestMapping注解指定 URL 地址时，通过使用通配符，匹配多个类似的地址。</p>
</li>
</ol>
<pre><code class="Java">@Controller
public class ProductController &#123;

    /**
     *  路径设置为 /product/*  
     *    /* 为单层任意字符串  /product/a  /product/aaa 可以访问此handler  
     *    /product/a/a 不可以
     *  路径设置为 /product/** 
     *   /** 为任意层任意字符串  /product/a  /product/aaa 可以访问此handler  
     *   /product/a/a 也可以访问
     */
    @RequestMapping(&quot;/product/*&quot;)
    @ResponseBody
    public String show()&#123;
        System.out.println(&quot;ProductController.show&quot;);
        return &quot;product show!&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="text">单层匹配和多层匹配：
  /*：只能匹配URL地址中的一层，如果想准确匹配两层，那么就写“/*/*”以此类推。
  /**：可以匹配URL地址中的多层。
其中所谓的一层或多层是指一个URL地址字符串被“/”划分出来的各个层次
这个知识点虽然对于@RequestMapping注解来说实用性不大，但是将来配置拦截器的时候也遵循这个规则。
</code></pre>
<ol start="3">
<li><p><strong>类和方法级别区别</strong></p>
<p> <code>@RequestMapping</code> 注解可以用于类级别和方法级别，它们之间的区别如下：</p>
<ol>
<li>设置到类级别：<code>@RequestMapping</code> 注解可以设置在控制器类上，用于映射整个控制器的通用请求路径。这样，如果控制器中的多个方法都需要映射同一请求路径，就不需要在每个方法上都添加映射路径。</li>
<li>设置到方法级别：<code>@RequestMapping</code> 注解也可以单独设置在控制器方法上，用于更细粒度地映射请求路径和处理方法。当多个方法处理同一个路径的不同操作时，可以使用方法级别的 <code>@RequestMapping</code> 注解进行更精细的映射。</li>
</ol>
</li>
</ol>
<pre><code class="Java">//1.标记到handler方法
@RequestMapping(&quot;/user/login&quot;)
@RequestMapping(&quot;/user/register&quot;)
@RequestMapping(&quot;/user/logout&quot;)

//2.优化标记类+handler方法
//类上
@RequestMapping(&quot;/user&quot;)
//handler方法上
@RequestMapping(&quot;/login&quot;)
@RequestMapping(&quot;/register&quot;)
@RequestMapping(&quot;/logout&quot;)
</code></pre>
<ol start="4">
<li><p><strong>附带请求方式限制</strong></p>
<p> HTTP 协议定义了八种请求方式，在 SpringMVC 中封装到了下面这个枚举类：</p>
</li>
</ol>
<pre><code class="Java">public enum RequestMethod &#123;
  GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE
&#125;
</code></pre>
<pre><code>  默认情况下：@RequestMapping(&quot;/logout&quot;) 任何请求方式都可以访问！

  如果需要特定指定：
</code></pre>
<pre><code class="Java">@Controller
public class UserController &#123;

    /**
     * 精准设置访问地址 /user/login
     * method = RequestMethod.POST 可以指定单个或者多个请求方式!
     * 注意:违背请求方式会出现405异常!
     */
    @RequestMapping(value = &#123;&quot;/user/login&quot;&#125; , method = RequestMethod.POST)
    @ResponseBody
    public String login()&#123;
        System.out.println(&quot;UserController.login&quot;);
        return &quot;login success!!&quot;;
    &#125;

    /**
     * 精准设置访问地址 /user/register
     */
    @RequestMapping(value = &#123;&quot;/user/register&quot;&#125;,method = &#123;RequestMethod.POST,RequestMethod.GET&#125;)
    @ResponseBody
    public String register()&#123;
        System.out.println(&quot;UserController.register&quot;);
        return &quot;register success!!&quot;;
    &#125;

&#125;
</code></pre>
<pre><code>  注意：违背请求方式，会出现405异常！！！
</code></pre>
<ol start="5">
<li><p><strong>进阶注解</strong></p>
<p> 还有 <code>@RequestMapping</code> 的 HTTP 方法特定快捷方式变体：</p>
<ul>
<li><code>@GetMapping</code></li>
<li><code>@PostMapping</code></li>
<li><code>@PutMapping</code></li>
<li><code>@DeleteMapping</code></li>
<li><code>@PatchMapping</code></li>
</ul>
</li>
</ol>
<pre><code class="Java">@RequestMapping(value=&quot;/login&quot;,method=RequestMethod.GET)
||
@GetMapping(value=&quot;/login&quot;)
</code></pre>
<pre><code>  注意：进阶注解只能添加到handler方法上，无法添加到类上！
</code></pre>
<ol start="6">
<li><p><strong>常见配置问题</strong></p>
<p> 出现原因：多个 handler 方法映射了同一个地址，导致 SpringMVC 在接收到这个地址的请求时该找哪个 handler 方法处理。</p>
<blockquote>
<p>There is already ‘demo03MappingMethodHandler’ bean method com.atguigu.mvc.handler.Demo03MappingMethodHandler#empGet() <strong>mapped</strong>.</p>
</blockquote>
</li>
</ol>
<pre><code class="java">package com.chenw.requestmapping;


import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
/*
*   如果RequestMapping标记在类上面的话
*   默认是路径的开头
* */

/*
*   请求方式
*       默认的情况 @RequestMapping主要地址正确，任何的请求方式都可以访问
*       限制请求方式
*           @RequestMapping(value = &quot;/login&quot;,method = RequestMethod.POST) //   /user/login 指定访问的方法为post
*           如果没有按照规定的请求方式访问就会报405
*           或者使用注解
*           @GetMapping //get请求地址
*           @PostMapping(&quot;/login&quot;)
*
* */
@RequestMapping(&quot;user&quot;)
public class UserController &#123;
    //handler  - HandlerMapping指定访问的地址
    //RequestMapping//作用注册地址 将handler注册到handlerMapping
    /*
    *   之前的@WebServlet(必须以斜线开头)
    *   但是这个的@RequestMapping(用不用斜线开头也是可以的)
    *   多个地址使用数组&#123;“1”，“2”&#125;
    *   模糊匹配 /user/*
    * */
    @RequestMapping(value = &quot;/login&quot;,method = RequestMethod.POST) //   /user/login 指定访问的方法为post
    public String login()&#123;
        return null;
    &#125;


    @RequestMapping(&quot;/register&quot;)//  /user/register
    public String register()&#123;
        return null;
    &#125;


&#125;
</code></pre>
<p><strong>接收参数</strong></p>
<p><strong>param 和 json参数比较</strong></p>
<p>  在 HTTP 请求中，我们可以选择不同的参数类型，如 param 类型和 JSON 类型。下面对这两种参数类型进行区别和对比：</p>
<ol>
<li><p>参数编码：  </p>
<p> param 类型的参数会被编码为 ASCII 码。例如，假设 <code>name=john doe</code>，则会被编码为 <code>name=john%20doe</code>。而 JSON 类型的参数会被编码为 UTF-8。</p>
</li>
<li><p>参数顺序：  </p>
<p> param 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。JSON 采用键值对的形式进行传递，其中键值对是有序排列的。</p>
</li>
<li><p>数据类型：  </p>
<p> param 类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。而 JSON 类型的参数则支持更复杂的数据类型，如数组、对象等。</p>
</li>
<li><p>嵌套性：  </p>
<p> param 类型的参数不支持嵌套。但是，JSON 类型的参数支持嵌套，可以传递更为复杂的数据结构。</p>
</li>
<li><p>可读性：  </p>
<p> param 类型的参数格式比 JSON 类型的参数更加简单、易读。但是，JSON 格式在传递嵌套数据结构时更加清晰易懂。</p>
</li>
</ol>
<p>  总的来说，param 类型的参数适用于单一的数据传递，而 JSON 类型的参数则更适用于更复杂的数据结构传递。根据具体的业务需求，需要选择合适的参数类型。在实际开发中，常见的做法是：在 GET 请求中采用 param 类型的参数，而在 POST 请求中采用 JSON 类型的参数传递。</p>
<p><strong>param参数接收</strong></p>
<ol>
<li><p><strong>直接接值</strong></p>
<p> 客户端请求</p>
<p> <img src="https://secure2.wostatic.cn/static/a3oaA2ZHewign7gd5xUG6D/image.png?auth_key=1714216585-miroK9HECyxKCiV6kdRbvA-0-5ec89183a7b596b2f0553e3d563f622a"></p>
<p> handler接收参数</p>
<p> 只要形参数名和类型与传递参数相同，即可自动接收!</p>
</li>
</ol>
<pre><code class="Java">@Controller
@RequestMapping(&quot;param&quot;)
public class ParamController &#123;

    /**
     * 前端请求: http://localhost:8080/param/value?name=xx&amp;age=18
     *
     * 可以利用形参列表,直接接收前端传递的param参数!
     *    要求: 参数名 = 形参名
     *          类型相同
     * 出现乱码正常，json接收具体解决！！
     * @return 返回前端数据
     */
    @GetMapping(value=&quot;/value&quot;)
    @ResponseBody
    public String setupForm(String name,int age)&#123;
        System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age);
        return name + age;
    &#125;
&#125;
</code></pre>
<ol start="2">
<li><p><strong>@RequestParam注解</strong></p>
<p> 可以使用 <code>@RequestParam</code> 注释将 Servlet 请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。</p>
<p> <code>@RequestParam</code>使用场景：</p>
<ul>
<li>指定绑定的请求参数名</li>
<li>要求请求参数必须传递</li>
<li>为请求参数提供默认值</li>
</ul>
<p> 基本用法：</p>
</li>
</ol>
<pre><code class="Java"> /**
 * 前端请求: http://localhost:8080/param/data?name=xx&amp;stuAge=18
 * 
 *  使用@RequestParam注解标记handler方法的形参
 *  指定形参对应的请求参数@RequestParam(请求参数名称)
 */
@GetMapping(value=&quot;/data&quot;)
@ResponseBody
public Object paramForm(@RequestParam(&quot;name&quot;) String name, 
                        @RequestParam(&quot;stuAge&quot;) int age)&#123;
    System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age);
    return name+age;
&#125;
</code></pre>
<pre><code>  默认情况下，使用此批注的方法参数是必需的，但您可以通过将 `@RequestParam` 批注的 `required` 标志设置为 `false`！

  如果没有没有设置非必须，也没有传递参数会出现：

  ![](https://secure2.wostatic.cn/static/rdbdJyYUSsMtSsANx5icFq/image.png?auth_key=1714216585-rCAQuhrNgFnXMG4mjxKxYx-0-4db2282364a2c3286aa3d53960c9bebf)

  将参数设置非必须，并且设置默认值：
</code></pre>
<pre><code class="Java">@GetMapping(value=&quot;/data&quot;)
@ResponseBody
public Object paramForm(@RequestParam(&quot;name&quot;) String name, 
                        @RequestParam(value = &quot;stuAge&quot;,required = false,defaultValue = &quot;18&quot;) int age)&#123;
    System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age);
    return name+age;
&#125;
</code></pre>
<ol start="3">
<li><strong>特殊场景接值</strong><ol>
<li><p>一名多值</p>
<p> 多选框，提交的数据的时候一个key对应多个值，我们可以使用集合进行接收！</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">  /**
   * 前端请求: http://localhost:8080/param/mul?hbs=吃&amp;hbs=喝
   *
   *  一名多值,可以使用集合接收即可!但是需要使用@RequestParam注解指定注意这里面一定需要加入@RequestParam的注解，没有注解的话，就会直接把?hbs=吃&amp;hbs=喝赋值给hbs，加入注解以后才会使用add方法加入到集合的里面
   */
  @GetMapping(value=&quot;/mul&quot;)
  @ResponseBody
  public Object mulForm(@RequestParam List&lt;String&gt; hbs)&#123;
      System.out.println(&quot;hbs = &quot; + hbs);
      return hbs;
  &#125;
</code></pre>
<pre><code>  2. 实体接收

      Spring MVC 是 Spring 框架提供的 Web 框架，它允许开发者使用实体对象来接收 HTTP 请求中的参数。通过这种方式，可以在方法内部直接使用对象的属性来访问请求参数，而不需要每个参数都写一遍。下面是一个使用实体对象接收参数的示例：

      定义一个用于接收参数的实体类：
</code></pre>
<pre><code class="Java">public class User &#123;

  private String name;

  private int age = 18;

  // getter 和 setter 略
&#125;

注意实体类的里面必须有get和set方法
</code></pre>
<pre><code>      在控制器中，使用实体对象接收，示例代码如下：
</code></pre>
<pre><code class="Java">@Controller
@RequestMapping(&quot;param&quot;)
public class ParamController &#123;

    @RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)
    @ResponseBody
    public String addUser(User user) &#123;
        // 在这里可以使用 user 对象的属性来接收请求参数
        System.out.println(&quot;user = &quot; + user);
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
<pre><code>      在上述代码中，将请求参数name和age映射到实体类属性上！要求属性名必须等于参数名！否则无法映射！

      使用postman传递参数测试
</code></pre>
<p><strong>路径传参接收参数</strong></p>
<pre><code>之前的的传参
是/param/data?name=hututu&amp;age=18
现在的路径传参
是/param/data/hututu/age
</code></pre>
<p>路径传递参数是一种在 URL 路径中传递参数的方式。在 RESTful 的 Web 应用程序中，经常使用路径传递参数来表示资源的唯一标识符或更复杂的表示方式。而 Spring MVC 框架提供了 <code>@PathVariable</code> 注解来处理路径传递参数。</p>
<p><code>@PathVariable</code> 注解允许将 URL 中的占位符映射到控制器方法中的参数。</p>
<p>例如，如果我们想将 <code>/user/&#123;id&#125;</code> 路径下的 <code>&#123;id&#125;</code> 映射到控制器方法的一个参数中，则可以使用 <code>@PathVariable</code> 注解来实现。</p>
<p>下面是一个使用 <code>@PathVariable</code> 注解处理路径传递参数的示例：</p>
<pre><code class="Java"> /**
 * 动态路径设计: /user/&#123;动态部分&#125;/&#123;动态部分&#125;   动态部分使用&#123;&#125;包含即可! &#123;&#125;内部动态标识!
 * 形参列表取值: @PathVariable Long id  如果形参名 = &#123;动态标识&#125; 自动赋值!
 *              @PathVariable(&quot;动态标识&quot;) Long id  如果形参名 != &#123;动态标识&#125; 可以通过指定动态标识赋值!
 *
 * 访问测试:  /param/user/1/root  -&gt; id = 1  uname = root
 */
@GetMapping(&quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)
@ResponseBody
public String getUser(@PathVariable Long id, 
                      @PathVariable(&quot;name&quot;) String uname) &#123;
    System.out.println(&quot;id = &quot; + id + &quot;, uname = &quot; + uname);
    return &quot;user_detail&quot;;
&#125;
</code></pre>
<p><strong>json 数据的接收</strong></p>
<p>前端传递 JSON 数据时，Spring MVC 框架可以使用 <code>@RequestBody</code> 注解来将 JSON 数据转换为 Java 对象。<code>@RequestBody</code> 注解表示当前方法参数的值应该从请求体中获取，并且需要指定 value 属性来指示请求体应该映射到哪个参数上。其使用方式和示例代码如下：</p>
<ol>
<li>前端发送 JSON 数据的示例：（使用postman测试）</li>
</ol>
<pre><code class="JSON">&#123;
  &quot;name&quot;: &quot;张三&quot;,
  &quot;age&quot;: 18,
  &quot;gender&quot;: &quot;男&quot;
&#125;
</code></pre>
<ol start="2">
<li>定义一个用于接收 JSON 数据的 Java 类，例如：</li>
</ol>
<pre><code class="Java">public class Person &#123;
  private String name;
  private int age;
  private String gender;
  // getter 和 setter 略
&#125;
</code></pre>
<ol start="3">
<li>在控制器中，使用 <code>@RequestBody</code> 注解来接收 JSON 数据，并将其转换为 Java 对象，例如：</li>
</ol>
<pre><code class="Java">@PostMapping(&quot;/person&quot;)
@ResponseBody
public String addPerson(@RequestBody Person person) &#123;

  // 在这里可以使用 person 对象来操作 JSON 数据中包含的属性
  return &quot;success&quot;;
&#125;
</code></pre>
<pre><code>在上述代码中，`@RequestBody` 注解将请求体中的 JSON 数据映射到 `Person` 类型的 `person` 参数上，并将其作为一个对象来传递给 `addPerson()` 方法进行处理。
</code></pre>
<ol start="4">
<li><p>完善配置</p>
<p> 测试：</p>
<p>   <img src="https://secure2.wostatic.cn/static/jGHVNLJs2adytDeM5VG7Kk/image.png?auth_key=1714283283-2Jgnp4FfFo2U7gcNU7Swx2-0-32e01a11e34fdb0478a4d6bc7560af34"></p>
<p> 问题：</p>
<p>   org.springframework.web.HttpMediaTypeNotSupportedException: Content-Type ‘application&#x2F;json;charset&#x3D;UTF-8’ is not supported]</p>
<p>   <img src="https://secure2.wostatic.cn/static/tojUpG6VkVj5XG41zqA7XU/image.png?auth_key=1714283283-pP552EZjE8ZugoBNZDzwrM-0-68a36a54cd918f1d5ea26fd95ca7d40c"></p>
<p> 原因：</p>
<ul>
<li>不支持json数据类型处理</li>
<li>没有json类型处理的工具（jackson）</li>
</ul>
<p> 解决：</p>
<p> springmvc handlerAdpater配置json转化器,配置类需要明确：</p>
</li>
</ol>
<pre><code class="Java">//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]

//TODO: 导入handlerMapping和handlerAdapter的三种方式
 //1.自动导入handlerMapping和handlerAdapter [推荐]
 //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载
 //3.使用@Bean方式配置handlerMapper和handlerAdapter
@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器
@Configuration
@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描

//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现
public class SpringMvcConfig implements WebMvcConfigurer &#123;


&#125;
</code></pre>
<pre><code>pom.xml 加入jackson依赖
</code></pre>
<pre><code class="XML">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.15.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="5">
<li><p>@EnableWebMvc注解说明</p>
<p> @EnableWebMvc注解效果等同于在 XML 配置中，可以使用 <code>&lt;mvc:annotation-driven&gt;</code> 元素！我们来解析<code>&lt;mvc:annotation-driven&gt;</code>对应的解析工作！</p>
<p> 让我们来查看下<code>&lt;mvc:annotation-driven&gt;</code>具体的动作！</p>
<ul>
<li><p>先查看<code>&lt;mvc:annotation-driven&gt;</code>标签最终对应解析的Java类</p>
<p>  <img src="https://secure2.wostatic.cn/static/8WWABqUcDmjVia69uGVyNY/image.png?auth_key=1714283283-5pYbjZDDCSFk3h6HruzBdz-0-130f235e0d5046b71f96f7eff65dec96"></p>
</li>
<li><p>查看解析类中具体的动作即可</p>
<p>  打开源码：org.springframework.web.servlet.config.MvcNamespaceHandler</p>
<p>  <img src="https://secure2.wostatic.cn/static/pyTLTV8syHWz4hGCm25CFb/image.png?auth_key=1714283283-u6c9us66gaDVwPPtreWMpn-0-df4c9577071135cc84687f0d3c88450a"></p>
<p>  打开源码：org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser</p>
</li>
</ul>
</li>
</ol>
<pre><code class="Java">class AnnotationDrivenBeanDefinitionParser implements BeanDefinitionParser &#123;

  public static final String HANDLER_MAPPING_BEAN_NAME = RequestMappingHandlerMapping.class.getName();

  public static final String HANDLER_ADAPTER_BEAN_NAME = RequestMappingHandlerAdapter.class.getName();

  static &#123;
    ClassLoader classLoader = AnnotationDrivenBeanDefinitionParser.class.getClassLoader();
    javaxValidationPresent = ClassUtils.isPresent(&quot;jakarta.validation.Validator&quot;, classLoader);
    romePresent = ClassUtils.isPresent(&quot;com.rometools.rome.feed.WireFeed&quot;, classLoader);
    jaxb2Present = ClassUtils.isPresent(&quot;jakarta.xml.bind.Binder&quot;, classLoader);
    jackson2Present = ClassUtils.isPresent(&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;, classLoader) &amp;&amp;
            ClassUtils.isPresent(&quot;com.fasterxml.jackson.core.JsonGenerator&quot;, classLoader);
    jackson2XmlPresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;, classLoader);
    jackson2SmilePresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.smile.SmileFactory&quot;, classLoader);
    jackson2CborPresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.cbor.CBORFactory&quot;, classLoader);
    gsonPresent = ClassUtils.isPresent(&quot;com.google.gson.Gson&quot;, classLoader);
  &#125;


  @Override
  @Nullable
  public BeanDefinition parse(Element element, ParserContext context) &#123;
    //handlerMapping加入到ioc容器
    readerContext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME, handlerMappingDef);

    //添加jackson转化器
    addRequestBodyAdvice(handlerAdapterDef);
    addResponseBodyAdvice(handlerAdapterDef);

    //handlerAdapter加入到ioc容器
    readerContext.getRegistry().registerBeanDefinition(HANDLER_ADAPTER_BEAN_NAME, handlerAdapterDef);
    return null;
  &#125;

  //具体添加jackson转化对象方法
  protected void addRequestBodyAdvice(RootBeanDefinition beanDef) &#123;
    if (jackson2Present) &#123;
      beanDef.getPropertyValues().add(&quot;requestBodyAdvice&quot;,
          new RootBeanDefinition(JsonViewRequestBodyAdvice.class));
    &#125;
  &#125;

  protected void addResponseBodyAdvice(RootBeanDefinition beanDef) &#123;
    if (jackson2Present) &#123;
      beanDef.getPropertyValues().add(&quot;responseBodyAdvice&quot;,
          new RootBeanDefinition(JsonViewResponseBodyAdvice.class));
    &#125;
  &#125;
</code></pre>
<p>注意试验好几次还是415需要把配置里面的@Bean里面都要注上</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240428141659265.png" alt="image-20240428141659265"></p>
<pre><code>因为这个注解@EnableWebMvc
就会添加RequestMappingHandlerMapping和RequestMappinghandlerAdapter，还会添加json解析器
</code></pre>
<p><strong>接收cookie数据</strong></p>
<p>可以使用 <code>@CookieValue</code> 注释将 HTTP Cookie 的值绑定到控制器中的方法参数。</p>
<p>考虑使用以下 cookie 的请求：</p>
<pre><code class="Java">JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84
</code></pre>
<p>下面的示例演示如何获取 cookie 值：</p>
<pre><code class="Java">@GetMapping(&quot;/demo&quot;)
public void handle(@CookieValue(&quot;JSESSIONID&quot;) String cookie) &#123; 
  //...
&#125;
</code></pre>
<p>cookie的设置和获取例如</p>
<pre><code class="java">package com.chenw.cookie;


import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.CookieValue;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;


@Controller
@RequestMapping(&quot;cookie&quot;)
@ResponseBody
public class CookieController &#123;

    @RequestMapping(&quot;data&quot;)
    public String data(@CookieValue(&quot;cookieName&quot;) String value)&#123;
        System.out.println(value);
        return value;
    &#125;

    @GetMapping(&quot;save&quot;)
    public String  save(HttpServletResponse response)&#123;
        Cookie cookie = new Cookie(&quot;cookieName&quot;, &quot;root&quot;);
        response.addCookie(cookie);;
        return &quot;ok&quot;;    
    &#125;
&#125;
</code></pre>
<p><strong>接收请求头的数据</strong></p>
<pre><code>使用注解@RequestHeader注解
</code></pre>
<pre><code class="java">package com.chenw.header;


import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@RequestMapping(&quot;header&quot;)
@ResponseBody
public class HeaderController &#123;
    @RequestMapping(&quot;data&quot;)
    public String data(@RequestHeader(&quot;Host&quot;) String host)&#123;
        System.out.println(host);
        return &quot;host=&quot;+host;
    &#125;
&#125;
</code></pre>
<p>可以使用 <code>@RequestHeader</code> 批注将请求标头绑定到控制器中的方法参数。</p>
<p>请考虑以下带有标头的请求：</p>
<pre><code class="Java">Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300
</code></pre>
<p>下面的示例获取 <code>Accept-Encoding</code> 和 <code>Keep-Alive</code> 标头的值：</p>
<pre><code class="Java">@GetMapping(&quot;/demo&quot;)
public void handle(
    @RequestHeader(&quot;Accept-Encoding&quot;) String encoding, 
    @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) &#123; 
  //...
&#125;
</code></pre>
<p><strong>原生api的使用</strong></p>
<pre><code>这些原生的参数可以直接在形参的列表声明，而且没有先后的顺序
</code></pre>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html">https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html</a></p>
<p>下表描述了支持的控制器方法参数</p>
<table>
<thead>
<tr>
<th>Controller method argument 控制器方法参数</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>jakarta.servlet.ServletRequest</code>, <code>jakarta.servlet.ServletResponse</code></td>
<td>请求&#x2F;响应对象</td>
</tr>
<tr>
<td><code>jakarta.servlet.http.HttpSession</code></td>
<td>强制存在会话。因此，这样的参数永远不会为 <code>null</code> 。</td>
</tr>
<tr>
<td><code>java.io.InputStream</code>, <code>java.io.Reader</code></td>
<td>用于访问由 Servlet API 公开的原始请求正文。</td>
</tr>
<tr>
<td><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td>
<td>用于访问由 Servlet API 公开的原始响应正文。</td>
</tr>
<tr>
<td><code>@PathVariable</code></td>
<td>接收路径参数注解</td>
</tr>
<tr>
<td><code>@RequestParam</code></td>
<td>用于访问 Servlet 请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。</td>
</tr>
<tr>
<td><code>@RequestHeader</code></td>
<td>用于访问请求标头。标头值将转换为声明的方法参数类型。</td>
</tr>
<tr>
<td><code>@CookieValue</code></td>
<td>用于访问Cookie。Cookie 值将转换为声明的方法参数类型。</td>
</tr>
<tr>
<td><code>@RequestBody</code></td>
<td>用于访问 HTTP 请求正文。正文内容通过使用 <code>HttpMessageConverter</code> 实现转换为声明的方法参数类型。</td>
</tr>
<tr>
<td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td>
<td>共享域对象，并在视图呈现过程中向模板公开。</td>
</tr>
<tr>
<td><code>Errors</code>, <code>BindingResult</code></td>
<td>验证和数据绑定中的错误信息获取对象！</td>
</tr>
</tbody></table>
<p>获取原生对象示例：</p>
<pre><code class="Java">/**
 * 如果想要获取请求或者响应对象,或者会话等,可以直接在形参列表传入,并且不分先后顺序!
 * 注意: 接收原生对象,并不影响参数接收!
 */
@GetMapping(&quot;api&quot;)
@ResponseBody
public String api(HttpSession session , HttpServletRequest request,
                  HttpServletResponse response)&#123;
    String method = request.getMethod();
    System.out.println(&quot;method = &quot; + method);
    return &quot;api&quot;;
&#125;
</code></pre>
<p>或者使用ioc容器的自动装配也是可以的</p>
<pre><code class="java">@Controller
@RequestMapping(&quot;api&quot;)
@ResponseBody
public class ApiController &#123;
    @Autowired
    private ServletContext servletContext;
    public String api()&#123;
        servletContext.setAttribute(&quot;username&quot;,&quot;root&quot;);
        String username =(String) servletContext.getAttribute(&quot;username&quot;);
        return username;
    &#125;
    
&#125;
</code></pre>
<p><strong>共享域对象的操作</strong></p>
<p><strong>属性（共享）域作用回顾</strong></p>
<p>  在 JavaWeb 中，共享域指的是在 Servlet 中存储数据，以便在同一 Web 应用程序的多个组件中进行共享和访问。常见的共享域有四种：<code>ServletContext</code>、<code>HttpSession</code>、<code>HttpServletRequest</code>、<code>PageContext</code>。</p>
<ol>
<li><code>ServletContext</code> 共享域：<code>ServletContext</code> 对象可以在整个 Web 应用程序中共享数据，是最大的共享域。一般可以用于保存整个 Web 应用程序的全局配置信息，以及所有用户都共享的数据。在 <code>ServletContext</code> 中保存的数据是线程安全的。</li>
<li><code>HttpSession</code> 共享域：<code>HttpSession</code> 对象可以在同一用户发出的多个请求之间共享数据，但只能在同一个会话中使用。比如，可以将用户登录状态保存在 <code>HttpSession</code> 中，让用户在多个页面间保持登录状态。</li>
<li><code>HttpServletRequest</code> 共享域：<code>HttpServletRequest</code> 对象可以在同一个请求的多个处理器方法之间共享数据。比如，可以将请求的参数和属性存储在 <code>HttpServletRequest</code> 中，让处理器方法之间可以访问这些数据。</li>
<li><code>PageContext</code> 共享域：<code>PageContext</code> 对象是在 JSP 页面Servlet 创建时自动创建的。它可以在 JSP 的各个作用域中共享数据，包括<code>pageScope</code>、<code>requestScope</code>、<code>sessionScope</code>、<code>applicationScope</code> 等作用域。</li>
</ol>
<p>  共享域的作用是提供了方便实用的方式在同一 Web 应用程序的多个组件之间传递数据，并且可以将数据保存在不同的共享域中，根据需要进行选择和使用。</p>
<p>  <img src="https://secure2.wostatic.cn/static/wusZjB7KSU7gHUfXMpja5u/img010.png?auth_key=1714287656-tHTtGhxS34ABWTZwQqXuPM-0-8ebf3b46e3d868ae89460c32e070c48c"></p>
<p>springMvc为几个共享域提供几种操作方式</p>
<p><strong>Request级别属性（共享）域</strong></p>
<ol>
<li>使用 Model 类型的形参</li>
</ol>
<pre><code class="Java">@RequestMapping(&quot;/attr/request/model&quot;)
@ResponseBody
public String testAttrRequestModel(
    
        // 在形参位置声明Model类型变量，用于存储模型数据
        Model model) &#123;
    
    // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域
    // 存入请求域这个动作也被称为暴露到请求域
    model.addAttribute(&quot;requestScopeMessageModel&quot;,&quot;i am very happy[model]&quot;);
    
    return &quot;target&quot;;
&#125;
</code></pre>
<ol start="2">
<li>使用 ModelMap 类型的形参</li>
</ol>
<pre><code class="Java">@RequestMapping(&quot;/attr/request/model/map&quot;)
@ResponseBody
public String testAttrRequestModelMap(
    
        // 在形参位置声明ModelMap类型变量，用于存储模型数据
        ModelMap modelMap) &#123;
    
    // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域
    // 存入请求域这个动作也被称为暴露到请求域
    modelMap.addAttribute(&quot;requestScopeMessageModelMap&quot;,&quot;i am very happy[model map]&quot;);
    
    return &quot;target&quot;;
&#125;
</code></pre>
<ol start="3">
<li>使用 Map 类型的形参</li>
</ol>
<pre><code class="Java">@RequestMapping(&quot;/attr/request/map&quot;)
@ResponseBody
public String testAttrRequestMap(
    
        // 在形参位置声明Map类型变量，用于存储模型数据
        Map&lt;String, Object&gt; map) &#123;
    
    // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域
    // 存入请求域这个动作也被称为暴露到请求域
    map.put(&quot;requestScopeMessageMap&quot;, &quot;i am very happy[map]&quot;);
    
    return &quot;target&quot;;
&#125;
</code></pre>
<ol start="4">
<li>使用原生 request 对象</li>
</ol>
<pre><code class="Java">@RequestMapping(&quot;/attr/request/original&quot;)
@ResponseBody
public String testAttrOriginalRequest(
    
        // 拿到原生对象，就可以调用原生方法执行各种操作
        HttpServletRequest request) &#123;
    
    request.setAttribute(&quot;requestScopeMessageOriginal&quot;, &quot;i am very happy[original]&quot;);
    
    return &quot;target&quot;;
&#125;
</code></pre>
<ol start="5">
<li>使用 ModelAndView 对象</li>
</ol>
<pre><code class="Java">@RequestMapping(&quot;/attr/request/mav&quot;)
public ModelAndView testAttrByModelAndView() &#123;
    
    // 1.创建ModelAndView对象
    ModelAndView modelAndView = new ModelAndView();
    // 2.存入模型数据
    modelAndView.addObject(&quot;requestScopeMessageMAV&quot;, &quot;i am very happy[mav]&quot;);
    // 3.设置视图名称
    modelAndView.setViewName(&quot;target&quot;);
    
    return modelAndView;
&#125;
</code></pre>
<p><strong>Session级别属性（共享）域</strong></p>
<pre><code class="Java">@RequestMapping(&quot;/attr/session&quot;)
@ResponseBody
public String testAttrSession(HttpSession session) &#123;
    //直接对session对象操作,即对会话范围操作!
    return &quot;target&quot;;
&#125;
</code></pre>
<p><strong>Application级别属性（共享）域</strong></p>
<p>  解释：springmvc会在初始化容器的时候，讲servletContext对象存储到ioc容器中！</p>
<pre><code class="Java">@Autowired
private ServletContext servletContext;

@RequestMapping(&quot;/attr/application&quot;)
@ResponseBody
public String attrApplication() &#123;
    
    servletContext.setAttribute(&quot;appScopeMsg&quot;, &quot;i am hungry...&quot;);
    
    return &quot;target&quot;;
&#125;
</code></pre>
<p><strong>SpringMVC接收数据</strong></p>
<p><strong>handler方法解析</strong></p>
<p>理解handler方法的作用和组成：</p>
<pre><code class="Java">/**
 * TODO: 一个controller的方法是控制层的一个处理器,我们称为handler
 * TODO: handler需要使用@RequestMapping/@GetMapping系列,声明路径,在HandlerMapping中注册,供DS查找!
 * TODO: handler作用总结:
 *       1.接收请求参数(param,json,pathVariable,共享域等) 
 *       2.调用业务逻辑 
 *       3.响应前端数据(页面（不讲解模版页面跳转）,json,转发和重定向等)
 * TODO: handler如何处理呢
 *       1.接收参数: handler(形参列表: 主要的作用就是用来接收参数)
 *       2.调用业务: &#123; 方法体  可以向后调用业务方法 service.xx() &#125;
 *       3.响应数据: return 返回结果,可以快速响应前端数据
 */
@GetMapping
public Object handler(简化请求参数接收)&#123;
    调用业务方法
    返回的结果 （页面跳转，返回数据（json））
    return 简化响应前端数据;
&#125;
</code></pre>
<p>总结： 请求数据接收，我们都是通过handler的形参列表</p>
<pre><code>         前端数据响应，我们都是通过handler的return关键字快速处理！

      springmvc简化了参数接收和响应！
</code></pre>
<p><strong>页面的跳转的控制</strong></p>
<p><strong>快速返回模板视图</strong></p>
<p>混合开发模式和前后端分离的模式</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240428153649207.png" alt="image-20240428153649207"></p>
<ol>
<li><p>开发模式回顾</p>
<p> 在 Web 开发中，有两种主要的开发模式：前后端分离和混合开发。</p>
<p> 前后端分离模式：[重点]</p>
<p>   指将前端的界面和后端的业务逻辑通过接口分离开发的一种方式。开发人员使用不同的技术栈和框架，前端开发人员主要负责页面的呈现和用户交互，后端开发人员主要负责业务逻辑和数据存储。前后端通信通过 API 接口完成，数据格式一般使用 JSON 或 XML。前后端分离模式可以提高开发效率，同时也有助于代码重用和维护。</p>
<p> 混合开发模式：</p>
<p>   指将前端和后端的代码集成在同一个项目中，共享相同的技术栈和框架。这种模式在小型项目中比较常见，可以减少学习成本和部署难度。但是，在大型项目中，这种模式会导致代码耦合性很高，维护和升级难度较大。</p>
<p>   对于混合开发，我们就需要使用动态页面技术，动态展示Java的共享域数据！！</p>
</li>
<li><p>jsp技术了解</p>
<p> JSP（JavaServer Pages）是一种动态网页开发技术，它是由 Sun 公司提出的一种基于 Java 技术的 Web 页面制作技术，可以在 HTML 文件中嵌入 Java 代码，使得生成动态内容的编写更加简单。</p>
<p> JSP 最主要的作用是生成动态页面。它允许将 Java 代码嵌入到 HTML 页面中，以便使用 Java 进行数据库查询、处理表单数据和生成 HTML 等动态内容。另外，JSP 还可以与 Servlet 结合使用，实现更加复杂的 Web 应用程序开发。</p>
<p> JSP 的主要特点包括：</p>
<ol>
<li>简单：JSP 通过将 Java 代码嵌入到 HTML 页面中，使得生成动态内容的编写更加简单。</li>
<li>高效：JSP 首次运行时会被转换为 Servlet，然后编译为字节码，从而可以启用 Just-in-Time（JIT）编译器，实现更高效的运行。</li>
<li>多样化：JSP 支持多种标准标签库，包括 JSTL（JavaServer Pages 标准标签库）、EL（表达式语言）等，可以帮助开发人员更加方便的处理常见的 Web 开发需求。</li>
</ol>
<p> 总之，JSP 是一种简单高效、多样化的动态网页开发技术，它可以方便地生成动态页面和与 Servlet 结合使用，是 Java Web 开发中常用的技术之一。</p>
</li>
<li><p>准备jsp页面和依赖</p>
<p> pom.xml依赖</p>
</li>
</ol>
<pre><code class="XML">&lt;!-- jsp需要依赖! jstl--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;jakarta.servlet.jsp.jstl&lt;/groupId&gt;
    &lt;artifactId&gt;jakarta.servlet.jsp.jstl-api&lt;/artifactId&gt;
    &lt;version&gt;3.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code>jsp页面创建

建议位置：/WEB-INF/下，避免外部直接访问！

位置：/WEB-INF/views/home.jsp
</code></pre>
<pre><code class="Java">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
        &lt;!-- 可以获取共享域的数据,动态展示! jsp== 后台vue --&gt;
        $&#123;msg&#125;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="4">
<li>快速响应模版页面<ol>
<li>配置jsp视图解析器</li>
</ol>
</li>
</ol>
<pre><code class="Java">@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器
@Configuration
@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描

//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现
public class SpringMvcConfig implements WebMvcConfigurer &#123;

    //配置jsp对应的视图解析器
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) &#123;
        //快速配置jsp模板语言对应的
        registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;);
    &#125;
&#125;
</code></pre>
<pre><code>2. handler返回视图
</code></pre>
<pre><code class="Java">/**
 *  跳转到提交文件页面  /save/jump
 *  
 *  如果要返回jsp页面!
 *     1.方法返回值改成字符串类型
 *     2.返回逻辑视图名即可    
 *         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt;
 *            + 逻辑视图名 +
 *         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
 */
    /*
    *   TODO:快速的查找的方法
    *       1.方法的返回值是字符串的类型
    *       2.不能添加@ResponseBody注解，因为这个注解的作用，就是直接将字符串返回给浏览器，不走视图，不走解析器
    *       3.返回值 对应的中间的视图名称即可
    *
    * */
@GetMapping(&quot;jump&quot;)
public String jumpJsp(Model model)&#123;
    System.out.println(&quot;FileController.jumpJsp&quot;);
    model.addAttribute(&quot;msg&quot;,&quot;request data!!&quot;);
    return &quot;home&quot;;
&#125;
</code></pre>
<p><strong>转发和重定向</strong></p>
<p>在 Spring MVC 中，Handler 方法返回值来实现快速转发，可以使用 <code>redirect</code> 或者 <code>forward</code> 关键字来实现重定向。</p>
<pre><code class="Java">/**
    转发和重定向返回的是String，而且前面需要加上redirect或者forward，如果不加的话，默认就会取找世图资源了，后面加上路径，不能添加@ResponseBody注解
**/

@RequestMapping(&quot;/redirect-demo&quot;)
public String redirectDemo() &#123;
    // 重定向到 /demo 路径 
    return &quot;redirect:/demo&quot;;
&#125;

@RequestMapping(&quot;/forward-demo&quot;)
public String forwardDemo() &#123;
    // 转发到 /demo 路径
    return &quot;forward:/demo&quot;;
&#125;

//注意： 转发和重定向到项目下资源路径都是相同，都不需要添加项目根路径！填写项目下路径即可！
</code></pre>
<p>总结：</p>
<ul>
<li>将方法的返回值，设置String类型</li>
<li>转发使用forward关键字，重定向使用redirect关键字</li>
<li>关键字: &#x2F;路径</li>
<li>注意：如果是项目下的资源，转发和重定向都一样都是项目下路径！都不需要添加项目根路径！</li>
</ul>
<pre><code>注意点
之前不使用springMvc 
    转发是项目下的资源跳转，路径：项目下的地址  /jsp/index  忽略应用的上下文
    重定向是项目下的资源也可以是项目意意外的地址 重定向的属于二次请求 路径：项目下的地址
    需要写全地址  applicationContext
使用springmvc不需要使用全地址
</code></pre>
<p>基本的使用</p>
<pre><code class="java">package com.chenw.jsp;


import jakarta.servlet.http.HttpServletRequest;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping(&quot;jsp&quot;)
public class JspController &#123;
    /*
    *   TODO:快速的查找的方法
    *       1.方法的返回值是字符串的类型
    *       2.不能添加@ResponseBody注解，因为这个注解的作用，就是直接将字符串返回给浏览器，不走视图，不走解析器
    *       3.返回值 对应的中间的视图名称即可
    *
    * */
    @GetMapping(&quot;index&quot;)
    public String index(HttpServletRequest request)&#123;
        request.setAttribute(&quot;data&quot;,&quot;hello!jsp!!!&quot;);
        System.out.println(&quot;JspController.index&quot;);
        return &quot;index&quot;;
    &#125;
    /*
    *   方法的返回值是String
    * */
    @GetMapping(&quot;forward&quot;)
    public String forward()&#123;
        return &quot;forward:/jsp/index&quot;;
    &#125;
    @GetMapping(&quot;redirect&quot;)
    public String redirect()&#123;
        return &quot;redirect:/jsp/index&quot;;
    &#125;
    @GetMapping(&quot;baidu&quot;)
    public String baidu()&#123;
        return &quot;redirect:http://www.baidu.com&quot;;
    &#125;

&#125;
</code></pre>
<p><strong>返回Json数据</strong></p>
<p>配置</p>
<pre><code>之前在接收json数据配置过
</code></pre>
<p>导入jackson依赖</p>
<pre><code class="XML">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.15.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>添加json数据转化器</p>
<p>@EnableWebMvc </p>
<pre><code class="Java">//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]

//TODO: 导入handlerMapping和handlerAdapter的三种方式
 //1.自动导入handlerMapping和handlerAdapter [推荐]
 //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载
 //3.使用@Bean方式配置handlerMapper和handlerAdapter
@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器
@Configuration
@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描

//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现
public class SpringMvcConfig implements WebMvcConfigurer &#123;


&#125;				
</code></pre>
<p><strong>@Response注解</strong></p>
<ol>
<li><p>方法上使用@ResponseBody</p>
<p> 可以在方法上使用 <code>@ResponseBody</code>注解，用于将方法返回的对象序列化为 JSON 或 XML 格式的数据，并发送给客户端。在前后端分离的项目中使用！</p>
<p> 测试方法：</p>
</li>
</ol>
<pre><code class="Java">@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)
@ResponseBody
public Object handle() &#123;
  // ...
  return obj;
&#125;
</code></pre>
<p>具体来说，<code>@ResponseBody</code> 注解可以用来标识方法或者方法返回值，表示方法的返回值是要直接返回给客户端的数据，而不是由视图解析器来解析并渲染生成响应体（viewResolver没用）。</p>
<pre><code>测试方法：
</code></pre>
<pre><code class="Java">@RequestMapping(value = &quot;/user/detail&quot;, method = RequestMethod.POST)
@ResponseBody
public User getUser(@RequestBody User userParam) &#123;
    System.out.println(&quot;userParam = &quot; + userParam);
    User user = new User();
    user.setAge(18);
    user.setName(&quot;John&quot;);
    //返回的对象,会使用jackson的序列化工具,转成json返回给前端!
    return user;
&#125;
</code></pre>
<pre><code>返回结果：

![](https://secure2.wostatic.cn/static/b8AAMNoaVABerV8BGsqNTo/image.png?auth_key=1714293548-6k9TUB2ZVUo8ro9rupLWJa-0-43c7e6adc109677eec8040dd15a3a63c)
</code></pre>
<ol start="2">
<li><p>类上使用@ResponseBody</p>
<p> 如果类中每个方法上都标记了 @ResponseBody 注解，那么这些注解就可以提取到类上。</p>
</li>
</ol>
<pre><code class="Java">@ResponseBody  //responseBody可以添加到类上,代表默认类中的所有方法都生效!
@Controller
@RequestMapping(&quot;param&quot;)
public class ParamController &#123;
</code></pre>
<p>例如</p>
<pre><code class="java">@EnableWebMvc
@Configuration
@ComponentScan(&quot;com.chenw&quot;)
public class MvcConfig implements WebMvcConfigurer &#123;
    /*
    *   配置视图解析器，指定前后缀
    * */

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) &#123;
        //registry可以快速的添加视图解析器
        registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;);
        //handler寻找这个视图的话，就会直接寻找这个
    &#125;

&#125;
</code></pre>
<pre><code class="java">package com.chenw.json;

import com.chenw.pojo.User;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.ArrayList;
import java.util.List;

@Controller
@RequestMapping(&quot;json&quot;)
public class JsonController &#123;

    @ResponseBody
    @GetMapping(&quot;data&quot;)
    public User data()&#123;
        User user = new User();
        user.setName(&quot;二狗子&quot;);
        user.setAge(19);
        return user;
        /*
        *  user在handlerAdapter里面解析成json格式的数据，因为我们之前已经导入json的依赖，而且使用注解@EnableWebMvc启用这个依赖了
        * 还需要加上@ResponseBody的注解
        * */
    &#125;
    /*
    *   如果返回的是列表的形式
    * */
    @ResponseBody
    @GetMapping(&quot;data1&quot;)
    public List&lt;User&gt; data1()&#123;
        User user = new User();
        user.setName(&quot;二狗子&quot;);
        user.setAge(19);
        ArrayList&lt;User&gt; users = new ArrayList&lt;&gt;();
        users.add(user);
        return users;
        /*
         *  user在handlerAdapter里面解析成json格式的数据，因为我们之前已经导入json的依赖，而且使用注解@EnableWebMvc启用这个依赖了
         * 还需要加上@ResponseBody的注解
         * */
    &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240428165402790.png" alt="image-20240428165402790"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240428165419968.png" alt="image-20240428165419968"></p>
<pre><code> @ResponseBody的注解直接加在类上也是可以的，这样每一个的都会
</code></pre>
<p>可以进行替代</p>
<pre><code class="java">@RestController = @Response + @Controller
</code></pre>
<pre><code>@Response注解 数据直接放入响应体返回，也不会走视图解析器
    快速查找视图，转发和重定向的语法都不生效了 
</code></pre>
<p><strong>@RestController注解</strong></p>
<p>  类上的 @ResponseBody 注解可以和 @Controller 注解合并为 @RestController 注解。所以使用了 @RestController 注解就相当于给类中的每个方法都加了 @ResponseBody 注解。</p>
<p>  RestController源码:</p>
<pre><code class="Java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Controller
@ResponseBody
public @interface RestController &#123;
 
  /**
   * The value may indicate a suggestion for a logical component name,
   * to be turned into a Spring bean in case of an autodetected component.
   * @return the suggested component name, if any (or empty String otherwise)
   * @since 4.0.1
   */
  @AliasFor(annotation = Controller.class)
  String value() default &quot;&quot;;
 
&#125;
</code></pre>
<p><strong>返回静态资源</strong></p>
<p><strong>静态资源概念</strong></p>
<p>资源本身已经是可以直接拿到浏览器上使用的程度了，<strong>不需要在服务器端做任何运算、处理</strong>。典型的静态资源包括：</p>
<ul>
<li>纯HTML文件</li>
<li>图片</li>
<li>CSS文件</li>
<li>JavaScript文件</li>
<li>……</li>
</ul>
<ol>
<li><strong>静态资源访问和问题解决</strong><ul>
<li><p>web应用加入静态资源</p>
<p>  <img src="https://secure2.wostatic.cn/static/2ADk35v3kBWvGQSwL99Z3S/image.png?auth_key=1714294816-cgnjvQFkbgxPt12bSyi1vW-0-cf2053f36a4df9b73b029b51cea78d44"></p>
</li>
<li><p>手动构建确保编译</p>
<p>  <img src="https://secure2.wostatic.cn/static/gBRmLxNhoWEd4o2eC2xamA/image.png?auth_key=1714294816-ezboJMBpzgs7oH9KPJtwNF-0-e696910c1395093732a5aa3fdfee1648"></p>
<p>  <img src="https://secure2.wostatic.cn/static/rKa2VeGDteC7Xk18LTZGWu/image.png?auth_key=1714294815-5Q2MM8Z7LA49USSkqCMBEG-0-704daaf1ed30a02fb24a7f6bd2e77332"></p>
<p>  <img src="https://secure2.wostatic.cn/static/jmvurwN5HSB44eVFPaNJa4/image.png?auth_key=1714294815-nrQ9YdfFaofoRUh17m9rDN-0-b73fe128520ab3dfbe330eae92e8f012"></p>
</li>
<li><p>访问静态资源</p>
<p>  <img src="https://secure2.wostatic.cn/static/2Ux86Et6qs3TsDkEg1NQTn/image.png?auth_key=1714294815-hdtCvvLiXnVoF6iTq6FAkU-0-10aac9b9273f2b9713fcb73a74cfc8f0"></p>
</li>
<li><p>问题分析</p>
<ul>
<li>DispatcherServlet 的 url-pattern 配置的是“&#x2F;”</li>
<li>url-pattern 配置“&#x2F;”表示整个 Web 应用范围内所有请求都由 SpringMVC 来处理</li>
<li>对 SpringMVC 来说，必须有对应的 @RequestMapping 才能找到处理请求的方法</li>
<li>现在 images&#x2F;mi.jpg 请求没有对应的 @RequestMapping 所以返回 404</li>
</ul>
</li>
<li><p>问题解决</p>
<p>  在 SpringMVC 配置配置类：</p>
</li>
</ul>
</li>
</ol>
<pre><code class="Java">@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器
@Configuration
@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描
//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现
public class SpringMvcConfig implements WebMvcConfigurer &#123;

    //配置jsp对应的视图解析器
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) &#123;
        //快速配置jsp模板语言对应的
        registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;);
    &#125;
    
    //开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;
        configurer.enable();
    &#125;
&#125;
</code></pre>
<pre><code>这样配置以后就实现了
    说一下为什么之前访问不到
        因为我们配置    protected String[] getServletMappings() &#123;
        return new String[]&#123;&quot;/&quot;&#125;;
    &#125;
       这样我们请求都会先去mapping查找有无对应的映射，没有的就返回404，所以这样就会导致，直接访问敬他资源失效，但是我们这样配置以后就开启了
</code></pre>
<pre><code class="XML">@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器
</code></pre>
<p><strong>RESTFul风格设计和实战</strong></p>
<p><strong>概述</strong></p>
<pre><code>Http协议的标准使用方案和风格
    教你怎么设计路径
    教你如何设置参数传递
    教你如何选择请求方式	
</code></pre>
<p><strong>简介</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<p>RESTful（Representational State Transfer）是一种软件架构风格，用于设计网络应用程序和服务之间的通信。它是一种基于标准 HTTP 方法的简单和轻量级的通信协议，广泛应用于现代的Web服务开发。</p>
<p>通过遵循 RESTful 架构的设计原则，可以构建出易于理解、可扩展、松耦合和可重用的 Web 服务。RESTful API 的特点是简单、清晰，并且易于使用和理解，它们使用标准的 HTTP 方法和状态码进行通信，不需要额外的协议和中间件。</p>
<p>总而言之，RESTful 是一种基于 HTTP 和标准化的设计原则的软件架构风格，用于设计和实现可靠、可扩展和易于集成的 Web 服务和应用程序！</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<p>学习RESTful设计原则可以帮助我们更好去设计HTTP协议的API接口！！</p>
<p><strong>分隔特点</strong></p>
<ol>
<li>每一个URI代表1种资源（URI 是名词）；</li>
<li>客户端使用GET、POST、PUT、DELETE 4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</li>
<li>资源的表现形式是XML或者<strong>JSON</strong>；</li>
<li>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</li>
</ol>
<p><strong>RESTFul的风格特点</strong></p>
<ol>
<li><p><strong>HTTP协议请求方式要求</strong></p>
<p> REST 风格主张在项目设计、开发过程中，具体的操作符合<strong>HTTP协议定义的请求方式的语义</strong>。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>操作</th>
<th>请求方式</th>
</tr>
</thead>
<tbody><tr>
<td>查询操作</td>
<td>GET</td>
</tr>
<tr>
<td>保存操作</td>
<td>POST</td>
</tr>
<tr>
<td>删除操作</td>
<td>DELETE</td>
</tr>
<tr>
<td>更新操作</td>
<td>PUT</td>
</tr>
</tbody></table>
<ol start="2">
<li><p><strong>URL路径风格要求</strong></p>
<p> REST风格下每个资源都应该有一个唯一的标识符，例如一个 URI（统一资源标识符）或者一个 URL（统一资源定位符）。资源的标识符应该能明确地说明该资源的信息，同时也应该是可被理解和解释的！</p>
<p> 使用URL+请求方式确定具体的动作，他也是一种标准的HTTP协议请求！</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>操作</th>
<th>传统风格</th>
<th>REST 风格</th>
</tr>
</thead>
<tbody><tr>
<td>保存</td>
<td>&#x2F;CRUD&#x2F;saveEmp</td>
<td>URL 地址：&#x2F;CRUD&#x2F;emp 请求方式：POST</td>
</tr>
<tr>
<td>删除</td>
<td>&#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2</td>
<td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2 请求方式：DELETE</td>
</tr>
<tr>
<td>更新</td>
<td>&#x2F;CRUD&#x2F;updateEmp</td>
<td>URL 地址：&#x2F;CRUD&#x2F; 请求方式：PUT</td>
</tr>
<tr>
<td>查询</td>
<td>&#x2F;CRUD&#x2F;editEmp?empId&#x3D;2</td>
<td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2 请求方式：GET</td>
</tr>
</tbody></table>
<ul>
<li><p>总结</p>
<p>  根据接口的具体动作，选择具体的HTTP协议请求方式</p>
<p>  路径设计从原来携带动标识，改成名词，对应资源的唯一标识即可！</p>
</li>
</ul>
<p><strong>好处</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240428181824162.png" alt="image-20240428181824162"></p>
<ol>
<li><p>含蓄，安全</p>
<p> 使用问号键值对的方式给服务器传递数据太明显，容易被人利用来对系统进行破坏。使用 REST 风格携带数据不再需要明显的暴露数据的名称。</p>
</li>
<li><p>风格统一</p>
<p> URL 地址整体格式统一，从前到后始终都使用斜杠划分各个单词，用简单一致的格式表达语义。</p>
</li>
<li><p>无状态</p>
<p> 在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了系统设计的复杂度。</p>
</li>
<li><p>严谨，规范</p>
<p> 严格按照 HTTP1.1 协议中定义的请求方式本身的语义进行操作。</p>
</li>
<li><p>简洁，优雅</p>
<p> 过去做增删改查操作需要设计4个不同的URL，现在一个就够了。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>操作</th>
<th>传统风格</th>
<th>REST 风格</th>
</tr>
</thead>
<tbody><tr>
<td>保存</td>
<td>&#x2F;CRUD&#x2F;saveEmp</td>
<td>URL 地址：&#x2F;CRUD&#x2F;emp 请求方式：POST</td>
</tr>
<tr>
<td>删除</td>
<td>&#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2</td>
<td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2 请求方式：DELETE</td>
</tr>
<tr>
<td>更新</td>
<td>&#x2F;CRUD&#x2F;updateEmp</td>
<td>URL 地址：&#x2F;CRUD&#x2F;emp 请求方式：PUT</td>
</tr>
<tr>
<td>查询</td>
<td>&#x2F;CRUD&#x2F;editEmp?empId&#x3D;2</td>
<td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2 请求方式：GET</td>
</tr>
</tbody></table>
<ol start="6">
<li><p>丰富的语义</p>
<p> 通过 URL 地址就可以知道资源之间的关系。它能够把一句话中的很多单词用斜杠连起来，反过来说就是可以在 URL 地址中用一句话来充分表达语义。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/shop">http://localhost:8080/shop</a> <a target="_blank" rel="noopener" href="http://localhost:8080/shop/product">http://localhost:8080/shop/product</a> <a target="_blank" rel="noopener" href="http://localhost:8080/shop/product/cellPhone">http://localhost:8080/shop/product/cellPhone</a> <a target="_blank" rel="noopener" href="http://localhost:8080/shop/product/cellPhone/iPhone">http://localhost:8080/shop/product/cellPhone/iPhone</a></p>
</blockquote>
</li>
</ol>
<p><strong>RESTFul风格实战</strong></p>
<ul>
<li>数据结构： User {id 唯一标识,name 用户名，age 用户年龄}</li>
<li>功能分析<ul>
<li>用户数据分页展示功能（条件：page 页数 默认1，size 每页数量 默认 10）</li>
<li>保存用户功能</li>
<li>根据用户id查询用户详情功能</li>
<li>根据用户id更新用户数据功能</li>
<li>根据用户id删除用户数据功能</li>
<li>多条件模糊查询用户功能（条件：keyword 模糊关键字，page 页数 默认1，size 每页数量 默认 10）</li>
</ul>
</li>
</ul>
<ol>
<li><strong>接口设计</strong></li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>功能</td>
<td>接口和请求方式</td>
<td>请求参数</td>
<td>返回值</td>
</tr>
<tr>
<td>分页查询</td>
<td>GET  &#x2F;user</td>
<td>page&#x3D;1&amp;size&#x3D;10</td>
<td>{ 响应数据 }</td>
</tr>
<tr>
<td>用户添加</td>
<td>POST &#x2F;user</td>
<td>{ user 数据 }</td>
<td>{响应数据}</td>
</tr>
<tr>
<td>用户详情</td>
<td>GET &#x2F;user&#x2F;1</td>
<td>路径参数</td>
<td>{响应数据}</td>
</tr>
<tr>
<td>用户更新</td>
<td>PUT &#x2F;user</td>
<td>{ user 更新数据}</td>
<td>{响应数据}</td>
</tr>
<tr>
<td>用户删除</td>
<td>DELETE &#x2F;user&#x2F;1</td>
<td>路径参数</td>
<td>{响应数据}</td>
</tr>
<tr>
<td>条件模糊</td>
<td>GET &#x2F;user&#x2F;search</td>
<td>page&#x3D;1&amp;size&#x3D;10&amp;keywork&#x3D;关键字</td>
<td>{响应数据}</td>
</tr>
</tbody></table>
<ol start="2">
<li><p><strong>问题讨论</strong></p>
<p> 为什么查询用户详情，就使用路径传递参数，多条件模糊查询，就使用请求参数传递？</p>
<p> 误区：restful风格下，不是所有请求参数都是路径传递！可以使用其他方式传递！</p>
<p> 在 RESTful API 的设计中，路径和请求参数和请求体都是用来向服务器传递信息的方式。</p>
<ul>
<li>对于查询用户详情，使用路径传递参数是因为这是一个单一资源的查询，即查询一条用户记录。使用路径参数可以明确指定所请求的资源，便于服务器定位并返回对应的资源，也符合 RESTful 风格的要求。</li>
<li>而对于多条件模糊查询，使用请求参数传递参数是因为这是一个资源集合的查询，即查询多条用户记录。使用请求参数可以通过组合不同参数来限制查询结果，路径参数的组合和排列可能会很多，不如使用请求参数更加灵活和简洁。</li>
</ul>
<p> 此外，还有一些通用的原则可以遵循：</p>
<ul>
<li>路径参数应该用于指定资源的唯一标识或者 ID，而请求参数应该用于指定查询条件或者操作参数。</li>
<li>请求参数应该限制在 10 个以内，过多的请求参数可能导致接口难以维护和使用。</li>
<li>对于敏感信息，最好使用 POST 和请求体来传递参数。</li>
</ul>
</li>
</ol>
<p><strong>springMVC其他扩展</strong></p>
<p><strong>全局的异常处理</strong></p>
<p><strong>处理的两种方式</strong></p>
<p>开发过程中是不可避免地会出现各种异常情况的，例如网络连接异常、数据格式异常、空指针异常等等。异常的出现可能导致程序的运行出现问题，甚至直接导致程序崩溃。因此，在开发过程中，合理处理异常、避免异常产生、以及对异常进行有效的调试是非常重要的。</p>
<p>对于异常的处理，一般分为两种方式：</p>
<ul>
<li>编程式异常处理：是指在代码中显式地编写处理异常的逻辑。它通常涉及到对异常类型的检测及其处理，例如使用 try-catch 块来捕获异常，然后在 catch 块中编写特定的处理代码，或者在 finally 块中执行一些清理操作。在编程式异常处理中，开发人员需要显式地进行异常处理，异常处理代码混杂在业务代码中，导致代码可读性较差。</li>
<li>声明式异常处理：则是将异常处理的逻辑从具体的业务逻辑中分离出来，通过配置等方式进行统一的管理和处理。在声明式异常处理中，开发人员只需要为方法或类标注相应的注解（如 <code>@Throws</code> 或 <code>@ExceptionHandler</code>），就可以处理特定类型的异常。相较于编程式异常处理，声明式异常处理可以使代码更加简洁、易于维护和扩展。</li>
</ul>
<p>站在宏观角度来看待声明式事务处理：</p>
<p>  整个项目从架构这个层面设计的异常处理的统一机制和规范。</p>
<p>  一个项目中会包含很多个模块，各个模块需要分工完成。如果张三负责的模块按照 A 方案处理异常，李四负责的模块按照 B 方案处理异常……各个模块处理异常的思路、代码、命名细节都不一样，那么就会让整个项目非常混乱。</p>
<p>  使用声明式异常处理，可以统一项目处理异常思路，项目更加清晰明了！</p>
<p><strong>基于注解异常处理</strong></p>
<ol>
<li><p>声明异常处理控制器类</p>
<p> 异常处理控制类，统一定义异常处理handler方法！</p>
</li>
</ol>
<pre><code class="Java">/**
 * projectName: com.atguigu.execptionhandler
 * 
 * description: 全局异常处理器,内部可以定义异常处理Handler!
 */

/**
 * @RestControllerAdvice = @ControllerAdvice + @ResponseBody
 * @ControllerAdvice 代表当前类的异常处理controller! 
 */
@RestControllerAdvice
public class GlobalExceptionHandler &#123;

  
&#125;
</code></pre>
<ol start="2">
<li><p>声明异常处理hander方法</p>
<p> 异常处理handler方法和普通的handler方法参数接收和响应都一致！</p>
<p> 只不过异常处理handler方法要映射异常，发生对应的异常会调用！</p>
<p> 普通的handler方法要使用@RequestMapping注解映射路径，发生对应的路径调用！</p>
</li>
</ol>
<pre><code class="Java">/**
 * 异常处理handler 
 * @ExceptionHandler(HttpMessageNotReadableException.class) 
 * 该注解标记异常处理Handler,并且指定发生异常调用该方法!
 * 
 * 
 * @param e 获取异常对象!
 * @return 返回handler处理结果!
 */
@ExceptionHandler(HttpMessageNotReadableException.class)
public Object handlerJsonDateException(HttpMessageNotReadableException e)&#123;
    
    return null;
&#125;

/**
 * 当发生空指针异常会触发此方法!
 * @param e
 * @return
 */
@ExceptionHandler(NullPointerException.class)
public Object handlerNullException(NullPointerException e)&#123;

    return null;
&#125;

/**
 * 所有异常都会触发此方法!但是如果有具体的异常处理Handler! 
 * 具体异常处理Handler优先级更高!
 * 例如: 发生NullPointerException异常!
 *       会触发handlerNullException方法,不会触发handlerException方法!
 * @param e
 * @return
 */
@ExceptionHandler(Exception.class)
public Object handlerException(Exception e)&#123;

    return null;
&#125;
</code></pre>
<ol start="3">
<li><p>配置文件扫描控制器类配置</p>
<p> 确保异常处理控制类被扫描</p>
</li>
</ol>
<pre><code class="Java"> &lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt;
 @ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,
 &quot;com.atguigu.exceptionhandler&quot;&#125;
</code></pre>
<p><strong>拦截器</strong></p>
<p>拦截器和过滤器解决问题</p>
<ul>
<li><p>生活中</p>
<p>  为了提高乘车效率，在乘客进入站台前统一检票</p>
<p>  <img src="https://secure2.wostatic.cn/static/qnwL468SbgHHucUQqmYxPV/img008.png?auth_key=1714301051-6hZ6VdakZ8pmrxMWPqMBVP-0-350e467bc3e8d1d28368caefb6c7b673"></p>
</li>
<li><p>程序中</p>
<p>  在程序中，使用拦截器在请求到达具体 handler 方法前，统一执行检测</p>
<p>  <img src="https://secure2.wostatic.cn/static/eBwRN4iKLw9e9DHpVGP4WX/img009.png?auth_key=1714301052-4Ep4oNZgDZ47TS1gj8Vf5Y-0-fc2699c9bf4f22858320409f63b54057"></p>
</li>
</ul>
<p>拦截器 Springmvc VS 过滤器 javaWeb：</p>
<ul>
<li>相似点<ul>
<li>拦截：必须先把请求拦住，才能执行后续操作</li>
<li>过滤：拦截器或过滤器存在的意义就是对请求进行统一处理</li>
<li>放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源</li>
</ul>
</li>
<li>不同点<ul>
<li>工作平台不同<ul>
<li>过滤器工作在 Servlet 容器中</li>
<li>拦截器工作在 SpringMVC 的基础上</li>
</ul>
</li>
<li>拦截的范围<ul>
<li>过滤器：能够拦截到的最大范围是整个 Web 应用</li>
<li>拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求</li>
</ul>
</li>
<li>IOC 容器支持<ul>
<li>过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的</li>
<li>拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>选择：</p>
<p>  功能需要如果用 SpringMVC 的拦截器能够实现，就不使用过滤器。</p>
<p>  <img src="https://secure-bigfile.wostatic.cn/static/prqG4dtu3rDWj7VwX4WgsW/image.png?auth_key=1714301052-6wVrFp3rjgjG6eT6wmBbBp-0-3ca7d148833de298b8b38fd996d55ac8"></p>
<p>应用</p>
<ol>
<li>创建拦截器类</li>
</ol>
<pre><code class="Java">public class Process01Interceptor implements HandlerInterceptor &#123;

    // if( ! preHandler())&#123;return;&#125;
    // 在处理请求的目标 handler 方法前执行
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler);
        System.out.println(&quot;Process01Interceptor.preHandle&quot;);
         
        // 返回true：放行
        // 返回false：不放行
        return true;
    &#125;
 
    // 在目标 handler 方法之后，handler报错不执行!
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler + &quot;, modelAndView = &quot; + modelAndView);
        System.out.println(&quot;Process01Interceptor.postHandle&quot;);
    &#125;
 
    // 渲染视图之后执行(最后),一定执行!
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler + &quot;, ex = &quot; + ex);
        System.out.println(&quot;Process01Interceptor.afterCompletion&quot;);
    &#125;
&#125;
</code></pre>
<p>拦截器方法拦截过程</p>
<p><img src="https://secure2.wostatic.cn/static/9W6TF7dUwqdv2qi4KHAkAr/image.png?auth_key=1714301083-tnpmoC8yP14R5m3RTf7Bg3-0-2283a3656d41d59087a8f2a9ee9bc8fc"></p>
<ol start="2">
<li>修改配置类添加拦截器</li>
</ol>
<pre><code class="Java">@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器
@Configuration
@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,&quot;com.atguigu.exceptionhandler&quot;&#125;) //TODO: 进行controller扫描
//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现
public class SpringMvcConfig implements WebMvcConfigurer &#123;

    //配置jsp对应的视图解析器
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) &#123;
        //快速配置jsp模板语言对应的
        registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;);
    &#125;

    //开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;
        configurer.enable();
    &#125;

    //添加拦截器
    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123; 
        //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求
        registry.addInterceptor(new Process01Interceptor());
    &#125;
&#125;

</code></pre>
<ol start="3">
<li>配置详解<ol>
<li>默认拦截全部</li>
</ol>
</li>
</ol>
<pre><code class="Java">@Override
public void addInterceptors(InterceptorRegistry registry) &#123;
    //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求
    registry.addInterceptor(new Process01Interceptor());
&#125;
</code></pre>
<pre><code>2. 精准配置
</code></pre>
<pre><code class="Java">@Override
public void addInterceptors(InterceptorRegistry registry) &#123;
    
    //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求
    registry.addInterceptor(new Process01Interceptor());
    
    //精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可
    //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径
    //也支持 /* 和 /** 模糊路径。 * 任意一层字符串 ** 任意层 任意字符串
    registry.addInterceptor(new Process01Interceptor()).addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;);
&#125;
</code></pre>
<pre><code>3. 排除配置
</code></pre>
<pre><code class="Java">//添加拦截器
@Override
public void addInterceptors(InterceptorRegistry registry) &#123;
    
    //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求
    registry.addInterceptor(new Process01Interceptor());
    
    //精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可
    //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径
    registry.addInterceptor(new Process01Interceptor()).addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;);
    
    
    //排除匹配,排除应该在匹配的范围内排除
    //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径
    //excludePathPatterns(&quot;/common/request/tow&quot;); 排除路径,排除应该在拦截的范围内
    registry.addInterceptor(new Process01Interceptor())
            .addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;)
            .excludePathPatterns(&quot;/common/request/tow&quot;);
&#125;
</code></pre>
<ol start="4">
<li>多个拦截器执行顺序<ol>
<li>preHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置顺序调用各个 preHandle() 方法。</li>
<li>postHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 postHandle() 方法。</li>
<li>afterCompletion() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 afterCompletion() 方法。</li>
</ol>
</li>
</ol>
<pre><code>注意拦截器和JavaWeb的过滤器的作用位置不一样
    拦截器作用在请求到达Dispatcher Servlet以后的handlerAdapter处理的阶段
    过滤器的生效的位置是请求到达Dispatcher Servlet之前
</code></pre>
<p><img src="https://secure-bigfile.wostatic.cn/static/prqG4dtu3rDWj7VwX4WgsW/image.png?auth_key=1714301052-6wVrFp3rjgjG6eT6wmBbBp-0-3ca7d148833de298b8b38fd996d55ac8"></p>
<p><strong>拦截器的基本使用</strong></p>
<p>写一个拦截器类，继承HandlerInterceptor</p>
<pre><code class="java">package com.chenw.interceptor;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

public class MyInterceptor implements HandlerInterceptor &#123;
    @Override
    /**
    * @Description   在执行handler方法之前调用的拦截的方法， 例如编码格式设置，登录保护 ，权限处理
    * @param [request, response, handler]
    * @return boolean true就会房型 false就不会放行
    * @Author 王昌晨
    * @Date 2024/4/28
    */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        return true;
    &#125;
    /**
    * @Description   当handler处理完毕以后执行的方法，没有拦截的机制，对结果
    * @param [request, response, handler, modelAndView]  modelAndView返回的视图和共享域数据对象
    * @return void
    * @Author 王昌晨
    * @Date 2024/4/28
    */
    
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
    &#125;

    /**
    * @Description  整体的处理完毕以后
    * @param [request, response, handler, ex] ex是异常的对象
    * @return void
    * @Author 王昌晨
    * @Date 2024/4/28
    */
    
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
    &#125;
&#125;
</code></pre>
<p>在配置累里面注射拦截器</p>
<pre><code class="java">package com.chenw.config;


import com.chenw.interceptor.MyInterceptor;
import org.springframework.beans.factory.annotation.Configurable;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.ViewResolverRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@EnableWebMvc
@Configuration
@ComponentScan(&quot;com.chenw&quot;)
public class MvcConfig implements WebMvcConfigurer &#123;
    /*
    *   配置视图解析器，指定前后缀
    * */

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) &#123;
        //registry可以快速的添加视图解析器
        registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;);
        //handler寻找这个视图的话，就会直接寻找这个
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        //配置方案1：拦截全部的请求
        registry.addInterceptor(new MyInterceptor());
    &#125;
&#125;
</code></pre>
<pre><code>这样的全部的请求都会被拦截
</code></pre>
<p>指定的拦截</p>
<pre><code class="java">//配置方案1：拦截全部的请求
registry.addInterceptor(new MyInterceptor());
//配置方案2：指定的地址拦截
registry.addInterceptor(new MyInterceptor())
        .addPathPatterns(&quot;/user/data&quot;);
</code></pre>
<p>模糊的拦截</p>
<pre><code class="java">//配置方案2：指定的地址拦截
*任意一层字符串
**任意多层字符串
registry.addInterceptor(new MyInterceptor())
        .addPathPatterns(&quot;/user/**&quot;);
</code></pre>
<p>排除拦截</p>
<pre><code class="java">        registry.addInterceptor(new MyInterceptor())
                .addPathPatterns(&quot;/user/*&quot;)
                .excludePathPatterns(&quot;/user/data&quot;);//除了data的全部都拦截
</code></pre>
<p><strong>多个拦截器的执行顺序</strong></p>
<pre><code class="java">      registry.addInterceptor(new MyInterceptor())
      registry.addInterceptor(new MyInterceptor1())
</code></pre>
<pre><code>和之前的过滤器差不多
    先声明的请求先进来，但是响应后出来
</code></pre>
<p><strong>参数校验</strong> </p>
<p>在 Web 应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。</p>
<ol>
<li><p><strong>校验概述</strong></p>
<p> JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>注解</th>
<th>规则</th>
</tr>
</thead>
<tbody><tr>
<td>@Null</td>
<td>标注值必须为 null</td>
</tr>
<tr>
<td>@NotNull</td>
<td>标注值不可为 null</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>标注值必须为 true</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>标注值必须为 false</td>
</tr>
<tr>
<td>@Min(value)</td>
<td>标注值必须大于或等于 value</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>标注值必须小于或等于 value</td>
</tr>
<tr>
<td>@DecimalMin(value)</td>
<td>标注值必须大于或等于 value</td>
</tr>
<tr>
<td>@DecimalMax(value)</td>
<td>标注值必须小于或等于 value</td>
</tr>
<tr>
<td>@Size(max,min)</td>
<td>标注值大小必须在 max 和 min 限定的范围内</td>
</tr>
<tr>
<td>@Digits(integer,fratction)</td>
<td>标注值值必须是一个数字，且必须在可接受的范围内</td>
</tr>
<tr>
<td>@Past</td>
<td>标注值只能用于日期型，且必须是过去的日期</td>
</tr>
<tr>
<td>@Future</td>
<td>标注值只能用于日期型，且必须是将来的日期</td>
</tr>
<tr>
<td>@Pattern(value)</td>
<td>标注值必须符合指定的正则表达式</td>
</tr>
</tbody></table>
<pre><code>JSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解：
</code></pre>
<table>
<thead>
<tr>
<th>注解</th>
<th>规则</th>
</tr>
</thead>
<tbody><tr>
<td>@Email</td>
<td>标注值必须是格式正确的 Email 地址</td>
</tr>
<tr>
<td>@Length</td>
<td>标注值字符串大小必须在指定的范围内</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>标注值字符串不能是空字符串</td>
</tr>
<tr>
<td>@Range</td>
<td>标注值必须在指定的范围内</td>
</tr>
</tbody></table>
<pre><code>Spring 4.0 版本已经拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在SpringMVC 中，可直接通过注解驱动 @EnableWebMvc 的方式进行数据校验。Spring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。Spring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。

配置 @EnableWebMvc后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 @Validated 注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。
</code></pre>
<ol start="2">
<li><strong>操作演示</strong><ul>
<li>导入依赖</li>
</ul>
</li>
</ol>
<pre><code class="XML">&lt;!-- 校验注解 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;jakarta.platform&lt;/groupId&gt;
    &lt;artifactId&gt;jakarta.jakartaee-web-api&lt;/artifactId&gt;
    &lt;version&gt;9.1.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
        
&lt;!-- 校验注解实现--&gt;        
&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
    &lt;version&gt;8.0.0.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt;
    &lt;version&gt;8.0.0.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code>- 应用校验注解
</code></pre>
<pre><code class="Java">import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Min;
import org.hibernate.validator.constraints.Length;

/**
 * projectName: com.atguigu.pojo
 */
public class User &#123;
    //age   1 &lt;=  age &lt; = 150
    @Min(10)
    private int age;

    //name 3 &lt;= name.length &lt;= 6
    @Length(min = 3,max = 10)
    private String name;

    //email 邮箱格式
    @Email
    private String email;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getEmail() &#123;
        return email;
    &#125;

    public void setEmail(String email) &#123;
        this.email = email;
    &#125;
&#125;
</code></pre>
<pre><code>- handler标记和绑定错误收集
</code></pre>
<pre><code class="Java">@RestController
@RequestMapping(&quot;user&quot;)
public class UserController &#123;

    /**
     * @Validated 代表应用校验注解! 必须添加!
     */
    @PostMapping(&quot;save&quot;)
    public Object save(@Validated @RequestBody User user,
                       //在实体类参数和 BindingResult 之间不能有任何其他参数, BindingResult可以接受错误信息,避免信息抛出!
                       BindingResult result)&#123;
       //判断是否有信息绑定错误! 有可以自行处理!
        if (result.hasErrors())&#123;
            System.out.println(&quot;错误&quot;);
            String errorMsg = result.getFieldError().toString();
            return errorMsg;
        &#125;
        //没有,正常处理业务即可
        System.out.println(&quot;正常&quot;);
        return user;
    &#125;
&#125;
</code></pre>
<pre><code>- 测试效果

    ![](https://secure2.wostatic.cn/static/oXLwvcaMaLc4TggmPFNToV/image.png?auth_key=1714303247-kkio4egrMRcWFd6hqfbZF9-0-9be20ac531f6d40a9b8caa8c7df1016f)
</code></pre>
<ol start="3">
<li><p><strong>易混总结</strong></p>
<p> @NotNull、@NotEmpty、@NotBlank 都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同。</p>
<ol>
<li><p>@NotNull  (包装类型不为null)</p>
<p> @NotNull 注解是 JSR 303 规范中定义的注解，当被标注的字段值为 null 时，会认为校验失败而抛出异常。该注解不能用于字符串类型的校验，若要对字符串进行校验，应该使用 @NotBlank 或 @NotEmpty 注解。</p>
</li>
<li><p>@NotEmpty (集合类型长度大于0)</p>
<p> @NotEmpty 注解同样是 JSR 303 规范中定义的注解，对于 CharSequence、Collection、Map 或者数组对象类型的属性进行校验，校验时会检查该属性是否为 Null 或者 size()&#x3D;&#x3D;0，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败。</p>
</li>
<li><p>@NotBlank （字符串，不为null，切不为”  “字符串）</p>
<p> @NotBlank 注解是 Hibernate Validator 附加的注解，对于字符串类型的属性进行校验，校验时会检查该属性是否为 Null 或 “” 或者只包含空格，如果是的话就会校验失败。需要注意的是，@NotBlank 注解只能用于字符串类型的校验。</p>
</li>
</ol>
<p> 总之，这三种注解都是用于校验字段值是否为空的注解，但是其校验规则和用法有所不同。在进行数据校验时，需要根据具体情况选择合适的注解进行校验。</p>
</li>
</ol>
<p>使用</p>
<pre><code class="java">package com.chenw.pojo;


import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Past;
import lombok.Data;
import org.hibernate.validator.constraints.Length;

import java.util.Date;

/*
*   name 不为空和空字符串
*   字符串 notblank 集合notempy 包装notnull
*   password 长度大于6
*   age 必须大于等一
*   email 邮箱格式的字符串
*   birthday 过去时间
*
* */
@Data
public class User &#123;
    @NotBlank
    private String name;
    @Min(1)
    private int age;
    @Length(min = 6)
    private String password;
    @Email
    private String email;
    @Past
    private Date birthday;
&#125;
</code></pre>
<pre><code class="java">package com.chenw.user;

import com.chenw.pojo.User;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @FileName UserController
 * @Description
 * @Author 王昌晨
 * @date 2024-04-28
 **/

@RestController
@RequestMapping(&quot;/user&quot;)
public class UserController &#123;
    /*
    *   这里面还需要添加校验注解     @Validated
    * */
    @GetMapping(&quot;data&quot;)
    public User register(@Validated User user)&#123;
        System.out.println(&quot;user=&quot;+user);
        return user;
    &#125;
&#125;
</code></pre>
<pre><code>这些注解既可以检验param参数还可以检验json数据
</code></pre>
<pre><code class="java">package com.chenw.user;

import com.chenw.pojo.User;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

/**
 * @FileName UserController
 * @Description
 * @Author 王昌晨
 * @date 2024-04-28
 **/

@RestController
@RequestMapping(&quot;/user&quot;)
public class UserController &#123;
    /*
    *   这里面还需要添加校验注解     @Validated
    * */
    @PostMapping(&quot;data&quot;)
    public User register(@Validated @RequestBody User user)&#123;
        System.out.println(&quot;user=&quot;+user);
        return user;
    &#125;
&#125;
</code></pre>
<p>我们使用postman测试一下</p>
<p>符合规则的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240428193723906.png" alt="image-20240428193723906"></p>
<p>如果传递错误的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240428193906084.png" alt="image-20240428193906084"></p>
<p>就会出错</p>
<pre><code>现在有一个问题
    如果不符合的话，现在就会直接像前端抛出一个异常，我们需要自定义返回的结果
     捕捉错误信息绑定错误信息
     	1.参数位置添加  BindingResult参数  BindingResult参数必须紧挨着校验对象
     	2.通过BindingResult获取绑定错误
     	3.如果有绑定错误，就不直接返回，有我们自己决定
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240428194709957.png" alt="image-20240428194709957"></p>
<pre><code class="java">package com.chenw.user;

import com.chenw.pojo.User;
import org.springframework.validation.BindException;
import org.springframework.validation.BindingResult;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;

/**
 * @FileName UserController
 * @Description
 * @Author 王昌晨
 * @date 2024-04-28
 **/

@RestController
@RequestMapping(&quot;/user&quot;)
public class UserController &#123;
    /*
    *   这里面还需要添加校验注解     @Validated
    * */
    @PostMapping(&quot;data&quot;)
    public Object register(@Validated @RequestBody User user, BindingResult result)&#123;
        System.out.println(&quot;user=&quot;+user);
        if (result.hasErrors())&#123;
            HashMap data = new HashMap&lt;&gt;();
            data.put(&quot;code&quot;,404);
            data.put(&quot;message&quot;,&quot;参数检验异常&quot;);
            return data;
        &#125;
        return user;
    &#125;
&#125;
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 哈哈哈哈哈哈哈重生之我是兵王
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;chenw
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
