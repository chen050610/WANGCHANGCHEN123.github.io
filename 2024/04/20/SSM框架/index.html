
<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8" />
    <title>SSM框架 | 哈哈哈哈哈哈哈重生之我是兵王</title>
    <meta name="author" content="chenw" />
    <meta name="description" content="description" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
	<canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
	<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
	<script src="/js/fireworks.min.js"></script>
	<canvas id="background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
	<script src="/js/background.min.js"></script>
	<div id="cursor"></div>
	<link rel="stylesheet" href="/css/cursor.min.css">
	<script src="/js/cursor.min.js"></script>
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>哈哈哈哈哈哈哈重生之我是兵王</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;哈哈哈哈哈哈哈重生之我是兵王</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>SSM框架</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/4/20
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/chenw/" style="color: #00bcd4">chenw</a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/SSM%E5%AD%A6%E4%B9%A0/" style="color: #03a9f4">SSM学习</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p>摘要</p>
<span id="more"></span>

<p>内容</p>
<h1 id="SSM框架"><a href="#SSM框架" class="headerlink" title="SSM框架"></a>SSM框架</h1><p>课程的学习路线</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240420223535106.png" alt="image-20240420223535106"></p>
<p><strong>SpringFramework</strong></p>
<pre><code>SSM框架
    SpringMVC
    Spring
    MyBaits
</code></pre>
<p><strong>SpringFramework</strong></p>
<pre><code>广义的spring泛指Spring Framework为基础的Spring技术栈
 如
     Spring Framework
    Spring MVC
    SpringBoot	
    Spring Cloud
    Spring Data等
    
</code></pre>
<p><strong>广义的 Spring：Spring 技术栈</strong>（全家桶）</p>
<p>广义上的 Spring 泛指以 Spring Framework 为基础的 Spring 技术栈。</p>
<p>经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。</p>
<p><strong>狭义的 Spring：Spring Framework</strong>（基础框架）</p>
<p>狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。</p>
<p>Spring Framework（Spring框架）是一个开源的应用程序框架，由SpringSource公司开发，最初是为了解决企业级开发中各种常见问题而创建的。它提供了很多功能，例如：依赖注入（Dependency Injection）、面向切面编程（AOP）、声明式事务管理（TX）等。其主要目标是使企业级应用程序的开发变得更加简单和快速，并且Spring框架被广泛应用于Java企业开发领域。</p>
<p>Spring全家桶的其他框架都是以SpringFramework框架为基础！</p>
<p><strong>SpringFramework框架结构图</strong>：</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png" alt="img"></p>
<table>
<thead>
<tr>
<th>功能模块</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Core Container</td>
<td>核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。</td>
</tr>
<tr>
<td>AOP&amp;Aspects</td>
<td>面向切面编程</td>
</tr>
<tr>
<td>TX</td>
<td>声明式事务管理。</td>
</tr>
<tr>
<td>Spring MVC</td>
<td>提供了面向Web应用程序的集成功能。</td>
</tr>
</tbody></table>
<p><strong>SpringFramework 主要优势</strong></p>
<ol>
<li>丰富的生态系统：Spring 生态系统非常丰富，支持许多模块和库，如 Spring Boot、Spring Security、Spring Cloud 等等，可以帮助开发人员快速构建高可靠性的企业应用程序。</li>
<li>模块化的设计：框架组件之间的松散耦合和模块化设计使得 Spring Framework 具有良好的可重用性、可扩展性和可维护性。开发人员可以轻松地选择自己需要的模块，根据自己的需求进行开发。</li>
<li>简化 Java 开发：Spring Framework 简化了 Java 开发，提供了各种工具和 API，可以降低开发复杂度和学习成本。同时，Spring Framework 支持各种应用场景，包括 Web 应用程序、RESTful API、消息传递、批处理等等。</li>
<li>不断创新和发展：Spring Framework 开发团队一直在不断创新和发展，保持与最新技术的接轨，为开发人员提供更加先进和优秀的工具和框架。</li>
</ol>
<p>  因此，这些优点使得 Spring Framework 成为了一个稳定、可靠、且创新的框架，为企业级 Java 开发提供了一站式的解决方案。</p>
<p>  Spring 使创建 Java 企业应用程序变得容易。它提供了在企业环境中采用 Java 语言所需的一切，支持 Groovy 和 Kotlin 作为 JVM 上的替代语言，并且可以根据应用程序的需求灵活地创建多种架构。从Spring Framework 6.0.6开始，Spring 需要 Java 17+。</p>
<p><strong>Core Container</strong></p>
<p><strong>Spring IoC容器和核心概念</strong></p>
<ul>
<li><p>组件和组件管理的概念</p>
<p>之前的三层架构  control-service-dao</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png" alt="img"></p>
</li>
</ul>
<p>上面的整个业务就是各种组件搭建而成的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png" alt="img"></p>
<p>如果实现这样的功能就好了</p>
<ul>
<li>有人替我们创建组件的对象</li>
<li>有人帮我们保存组件的对象</li>
<li>有人帮助我们自动组装</li>
<li>有人替我们管理事务</li>
<li>有人协助我们整合其他框架</li>
</ul>
<p>所以这个 <strong>core Container</strong>就能充当这个功能</p>
<p><strong>Spring充当组件管理角色（IoC）</strong></p>
<p>组件可以完全交给Spring 框架进行管理，Spring框架替代了程序员原有的new对象和对象属性赋值动作等！</p>
<p>Spring具体的组件管理动作包含：</p>
<ul>
<li>组件对象实例化</li>
<li>组件属性属性赋值</li>
<li>组件对象之间引用</li>
<li>组件对象存活周期管理</li>
<li>……</li>
</ul>
<p>我们只需要编写元数据（配置文件）告知Spring 管理哪些类组件和他们的关系即可！</p>
<p>注意：组件是映射到应用程序中所有可重用组件的Java对象，应该是可复用的功能对象！</p>
<ul>
<li>组件一定是对象</li>
<li>对象不一定是组件</li>
</ul>
<p>综上所述，Spring 充当一个组件容器，创建、管理、存储组件，减少了我们的编码压力，让我们更加专注进行业务编写！</p>
<ul>
<li>组件就是可以复用的java对象</li>
</ul>
<p><strong>优点</strong></p>
<pre><code>1. 降低了组件之间的耦合性：Spring IoC容器通过依赖注入机制，将组件之间的依赖关系削弱，减少了程序组件之间的耦合性，使得组件更加松散地耦合。
2. 提高了代码的可重用性和可维护性：将组件的实例化过程、依赖关系的管理等功能交给Spring IoC容器处理，使得组件代码更加模块化、可重用、更易于维护。
3. 方便了配置和管理：Spring IoC容器通过XML文件或者注解，轻松的对组件进行配置和管理，使得组件的切换、替换等操作更加的方便和快捷。
4. 交给Spring管理的对象（组件），方可享受Spring框架的其他功能（AOP,声明事务管理）等
</code></pre>
<p><strong>Spring IoC容器和容器的实现</strong></p>
<p>普通的容器</p>
<blockquote>
<p>普通容器只能用来存储，没有更多功能。</p>
</blockquote>
<p>程序中的普通容器</p>
<ul>
<li>数组</li>
<li>集合：List</li>
<li>集合：Set</li>
</ul>
<p>复杂容器</p>
<p>  生活中的复杂容器  <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img003.6f9c041c.png"></p>
<blockquote>
<p>政府管理我们的一生，生老病死都和政府有关。</p>
</blockquote>
<p>  程序中的复杂容器</p>
<p>  Servlet 容器能够管理 Servlet(init,service,destroy)、Filter、Listener 这样的组件的一生，所以它是一个复杂容器。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>时机</th>
<th>次数</th>
</tr>
</thead>
<tbody><tr>
<td>创建对象</td>
<td>默认情况：接收到第一次请求  修改启动顺序后：Web应用启动过程中</td>
<td>一次</td>
</tr>
<tr>
<td>初始化操作</td>
<td>创建对象之后</td>
<td>一次</td>
</tr>
<tr>
<td>处理请求</td>
<td>接收到请求</td>
<td>多次</td>
</tr>
<tr>
<td>销毁操作</td>
<td>Web应用卸载之前</td>
<td>一次</td>
</tr>
</tbody></table>
<p>我们即将要学习的 SpringIoC 容器也是一个复杂容器。它们不仅要负责创建组件的对象、存储组件的对象，还要负责调用组件的方法让它们工作，最终在特定情况下销毁组件。</p>
<p>总结：Spring管理组件的容器，就是一个复杂容器，不仅存储组件，也可以管理组件之间依赖关系，并且创建和销毁组件等！</p>
<p>Spring IoC 容器，负责实例化、配置和组装 bean（组件）。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。配置元数据以 XML、Java 注解或 Java 代码形式表现。它允许表达组成应用程序的组件以及这些组件之间丰富的相互依赖关系。</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<p>上图显示了 Spring 容器工作原理的高级视图。应用程序类与配置元数据相结合，您拥有完全配置且可执行的系统或应用程序。</p>
<p><strong>SpringIoC容器具体接口和实现类</strong></p>
<p><strong>SpringIoc容器接口</strong>： </p>
<p><code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！</p>
<p><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。它扩展了以下功能：</p>
<ul>
<li>更容易与 Spring 的 AOP 功能集成</li>
<li>消息资源处理（用于国际化）</li>
<li>特定于应用程序给予此接口实现，例如Web 应用程序的 <code>WebApplicationContext</code></li>
</ul>
<p>简而言之， <code>BeanFactory</code> 提供了配置框架和基本功能，而 <code>ApplicationContext</code> 添加了更多特定于企业的功能。 <code>ApplicationContext</code> 是 <code>BeanFactory</code> 的完整超集！</p>
<p><strong>ApplicationContext容器实现类</strong>：</p>
<p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img004.f6680aef.png"></p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>ClassPathXmlApplicationContext</td>
<td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>FileSystemXmlApplicationContext</td>
<td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>AnnotationConfigApplicationContext</td>
<td>通过读取Java配置类创建 IOC 容器对象</td>
</tr>
<tr>
<td>WebApplicationContext</td>
<td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td>
</tr>
</tbody></table>
<p>总的来说是这样的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421104631981.png" alt="image-20240421104631981"></p>
<p><strong>SpringIoC容器管理配置方式</strong></p>
<p>Spring IoC 容器使用多种形式的配置元数据。此配置元数据表示您作为应用程序开发人员如何告诉 Spring 容器实例化、配置和组装应用程序中的对象。</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<p>Spring框架提供了多种配置方式：XML配置方式、注解方式和Java配置类方式</p>
<ol>
<li>XML配置方式：是Spring框架最早的配置方式之一，通过在XML文件中定义Bean及其依赖关系、Bean的作用域等信息，让Spring IoC容器来管理Bean之间的依赖关系。该方式从Spring框架的第一版开始提供支持。</li>
<li>注解方式：从Spring 2.5版本开始提供支持，可以通过在Bean类上使用注解来代替XML配置文件中的配置信息。通过在Bean类上加上相应的注解（如@Component, @Service, @Autowired等），将Bean注册到Spring IoC容器中，这样Spring IoC容器就可以管理这些Bean之间的依赖关系。</li>
<li><strong>Java配置类</strong>方式：从Spring 3.0版本开始提供支持，通过Java类来定义Bean、Bean之间的依赖关系和配置信息，从而代替XML配置文件的方式。Java配置类是一种使用Java编写配置信息的方式，通过@Configuration、@Bean等注解来实现Bean和依赖关系的配置。</li>
</ol>
<p>为了迎合当下开发环境，我们将以<strong>配置类+注解方式</strong>为主进行讲解！</p>
<p><strong>Spring IoC &#x2F; DI概念总结</strong></p>
<ul>
<li><p><strong>IoC容器</strong></p>
<p>Spring IoC 容器，负责实例化、配置和组装 bean（组件）核心容器。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。</p>
</li>
<li><p><strong>IoC（Inversion of Control）控制反转</strong></p>
<p>IoC 主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由 IoC 容器来创建和管理，即控制权由应用程序转移到 IoC 容器中，也就是“反转”了控制权。这种方式基本上是通过依赖查找的方式来实现的，即 IoC 容器维护着构成应用程序的对象，并负责创建这些对象。</p>
</li>
<li><p><strong>DI (Dependency Injection) 依赖注入</strong></p>
<p>DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，DI 是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter 方法注入和接口注入。</p>
</li>
</ul>
<p> <strong>Spring IoC &#x2F; DI 实现步骤</strong></p>
<blockquote>
<p>我们总结下，组件交给Spring IoC容器管理，并且获取和使用的基本步骤！</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421113253180.png" alt="image-20240421113253180"></p>
</blockquote>
<ol>
<li><p><strong>配置元数据（配置）</strong></p>
<p> 配置元数据，既是编写交给SpringIoC容器管理组件的信息，配置方式有三种。</p>
<p> 基于 XML 的配置元数据的基本结构：</p>
<p> &lt;bean id&#x3D;”…” [1] class&#x3D;”…” [2]&gt;</p>
</li>
</ol>
<pre><code>&lt;!-- collaborators and configuration for this bean go here --&gt;
</code></pre>
  </bean>

<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!-- 此处要添加一些约束，配置文件的标签并不是随意命名 --&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

  &lt;bean id=&quot;...&quot; [1] class=&quot;...&quot; [2]&gt;  
    &lt;!-- collaborators and configuration for this bean go here --&gt;
  &lt;/bean&gt;

  &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;
    &lt;!-- collaborators and configuration for this bean go here --&gt;
  &lt;/bean&gt;
  &lt;!-- more bean definitions go here --&gt;
&lt;/beans&gt;
</code></pre>
<pre><code>  Spring IoC 容器管理一个或多个组件。这些 组件是使用你提供给容器的配置元数据（例如，以 XML `&lt;bean/&gt;` 定义的形式）创建的。

  &lt;bean /&gt; 标签 == 组件信息声明

  - `id` 属性是标识单个 Bean 定义的字符串。
  - `class` 属性定义 Bean 的类型并使用完全限定的类名。
</code></pre>
<ol start="2">
<li><p><strong>实例化IoC容器</strong></p>
<p> 提供给 <code>ApplicationContext</code> 构造函数的位置路径是资源字符串地址，允许容器从各种外部资源（如本地文件系统、Java <code>CLASSPATH</code> 等）加载配置元数据。</p>
<p> 我们应该选择一个合适的容器实现类，进行IoC容器的实例化工作：</p>
</li>
</ol>
<pre><code class="Java">//实例化ioc容器,读取外部配置文件,最终会在容器内进行ioc和di动作
ApplicationContext context = 
           new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);
</code></pre>
<ol start="3">
<li><p><strong>获取Bean（组件）</strong></p>
<p> <code>ApplicationContext</code> 是一个高级工厂的接口，能够维护不同 bean 及其依赖项的注册表。通过使用方法 <code>T getBean(String name, Class&lt;T&gt; requiredType)</code> ，您可以检索 bean 的实例。</p>
<p> 允许读取 Bean 定义并访问它们，如以下示例所示：</p>
</li>
</ol>
<pre><code class="Java">//创建ioc容器对象，指定配置文件，ioc也开始实例组件对象
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);
//获取ioc容器的组件对象
PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class);
//使用组件对象
List&lt;String&gt; userList = service.getUsernameList();
</code></pre>
<p><strong>基于XML的方式配置组件的管理</strong></p>
<p><strong>组件（Bean）信息声明配置（IoC）</strong></p>
<ol>
<li><p>目标</p>
<p> Spring IoC 容器管理一个或多个 bean。这些 Bean 是使用您提供给容器的配置元数据创建的（例如，以 XML <code>&lt;bean/&gt;</code> 定义的形式）。</p>
<p> 我们学习，如何通过定义XML配置文件，声明组件类信息，交给 Spring 的 IoC 容器进行组件管理！</p>
</li>
<li><p>思路</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img006.c8bae859.png"></p>
</li>
<li><p>准备项目</p>
<ol>
<li><p>创建maven工程（spring-ioc-xml-01）</p>
</li>
<li><p>导入SpringIoC相关依赖</p>
<p> pom.xml</p>
</li>
</ol>
</li>
</ol>
<pre><code class="XML">&lt;dependencies&gt;
    &lt;!--spring context依赖--&gt;
    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;6.0.6&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--junit5测试--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ol start="4">
<li><p>基于无参数构造函数</p>
<blockquote>
<p>当通过构造函数方法创建一个 bean（组件对象） 时，所有普通类都可以由 Spring 使用并与之兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。只需指定 Bean 类信息就足够了。但是，默认情况下，我们需要一个默认（空）构造函数。</p>
</blockquote>
<ol>
<li>准备组件类</li>
</ol>
</li>
</ol>
<pre><code class="Java">package com.atguigu.ioc;


public class HappyComponent &#123;

    //默认包含无参数构造函数

    public void doWork() &#123;
        System.out.println(&quot;HappyComponent.doWork&quot;);
    &#125;
&#125;
</code></pre>
<pre><code>  2. xml配置文件编写

      创建携带spring约束的xml配置文件


      编写配置文件：

      文件：resources/spring-bean-01.xml
</code></pre>
<pre><code class="Java">&lt;!-- 实验一 [重要]创建bean --&gt;
&lt;bean id=&quot;happyComponent&quot; class=&quot;com.atguigu.ioc.HappyComponent&quot;/&gt;
</code></pre>
<pre><code>      - bean标签：通过配置bean标签告诉IOC容器需要创建对象的组件信息
      - id属性：bean的唯一标识,方便后期获取Bean！
      - class属性：组件类的全限定符！
      - 注意：要求当前组件类必须包含无参数构造函数！
</code></pre>
<ol start="5">
<li><p>基于静态工厂方法实例化</p>
<blockquote>
<p>除了使用构造函数实例化对象，还有一类是通过工厂模式实例化对象。接下来我们讲解如何定义使用静态工厂方法创建Bean的配置 ！</p>
</blockquote>
<ol>
<li>准备组件类</li>
</ol>
</li>
</ol>
<pre><code class="Java">public class ClientService &#123;
  private static ClientService clientService = new ClientService();
  private ClientService() &#123;&#125;

  public static ClientService createInstance() &#123;
  
    return clientService;
  &#125;
&#125;
</code></pre>
<pre><code>  2. xml配置文件编写

      文件：resources/spring-bean-01.xml
</code></pre>
<pre><code class="XML">&lt;bean id=&quot;clientService&quot;
  class=&quot;examples.ClientService&quot;
  factory-method=&quot;createInstance&quot;/&gt;
</code></pre>
<pre><code>      - class属性：指定工厂类的全限定符！
      - factory-method: 指定静态工厂方法，注意，该方法必须是static方法。
</code></pre>
<ol start="6">
<li><p>基于实例工厂方法实例化</p>
<blockquote>
<p>接下来我们讲解下如何定义使用实例工厂方法创建Bean的配置 ！</p>
</blockquote>
<ol>
<li>准备组建类</li>
</ol>
</li>
</ol>
<pre><code class="Java">package com.chenw.ioc_01;

public class DefaultServiceLocator &#123;

  private static ClientServiceImpl clientService = new ClientServiceImpl();

  public ClientServiceImpl createClientServiceInstance() &#123;
    return clientService;
  &#125;
&#125;
</code></pre>
<pre><code>  2. xml配置文件编写

      文件：resources/spring-bean-01.xml
</code></pre>
<pre><code class="XML">&lt;!-- 将工厂类进行ioc配置 --&gt;
&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;
&lt;/bean&gt;

&lt;!-- 根据工厂对象的实例工厂方法进行实例化组件对象 --&gt;
&lt;bean id=&quot;clientService&quot;
  factory-bean=&quot;serviceLocator&quot;
  factory-method=&quot;createClientServiceInstance&quot;/&gt;
</code></pre>
<pre><code>      - factory-bean属性：指定当前容器中工厂Bean 的名称。
      - factory-method:  指定实例工厂方法名。注意，实例方法必须是非static的！
</code></pre>
<ol start="7">
<li><p>图解IoC配置流程</p>
<p> <img src="https://secure2.wostatic.cn/static/mpqqiD6Bmbno45SpRwBNom/image.png?auth_key=1713670560-duArnWPbh3N648zpywt4TQ-0-a9a4e362a86ac845b548422894d84630"></p>
</li>
</ol>
<p><strong>组件之间的依赖注入的配置</strong></p>
<ol>
<li><p>目标</p>
<p> 通过配置文件,实现IoC容器中Bean之间的引用（依赖注入DI配置）。</p>
<p> 主要涉及注入场景：基于构造函数的依赖注入和基于 Setter 的依赖注入。</p>
</li>
<li><p>思路</p>
<p> <img src="https://secure2.wostatic.cn/static/opfLAb8XnCZDyPMm9BuiMc/image.png?auth_key=1713684087-bBRYsMKzN7SHz6zStP3DJ1-0-641ac1f4b0398f3884e4e5df5caa7e78"></p>
</li>
<li><p>基于构造函数的依赖注入（单个构造参数）</p>
<ol>
<li><p>介绍</p>
<p> 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。</p>
<p> 下面的示例演示一个只能通过构造函数注入进行依赖项注入的类！</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public class UserDao &#123;
&#125;


public class UserService &#123;
    
    private UserDao userDao;

    public UserService(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code>3. 编写配置文件

    文件：resources/spring-02.xml
</code></pre>
<pre><code class="XML">        &lt;!--引用和被引用的组件 必须全部在ioc容器--&gt;
    &lt;!--单个构造函数的注入--&gt;
    &lt;!--将他们呢都存放在ioc容器的--&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.chenw.ioc_02.UserDao&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.chenw.ioc_02.UserService&quot;&gt;
        &lt;!--这个参数作为构造函数参数传值的设置
        value   是直接的属性值,例如 String name = &quot;二狗子&quot; int age = 18
        ref   引用其他的bean bean的id值
        --&gt;
        &lt;constructor-arg  ref=&quot;userDao&quot; /&gt;
    &lt;/bean&gt;
</code></pre>
<pre><code>    - constructor-arg标签：可以引用构造参数 ref引用其他bean的标识。
</code></pre>
<ol start="4">
<li>基于构造函数的依赖注入（多构造参数解析）<ol>
<li><p>介绍</p>
<p> 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。</p>
<p> 下面的示例演示通过构造函数注入多个参数，参数包含其他bean和基本数据类型！</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public class UserDao &#123;
&#125;


public class UserService &#123;
    
    private UserDao userDao;
    
    private int age;
    
    private String name;

    public UserService(int age , String name ,UserDao userDao) &#123;
        this.userDao = userDao;
        this.age = age;
        this.name = name;
    &#125;
&#125;
</code></pre>
<pre><code>3. 编写配置文件
</code></pre>
<pre><code class="XML">&lt;!-- 场景1: 多参数，可以按照相应构造函数的顺序注入数据 --&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.chenw.ioc_02.UserDao&quot;/&gt;
    &lt;bean id=&quot;userService2&quot; class=&quot;com.chenw.ioc_02.UserService2&quot;&gt;
        &lt;!--第一种收按照顺序写 --&gt;
        &lt;constructor-arg    value=&quot;18&quot;/&gt;
        &lt;constructor-arg    value=&quot;二狗子&quot;/&gt;
        &lt;constructor-arg    ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;

&lt;!-- 场景2: 多参数，可以按照相应构造函数的参数的名字注入数据 --&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.chenw.ioc_02.UserDao&quot;/&gt;
    &lt;bean id=&quot;userService2&quot; class=&quot;com.chenw.ioc_02.UserService2&quot;&gt;
        &lt;!-- --&gt;
        &lt;constructor-arg  name=&quot;age&quot;  value=&quot;18&quot;/&gt;
        &lt;constructor-arg  name=&quot;name&quot;  value=&quot;二狗子&quot;/&gt;
        &lt;constructor-arg name=&quot;userDao&quot;   ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;

&lt;!-- 场景3: 多参数，可以按照相应构造函数的角标注入数据 
           index从0开始 构造函数(0,1,2....)
--&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.chenw.ioc_02.UserDao&quot;/&gt;
    &lt;bean id=&quot;userService2&quot; class=&quot;com.chenw.ioc_02.UserService2&quot;&gt;
        &lt;!-- --&gt;
        &lt;constructor-arg  index=&quot;0&quot;  value=&quot;18&quot;/&gt;
        &lt;constructor-arg  index=&quot;1&quot;  value=&quot;二狗子&quot;/&gt;
        &lt;constructor-arg index=&quot;2&quot;   ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<pre><code>    - constructor-arg标签：指定构造参数和对应的值
    - constructor-arg标签：name属性指定参数名、index属性指定参数角标、value属性指定普通属性值
</code></pre>
<ol start="5">
<li><strong>基于Setter方法依赖注入</strong><ol>
<li><p>介绍</p>
<p> 开发中，除了构造函数注入（DI）更多的使用的Setter方法进行注入！</p>
<p> 下面的示例演示一个只能使用纯 setter 注入进行依赖项注入的类。</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public Class MovieFinder&#123;

&#125;

public class SimpleMovieLister &#123;

  private MovieFinder movieFinder;
  
  private String movieName;

  public void setMovieFinder(MovieFinder movieFinder) &#123;
    this.movieFinder = movieFinder;
  &#125;
  
  public void setMovieName(String movieName)&#123;
    this.movieName = movieName;
  &#125;

  // business logic that actually uses the injected MovieFinder is omitted...
&#125;
</code></pre>
<pre><code>3. 编写配置文件
</code></pre>
<pre><code class="XML">    &lt;!--3.触发setter方法进行注入--&gt;
    &lt;bean id=&quot;movieFinder&quot; class=&quot;com.chenw.ioc_02.MovieFinder&quot;/&gt;
    &lt;bean id=&quot;simpleMovieLister&quot; class=&quot;com.chenw.ioc_02.SimpleMovieLister&quot;&gt;
        &lt;!--name -&gt; 属性名 （setter方法的 去掉setter方法的set并且首字母小写的值）
           例如
           setMovieFinder  -&gt;  movieFinder

           ref和value二选一和之前的使用一样

           这个本质的是找的set方法，不是找的属性
           --&gt;
        &lt;property name=&quot;movieFinder&quot; ref=&quot;movieFinder&quot;/&gt;
        &lt;property name=&quot;movieName&quot; value=&quot;消失的她&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<pre><code>    - property标签： 可以给setter方法对应的属性赋值
    - property 标签： name属性代表**set方法标识**、ref代表引用bean的标识id、value属性代表基本属性值
</code></pre>
<p><strong>总结：</strong></p>
<p>  依赖注入（DI）包含引用类型和基本数据类型，同时注入的方式也有多种！主流的注入方式为setter方法注入和构造函数注入，两种注入语法都需要掌握！</p>
<p>  需要特别注意：引用其他bean，使用ref属性。直接注入基本类型值，使用value属性。</p>
<h4 id="4-2-2-实验二：-组件（Bean）依赖注入配置（DI）"><a href="#4-2-2-实验二：-组件（Bean）依赖注入配置（DI）" class="headerlink" title="4.2.2 实验二： 组件（Bean）依赖注入配置（DI）"></a>4.2.2 实验二： 组件（Bean）依赖注入配置（DI）</h4><ol>
<li><p>目标</p>
<p> 通过配置文件,实现IoC容器中Bean之间的引用（依赖注入DI配置）。</p>
<p> 主要涉及注入场景：基于构造函数的依赖注入和基于 Setter 的依赖注入。</p>
</li>
<li><p>思路</p>
<p> <img src="https://secure2.wostatic.cn/static/opfLAb8XnCZDyPMm9BuiMc/image.png?auth_key=1713684087-bBRYsMKzN7SHz6zStP3DJ1-0-641ac1f4b0398f3884e4e5df5caa7e78"></p>
</li>
<li><p>基于构造函数的依赖注入（单个构造参数）</p>
<ol>
<li><p>介绍</p>
<p> 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。</p>
<p> 下面的示例演示一个只能通过构造函数注入进行依赖项注入的类！</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public class UserDao &#123;
&#125;


public class UserService &#123;
    
    private UserDao userDao;

    public UserService(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code>  3. 编写配置文件

      文件：resources/spring-02.xml
</code></pre>
<pre><code class="XML">&lt;beans&gt;
  &lt;!-- 引用类bean声明 --&gt;
  &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt;
   &lt;!-- 构造函数引用 --&gt;
    &lt;constructor-arg ref=&quot;userDao&quot;/&gt;
  &lt;/bean&gt;
  &lt;!-- 被引用类bean声明 --&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code>      - constructor-arg标签：可以引用构造参数 ref引用其他bean的标识。
</code></pre>
<ol start="4">
<li>基于构造函数的依赖注入（多构造参数解析）<ol>
<li><p>介绍</p>
<p> 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。</p>
<p> 下面的示例演示通过构造函数注入多个参数，参数包含其他bean和基本数据类型！</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public class UserDao &#123;
&#125;


public class UserService &#123;
    
    private UserDao userDao;
    
    private int age;
    
    private String name;

    public UserService(int age , String name ,UserDao userDao) &#123;
        this.userDao = userDao;
        this.age = age;
        this.name = name;
    &#125;
&#125;
</code></pre>
<pre><code>  3. 编写配置文件
</code></pre>
<pre><code class="XML">&lt;!-- 场景1: 多参数，可以按照相应构造函数的顺序注入数据 --&gt;
&lt;beans&gt;
  &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt;
    &lt;!-- value直接注入基本类型值 --&gt;
    &lt;constructor-arg  value=&quot;18&quot;/&gt;
    &lt;constructor-arg  value=&quot;赵伟风&quot;/&gt;
    
    &lt;constructor-arg  ref=&quot;userDao&quot;/&gt;
  &lt;/bean&gt;
  &lt;!-- 被引用类bean声明 --&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;
&lt;/beans&gt;


&lt;!-- 场景2: 多参数，可以按照相应构造函数的名称注入数据 --&gt;
&lt;beans&gt;
  &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt;
    &lt;!-- value直接注入基本类型值 --&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;赵伟风&quot;/&gt;
    &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;constructor-arg name=&quot;age&quot;  value=&quot;18&quot;/&gt;
  &lt;/bean&gt;
  &lt;!-- 被引用类bean声明 --&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;
&lt;/beans&gt;

&lt;!-- 场景2: 多参数，可以按照相应构造函数的角标注入数据 
           index从0开始 构造函数(0,1,2....)
--&gt;
&lt;beans&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt;
    &lt;!-- value直接注入基本类型值 --&gt;
    &lt;constructor-arg index=&quot;1&quot; value=&quot;赵伟风&quot;/&gt;
    &lt;constructor-arg index=&quot;2&quot; ref=&quot;userDao&quot;/&gt;
    &lt;constructor-arg index=&quot;0&quot;  value=&quot;18&quot;/&gt;
  &lt;/bean&gt;
  &lt;!-- 被引用类bean声明 --&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code>      - constructor-arg标签：指定构造参数和对应的值
      - constructor-arg标签：name属性指定参数名、index属性指定参数角标、value属性指定普通属性值
</code></pre>
<ol start="5">
<li><strong>基于Setter方法依赖注入</strong><ol>
<li><p>介绍</p>
<p> 开发中，除了构造函数注入（DI）更多的使用的Setter方法进行注入！</p>
<p> 下面的示例演示一个只能使用纯 setter 注入进行依赖项注入的类。</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public Class MovieFinder&#123;

&#125;

public class SimpleMovieLister &#123;

  private MovieFinder movieFinder;
  
  private String movieName;

  public void setMovieFinder(MovieFinder movieFinder) &#123;
    this.movieFinder = movieFinder;
  &#125;
  
  public void setMovieName(String movieName)&#123;
    this.movieName = movieName;
  &#125;

  // business logic that actually uses the injected MovieFinder is omitted...
&#125;
</code></pre>
<pre><code>  3. 编写配置文件
</code></pre>
<pre><code class="XML">&lt;bean id=&quot;simpleMovieLister&quot; class=&quot;examples.SimpleMovieLister&quot;&gt;
  &lt;!-- setter方法，注入movieFinder对象的标识id
       name = 属性名  ref = 引用bean的id值
   --&gt;
  &lt;property name=&quot;movieFinder&quot; ref=&quot;movieFinder&quot; /&gt;

  &lt;!-- setter方法，注入基本数据类型movieName
       name = 属性名 value= 基本类型值
   --&gt;
  &lt;property name=&quot;movieName&quot; value=&quot;消失的她&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;movieFinder&quot; class=&quot;examples.MovieFinder&quot;/&gt;
</code></pre>
<pre><code>      - property标签： 可以给setter方法对应的属性赋值
      - property 标签： name属性代表**set方法标识**、ref代表引用bean的标识id、value属性代表基本属性值
</code></pre>
<p>  <strong>总结：</strong></p>
<pre><code>依赖注入（DI）包含引用类型和基本数据类型，同时注入的方式也有多种！主流的注入方式为setter方法注入和构造函数注入，两种注入语法都需要掌握！

需要特别注意：引用其他bean，使用ref属性。直接注入基本类型值，使用value属性。
</code></pre>
<p> <strong>IoC容器创建和使用</strong></p>
<ol>
<li><p>介绍</p>
<p> 上面的实验只是讲解了如何在XML格式的配置文件编写IoC和DI配置！</p>
<p> 如图：</p>
<p> <img src="https://secure2.wostatic.cn/static/ngQZT7qhVfAzTxrr2oX1ny/image.png?auth_key=1713686158-sbfHvbb8SRsw7s3ZkFgXtY-0-f2d76343dcd8e0eff2fb9205ed5498ca"></p>
<p> 想要配置文件中声明组件类信息真正的进行实例化成Bean对象和形成Bean之间的引用关系，我们需要声明IoC容器对象，读取配置文件，实例化组件和关系维护的过程都是在IoC容器中实现的！</p>
</li>
<li><p>容器实例化</p>
</li>
</ol>
<pre><code class="Java">//方式1:实例化并且指定配置文件
//参数：String...locations 传入一个或者多个配置文件
ApplicationContext context = 
           new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);
           
//方式2:先实例化，再指定配置文件，最后刷新容器触发Bean实例化动作 [springmvc源码和contextLoadListener源码方式]  
ApplicationContext context = 
           new ClassPathXmlApplicationContext();   
//设置配置配置文件,方法参数为可变参数,可以设置一个或者多个配置
iocContainer1.setConfigLocations(&quot;services.xml&quot;, &quot;daos.xml&quot;);
//后配置的文件,需要调用refresh方法,触发刷新配置
iocContainer1.refresh();           
</code></pre>
<ol start="3">
<li>Bean对象读取</li>
</ol>
<pre><code class="Java">//方式1: 根据id获取
//没有指定类型,返回为Object,需要类型转化!
HappyComponent happyComponent = 
        (HappyComponent) iocContainer.getBean(&quot;bean的id标识&quot;);
        
//使用组件对象        
happyComponent.doWork();

//方式2: 根据类型获取
//根据类型获取,但是要求,同类型(当前类,或者之类,或者接口的实现类)只能有一个对象交给IoC容器管理
//配置两个或者以上出现: org.springframework.beans.factory.NoUniqueBeanDefinitionException 问题
HappyComponent happyComponent = iocContainer.getBean(HappyComponent.class);
happyComponent.doWork();

//方式3: 根据id和类型获取
HappyComponent happyComponent = iocContainer.getBean(&quot;bean的id标识&quot;, HappyComponent.class);
happyComponent.doWork();

根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，
只要返回的是true就可以认定为和类型匹配，能够获取到。
</code></pre>
<p>演示</p>
<pre><code class="java">package com.chenw.test;

import com.chenw.ioc_03.HappyComponent;
import org.junit.jupiter.api.Test;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringIoCTest &#123;
    /*
    * 如何创建ioc容器并且读取配置文件
    * */
    public void createIoC()&#123;
        //创建容器，选择合适的容器实现
        /*
        *接口
        * BeanFactory
        *   ApplicationContext
        * 实现类
        *   直接通过构造函数实例化
        *   ClassPathXmlApplicationContext
        *   FileSystemXmlApplicationContext
        *   AnnotationConfigApplicationContext
        *   WebApplicationContext
        *
        * */
        //构造函数（string...配置文件）可以写一个或者多个，推荐
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-03.xml&quot;);
        //先创建
        ClassPathXmlApplicationContext applicationContext1 = new ClassPathXmlApplicationContext();
        //外部配置文件的配置
        applicationContext1.setConfigLocations(&quot;spring-03.xml&quot;);
        //调用ioc和di的流程
        applicationContext1.refresh();


    &#125;
    /*
    *   如何在Ioc容器中获取组件Bean
    * */
    @Test
    public void getBeanFromIoC()&#123;
        //1.创建容器
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext();
        applicationContext.setConfigLocations(&quot;spring-03.xml&quot;);
        applicationContext.refresh();

        //2.读取ioc容器的组件
        //方案1:根据bean的id获取 返回值为object,这种需要强转不推荐
        HappyComponent happyComponent = (HappyComponent)applicationContext.getBean(&quot;happyComponent&quot;);
        //方案2:根据bean的id和类型获取
        HappyComponent happyComponent1 = applicationContext.getBean(&quot;happyComponent&quot;, HappyComponent.class);
        //方案3:直接根据类型获取
        HappyComponent bean = applicationContext.getBean(HappyComponent.class);
        happyComponent.doWork();  //HappyComponent.doWork
        happyComponent1.doWork(); //HappyComponent.doWork
        bean.doWork();   //HappyComponent.doWor

        //而且创建的都是同一个对象
        System.out.println(happyComponent1==happyComponent); //true
        System.out.println(happyComponent1==bean); //true
    &#125;

&#125;
</code></pre>
<pre><code class="xml">注意第三中方法，通过类的类对象作为参数可能出现一些问题 
如果下面这样，这样第三种方法就会出错
    &lt;bean id=&quot;happyComponent&quot; class=&quot;com.chenw.ioc_03.HappyComponent&quot;/&gt;
    &lt;bean id=&quot;happyComponent1&quot; class=&quot;com.chenw.ioc_03.HappyComponent&quot;/&gt;
</code></pre>
<pre><code class="java">还有一个注意点
第三中方法，如果该类实现一个接口吗，下面这些操作也是可行的，因为参数的判断是通过 instanceof
    例如
    package com.chenw.ioc_03;

public interface A &#123;
    void doWork();
&#125;

实现
package com.chenw.ioc_03;


public class HappyComponent implements A &#123;

    //默认包含无参数构造函数

    public void doWork() &#123;
        System.out.println(&quot;HappyComponent.doWork&quot;);
    &#125;
&#125;

配置
    &lt;bean id=&quot;happyComponent&quot; class=&quot;com.chenw.ioc_03.HappyComponent&quot;/&gt;
测试类
            A bean = applicationContext.getBean(A.class);
            bean.doWork();   //HappyComponent.doWork
</code></pre>
<p><strong>组件(bean)的作用域和周期方法的配置</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421165645730.png" alt="image-20240421165645730"></p>
<pre><code>我们可以组件类里面声明周期方法，然后通过配置文件告诉容器
</code></pre>
<ol>
<li>组件周期方法配置<ol>
<li><p>周期方法概念</p>
<p> 我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！</p>
<p> 类似于Servlet的init&#x2F;destroy方法,我们可以在周期方法完成初始化和释放资源等工作。</p>
</li>
<li><p>周期方法声明</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">package com.chenw.ioc_04;

public class JavaBean &#123;
    /*
    * 必须public 必须是void返回值 必须是无参数的
    * 命名是随意的的
    *
    * */
    public void init()&#123;
        System.out.println(&quot;javaBean.init&quot;);
    &#125;
    public void clear()&#123;
        System.out.println(&quot;JavaBean,clear&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">3. 周期方法配置
    &lt;bean id=&quot;javaBean&quot; class=&quot;com.chenw.ioc_04.JavaBean&quot; init-method=&quot;init&quot; destroy-method=&quot;clear&quot;/&gt;
</code></pre>
<pre><code class="xml">&lt;beans&gt;
  &lt;bean id=&quot;beanOne&quot; class=&quot;examples.BeanOne&quot; init-method=&quot;init&quot; /&gt;
  &lt;bean id=&quot;beanTwo&quot; class=&quot;examples.BeanTwo&quot; destroy-method=&quot;cleanup&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<p>例如</p>
<p>上面配置玩以后</p>
<pre><code class="java">    @Test
    public void Test_o4()&#123;
        //但我们创建ioc容器的时候 就会对组件实例化 ，然后就会调用初始化方法
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring_04.xml&quot;);
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421171007793.png" alt="image-20240421171007793"></p>
<p>怎么调用销毁呢？</p>
<pre><code class="java">    @Test
    public void Test_o4()&#123;
        //但我们创建ioc容器的时候 就会对组件实例化 ，然后就会调用初始化方法
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring_04.xml&quot;);

        //怎么调用销毁的方法呢？
        //当我们代码执行玩以后，ioc直接就会释放掉，没有机会去调用组件的销毁方法
        // 需要手动销毁ioc
        applicationContext.close();
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421171336304.png" alt="image-20240421171336304"></p>
<p>2.组件作用域配置</p>
<ol>
<li><p>Bean作用域概念</p>
<p> <code>&lt;bean</code> 标签声明Bean，只是将Bean的信息配置给SpringIoC容器！</p>
<p> 在IoC容器中，这些<code>&lt;bean</code>标签对应的信息转成Spring内部 <code>BeanDefinition</code> 对象，<code>BeanDefinition</code> 对象内，包含定义的信息（id,class,属性等等）！</p>
<p> 这意味着，<code>BeanDefinition</code>与<code>类</code>概念一样，SpringIoC容器可以可以根据<code>BeanDefinition</code>对象反射创建多个Bean对象实例。</p>
<p> 具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！</p>
</li>
<li><p>作用域可选值</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>在 IOC 容器中，这个 bean 的对象始终为单实例</td>
<td>IOC 容器初始化时</td>
<td>是</td>
</tr>
<tr>
<td>prototype</td>
<td>这个 bean 在 IOC 容器中有多个实例</td>
<td>获取 bean 时</td>
<td>否</td>
</tr>
</tbody></table>
<pre><code>    如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）：
</code></pre>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>request</td>
<td>请求范围内有效的实例</td>
<td>每次请求</td>
<td>否</td>
</tr>
<tr>
<td>session</td>
<td>会话范围内有效的实例</td>
<td>每次会话</td>
<td>否</td>
</tr>
</tbody></table>
<pre><code>3. 作用域配置

    配置scope范围
</code></pre>
<pre><code class="XML">&lt;!--bean的作用域 
    准备两个引用关系的组件类即可！！
--&gt;
&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;
&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;
&lt;bean id=&quot;happyMachine8&quot; scope=&quot;prototype&quot; class=&quot;com.atguigu.ioc.HappyMachine&quot;&gt;
    &lt;property name=&quot;machineName&quot; value=&quot;happyMachine&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;happyComponent8&quot; scope=&quot;singleton&quot; class=&quot;com.atguigu.ioc.HappyComponent&quot;&gt;
    &lt;property name=&quot;componentName&quot; value=&quot;happyComponent&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code>4. 作用域测试
</code></pre>
<pre><code class="Java">@Test
public void testExperiment08()  &#123;
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(&quot;配置文件名&quot;);

    HappyMachine bean = iocContainer.getBean(HappyMachine.class);
    HappyMachine bean1 = iocContainer.getBean(HappyMachine.class);
    //多例对比 false
    System.out.println(bean == bean1);

    HappyComponent bean2 = iocContainer.getBean(HappyComponent.class);
    HappyComponent bean3 = iocContainer.getBean(HappyComponent.class);
    //单例对比 true
    System.out.println(bean2 == bean3);
&#125;
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 哈哈哈哈哈哈哈重生之我是兵王
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;chenw
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
