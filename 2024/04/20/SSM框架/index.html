
<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8" />
    <title>SSM框架 | 哈哈哈哈哈哈哈重生之我是兵王</title>
    <meta name="author" content="chenw" />
    <meta name="description" content="description" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
	<canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
	<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
	<script src="/js/fireworks.min.js"></script>
	<canvas id="background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
	<script src="/js/background.min.js"></script>
	<div id="cursor"></div>
	<link rel="stylesheet" href="/css/cursor.min.css">
	<script src="/js/cursor.min.js"></script>
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>哈哈哈哈哈哈哈重生之我是兵王</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;哈哈哈哈哈哈哈重生之我是兵王</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>SSM框架</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/4/20
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/chenw/" style="color: #00bcd4">chenw</a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/SSM%E5%AD%A6%E4%B9%A0/" style="color: #ffa2c4">SSM学习</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p>摘要</p>
<span id="more"></span>

<p>内容</p>
<h1 id="SSM框架"><a href="#SSM框架" class="headerlink" title="SSM框架"></a>SSM框架</h1><p>课程的学习路线</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240420223535106.png" alt="image-20240420223535106"></p>
<p><strong>SpringFramework</strong></p>
<pre><code>SSM框架
    SpringMVC
    Spring
    MyBaits
</code></pre>
<p><strong>SpringFramework</strong></p>
<pre><code>广义的spring泛指Spring Framework为基础的Spring技术栈
 如
     Spring Framework
    Spring MVC
    SpringBoot	
    Spring Cloud
    Spring Data等
    
</code></pre>
<p><strong>广义的 Spring：Spring 技术栈</strong>（全家桶）</p>
<p>广义上的 Spring 泛指以 Spring Framework 为基础的 Spring 技术栈。</p>
<p>经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。</p>
<p><strong>狭义的 Spring：Spring Framework</strong>（基础框架）</p>
<p>狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。</p>
<p>Spring Framework（Spring框架）是一个开源的应用程序框架，由SpringSource公司开发，最初是为了解决企业级开发中各种常见问题而创建的。它提供了很多功能，例如：依赖注入（Dependency Injection）、面向切面编程（AOP）、声明式事务管理（TX）等。其主要目标是使企业级应用程序的开发变得更加简单和快速，并且Spring框架被广泛应用于Java企业开发领域。</p>
<p>Spring全家桶的其他框架都是以SpringFramework框架为基础！</p>
<p><strong>SpringFramework框架结构图</strong>：</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png" alt="img"></p>
<table>
<thead>
<tr>
<th>功能模块</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Core Container</td>
<td>核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。</td>
</tr>
<tr>
<td>AOP&amp;Aspects</td>
<td>面向切面编程</td>
</tr>
<tr>
<td>TX</td>
<td>声明式事务管理。</td>
</tr>
<tr>
<td>Spring MVC</td>
<td>提供了面向Web应用程序的集成功能。</td>
</tr>
</tbody></table>
<p><strong>SpringFramework 主要优势</strong></p>
<ol>
<li>丰富的生态系统：Spring 生态系统非常丰富，支持许多模块和库，如 Spring Boot、Spring Security、Spring Cloud 等等，可以帮助开发人员快速构建高可靠性的企业应用程序。</li>
<li>模块化的设计：框架组件之间的松散耦合和模块化设计使得 Spring Framework 具有良好的可重用性、可扩展性和可维护性。开发人员可以轻松地选择自己需要的模块，根据自己的需求进行开发。</li>
<li>简化 Java 开发：Spring Framework 简化了 Java 开发，提供了各种工具和 API，可以降低开发复杂度和学习成本。同时，Spring Framework 支持各种应用场景，包括 Web 应用程序、RESTful API、消息传递、批处理等等。</li>
<li>不断创新和发展：Spring Framework 开发团队一直在不断创新和发展，保持与最新技术的接轨，为开发人员提供更加先进和优秀的工具和框架。</li>
</ol>
<p>  因此，这些优点使得 Spring Framework 成为了一个稳定、可靠、且创新的框架，为企业级 Java 开发提供了一站式的解决方案。</p>
<p>  Spring 使创建 Java 企业应用程序变得容易。它提供了在企业环境中采用 Java 语言所需的一切，支持 Groovy 和 Kotlin 作为 JVM 上的替代语言，并且可以根据应用程序的需求灵活地创建多种架构。从Spring Framework 6.0.6开始，Spring 需要 Java 17+。</p>
<p><strong>Core Container</strong></p>
<p><strong>Spring IoC容器和核心概念</strong></p>
<ul>
<li><p>组件和组件管理的概念</p>
<p>之前的三层架构  control-service-dao</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png" alt="img"></p>
</li>
</ul>
<p>上面的整个业务就是各种组件搭建而成的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png" alt="img"></p>
<p>如果实现这样的功能就好了</p>
<ul>
<li>有人替我们创建组件的对象</li>
<li>有人帮我们保存组件的对象</li>
<li>有人帮助我们自动组装</li>
<li>有人替我们管理事务</li>
<li>有人协助我们整合其他框架</li>
</ul>
<p>所以这个 <strong>core Container</strong>就能充当这个功能</p>
<p><strong>Spring充当组件管理角色（IoC）</strong></p>
<p>组件可以完全交给Spring 框架进行管理，Spring框架替代了程序员原有的new对象和对象属性赋值动作等！</p>
<p>Spring具体的组件管理动作包含：</p>
<ul>
<li>组件对象实例化</li>
<li>组件属性属性赋值</li>
<li>组件对象之间引用</li>
<li>组件对象存活周期管理</li>
<li>……</li>
</ul>
<p>我们只需要编写元数据（配置文件）告知Spring 管理哪些类组件和他们的关系即可！</p>
<p>注意：组件是映射到应用程序中所有可重用组件的Java对象，应该是可复用的功能对象！</p>
<ul>
<li>组件一定是对象</li>
<li>对象不一定是组件</li>
</ul>
<p>综上所述，Spring 充当一个组件容器，创建、管理、存储组件，减少了我们的编码压力，让我们更加专注进行业务编写！</p>
<ul>
<li>组件就是可以复用的java对象</li>
</ul>
<p><strong>优点</strong></p>
<pre><code>1. 降低了组件之间的耦合性：Spring IoC容器通过依赖注入机制，将组件之间的依赖关系削弱，减少了程序组件之间的耦合性，使得组件更加松散地耦合。
2. 提高了代码的可重用性和可维护性：将组件的实例化过程、依赖关系的管理等功能交给Spring IoC容器处理，使得组件代码更加模块化、可重用、更易于维护。
3. 方便了配置和管理：Spring IoC容器通过XML文件或者注解，轻松的对组件进行配置和管理，使得组件的切换、替换等操作更加的方便和快捷。
4. 交给Spring管理的对象（组件），方可享受Spring框架的其他功能（AOP,声明事务管理）等
</code></pre>
<p><strong>Spring IoC容器和容器的实现</strong></p>
<p>普通的容器</p>
<blockquote>
<p>普通容器只能用来存储，没有更多功能。</p>
</blockquote>
<p>程序中的普通容器</p>
<ul>
<li>数组</li>
<li>集合：List</li>
<li>集合：Set</li>
</ul>
<p>复杂容器</p>
<p>  生活中的复杂容器  <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img003.6f9c041c.png"></p>
<blockquote>
<p>政府管理我们的一生，生老病死都和政府有关。</p>
</blockquote>
<p>  程序中的复杂容器</p>
<p>  Servlet 容器能够管理 Servlet(init,service,destroy)、Filter、Listener 这样的组件的一生，所以它是一个复杂容器。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>时机</th>
<th>次数</th>
</tr>
</thead>
<tbody><tr>
<td>创建对象</td>
<td>默认情况：接收到第一次请求  修改启动顺序后：Web应用启动过程中</td>
<td>一次</td>
</tr>
<tr>
<td>初始化操作</td>
<td>创建对象之后</td>
<td>一次</td>
</tr>
<tr>
<td>处理请求</td>
<td>接收到请求</td>
<td>多次</td>
</tr>
<tr>
<td>销毁操作</td>
<td>Web应用卸载之前</td>
<td>一次</td>
</tr>
</tbody></table>
<p>我们即将要学习的 SpringIoC 容器也是一个复杂容器。它们不仅要负责创建组件的对象、存储组件的对象，还要负责调用组件的方法让它们工作，最终在特定情况下销毁组件。</p>
<p>总结：Spring管理组件的容器，就是一个复杂容器，不仅存储组件，也可以管理组件之间依赖关系，并且创建和销毁组件等！</p>
<p>Spring IoC 容器，负责实例化、配置和组装 bean（组件）。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。配置元数据以 XML、Java 注解或 Java 代码形式表现。它允许表达组成应用程序的组件以及这些组件之间丰富的相互依赖关系。</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<p>上图显示了 Spring 容器工作原理的高级视图。应用程序类与配置元数据相结合，您拥有完全配置且可执行的系统或应用程序。</p>
<p><strong>SpringIoC容器具体接口和实现类</strong></p>
<p><strong>SpringIoc容器接口</strong>： </p>
<p><code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！</p>
<p><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。它扩展了以下功能：</p>
<ul>
<li>更容易与 Spring 的 AOP 功能集成</li>
<li>消息资源处理（用于国际化）</li>
<li>特定于应用程序给予此接口实现，例如Web 应用程序的 <code>WebApplicationContext</code></li>
</ul>
<p>简而言之， <code>BeanFactory</code> 提供了配置框架和基本功能，而 <code>ApplicationContext</code> 添加了更多特定于企业的功能。 <code>ApplicationContext</code> 是 <code>BeanFactory</code> 的完整超集！</p>
<p><strong>ApplicationContext容器实现类</strong>：</p>
<p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img004.f6680aef.png"></p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>ClassPathXmlApplicationContext</td>
<td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>FileSystemXmlApplicationContext</td>
<td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>AnnotationConfigApplicationContext</td>
<td>通过读取Java配置类创建 IOC 容器对象</td>
</tr>
<tr>
<td>WebApplicationContext</td>
<td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td>
</tr>
</tbody></table>
<p>总的来说是这样的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421104631981.png" alt="image-20240421104631981"></p>
<p><strong>SpringIoC容器管理配置方式</strong></p>
<p>Spring IoC 容器使用多种形式的配置元数据。此配置元数据表示您作为应用程序开发人员如何告诉 Spring 容器实例化、配置和组装应用程序中的对象。</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<p>Spring框架提供了多种配置方式：XML配置方式、注解方式和Java配置类方式</p>
<ol>
<li>XML配置方式：是Spring框架最早的配置方式之一，通过在XML文件中定义Bean及其依赖关系、Bean的作用域等信息，让Spring IoC容器来管理Bean之间的依赖关系。该方式从Spring框架的第一版开始提供支持。</li>
<li>注解方式：从Spring 2.5版本开始提供支持，可以通过在Bean类上使用注解来代替XML配置文件中的配置信息。通过在Bean类上加上相应的注解（如@Component, @Service, @Autowired等），将Bean注册到Spring IoC容器中，这样Spring IoC容器就可以管理这些Bean之间的依赖关系。</li>
<li><strong>Java配置类</strong>方式：从Spring 3.0版本开始提供支持，通过Java类来定义Bean、Bean之间的依赖关系和配置信息，从而代替XML配置文件的方式。Java配置类是一种使用Java编写配置信息的方式，通过@Configuration、@Bean等注解来实现Bean和依赖关系的配置。</li>
</ol>
<p>为了迎合当下开发环境，我们将以<strong>配置类+注解方式</strong>为主进行讲解！</p>
<p><strong>Spring IoC &#x2F; DI概念总结</strong></p>
<ul>
<li><p><strong>IoC容器</strong></p>
<p>Spring IoC 容器，负责实例化、配置和组装 bean（组件）核心容器。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。</p>
</li>
<li><p><strong>IoC（Inversion of Control）控制反转</strong></p>
<p>IoC 主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由 IoC 容器来创建和管理，即控制权由应用程序转移到 IoC 容器中，也就是“反转”了控制权。这种方式基本上是通过依赖查找的方式来实现的，即 IoC 容器维护着构成应用程序的对象，并负责创建这些对象。</p>
</li>
<li><p><strong>DI (Dependency Injection) 依赖注入</strong></p>
<p>DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，DI 是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter 方法注入和接口注入。</p>
</li>
</ul>
<p> <strong>Spring IoC &#x2F; DI 实现步骤</strong></p>
<blockquote>
<p>我们总结下，组件交给Spring IoC容器管理，并且获取和使用的基本步骤！</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421113253180.png" alt="image-20240421113253180"></p>
</blockquote>
<ol>
<li><p><strong>配置元数据（配置）</strong></p>
<p> 配置元数据，既是编写交给SpringIoC容器管理组件的信息，配置方式有三种。</p>
<p> 基于 XML 的配置元数据的基本结构：</p>
<p> &lt;bean id&#x3D;”…” [1] class&#x3D;”…” [2]&gt;</p>
</li>
</ol>
<pre><code>&lt;!-- collaborators and configuration for this bean go here --&gt;
</code></pre>
  </bean>

<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!-- 此处要添加一些约束，配置文件的标签并不是随意命名 --&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

  &lt;bean id=&quot;...&quot; [1] class=&quot;...&quot; [2]&gt;  
    &lt;!-- collaborators and configuration for this bean go here --&gt;
  &lt;/bean&gt;

  &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;
    &lt;!-- collaborators and configuration for this bean go here --&gt;
  &lt;/bean&gt;
  &lt;!-- more bean definitions go here --&gt;
&lt;/beans&gt;
</code></pre>
<pre><code>  Spring IoC 容器管理一个或多个组件。这些 组件是使用你提供给容器的配置元数据（例如，以 XML `&lt;bean/&gt;` 定义的形式）创建的。

  &lt;bean /&gt; 标签 == 组件信息声明

  - `id` 属性是标识单个 Bean 定义的字符串。
  - `class` 属性定义 Bean 的类型并使用完全限定的类名。
</code></pre>
<ol start="2">
<li><p><strong>实例化IoC容器</strong></p>
<p> 提供给 <code>ApplicationContext</code> 构造函数的位置路径是资源字符串地址，允许容器从各种外部资源（如本地文件系统、Java <code>CLASSPATH</code> 等）加载配置元数据。</p>
<p> 我们应该选择一个合适的容器实现类，进行IoC容器的实例化工作：</p>
</li>
</ol>
<pre><code class="Java">//实例化ioc容器,读取外部配置文件,最终会在容器内进行ioc和di动作
ApplicationContext context = 
           new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);
</code></pre>
<ol start="3">
<li><p><strong>获取Bean（组件）</strong></p>
<p> <code>ApplicationContext</code> 是一个高级工厂的接口，能够维护不同 bean 及其依赖项的注册表。通过使用方法 <code>T getBean(String name, Class&lt;T&gt; requiredType)</code> ，您可以检索 bean 的实例。</p>
<p> 允许读取 Bean 定义并访问它们，如以下示例所示：</p>
</li>
</ol>
<pre><code class="Java">//创建ioc容器对象，指定配置文件，ioc也开始实例组件对象
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);
//获取ioc容器的组件对象
PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class);
//使用组件对象
List&lt;String&gt; userList = service.getUsernameList();
</code></pre>
<p><strong>基于XML的方式配置组件的管理</strong></p>
<p><strong>组件（Bean）信息声明配置（IoC）</strong></p>
<ol>
<li><p>目标</p>
<p> Spring IoC 容器管理一个或多个 bean。这些 Bean 是使用您提供给容器的配置元数据创建的（例如，以 XML <code>&lt;bean/&gt;</code> 定义的形式）。</p>
<p> 我们学习，如何通过定义XML配置文件，声明组件类信息，交给 Spring 的 IoC 容器进行组件管理！</p>
</li>
<li><p>思路</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img006.c8bae859.png"></p>
</li>
<li><p>准备项目</p>
<ol>
<li><p>创建maven工程（spring-ioc-xml-01）</p>
</li>
<li><p>导入SpringIoC相关依赖</p>
<p> pom.xml</p>
</li>
</ol>
</li>
</ol>
<pre><code class="XML">&lt;dependencies&gt;
    &lt;!--spring context依赖--&gt;
    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;6.0.6&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--junit5测试--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ol start="4">
<li><p>基于无参数构造函数</p>
<blockquote>
<p>当通过构造函数方法创建一个 bean（组件对象） 时，所有普通类都可以由 Spring 使用并与之兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。只需指定 Bean 类信息就足够了。但是，默认情况下，我们需要一个默认（空）构造函数。</p>
</blockquote>
<ol>
<li>准备组件类</li>
</ol>
</li>
</ol>
<pre><code class="Java">package com.atguigu.ioc;


public class HappyComponent &#123;

    //默认包含无参数构造函数

    public void doWork() &#123;
        System.out.println(&quot;HappyComponent.doWork&quot;);
    &#125;
&#125;
</code></pre>
<pre><code>  2. xml配置文件编写

      创建携带spring约束的xml配置文件
</code></pre>
<p>​<br>​          编写配置文件：<br>​<br>          文件：resources&#x2F;spring-bean-01.xml</p>
<pre><code class="Java">&lt;!-- 实验一 [重要]创建bean --&gt;
&lt;bean id=&quot;happyComponent&quot; class=&quot;com.atguigu.ioc.HappyComponent&quot;/&gt;
</code></pre>
<pre><code>      - bean标签：通过配置bean标签告诉IOC容器需要创建对象的组件信息
      - id属性：bean的唯一标识,方便后期获取Bean！
      - class属性：组件类的全限定符！
      - 注意：要求当前组件类必须包含无参数构造函数！
</code></pre>
<ol start="5">
<li><p>基于静态工厂方法实例化</p>
<blockquote>
<p>除了使用构造函数实例化对象，还有一类是通过工厂模式实例化对象。接下来我们讲解如何定义使用静态工厂方法创建Bean的配置 ！</p>
</blockquote>
<ol>
<li>准备组件类</li>
</ol>
</li>
</ol>
<pre><code class="Java">public class ClientService &#123;
  private static ClientService clientService = new ClientService();
  private ClientService() &#123;&#125;

  public static ClientService createInstance() &#123;
  
    return clientService;
  &#125;
&#125;
</code></pre>
<pre><code>  2. xml配置文件编写

      文件：resources/spring-bean-01.xml
</code></pre>
<pre><code class="XML">&lt;bean id=&quot;clientService&quot;
  class=&quot;examples.ClientService&quot;
  factory-method=&quot;createInstance&quot;/&gt;
</code></pre>
<pre><code>      - class属性：指定工厂类的全限定符！
      - factory-method: 指定静态工厂方法，注意，该方法必须是static方法。
</code></pre>
<ol start="6">
<li><p>基于实例工厂方法实例化</p>
<blockquote>
<p>接下来我们讲解下如何定义使用实例工厂方法创建Bean的配置 ！</p>
</blockquote>
<ol>
<li>准备组建类</li>
</ol>
</li>
</ol>
<pre><code class="Java">package com.chenw.ioc_01;

public class DefaultServiceLocator &#123;

  private static ClientServiceImpl clientService = new ClientServiceImpl();

  public ClientServiceImpl createClientServiceInstance() &#123;
    return clientService;
  &#125;
&#125;
</code></pre>
<pre><code>  2. xml配置文件编写

      文件：resources/spring-bean-01.xml
</code></pre>
<pre><code class="XML">&lt;!-- 将工厂类进行ioc配置 --&gt;
&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;
&lt;/bean&gt;

&lt;!-- 根据工厂对象的实例工厂方法进行实例化组件对象 --&gt;
&lt;bean id=&quot;clientService&quot;
  factory-bean=&quot;serviceLocator&quot;
  factory-method=&quot;createClientServiceInstance&quot;/&gt;
</code></pre>
<pre><code>      - factory-bean属性：指定当前容器中工厂Bean 的名称。
      - factory-method:  指定实例工厂方法名。注意，实例方法必须是非static的！
</code></pre>
<ol start="7">
<li><p>图解IoC配置流程</p>
<p> <img src="https://secure2.wostatic.cn/static/mpqqiD6Bmbno45SpRwBNom/image.png?auth_key=1713670560-duArnWPbh3N648zpywt4TQ-0-a9a4e362a86ac845b548422894d84630"></p>
</li>
</ol>
<p><strong>组件之间的依赖注入的配置</strong></p>
<ol>
<li><p>目标</p>
<p> 通过配置文件,实现IoC容器中Bean之间的引用（依赖注入DI配置）。</p>
<p> 主要涉及注入场景：基于构造函数的依赖注入和基于 Setter 的依赖注入。</p>
</li>
<li><p>思路</p>
<p> <img src="https://secure2.wostatic.cn/static/opfLAb8XnCZDyPMm9BuiMc/image.png?auth_key=1713684087-bBRYsMKzN7SHz6zStP3DJ1-0-641ac1f4b0398f3884e4e5df5caa7e78"></p>
</li>
<li><p>基于构造函数的依赖注入（单个构造参数）</p>
<ol>
<li><p>介绍</p>
<p> 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。</p>
<p> 下面的示例演示一个只能通过构造函数注入进行依赖项注入的类！</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public class UserDao &#123;
&#125;


public class UserService &#123;
    
    private UserDao userDao;

    public UserService(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code>3. 编写配置文件

    文件：resources/spring-02.xml
</code></pre>
<pre><code class="XML">        &lt;!--引用和被引用的组件 必须全部在ioc容器--&gt;
    &lt;!--单个构造函数的注入--&gt;
    &lt;!--将他们呢都存放在ioc容器的--&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.chenw.ioc_02.UserDao&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.chenw.ioc_02.UserService&quot;&gt;
        &lt;!--这个参数作为构造函数参数传值的设置
        value   是直接的属性值,例如 String name = &quot;二狗子&quot; int age = 18
        ref   引用其他的bean bean的id值
        --&gt;
        &lt;constructor-arg  ref=&quot;userDao&quot; /&gt;
    &lt;/bean&gt;
</code></pre>
<pre><code>    - constructor-arg标签：可以引用构造参数 ref引用其他bean的标识。
</code></pre>
<ol start="4">
<li>基于构造函数的依赖注入（多构造参数解析）<ol>
<li><p>介绍</p>
<p> 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。</p>
<p> 下面的示例演示通过构造函数注入多个参数，参数包含其他bean和基本数据类型！</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public class UserDao &#123;
&#125;


public class UserService &#123;
    
    private UserDao userDao;
    
    private int age;
    
    private String name;

    public UserService(int age , String name ,UserDao userDao) &#123;
        this.userDao = userDao;
        this.age = age;
        this.name = name;
    &#125;
&#125;
</code></pre>
<pre><code>3. 编写配置文件
</code></pre>
<pre><code class="XML">&lt;!-- 场景1: 多参数，可以按照相应构造函数的顺序注入数据 --&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.chenw.ioc_02.UserDao&quot;/&gt;
    &lt;bean id=&quot;userService2&quot; class=&quot;com.chenw.ioc_02.UserService2&quot;&gt;
        &lt;!--第一种收按照顺序写 --&gt;
        &lt;constructor-arg    value=&quot;18&quot;/&gt;
        &lt;constructor-arg    value=&quot;二狗子&quot;/&gt;
        &lt;constructor-arg    ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;

&lt;!-- 场景2: 多参数，可以按照相应构造函数的参数的名字注入数据 --&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.chenw.ioc_02.UserDao&quot;/&gt;
    &lt;bean id=&quot;userService2&quot; class=&quot;com.chenw.ioc_02.UserService2&quot;&gt;
        &lt;!-- --&gt;
        &lt;constructor-arg  name=&quot;age&quot;  value=&quot;18&quot;/&gt;
        &lt;constructor-arg  name=&quot;name&quot;  value=&quot;二狗子&quot;/&gt;
        &lt;constructor-arg name=&quot;userDao&quot;   ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;

&lt;!-- 场景3: 多参数，可以按照相应构造函数的角标注入数据 
           index从0开始 构造函数(0,1,2....)
--&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.chenw.ioc_02.UserDao&quot;/&gt;
    &lt;bean id=&quot;userService2&quot; class=&quot;com.chenw.ioc_02.UserService2&quot;&gt;
        &lt;!-- --&gt;
        &lt;constructor-arg  index=&quot;0&quot;  value=&quot;18&quot;/&gt;
        &lt;constructor-arg  index=&quot;1&quot;  value=&quot;二狗子&quot;/&gt;
        &lt;constructor-arg index=&quot;2&quot;   ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<pre><code>    - constructor-arg标签：指定构造参数和对应的值
    - constructor-arg标签：name属性指定参数名、index属性指定参数角标、value属性指定普通属性值
</code></pre>
<ol start="5">
<li><strong>基于Setter方法依赖注入</strong><ol>
<li><p>介绍</p>
<p> 开发中，除了构造函数注入（DI）更多的使用的Setter方法进行注入！</p>
<p> 下面的示例演示一个只能使用纯 setter 注入进行依赖项注入的类。</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public Class MovieFinder&#123;

&#125;

public class SimpleMovieLister &#123;

  private MovieFinder movieFinder;
  
  private String movieName;

  public void setMovieFinder(MovieFinder movieFinder) &#123;
    this.movieFinder = movieFinder;
  &#125;
  
  public void setMovieName(String movieName)&#123;
    this.movieName = movieName;
  &#125;

  // business logic that actually uses the injected MovieFinder is omitted...
&#125;
</code></pre>
<pre><code>3. 编写配置文件
</code></pre>
<pre><code class="XML">    &lt;!--3.触发setter方法进行注入--&gt;
    &lt;bean id=&quot;movieFinder&quot; class=&quot;com.chenw.ioc_02.MovieFinder&quot;/&gt;
    &lt;bean id=&quot;simpleMovieLister&quot; class=&quot;com.chenw.ioc_02.SimpleMovieLister&quot;&gt;
        &lt;!--name -&gt; 属性名 （setter方法的 去掉setter方法的set并且首字母小写的值）
           例如
           setMovieFinder  -&gt;  movieFinder

           ref和value二选一和之前的使用一样

           这个本质的是找的set方法，不是找的属性
           --&gt;
        &lt;property name=&quot;movieFinder&quot; ref=&quot;movieFinder&quot;/&gt;
        &lt;property name=&quot;movieName&quot; value=&quot;消失的她&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<pre><code>    - property标签： 可以给setter方法对应的属性赋值
    - property 标签： name属性代表**set方法标识**、ref代表引用bean的标识id、value属性代表基本属性值
</code></pre>
<p><strong>总结：</strong></p>
<p>  依赖注入（DI）包含引用类型和基本数据类型，同时注入的方式也有多种！主流的注入方式为setter方法注入和构造函数注入，两种注入语法都需要掌握！</p>
<p>  需要特别注意：引用其他bean，使用ref属性。直接注入基本类型值，使用value属性。</p>
<h4 id="4-2-2-实验二：-组件（Bean）依赖注入配置（DI）"><a href="#4-2-2-实验二：-组件（Bean）依赖注入配置（DI）" class="headerlink" title="4.2.2 实验二： 组件（Bean）依赖注入配置（DI）"></a>4.2.2 实验二： 组件（Bean）依赖注入配置（DI）</h4><ol>
<li><p>目标</p>
<p> 通过配置文件,实现IoC容器中Bean之间的引用（依赖注入DI配置）。</p>
<p> 主要涉及注入场景：基于构造函数的依赖注入和基于 Setter 的依赖注入。</p>
</li>
<li><p>思路</p>
<p> <img src="https://secure2.wostatic.cn/static/opfLAb8XnCZDyPMm9BuiMc/image.png?auth_key=1713684087-bBRYsMKzN7SHz6zStP3DJ1-0-641ac1f4b0398f3884e4e5df5caa7e78"></p>
</li>
<li><p>基于构造函数的依赖注入（单个构造参数）</p>
<ol>
<li><p>介绍</p>
<p> 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。</p>
<p> 下面的示例演示一个只能通过构造函数注入进行依赖项注入的类！</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public class UserDao &#123;
&#125;


public class UserService &#123;
    
    private UserDao userDao;

    public UserService(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code>  3. 编写配置文件

      文件：resources/spring-02.xml
</code></pre>
<pre><code class="XML">&lt;beans&gt;
  &lt;!-- 引用类bean声明 --&gt;
  &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt;
   &lt;!-- 构造函数引用 --&gt;
    &lt;constructor-arg ref=&quot;userDao&quot;/&gt;
  &lt;/bean&gt;
  &lt;!-- 被引用类bean声明 --&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code>      - constructor-arg标签：可以引用构造参数 ref引用其他bean的标识。
</code></pre>
<ol start="4">
<li>基于构造函数的依赖注入（多构造参数解析）<ol>
<li><p>介绍</p>
<p> 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。</p>
<p> 下面的示例演示通过构造函数注入多个参数，参数包含其他bean和基本数据类型！</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public class UserDao &#123;
&#125;


public class UserService &#123;
    
    private UserDao userDao;
    
    private int age;
    
    private String name;

    public UserService(int age , String name ,UserDao userDao) &#123;
        this.userDao = userDao;
        this.age = age;
        this.name = name;
    &#125;
&#125;
</code></pre>
<pre><code>  3. 编写配置文件
</code></pre>
<pre><code class="XML">&lt;!-- 场景1: 多参数，可以按照相应构造函数的顺序注入数据 --&gt;
&lt;beans&gt;
  &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt;
    &lt;!-- value直接注入基本类型值 --&gt;
    &lt;constructor-arg  value=&quot;18&quot;/&gt;
    &lt;constructor-arg  value=&quot;赵伟风&quot;/&gt;
    
    &lt;constructor-arg  ref=&quot;userDao&quot;/&gt;
  &lt;/bean&gt;
  &lt;!-- 被引用类bean声明 --&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;
&lt;/beans&gt;


&lt;!-- 场景2: 多参数，可以按照相应构造函数的名称注入数据 --&gt;
&lt;beans&gt;
  &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt;
    &lt;!-- value直接注入基本类型值 --&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;赵伟风&quot;/&gt;
    &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;constructor-arg name=&quot;age&quot;  value=&quot;18&quot;/&gt;
  &lt;/bean&gt;
  &lt;!-- 被引用类bean声明 --&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;
&lt;/beans&gt;

&lt;!-- 场景2: 多参数，可以按照相应构造函数的角标注入数据 
           index从0开始 构造函数(0,1,2....)
--&gt;
&lt;beans&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt;
    &lt;!-- value直接注入基本类型值 --&gt;
    &lt;constructor-arg index=&quot;1&quot; value=&quot;赵伟风&quot;/&gt;
    &lt;constructor-arg index=&quot;2&quot; ref=&quot;userDao&quot;/&gt;
    &lt;constructor-arg index=&quot;0&quot;  value=&quot;18&quot;/&gt;
  &lt;/bean&gt;
  &lt;!-- 被引用类bean声明 --&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code>      - constructor-arg标签：指定构造参数和对应的值
      - constructor-arg标签：name属性指定参数名、index属性指定参数角标、value属性指定普通属性值
</code></pre>
<ol start="5">
<li><strong>基于Setter方法依赖注入</strong><ol>
<li><p>介绍</p>
<p> 开发中，除了构造函数注入（DI）更多的使用的Setter方法进行注入！</p>
<p> 下面的示例演示一个只能使用纯 setter 注入进行依赖项注入的类。</p>
</li>
<li><p>准备组件类</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public Class MovieFinder&#123;

&#125;

public class SimpleMovieLister &#123;

  private MovieFinder movieFinder;
  
  private String movieName;

  public void setMovieFinder(MovieFinder movieFinder) &#123;
    this.movieFinder = movieFinder;
  &#125;
  
  public void setMovieName(String movieName)&#123;
    this.movieName = movieName;
  &#125;

  // business logic that actually uses the injected MovieFinder is omitted...
&#125;
</code></pre>
<pre><code>  3. 编写配置文件
</code></pre>
<pre><code class="XML">&lt;bean id=&quot;simpleMovieLister&quot; class=&quot;examples.SimpleMovieLister&quot;&gt;
  &lt;!-- setter方法，注入movieFinder对象的标识id
       name = 属性名  ref = 引用bean的id值
   --&gt;
  &lt;property name=&quot;movieFinder&quot; ref=&quot;movieFinder&quot; /&gt;

  &lt;!-- setter方法，注入基本数据类型movieName
       name = 属性名 value= 基本类型值
   --&gt;
  &lt;property name=&quot;movieName&quot; value=&quot;消失的她&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;movieFinder&quot; class=&quot;examples.MovieFinder&quot;/&gt;
</code></pre>
<pre><code>      - property标签： 可以给setter方法对应的属性赋值
      - property 标签： name属性代表**set方法标识**、ref代表引用bean的标识id、value属性代表基本属性值
</code></pre>
<p>  <strong>总结：</strong></p>
<pre><code>依赖注入（DI）包含引用类型和基本数据类型，同时注入的方式也有多种！主流的注入方式为setter方法注入和构造函数注入，两种注入语法都需要掌握！

需要特别注意：引用其他bean，使用ref属性。直接注入基本类型值，使用value属性。
</code></pre>
<p> <strong>IoC容器创建和使用</strong></p>
<ol>
<li><p>介绍</p>
<p> 上面的实验只是讲解了如何在XML格式的配置文件编写IoC和DI配置！</p>
<p> 如图：</p>
<p> <img src="https://secure2.wostatic.cn/static/ngQZT7qhVfAzTxrr2oX1ny/image.png?auth_key=1713686158-sbfHvbb8SRsw7s3ZkFgXtY-0-f2d76343dcd8e0eff2fb9205ed5498ca"></p>
<p> 想要配置文件中声明组件类信息真正的进行实例化成Bean对象和形成Bean之间的引用关系，我们需要声明IoC容器对象，读取配置文件，实例化组件和关系维护的过程都是在IoC容器中实现的！</p>
</li>
<li><p>容器实例化</p>
</li>
</ol>
<pre><code class="Java">//方式1:实例化并且指定配置文件
//参数：String...locations 传入一个或者多个配置文件
ApplicationContext context = 
           new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);
           
//方式2:先实例化，再指定配置文件，最后刷新容器触发Bean实例化动作 [springmvc源码和contextLoadListener源码方式]  
ApplicationContext context = 
           new ClassPathXmlApplicationContext();   
//设置配置配置文件,方法参数为可变参数,可以设置一个或者多个配置
iocContainer1.setConfigLocations(&quot;services.xml&quot;, &quot;daos.xml&quot;);
//后配置的文件,需要调用refresh方法,触发刷新配置
iocContainer1.refresh();           
</code></pre>
<ol start="3">
<li>​	对象读取</li>
</ol>
<pre><code class="Java">//方式1: 根据id获取
//没有指定类型,返回为Object,需要类型转化!
HappyComponent happyComponent = 
        (HappyComponent) iocContainer.getBean(&quot;bean的id标识&quot;);
        
//使用组件对象        
happyComponent.doWork();

//方式2: 根据类型获取
//根据类型获取,但是要求,同类型(当前类,或者之类,或者接口的实现类)只能有一个对象交给IoC容器管理
//配置两个或者以上出现: org.springframework.beans.factory.NoUniqueBeanDefinitionException 问题
HappyComponent happyComponent = iocContainer.getBean(HappyComponent.class);
happyComponent.doWork();

//方式3: 根据id和类型获取
HappyComponent happyComponent = iocContainer.getBean(&quot;bean的id标识&quot;, HappyComponent.class);
happyComponent.doWork();

根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，
只要返回的是true就可以认定为和类型匹配，能够获取到。
</code></pre>
<p>演示</p>
<pre><code class="java">package com.chenw.test;

import com.chenw.ioc_03.HappyComponent;
import org.junit.jupiter.api.Test;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringIoCTest &#123;
    /*
    * 如何创建ioc容器并且读取配置文件
    * */
    public void createIoC()&#123;
        //创建容器，选择合适的容器实现
        /*
        *接口
        * BeanFactory
        *   ApplicationContext
        * 实现类
        *   直接通过构造函数实例化
        *   ClassPathXmlApplicationContext
        *   FileSystemXmlApplicationContext
        *   AnnotationConfigApplicationContext
        *   WebApplicationContext
        *
        * */
        //构造函数（string...配置文件）可以写一个或者多个，推荐
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-03.xml&quot;);
        //先创建
        ClassPathXmlApplicationContext applicationContext1 = new ClassPathXmlApplicationContext();
        //外部配置文件的配置
        applicationContext1.setConfigLocations(&quot;spring-03.xml&quot;);
        //调用ioc和di的流程
        applicationContext1.refresh();


    &#125;
    /*
    *   如何在Ioc容器中获取组件Bean
    * */
    @Test
    public void getBeanFromIoC()&#123;
        //1.创建容器
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext();
        applicationContext.setConfigLocations(&quot;spring-03.xml&quot;);
        applicationContext.refresh();

        //2.读取ioc容器的组件
        //方案1:根据bean的id获取 返回值为object,这种需要强转不推荐
        HappyComponent happyComponent = (HappyComponent)applicationContext.getBean(&quot;happyComponent&quot;);
        //方案2:根据bean的id和类型获取
        HappyComponent happyComponent1 = applicationContext.getBean(&quot;happyComponent&quot;, HappyComponent.class);
        //方案3:直接根据类型获取
        HappyComponent bean = applicationContext.getBean(HappyComponent.class);
        happyComponent.doWork();  //HappyComponent.doWork
        happyComponent1.doWork(); //HappyComponent.doWork
        bean.doWork();   //HappyComponent.doWor

        //而且创建的都是同一个对象
        System.out.println(happyComponent1==happyComponent); //true
        System.out.println(happyComponent1==bean); //true
    &#125;

&#125;
</code></pre>
<pre><code class="xml">注意第三中方法，通过类的类对象作为参数可能出现一些问题 
如果下面这样，这样第三种方法就会出错
    &lt;bean id=&quot;happyComponent&quot; class=&quot;com.chenw.ioc_03.HappyComponent&quot;/&gt;
    &lt;bean id=&quot;happyComponent1&quot; class=&quot;com.chenw.ioc_03.HappyComponent&quot;/&gt;
</code></pre>
<pre><code class="java">还有一个注意点
第三中方法，如果该类实现一个接口吗，下面这些操作也是可行的，因为参数的判断是通过 instanceof
    例如
    package com.chenw.ioc_03;

public interface A &#123;
    void doWork();
&#125;

实现
package com.chenw.ioc_03;


public class HappyComponent implements A &#123;

    //默认包含无参数构造函数

    public void doWork() &#123;
        System.out.println(&quot;HappyComponent.doWork&quot;);
    &#125;
&#125;

配置
    &lt;bean id=&quot;happyComponent&quot; class=&quot;com.chenw.ioc_03.HappyComponent&quot;/&gt;
测试类
            A bean = applicationContext.getBean(A.class);
            bean.doWork();   //HappyComponent.doWork
</code></pre>
<p><strong>组件(bean)的作用域和周期方法的配置</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421165645730.png" alt="image-20240421165645730"></p>
<pre><code>我们可以组件类里面声明周期方法，然后通过配置文件告诉容器
</code></pre>
<ol>
<li>组件周期方法配置<ol>
<li><p>周期方法概念</p>
<p> 我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！</p>
<p> 类似于Servlet的init&#x2F;destroy方法,我们可以在周期方法完成初始化和释放资源等工作。</p>
</li>
<li><p>周期方法声明</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">package com.chenw.ioc_04;

public class JavaBean &#123;
    /*
    * 必须public 必须是void返回值 必须是无参数的
    * 命名是随意的的
    *
    * */
    public void init()&#123;
        System.out.println(&quot;javaBean.init&quot;);
    &#125;
    public void clear()&#123;
        System.out.println(&quot;JavaBean,clear&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">3. 周期方法配置
    &lt;bean id=&quot;javaBean&quot; class=&quot;com.chenw.ioc_04.JavaBean&quot; init-method=&quot;init&quot; destroy-method=&quot;clear&quot;/&gt;
</code></pre>
<pre><code class="xml">&lt;beans&gt;
  &lt;bean id=&quot;beanOne&quot; class=&quot;examples.BeanOne&quot; init-method=&quot;init&quot; /&gt;
  &lt;bean id=&quot;beanTwo&quot; class=&quot;examples.BeanTwo&quot; destroy-method=&quot;cleanup&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<p>例如</p>
<p>上面配置玩以后</p>
<pre><code class="java">    @Test
    public void Test_o4()&#123;
        //但我们创建ioc容器的时候 就会对组件实例化 ，然后就会调用初始化方法
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring_04.xml&quot;);
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421171007793.png" alt="image-20240421171007793"></p>
<p>怎么调用销毁呢？</p>
<pre><code class="java">    @Test
    public void Test_o4()&#123;
        //但我们创建ioc容器的时候 就会对组件实例化 ，然后就会调用初始化方法
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring_04.xml&quot;);

        //怎么调用销毁的方法呢？
        //当我们代码执行玩以后，ioc直接就会释放掉，没有机会去调用组件的销毁方法
        // 需要手动销毁ioc
        applicationContext.close();
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421171336304.png" alt="image-20240421171336304"></p>
<p>2.组件作用域配置</p>
<ol>
<li><p>Bean作用域概念</p>
<p> <code>&lt;bean</code> 标签声明Bean，只是将Bean的信息配置给SpringIoC容器！</p>
<p> 在IoC容器中，这些<code>&lt;bean</code>标签对应的信息转成Spring内部 <code>BeanDefinition</code> 对象，<code>BeanDefinition</code> 对象内，包含定义的信息（id,class,属性等等）！</p>
<p> 这意味着，<code>BeanDefinition</code>与<code>类</code>概念一样，SpringIoC容器可以可以根据<code>BeanDefinition</code>对象反射创建多个Bean对象实例。</p>
<p> 具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！</p>
<p> 例如，当我们写配置的时候默认的在BeanDefinition的scope为单列，就只会创建对象，如果是多例的话，每当我们获取对象的时候，获取就可能不是同一个对象</p>
<p> 如下</p>
<pre><code class="xml">    &lt;!--声明组件信息！默认就是单例模式  --&gt;
    &lt;bean id=&quot;javaBean2&quot; class=&quot;com.chenw.ioc_04.JavaBean2&quot;/&gt;
</code></pre>
<pre><code class="java">JavaBean2 javaBean2 = applicationContext.getBean(&quot;javaBean2&quot;, JavaBean2.class);
JavaBean2 javaBean21 = applicationContext.getBean(&quot;javaBean2&quot;, JavaBean2.class);
System.out.println(javaBean21 == javaBean2);  //true
</code></pre>
<p> 这就说明这个就是单例，在我们容器创建的时候实例对象</p>
<p> <strong>多例</strong></p>
<pre><code class="xml">&lt;!-- scope=&quot;prototype&quot; 这样获取的就是多例，每次获取就会创建一个新的对象 --&gt;
&lt;bean id=&quot;javaBean2&quot; class=&quot;com.chenw.ioc_04.JavaBean2&quot; scope=&quot;prototype&quot;/&gt;
</code></pre>
<pre><code class="java">JavaBean2 javaBean2 = applicationContext.getBean(&quot;javaBean2&quot;, JavaBean2.class);
JavaBean2 javaBean21 = applicationContext.getBean(&quot;javaBean2&quot;, JavaBean2.class);
System.out.println(javaBean21 == javaBean2);  //false
</code></pre>
<p> 上面就是多例，在获取bean的时候实例对象</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421173834085.png" alt="image-20240421173834085"></p>
</li>
<li><p>作用域可选值</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>在 IOC 容器中，这个 bean 的对象始终为单实例</td>
<td>IOC 容器初始化时</td>
<td>是</td>
</tr>
<tr>
<td>prototype</td>
<td>这个 bean 在 IOC 容器中有多个实例</td>
<td>获取 bean 时</td>
<td>否</td>
</tr>
</tbody></table>
<pre><code>    如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）：
</code></pre>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>request</td>
<td>请求范围内有效的实例</td>
<td>每次请求</td>
<td>否</td>
</tr>
<tr>
<td>session</td>
<td>会话范围内有效的实例</td>
<td>每次会话</td>
<td>否</td>
</tr>
</tbody></table>
<pre><code>3. 作用域配置

    配置scope范围
</code></pre>
<pre><code class="XML">&lt;!--bean的作用域 
    准备两个引用关系的组件类即可！！
--&gt;
&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;
&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;
&lt;bean id=&quot;happyMachine8&quot; scope=&quot;prototype&quot; class=&quot;com.atguigu.ioc.HappyMachine&quot;&gt;
    &lt;property name=&quot;machineName&quot; value=&quot;happyMachine&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;happyComponent8&quot; scope=&quot;singleton&quot; class=&quot;com.atguigu.ioc.HappyComponent&quot;&gt;
    &lt;property name=&quot;componentName&quot; value=&quot;happyComponent&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code>4. 作用域测试
</code></pre>
<pre><code class="Java">@Test
public void testExperiment08()  &#123;
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(&quot;配置文件名&quot;);

    HappyMachine bean = iocContainer.getBean(HappyMachine.class);
    HappyMachine bean1 = iocContainer.getBean(HappyMachine.class);
    //多例对比 false
    System.out.println(bean == bean1);

    HappyComponent bean2 = iocContainer.getBean(HappyComponent.class);
    HappyComponent bean3 = iocContainer.getBean(HappyComponent.class);
    //单例对比 true
    System.out.println(bean2 == bean3);
&#125;
</code></pre>
<p><strong>FactoryBean特性和使用</strong></p>
<pre><code>对于复杂bean的创建
</code></pre>
<p>​	<img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421175849476.png" alt="image-20240421175849476"></p>
<ol>
<li><p>FactoryBean简介</p>
<p> <code>FactoryBean</code> 接口是Spring IoC容器实例化逻辑的可插拔性点。</p>
<p> 用于配置复杂的Bean对象，可以将创建过程存储在<code>FactoryBean</code> 的getObject方法！</p>
<p> <code>FactoryBean&lt;T&gt;</code> 接口提供三种方法：</p>
<ul>
<li><p><code>T getObject()</code>: </p>
<p>  返回此工厂创建的对象的实例。该返回值会被存储到IoC容器！</p>
</li>
<li><p><code>boolean isSingleton()</code>: </p>
<p>  如果此 <code>FactoryBean</code> 返回单例，则返回 <code>true</code> ，否则返回 <code>false</code> 。此方法的默认实现返回 <code>true</code> （注意，lombok插件使用，可能影响效果）。</p>
</li>
<li><p><code>Class&lt;?&gt; getObjectType()</code>: 返回 <code>getObject()</code> 方法返回的对象类型，如果事先不知道类型，则返回 <code>null</code> 。</p>
</li>
</ul>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png">
 </p>
</li>
<li><p>FactoryBean使用场景</p>
<ol>
<li>代理类的创建</li>
<li>第三方框架整合</li>
<li>复杂对象实例化等</li>
</ol>
</li>
<li><p>Factorybean应用</p>
</li>
</ol>
<pre><code class="java">package com.chenw.ioc_05;

public class JavaBean &#123;
    private String name;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
</code></pre>
<ol>
<li>准备FactoryBean实现类</li>
</ol>
<pre><code class="Java">package com.chenw.ioc_05;

import org.springframework.beans.factory.FactoryBean;



/*
* 实现FactoryBean的接口
* 这个的泛型就是我们需要造出来的对象
* */
public class JavaBeanFactoryBean implements FactoryBean&lt;JavaBean&gt; &#123;
    @Override
    public JavaBean getObject() throws Exception &#123;
        //使用自己的方法实例化对象就行了
        JavaBean javaBean = new JavaBean();
        return javaBean;
    &#125;

    @Override
    public Class&lt;?&gt; getObjectType() &#123;
        return JavaBean.class;
    &#125;
&#125;
</code></pre>
<pre><code>2. 配置FactoryBean实现类
</code></pre>
<pre><code class="XML">    &lt;!--
        id 就是为getObject方法返回对象的值
        Class  factoryBean标准话工厂类

    --&gt;
    &lt;bean id=&quot;javaBean&quot; class=&quot;com.chenw.ioc_05.JavaBeanFactoryBean&quot;&gt;&lt;/bean&gt;
</code></pre>
<pre><code>3. 测试读取FactoryBean和FactoryBean.getObject对象
</code></pre>
<pre><code class="Java">    /*
    *   读取使用factoryBean 工厂配置组件对象
    * */
    @Test
    public void test_05()&#123;
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-05.xml&quot;);
        JavaBean javaBean = applicationContext.getBean(&quot;javaBean&quot;, JavaBean.class);
        javaBean.setName(&quot;王昌晨&quot;);
        System.out.println(javaBean.getName()); //王昌晨
    &#125;
</code></pre>
<ul>
<li><p>注意我们也可以获取工厂的对象，工厂bean的id值为&amp;+id值</p>
<p>例如</p>
<pre><code class="java">/*
* TODO:FactoryBean也会加入工厂，名字&amp;id
* */
Object bean = applicationContext.getBean(&quot;&amp;javaBean&quot;);
System.out.println(bean);//com.chenw.ioc_05.JavaBeanFactoryBean@3738449f
</code></pre>
</li>
</ul>
<p>4.FactoryBean和BeanFactory区别</p>
<p>**FactoryBean **是 Spring 中一种特殊的 bean，可以在 getObject() 工厂方法自定义的逻辑创建Bean！是一种能够生产其他 Bean 的 Bean。FactoryBean 在容器启动时被创建，而在实际使用时则是通过调用 getObject() 方法来得到其所生产的 Bean。因此，FactoryBean 可以自定义任何所需的初始化逻辑，生产出一些定制化的 bean。</p>
<p>一般情况下，整合第三方框架，都是通过定义FactoryBean实现！！！</p>
<p><strong>BeanFactory</strong> 是 Spring 框架的基础，其作为一个顶级接口定义了容器的基本行为，例如管理 bean 的生命周期、配置文件的加载和解析、bean 的装配和依赖注入等。BeanFactory 接口提供了访问 bean 的方式，例如 getBean() 方法获取指定的 bean 实例。它可以从不同的来源（例如 Mysql 数据库、XML 文件、Java 配置类等）获取 bean 定义，并将其转换为 bean 实例。同时，BeanFactory 还包含很多子类（例如，ApplicationContext 接口）提供了额外的强大功能。</p>
<p>总的来说，FactoryBean 和 BeanFactory 的区别主要在于前者是用于创建 bean 的接口，它提供了更加灵活的初始化定制功能，而后者是用于管理 bean 的框架基础接口，提供了基本的容器功能和 bean 生命周期管理。</p>
<p>还有一个注意点</p>
<p>如果我们想要在xml配置set方法设置，给我的name属性赋值</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421183500442.png" alt="image-20240421183500442"></p>
<p>切记不可以直接这样，这样就会直接给我们的bean工厂的name赋值，而不是加工的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421183554888.png" alt="image-20240421183554888"></p>
<p>但是我们可以这么写在工厂的里面，这样工厂像一个桥梁</p>
<pre><code class="java">package com.chenw.ioc_05;

import org.springframework.beans.factory.FactoryBean;



/*
* 实现FactoryBean的接口
* 这个的泛型就是我们需要造出来的对象
* */
public class JavaBeanFactoryBean implements FactoryBean&lt;JavaBean&gt; &#123;
    private String name;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public JavaBean getObject() throws Exception &#123;
        //使用自己的方法实例化对象就行了
        JavaBean javaBean = new JavaBean();
        javaBean.setName(name);
        return javaBean;
    &#125;

    @Override
    public Class&lt;?&gt; getObjectType() &#123;
        return JavaBean.class;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">&lt;bean id=&quot;javaBean&quot; class=&quot;com.chenw.ioc_05.JavaBeanFactoryBean&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;chenw&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>或者直接调用方法赋值</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421183855851.png" alt="image-20240421183855851"></p>
<p><strong>基于XML方式整合的三层架构组件</strong></p>
<ol>
<li><p>需求分析</p>
<p> 搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用XML方式进行组件管理！</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
</li>
<li><p>数据库准备</p>
</li>
</ol>
<pre><code class="Java">create database studb;

use studb;

CREATE TABLE students (
  id INT PRIMARY KEY,
  name VARCHAR(50) NOT NULL,
  gender VARCHAR(10) NOT NULL,
  age INT,
  class VARCHAR(50)
);

INSERT INTO students (id, name, gender, age, class)
VALUES
  (1, &#39;张三&#39;, &#39;男&#39;, 20, &#39;高中一班&#39;),
  (2, &#39;李四&#39;, &#39;男&#39;, 19, &#39;高中二班&#39;),
  (3, &#39;王五&#39;, &#39;女&#39;, 18, &#39;高中一班&#39;),
  (4, &#39;赵六&#39;, &#39;女&#39;, 20, &#39;高中三班&#39;),
  (5, &#39;刘七&#39;, &#39;男&#39;, 19, &#39;高中二班&#39;),
  (6, &#39;陈八&#39;, &#39;女&#39;, 18, &#39;高中一班&#39;),
  (7, &#39;杨九&#39;, &#39;男&#39;, 20, &#39;高中三班&#39;),
  (8, &#39;吴十&#39;, &#39;男&#39;, 19, &#39;高中二班&#39;);
</code></pre>
<ol>
<li>项目准备<ol>
<li><p>项目创建</p>
<p> spring-xml-practice-02</p>
</li>
<li><p>依赖导入</p>
</li>
</ol>
</li>
</ol>
<pre><code class="XML">&lt;dependencies&gt;
      &lt;!--spring context依赖--&gt;
      &lt;!--当你引入SpringContext依赖之后，表示将Spring的基础依赖引入了--&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
          &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
          &lt;version&gt;6.0.6&lt;/version&gt;
      &lt;/dependency&gt;

      &lt;!-- 数据库驱动和连接池--&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;mysql&lt;/groupId&gt;
          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
          &lt;version&gt;8.0.25&lt;/version&gt;
      &lt;/dependency&gt;

      &lt;dependency&gt;
          &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
          &lt;artifactId&gt;druid&lt;/artifactId&gt;
          &lt;version&gt;1.2.8&lt;/version&gt;
      &lt;/dependency&gt;

      &lt;!-- spring-jdbc --&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
          &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
          &lt;version&gt;6.0.6&lt;/version&gt;
      &lt;/dependency&gt;

&lt;/dependencies&gt; 
</code></pre>
<pre><code>3. 实体类准备
</code></pre>
<pre><code class="Java">public class Student &#123;

    private Integer id;
    private String name;
    private String gender;
    private Integer age;
    private String classes;

    public Integer getId() &#123;
        return id;
    &#125;

    public void setId(Integer id) &#123;
        this.id = id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getGender() &#123;
        return gender;
    &#125;

    public void setGender(String gender) &#123;
        this.gender = gender;
    &#125;

    public Integer getAge() &#123;
        return age;
    &#125;

    public void setAge(Integer age) &#123;
        this.age = age;
    &#125;

    public String getClasses() &#123;
        return classes;
    &#125;

    public void setClasses(String classes) &#123;
        this.classes = classes;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, gender=&#39;&quot; + gender + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, classes=&#39;&quot; + classes + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<ol start="2">
<li><p>JdbcTemplate技术讲解</p>
<blockquote>
<p>为了在特定领域帮助我们简化代码，Spring 封装了很多 『Template』形式的模板类。例如：RedisTemplate、RestTemplate 等等，包括我们今天要学习的 JdbcTemplate。</p>
</blockquote>
<p> jdbcTemplate的基本使用</p>
<pre><code class="java">package com.chenw.jdbc;

import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class jdbcTemplateTest &#123;
    public void testForJava()&#123;
        /*
        * jdbcTemplate  简化了数据库的curd 不提供连续持等操作
        * DruidDataSource  负责连接的创建和数据库驱动的注册
        *   所以DruidDataSource赋值给jdbcTemplate
        * */
        //1.实例对象
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        //2.调用方法
//        jdbcTemplate.update();     //DDL  DML   DCL ...非查询语句
//        jdbcTemplate.queryForObject();  //DQL 查询单个语句
//        jdbcTemplate.query()  //DQL查询集合
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl(&quot;jdbc:mysql:///studb&quot;);
        dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;root&quot;);
        //参数是连接池对象
        jdbcTemplate.setDataSource(dataSource);
    &#125;
&#125;
</code></pre>
<p> 上面时使用java代码实现，如何使用ioc管理呢？</p>
<p> 下面的操作在配置文件完成上面的操作</p>
<pre><code class="xml">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource &quot;&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///studb&quot;/&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
&lt;/bean&gt;
&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p> 但是一般的这个数据库的配置信息这样写不太好，所最好写一个配置文件</p>
<p> jdbc.properties</p>
<p> 提取数据库连接信息</p>
</li>
</ol>
<pre><code class=".properties">atguigu.url=jdbc:mysql://localhost:3306/studb
atguigu.driver=com.mysql.cj.jdbc.Driver
atguigu.username=root
atguigu.password=root
</code></pre>
<pre><code>springioc配置文件
</code></pre>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd 
       http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;


    &lt;!--读取外部的配置文件 .properties -&gt;  value = $&#123;&#125;--&gt;
    &lt;!--需要这，注意这里面的classpath是类路径的意思，而且只能支持properties的文件--&gt;
    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;chenw.url&#125;&quot;/&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;chenw.driver&#125;&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;chenw.username&#125;&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;chenw.password&#125;&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;	
    
&lt;/beans&gt;
</code></pre>
<pre><code>基于jdbcTemplate的CRUD使用
</code></pre>
<pre><code class="Java">package com.chenw.jdbc;

import com.alibaba.druid.pool.DruidDataSource;
import com.chenw.pojo.Student;
import org.junit.jupiter.api.Test;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

public class jdbcTemplateTest &#123;
    public void testForJava()&#123;
        /*
        * jdbcTemplate  简化了数据库的curd 不提供连续持等操作
        * DruidDataSource  负责连接的创建和数据库驱动的注册
        *   所以DruidDataSource赋值给jdbcTemplate
        * */
        //1.实例对象
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        //2.调用方法
//        jdbcTemplate.update();     //DDL  DML   DCL ...非查询语句
//        jdbcTemplate.queryForObject();  //DQL 查询单个语句
//        jdbcTemplate.query()  //DQL查询集合
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl(&quot;jdbc:mysql:///studb&quot;);
        dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;root&quot;);
        //参数是连接池对象
        jdbcTemplate.setDataSource(dataSource);
    &#125;

    /*
    * TODO 通过ioc容器读取配置的jdbcTemplate的组件
    * */
    @Test
    public void testForIoC()&#123;

        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-01.xml&quot;);
        JdbcTemplate jdbcTemplate = applicationContext.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
        //插入删除修改
        String sql = &quot;insert into students (id,name,gender,age,class) values (?,?,?,?,?)&quot;;
        /*
        * 参数1，sql语句
        * 参数二，占位符的值
        * 返回值是影响的行数
        * */
        int rows = jdbcTemplate.update(sql, 10,&quot;王昌晨&quot;, &quot;男&quot;, 18, &quot;三年二班&quot;);
        System.out.println(rows);


        //查询单条数据，返回实体对象
        sql = &quot;select  * from students where id = ?&quot;;
        /*
        * 参数一sql语句 可以使用占位符
        * 参数2 RowMapper 列名和属性名的映射器接口,里面的泛型是实体类对象
        * 参数3 Object ...params 占位符参数
        * 返回值 rowMapper指定的参数
        * */
//        Student student = jdbcTemplate.queryForObject(sql, new RowMapper&lt;Student&gt;() &#123;
//            @Override
//            public Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123;
//                //rs代表结果集
//                //rowNum 行数
//                //rs获取列的值 赋值给尸体类对象
//                Student student1 = new Student();
//                student1.setId(rs.getInt(&quot;id&quot;));
//                student1.setName(rs.getString(&quot;name&quot;));
//                student1.setGender(rs.getString(&quot;gender&quot;));
//                student1.setClasses(rs.getString(&quot;class&quot;));
//                return student1;
//            &#125;
//        &#125;, 1);
//        然后缓冲lamda表达式
        Student student = jdbcTemplate.queryForObject(sql, ( rs,     rowNum)-&gt;&#123;
                //rs代表结果集
                //rowNum 行数
                //rs获取列的值 赋值给尸体类对象
                Student student1 = new Student();
                student1.setId(rs.getInt(&quot;id&quot;));
                student1.setName(rs.getString(&quot;name&quot;));
                student1.setGender(rs.getString(&quot;gender&quot;));
                student1.setClasses(rs.getString(&quot;class&quot;));
                return student1;
            &#125;, 1);
        System.out.println(student);


        //查询所有的数据
        sql = &quot;select id ,name,gender,age,class as classes  from students&quot;;
        //注意这个BeanPropertyRowMapper，就自动实现映射，注意列名和实体类的属性名要一致，不一致的需要起别名
        List&lt;Student&gt; query = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;Student&gt;(Student.class), null);
        System.out.println(query);
    &#125;
&#125;
</code></pre>
<p>3.三层架构搭建和实现</p>
<ol>
<li>持久层</li>
</ol>
<pre><code class="Java">//接口
public interface StudentDao &#123;

    /**
     * 查询全部学生数据
     * @return
     */
    List&lt;Student&gt; queryAll();
&#125;

//实现类
public class StudentDaoImpl implements StudentDao &#123;

    private JdbcTemplate jdbcTemplate;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;

    /**
     * 查询全部学生数据
     * @return
     */
    @Override
    public List&lt;Student&gt; queryAll() &#123;

        String sql = &quot;select id , name , age , gender , class as classes from students ;&quot;;

        /*
          query可以返回集合!
          BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可
         */
        List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class));

        return studentList;
   &#125;
&#125;
</code></pre>
<pre><code>2. 业务层
</code></pre>
<pre><code class="Java">//接口
public interface StudentService &#123;

    /**
     * 查询全部学员业务
     * @return
     */
    List&lt;Student&gt; findAll();

&#125;

//实现类
public class StudentServiceImpl  implements StudentService &#123;
    
    private StudentDao studentDao;

    public void setStudentDao(StudentDao studentDao) &#123;
        this.studentDao = studentDao;
    &#125;

    /**
     * 查询全部学员业务
     * @return
     */
    @Override
    public List&lt;Student&gt; findAll() &#123;
        
        List&lt;Student&gt; studentList =  studentDao.queryAll();
        
        return studentList;
    &#125;
&#125;
</code></pre>
<pre><code>3. 表述层
</code></pre>
<pre><code class="Java">public class StudentController &#123;
    
    private StudentService studentService;

    public void setStudentService(StudentService studentService) &#123;
        this.studentService = studentService;
    &#125;
    
    public void  findAll()&#123;
       List&lt;Student&gt; studentList =  studentService.findAll();
        System.out.println(&quot;studentList = &quot; + studentList);
    &#125;
&#125;
</code></pre>
<ol start="4">
<li>三层架构IoC配置</li>
</ol>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;
    &lt;!--druid--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;chenw.url&#125;&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;chenw.username&#125;&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;chenw.password&#125;&quot;/&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;chenw.driver&#125;&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--jdbcTemplate--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--dao 配置注入 di jdbcTemplate--&gt;
    &lt;bean id=&quot;studentDao&quot; class=&quot;com.chenw.dao.Imp.StudentDaoImpl&quot;&gt;
        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--service 配置注入 di dao--&gt;
    &lt;bean id=&quot;studentServiceImp&quot; class=&quot;com.chenw.service.Imp.StudentServiceImp&quot;&gt;
        &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--controller 配置注入 di service--&gt;
    &lt;bean id=&quot;studentController&quot; class=&quot;com.chenw.controller.StudentController&quot;&gt;
        &lt;property name=&quot;studentService&quot; ref=&quot;studentServiceImp&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ol start="5">
<li>运行测试</li>
</ol>
<pre><code class="Java">    /*
    * 从ioc容器里面获取controller并且调用业务！内部都是ioc
    * */
    @Test
    public void testQueryAll()&#123;
        //创建ioc容器
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-02.xml&quot;);
        //获取组件对象
        StudentController bean = applicationContext.getBean(StudentController.class);
        //使用组件对象
        bean.findAll();
        //关闭容器
        applicationContext.close();
    &#125;
</code></pre>
<p>结果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240421211218635.png" alt="image-20240421211218635"></p>
<p>6.XMLIoC方式问题总结</p>
<ol>
<li>注入的属性必须添加setter方法、代码结构乱！</li>
<li>配置文件和Java代码分离、编写不是很方便！</li>
<li>XML配置文件解析效率低</li>
</ol>
<p><strong>Bean注解标记和扫描 (IoC)</strong></p>
<ol>
<li><p><strong>注解理解</strong></p>
<p> 和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。</p>
<p> 本质上：所有一切的操作都是 Java 代码来完成的，XML 和注解只是告诉框架中的 Java 代码如何执行。</p>
<p> 举例：元旦联欢会要布置教室，蓝色的地方贴上元旦快乐四个字，红色的地方贴上拉花，黄色的地方贴上气球。</p>
<p> <img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img015.a6b65329.png"></p>
<p> 班长做了所有标记，同学们来完成具体工作。墙上的标记相当于我们在代码中使用的注解，后面同学们做的工作，相当于框架的具体操作。</p>
</li>
<li><p><strong>扫描理解</strong></p>
<p> Spring 为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注解进行后续操作。</p>
</li>
<li><p><strong>准备Spring项目和组件</strong></p>
<ol>
<li>准备项目pom.xml</li>
</ol>
</li>
</ol>
<pre><code class="XML">&lt;dependencies&gt;
    &lt;!--spring context依赖--&gt;
    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;6.0.6&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!--junit5测试--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code>  2. 准备组件类

      普通组件
</code></pre>
<pre><code class="Java">/**
 * projectName: com.atguigu.components
 *
 * description: 普通的组件
 */
public class CommonComponent &#123;
&#125;
</code></pre>
<pre><code>      Controller组件
</code></pre>
<pre><code class="Java">/**
 * projectName: com.atguigu.components
 *
 * description: controller类型组件
 */
public class XxxController &#123;
&#125;
</code></pre>
<pre><code>      Service组件
</code></pre>
<pre><code class="Java">/**
 * projectName: com.atguigu.components
 *
 * description: service类型组件
 */
public class XxxService &#123;
&#125;
</code></pre>
<pre><code>      Dao组件
</code></pre>
<pre><code class="Java">/**
 * projectName: com.atguigu.components
 *
 * description: dao类型组件
 */
public class XxxDao &#123;
&#125;
</code></pre>
<ol start="4">
<li><strong>组件添加标记注解</strong><ol>
<li><p>组件标记注解和区别</p>
<p> Spring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。</p>
<ul>
<li>注意:添加注解默认的id为类的开头小写</li>
</ul>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。</td>
</tr>
<tr>
<td>@Repository</td>
<td>该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
<tr>
<td>@Service</td>
<td>该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
<tr>
<td>@Controller</td>
<td>该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
</tbody></table>
<p>​<br>​          通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是在@Component注解的基础上起了三个新的名字。<br>​<br>          对于Spring使用IOC容器管理这些组件来说没有区别，也就是语法层面没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。</p>
<pre><code>      注意：虽然它们本质上一样，但是为了代码的可读性、程序结构严谨！我们肯定不能随便胡乱标记。
  2. 使用注解标记
  
      普通组件
</code></pre>
<pre><code class="Java">/**
 * projectName: com.atguigu.components
 *
 * description: 普通的组件
 */
@Component
public class CommonComponent &#123;
&#125;
</code></pre>
<pre><code>      Controller组件
</code></pre>
<pre><code class="Java">/**
 * projectName: com.atguigu.components
 *
 * description: controller类型组件
 */
@Controller
public class XxxController &#123;
&#125;
</code></pre>
<pre><code>      Service组件
</code></pre>
<pre><code class="Java">/**
 * projectName: com.atguigu.components
 *
 * description: service类型组件
 */
@Service
public class XxxService &#123;
&#125;
</code></pre>
<pre><code>      Dao组件
</code></pre>
<pre><code class="Java">/**
 * projectName: com.atguigu.components
 *
 * description: dao类型组件
 */
@Repository
public class XxxDao &#123;
&#125;
</code></pre>
<ol start="5">
<li><p><strong>配置文件确定扫描范围</strong></p>
<p> 情况1：基本扫描配置</p>
</li>
</ol>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 配置自动扫描的包 --&gt;
    &lt;!-- 1.包要精准,提高性能!
         2.会扫描指定的包和子包内容
         3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等
    --&gt;
    &lt;context:component-scan base-package=&quot;com.chenw.ioc_01&quot;/&gt;
  
&lt;/beans&gt;
</code></pre>
<pre><code>  情况2：指定排除组件
</code></pre>
<pre><code class="XML">&lt;!-- 情况三：指定不扫描的组件 --&gt;
    &lt;context:component-scan base-package=&quot;com.chenw.ioc_01&quot;&gt;
        &lt;!--排序com.chenw.ioc_01下面的Repository的注解--&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot;/&gt;
        &lt;!--排序com.chenw.ioc_01下面的Service的注解--&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;/&gt;
    &lt;/context:component-scan&gt;
</code></pre>
<pre><code>  情况3：指定扫描组件
</code></pre>
<pre><code class="XML">&lt;!-- 情况四：仅扫描指定的组件 --&gt;
&lt;!-- 仅扫描 = 关闭默认规则 + 追加规则 --&gt;
&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;
    &lt;!--
        指定包下面的哪些注解是生效的
        注意
            因为base-package是指定包下面的所有的注解都生效，use-default-filters是指定这个包下面的注解都不生效
    --&gt;
    &lt;context:component-scan base-package=&quot;com.chenw.ioc_01&quot; use-default-filters=&quot;false&quot;&gt;
        &lt;!--上面的包的注解都失效了，才能指定哪些的注解生效--&gt;
        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot;/&gt;
    &lt;/context:component-scan&gt;
</code></pre>
<ol start="6">
<li><p><strong>组件BeanName问题</strong></p>
<p> 在我们使用 XML 方式管理 bean 的时候，每个 bean 都有一个唯一标识——id 属性的值，便于在其他地方引用。现在使用注解后，每个组件仍然应该有一个唯一标识。</p>
<p> 默认情况：</p>
<p> 类名首字母小写就是 bean 的 id。例如：SoldierController 类对应的 bean 的 id 就是 soldierController。</p>
<p> 使用value属性指定：</p>
</li>
</ol>
<pre><code class="Java">@Controller(value = &quot;tianDog&quot;)
public class SoldierController &#123;
&#125;
</code></pre>
<pre><code>  当注解中只设置一个属性时，value属性的属性名可以省略：
</code></pre>
<pre><code class="Java">@Service(&quot;smallDog&quot;)
public class SoldierService &#123;
&#125;
</code></pre>
<ol start="7">
<li><strong>总结</strong><ol>
<li>注解方式IoC只是标记哪些类要被Spring管理</li>
<li>最终，我们还需要XML方式或者后面讲解Java配置类方式指定注解生效的包</li>
<li><strong>现阶段配置方式为 注解 （标记）+ XML（扫描）</strong></li>
</ol>
</li>
</ol>
<p><strong>组件(Bean)作用域和周期方法注解</strong></p>
<ol>
<li>组件周期方法配置<ol>
<li><p>周期方法概念</p>
<p> 我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！</p>
<p> 类似于Servlet的init&#x2F;destroy方法,我们可以在周期方法完成初始化和释放资源等工作。</p>
</li>
<li><p>周期方法声明</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">public class BeanOne &#123;
  //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表
  @PostConstruct  //注解制指定初始化方法
  public void init() &#123;
    // 初始化逻辑
  &#125;
&#125;

public class BeanTwo &#123;
  @PreDestroy //注解指定销毁方法
  public void cleanup() &#123;
    // 释放资源逻辑
  &#125;
&#125;
</code></pre>
<ol start="2">
<li>组件作用域配置<ol>
<li><p>Bean作用域概念</p>
<p> <code>&lt;bean</code> 标签声明Bean，只是将Bean的信息配置给SpringIoC容器！</p>
<p> 在IoC容器中，这些<code>&lt;bean</code>标签对应的信息转成Spring内部 <code>BeanDefinition</code> 对象，<code>BeanDefinition</code> 对象内，包含定义的信息（id,class,属性等等）！</p>
<p> 这意味着，<code>BeanDefinition</code>与<code>类</code>概念一样，SpringIoC容器可以可以根据<code>BeanDefinition</code>对象反射创建多个Bean对象实例。</p>
<p> 具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！</p>
</li>
<li><p>作用域可选值</p>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>在 IOC 容器中，这个 bean 的对象始终为单实例</td>
<td>IOC 容器初始化时</td>
<td>是</td>
</tr>
<tr>
<td>prototype</td>
<td>这个 bean 在 IOC 容器中有多个实例</td>
<td>获取 bean 时</td>
<td>否</td>
</tr>
</tbody></table>
<pre><code>    如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）：
</code></pre>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>request</td>
<td>请求范围内有效的实例</td>
<td>每次请求</td>
<td>否</td>
</tr>
<tr>
<td>session</td>
<td>会话范围内有效的实例</td>
<td>每次会话</td>
<td>否</td>
</tr>
</tbody></table>
<pre><code>3. 作用域配置
</code></pre>
<pre><code class="Java">package com.chenw.ioc_02;


import org.springframework.beans.factory.annotation.Configurable;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;


@Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON)  //默认的单列
@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE)  //多例模式
@Component
public class JavaBean &#123;
    /*
    * 周期方法名字随意，
    * 但是还是之前的要求，方法没有返回值，没有参数
    * */
    @PostConstruct
    public void init()&#123;
        System.out.println(&quot;init start&quot;);

    &#125;
    @PreDestroy
    public void destroy()&#123;
        System.out.println(&quot;destroy start&quot;);
    &#125;
&#125;
</code></pre>
<p>测试</p>
<pre><code class="java">    @Test
    public void testIoC_02()&#123;
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-02.xml&quot;);
        JavaBean javaBean = applicationContext.getBean(&quot;javaBean&quot;, JavaBean.class);
        JavaBean javaBean1 = applicationContext.getBean(&quot;javaBean&quot;, JavaBean.class);
        System.out.println(javaBean1 == javaBean);
        applicationContext.close();
        /*
        * 	init start
            init start
            false
        * */
    &#125;
</code></pre>
<pre><code>注意这里面没有调用周期方法destroy的方法，是因为多例不会调用
</code></pre>
<p><strong>基于注解的注入(引入类型的自动装配)</strong></p>
<ol>
<li><strong>设定场景</strong><ul>
<li><p>SoldierController 需要 SoldierService</p>
</li>
<li><p>SoldierService 需要 SoldierDao</p>
<p>同时在各个组件中声明要调用的方法。</p>
</li>
<li><p>SoldierController中声明方法</p>
</li>
</ul>
</li>
</ol>
<pre><code class="Java">import org.springframework.stereotype.Controller;

@Controller(value = &quot;tianDog&quot;)
public class SoldierController &#123;

    private SoldierService soldierService;

    public void getMessage() &#123;
        soldierService.getMessage();
    &#125;

&#125;
</code></pre>
<pre><code>- SoldierService中声明方法
</code></pre>
<pre><code class="Java">@Service(&quot;smallDog&quot;)
public class SoldierService &#123;

    private SoldierDao soldierDao;

    public void getMessage() &#123;
        soldierDao.getMessage();
    &#125;
&#125;
</code></pre>
<pre><code>- SoldierDao中声明方法
</code></pre>
<pre><code class="Java">@Repository
public class SoldierDao &#123;

    public void getMessage() &#123;
        System.out.print(&quot;I am a soldier&quot;);
    &#125;

&#125;
</code></pre>
<ol start="2">
<li><strong>自动装配实现</strong><ol>
<li><p>前提</p>
<p> 参与自动装配的组件（需要装配、被装配）全部都必须在IoC容器中。</p>
<p> 注意：不区分IoC的方式！XML和注解都可以！</p>
</li>
<li><p>@Autowired注解</p>
<p> 在成员变量上直接标记@Autowired注解即可，不需要提供setXxx()方法。以后我们在项目中的正式用法就是这样。</p>
</li>
<li><p>给Controller装配Service</p>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">@Controller(value = &quot;tianDog&quot;)
public class SoldierController &#123;
    
    @Autowired
    private SoldierService soldierService;
    
    public void getMessage() &#123;
        soldierService.getMessage();
    &#125;
    
&#125;
</code></pre>
<pre><code>4. 给Service装配Dao
</code></pre>
<pre><code class="Java">@Service(&quot;smallDog&quot;)
public class SoldierService &#123;
    
    @Autowired
    private SoldierDao soldierDao;
    
    public void getMessage() &#123;
        soldierDao.getMessage();
    &#125;
&#125;
</code></pre>
<ol start="3">
<li><strong>@Autowired注解细节</strong><ol>
<li>标记位置<ol>
<li><p>成员变量</p>
<p> <strong>这是最主要的使用方式！</strong></p>
<p> <strong>与xml进行bean ref引用不同，他不需要有set方法！</strong></p>
<p> <strong>所以这是直接属性进行赋值操作，不像之前的xml配置方式，通过set等方法实现</strong></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code class="Java">@Service(&quot;smallDog&quot;)
public class SoldierService &#123;
    
    @Autowired
    private SoldierDao soldierDao;
    
    public void getMessage() &#123;
        soldierDao.getMessage();
    &#125;
&#125;
</code></pre>
<pre><code>    2. 构造器
</code></pre>
<pre><code class="Java">@Controller(value = &quot;tianDog&quot;)
public class SoldierController &#123;
    
    private SoldierService soldierService;
    
    @Autowired
    public SoldierController(SoldierService soldierService) &#123;
        this.soldierService = soldierService;
    &#125;
    ……
</code></pre>
<pre><code>    3. setXxx()方法
</code></pre>
<pre><code class="Java">@Controller(value = &quot;tianDog&quot;)
public class SoldierController &#123;

    private SoldierService soldierService;

    @Autowired
    public void setSoldierService(SoldierService soldierService) &#123;
        this.soldierService = soldierService;
    &#125;
    ……
</code></pre>
<ol start="2">
<li>工作流程</li>
</ol>
<p>​    <img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img018.2ff0ae09.png"></p>
<ul>
<li>首先根据所需要的组件类型到 IOC 容器中查找<ul>
<li>能够找到唯一的 bean：直接执行装配</li>
<li>如果完全找不到匹配这个类型的 bean：装配失败</li>
<li>和所需类型匹配的 bean 不止一个<ul>
<li>没有 @Qualifier 注解：根据 @Autowired 标记位置成员变量的变量名作为 bean 的 id 进行匹配<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
<li>使用 @Qualifier 注解：根据 @Qualifier 注解中指定的名称作为 bean 的id进行匹配<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="Java">@Controller(value = &quot;tianDog&quot;)
public class SoldierController &#123;
    
    @Autowired
    @Qualifier(value = &quot;maomiService222&quot;)
    // 根据面向接口编程思想，使用接口类型引入Service组件
    private ISoldierService soldierService;
</code></pre>
<ol start="4">
<li><p><strong>佛系装配</strong></p>
<p> 给 @Autowired 注解设置 required &#x3D; false 属性表示：能装就装，装不上就不装。但是实际开发时，基本上所有需要装配组件的地方都是必须装配的，用不上这个属性</p>
</li>
</ol>
<pre><code class="java">@Controller(value = &quot;tianDog&quot;)
public class SoldierController &#123;

    // 给@Autowired注解设置required = false属性表示：能装就装，装不上就不装
    @Autowired(required = false)
    private ISoldierService soldierService;
</code></pre>
<p>还有一种情况，对应多个的情况</p>
<p>例如</p>
<pre><code class="java">controller层有一个的定义的一个接口的成员变量，UserService
    他的下面有两个实现类
@Service
public class NewUserService implements UserService &#123;
    @Override
    public String show() &#123;
        return &quot;UserServiceImpl show&quot;;
    &#125;
&#125;
@Service
public class UserServiceImpl implements UserService &#123;
    @Override
    public String show() &#123;
        return &quot;UserServiceImpl show&quot;;
    &#125;
&#125;
上面都添加注解，而且没有指定名字，这样自动装配，就会出错	
</code></pre>
<pre><code class="java">public class UserController &#123;
    /*
    * @Autowired相当于&lt;property userService -&gt; 对应类型的bean装配&gt;
    //自动装配注解（DI）:1.ioc容器里面查找符合类型的组件的对象 2.设置给当前的属性（di）
    * */
    @Autowired
    private UserService userService;

    public void setUserService(UserService userService) &#123;
        this.userService = userService;
    &#125;

    @Test
    public void show()&#123;
        //调用业务层的show
        System.out.println(userService.show());
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240422111659141.png" alt="image-20240422111659141"></p>
<p>这样就会出错</p>
<pre><code>解决的方法
    1.成员属性名指定@AutoWired的时候，默认的会根据成员的属性名作为bean的id去查找
</code></pre>
<p>例如</p>
<p>我们的属性的名字为</p>
<pre><code>newUserService这样就会寻找id为newUserServicebean的bean
</code></pre>
<pre><code class="java">package com.chenw.ioc_03;


import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

@Controller
public class UserController &#123;
    /*
    * @Autowired相当于&lt;property userService -&gt; 对应类型的bean装配&gt;
    //自动装配注解（DI）:1.ioc容器里面查找符合类型的组件的对象 2.设置给当前的属性（di）
    * */
    @Autowired
    private UserService newUserService;

    public void setUserService(UserService userService) &#123;
        this.newUserService = userService;
    &#125;

    @Test
    public void show()&#123;
        //调用业务层的show
        System.out.println(newUserService.show());
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.chenw.ioc_03;


import org.springframework.stereotype.Service;

@Service
public class NewUserService implements UserService &#123;
    @Override
    public String show() &#123;
        return &quot;NewUserService show&quot;;
    &#125;
&#125;
</code></pre>
<p>再来测试</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240422112302142.png" alt="image-20240422112302142"></p>
<pre><code>解决方法2,注解
    @Qualifier，使用该注解指定Bean的id，不能单独使用必须配合autowired
</code></pre>
<pre><code class="java">@Autowired()
@Qualifier(&quot;userServiceImpl&quot;)
private UserService newUserService;

public void setUserService(UserService userService) &#123;
    this.newUserService = userService;
&#125;
</code></pre>
<p>测试</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240422115010462.png" alt="image-20240422115010462"></p>
<p>上面需要两个注解联合使用，</p>
<p>下面的Resource注解将他们的功能整合到一起,就直接实现找到对应id的bean然后实现自动装配</p>
<pre><code class="java">@Autowired(required = true) + @Qualifier(&quot;userServiceImpl&quot;)  = @Source(name=&quot;userServiceImpl&quot;)
</code></pre>
<ol start="5">
<li><p><strong>扩展JSR-250注解@Resource</strong></p>
<ul>
<li><p>理解JSR系列注解</p>
<p>  JSR（Java Specification Requests）是Java平台标准化进程中的一种技术规范，而JSR注解是其中一部分重要的内容。按照JSR的分类以及注解语义的不同，可以将JSR注解分为不同的系列，主要有以下几个系列：</p>
<ol>
<li>JSR-175: 这个JSR是Java SE 5引入的，是Java注解最早的规范化版本，Java SE 5后的版本中都包含该JSR中定义的注解。主要包括以下几种标准注解：</li>
</ol>
<ul>
<li><code>@Deprecated</code>: 标识一个程序元素（如类、方法或字段）已过时，并且在将来的版本中可能会被删除。</li>
<li><code>@Override</code>: 标识一个方法重写了父类中的方法。</li>
<li><code>@SuppressWarnings</code>: 抑制编译时产生的警告消息。</li>
<li><code>@SafeVarargs</code>: 标识一个有安全性警告的可变参数方法。</li>
<li><code>@FunctionalInterface</code>: 标识一个接口只有一个抽象方法，可以作为lambda表达式的目标。</li>
</ul>
<ol>
<li>JSR-250: 这个JSR主要用于在Java EE 5中定义一些支持注解。该JSR主要定义了一些用于进行对象管理的注解，包括：</li>
</ol>
<ul>
<li><code>@Resource</code>: 标识一个需要注入的资源，是实现Java EE组件之间依赖关系的一种方式。</li>
<li><code>@PostConstruct</code>: 标识一个方法作为初始化方法。</li>
<li><code>@PreDestroy</code>: 标识一个方法作为销毁方法。</li>
<li><code>@Resource.AuthenticationType</code>: 标识注入的资源的身份验证类型。</li>
<li><code>@Resource.AuthenticationType</code>: 标识注入的资源的默认名称。</li>
</ul>
<ol>
<li>JSR-269: 这个JSR主要是Java SE 6中引入的一种支持编译时元数据处理的框架，即使用注解来处理Java源文件。该JSR定义了一些可以用注解标记的注解处理器，用于生成一些元数据，常用的注解有：</li>
</ol>
<ul>
<li><code>@SupportedAnnotationTypes</code>: 标识注解处理器所处理的注解类型。</li>
<li><code>@SupportedSourceVersion</code>: 标识注解处理器支持的Java源码版本。</li>
</ul>
<ol>
<li>JSR-330: 该JSR主要为Java应用程序定义了一个依赖注入的标准，即Java依赖注入标准（javax.inject）。在此规范中定义了多种注解，包括：</li>
</ol>
<ul>
<li><code>@Named</code>: 标识一个被依赖注入的组件的名称。</li>
<li><code>@Inject</code>: 标识一个需要被注入的依赖组件。</li>
<li><code>@Singleton</code>: 标识一个组件的生命周期只有一个唯一的实例。</li>
</ul>
<ol>
<li>JSR-250: 这个JSR主要是Java EE 5中定义一些支持注解。该JSR包含了一些支持注解，可以用于对Java EE组件进行管理，包括：</li>
</ol>
<ul>
<li><code>@RolesAllowed</code>: 标识授权角色</li>
<li><code>@PermitAll</code>: 标识一个活动无需进行身份验证。</li>
<li><code>@DenyAll</code>: 标识不提供针对该方法的访问控制。</li>
<li><code>@DeclareRoles</code>: 声明安全角色。</li>
</ul>
<p>  但是你要理解JSR是Java提供的<strong>技术规范</strong>，也就是说，他只是规定了注解和注解的含义，<strong>JSR并不是直接提供特定的实现</strong>，而是提供标准和指导方针，由第三方框架（Spring）和库来实现和提供对应的功能。</p>
</li>
<li><p>JSR-250 @Resource注解</p>
<p>  @Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？</p>
<ul>
<li>@Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。)</li>
<li>@Autowired注解是Spring框架自己的。</li>
<li><strong>@Resource注解默认根据Bean名称装配，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型装配。</strong></li>
<li><strong>@Autowired注解默认根据类型装配，如果想根据名称装配，需要配合@Qualifier注解一起用。</strong></li>
<li>@Resource注解用在属性上、setter方法上。</li>
<li>@Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。</li>
</ul>
<p>  @Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【<strong>高于JDK11或低于JDK8需要引入以下依赖</strong>】</p>
</li>
</ul>
</li>
</ol>
<pre><code class="XML">&lt;dependency&gt;
    &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;
    &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;
    &lt;version&gt;2.1.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code>- @Resource使用
</code></pre>
<pre><code class="Java">@Controller
public class XxxController &#123;
    /**
     * 1. 如果没有指定name,先根据属性名查找IoC中组件xxxService
     * 2. 如果没有指定name,并且属性名没有对应的组件,会根据属性类型查找
     * 3. 可以指定name名称查找!  @Resource(name=&#39;test&#39;) == @Autowired + @Qualifier(value=&#39;test&#39;)
     */
    @Resource
    private XxxService xxxService;

    //@Resource(name = &quot;指定beanName&quot;)
    //private XxxService xxxService;

    public void show()&#123;
        System.out.println(&quot;XxxController.show&quot;);
        xxxService.show();
    &#125;
&#125;
</code></pre>
<p>注意resource是这个包</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240422120914997.png" alt="image-20240422120914997"></p>
<p><strong>赋值类型的属性赋值(使用注解)</strong></p>
<p><code>@Value</code> 通常用于注入外部化属性</p>
<p><strong>声明外部配置</strong></p>
<p>jdbc.properties</p>
<pre><code class="Java">jdbc.username=root
jdbc.password=root
</code></pre>
<p><strong>xml引入外部配置</strong></p>
<pre><code class="Java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;com.chenw.ioc_04&quot;/&gt;
        //引入外部的配置文件
    &lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>@Value注解读取配置</strong></p>
<pre><code class="java">package com.chenw.ioc_04;


import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class JavaBean &#123;

    //方案1直接赋值
    //方案2 注解赋值，通常一般是直接赋值，一般使用注解是读取外部的信息
    @Value(&quot;张三&quot;)
    private String name;
    @Value(&quot;$&#123;jdbc.username&#125;&quot;)
    private String username;
    @Value(&quot;$&#123;jdbc.password&#125;&quot;)
    private String password;
&#125;
</code></pre>
<p><strong>测试</strong></p>
<pre><code class="java">    @Test
    public void testIoC_04()&#123;
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-04.xml&quot;);
        com.chenw.ioc_04.JavaBean bean = applicationContext.getBean(com.chenw.ioc_04.JavaBean.class);
        System.out.println(bean);
    &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240422162441038.png" alt="image-20240422162441038"></p>
<p>注解那里还可以添加默认值</p>
<pre><code class="java">@Value(&quot;$&#123;jdbc.username:胡图图&#125;&quot;)
private String username;
</code></pre>
<pre><code>如果外部的配置文件的里面没有username的值，那么就会使用胡图图
</code></pre>
<pre><code>对于之前的第三方的jar包，我们不能再第三方jar包上面添加注解，需要使用XML的方式进行配置	 
</code></pre>
<p><strong>使用注解+XML的方式实现整合的三层架构</strong></p>
<ol>
<li>三层架构搭建和实现<ol>
<li>持久层</li>
</ol>
</li>
</ol>
<pre><code class="Java">package com.chenw.dao;

import com.chenw.pojo.Student;

import java.util.List;

public interface StudentDao &#123;
    List&lt;Student&gt; queryAll();
&#125;


//实现类
package com.chenw.dao.Impl;

import com.chenw.dao.StudentDao;
import com.chenw.pojo.Student;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Repository;

import java.util.List;


@Repository
public class StudentDaoImpl implements StudentDao &#123;
    @Autowired
    private JdbcTemplate jdbcTemplate;
    @Override
    public List&lt;Student&gt; queryAll() &#123;
        String sql = &quot;select id ,name , age ,gender,class as classes from students&quot;;
        List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class));
        return studentList;
    &#125;
&#125;

</code></pre>
<pre><code>2. 业务层
</code></pre>
<pre><code class="Java">//接口
package com.chenw.service;

import com.chenw.pojo.Student;

import java.util.List;

public interface StudentService &#123;

    /**
     * 查询全部学员业务
     * @return
     */
    List&lt;Student&gt; findAll();

&#125;

//实现类
import com.chenw.pojo.Student;
import com.chenw.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class StudentServiceImpl  implements StudentService &#123;

    @Autowired
    private StudentDao studentDao;

    /**
     * 查询全部学员业务
     * @return
     */
    @Override
    public List&lt;Student&gt; findAll() &#123;

        List&lt;Student&gt; studentList =  studentDao.queryAll();

        return studentList;
    &#125;
&#125;
</code></pre>
<pre><code>3. 表述层
</code></pre>
<pre><code class="Java">package com.chenw.controller;

import com.chenw.pojo.Student;
import com.chenw.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

import java.util.List;

@Controller
public class StudentController &#123;

    @Autowired
    private StudentService studentService;

    public void  findAll()&#123;
       List&lt;Student&gt; studentList =  studentService.findAll();
        System.out.println(&quot;studentList = &quot; + studentList);
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>三层架构IoC配置</li>
</ol>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!--将自己的类注解扫描--&gt;
    &lt;context:component-scan base-package=&quot;com.chenw&quot;/&gt;

    &lt;!--第三方的类依然使用bean标签配置--&gt;
    &lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;chenw.driver&#125;&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;chenw.username&#125;&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;chenw.password&#125;&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;chenw.url&#125;&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ol start="3">
<li>运行测试</li>
</ol>
<pre><code class="Java">    @Test
    public void test()&#123;
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        StudentController bean = applicationContext.getBean(StudentController.class);
        bean.findAll();
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240422171952627.png" alt="image-20240422171952627"></p>
<p>4.注解+XML IoC方式问题总结</p>
<ol>
<li>自定义类可以使用注解方式，但是第三方依赖的类依然使用XML方式！</li>
<li>XML格式解析效率低！</li>
</ol>
<p><strong>配置类完成完全的注解开发</strong></p>
<pre><code>之前我们使用注解，还需要XML配置文件进行辅助，但是使用配置类的方法以后，就可以不用写配置文件了
</code></pre>
<h4 id="4-4-1-完全注解开发理解"><a href="#4-4-1-完全注解开发理解" class="headerlink" title="4.4.1 完全注解开发理解"></a>4.4.1 完全注解开发理解</h4><p>  Spring 完全注解配置（Fully Annotation-based Configuration）是指通过 Java配置类 代码来配置 Spring 应用程序，使用注解来替代原本在 XML 配置文件中的配置。相对于 XML 配置，完全注解配置具有更强的类型安全性和更好的可读性。</p>
<p>  <strong>两种方式思维转化</strong>：</p>
<p>  <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<p><strong>配置类和扫描注解</strong></p>
<p><strong>xml+注解方式</strong></p>
<p>配置文件application.xml</p>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;


    &lt;!-- 配置自动扫描的包 --&gt;
    &lt;!-- 1.包要精准,提高性能!
         2.会扫描指定的包和子包内容
         3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等
    --&gt;
    &lt;context:component-scan base-package=&quot;com.atguigu.components&quot;/&gt;

    &lt;!-- 引入外部配置文件--&gt;
    &lt;context:property-placeholder location=&quot;application.properties&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<p>测试创建IoC容器</p>
<pre><code class="Java"> // xml方式配置文件使用ClassPathXmlApplicationContext容器读取
 ApplicationContext applicationContext =
                new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
</code></pre>
<p><strong>配置类+注解方式（完全注解方式）</strong></p>
<p>配置类</p>
<p>使用 @Configuration 注解将一个普通的类标记为 Spring 的配置类。</p>
<pre><code class="Java">import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;

//标注当前类是配置类，替代application.xml    
@Configuration
//使用注解读取外部配置，替代 &lt;context:property-placeholder标签，指定类路径下的配置文件
@PropertySource(&quot;classpath:application.properties&quot;)
//使用@ComponentScan注解,可以配置扫描包,替代&lt;context:component-scan标签
@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)
public class MyConfiguration &#123;
    
&#125;
</code></pre>
<p>测试创建IoC容器</p>
<pre><code class="Java">// AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象
ApplicationContext iocContainerAnnotation = 
new AnnotationConfigApplicationContext(MyConfiguration.class);
</code></pre>
<p>可以使用 no-arg 构造函数实例化 <code>AnnotationConfigApplicationContext</code> ，然后使用 <code>register()</code> 方法对其进行配置。此方法在以编程方式生成 <code>AnnotationConfigApplicationContext</code> 时特别有用。以下示例演示如何执行此操作：</p>
<pre><code class="Java">// AnnotationConfigApplicationContext-IOC容器对象
ApplicationContext iocContainerAnnotation = 
new AnnotationConfigApplicationContext();
//外部设置配置类
iocContainerAnnotation.register(MyConfiguration.class);
//刷新后方可生效！！
iocContainerAnnotation.refresh();
</code></pre>
<p><strong>总结：</strong></p>
<p>  @Configuration指定一个类为配置类，可以添加配置注解，替代配置xml文件</p>
<p>  @ComponentScan(basePackages &#x3D; {“包”,”包”}) 替代&lt;context:component-scan标签实现注解扫描</p>
<p>  @PropertySource(“classpath:配置文件地址”) 替代 &lt;context:property-placeholder标签</p>
<p>  配合IoC&#x2F;DI注解，可以进行完整注解开发！</p>
<p><strong>@Bean定义组件</strong></p>
<pre><code>如果是第三方类那应该怎么声明
</code></pre>
<p><strong>场景需求</strong>：将Druid连接池对象存储到IoC容器</p>
<p><strong>需求分析</strong>：第三方jar包的类，添加到ioc容器，无法使用@Component等相关注解！因为源码jar包内容为只读模式！</p>
<p><strong>xml方式实现</strong>：</p>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;


    &lt;!-- 引入外部属性文件 --&gt;
    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;

    &lt;!-- 实验六 [重要]给bean的属性赋值：引入外部属性文件 --&gt;
    &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p><strong>配置类方式实现</strong>：</p>
<p>  <code>@Bean</code> 注释用于指示方法实例化、配置和初始化要由 Spring IoC 容器管理的新对象。对于那些熟悉 Spring 的 <code>&lt;beans/&gt;</code> XML 配置的人来说， <code>@Bean</code> 注释与 <code>&lt;bean/&gt;</code> 元素起着相同的作用。</p>
<pre><code class="Java">package com.chenw.config;



/*
*
*   1.b包扫描注解配置类，代替XML配置文件
*   2.引用外部的配置文件
*   3.声明第三方依赖的bean组件
* */

import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;

/*
*1.添加configuration的注解
* 2.实现上面的功能注解
* */
@Configuration
@ComponentScan(&quot;com.chenw.ioc_01&quot;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
public class JavaConfiguration &#123;
    @Value(&quot;$&#123;chenw.url&#125;&quot;)
    private String url;
    @Value(&quot;$&#123;chenw.username&#125;&quot;)
    private String username;
    @Value(&quot;$&#123;chenw.password&#125;&quot;)
    private String password;
    @Value(&quot;$&#123;chenw.driver&#125;&quot;)
    private String driver;

    /*
    *   方法的返回值的类型 == bean组件的类型或则其他的接口和父类
    *   方法名字  = bean的id的标识
    *   在方法体实现自定义类的过程
    *   最后添加@Bean注解 真正的让配置类的方法创建的组件存储到ioc容器
    *
    * */
    @Bean
    public DruidDataSource dataSource()&#123;
        //具体实例化的方法
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        dataSource.setDriverClassName(driver);
        dataSource.setUrl(url);
        return dataSource;
    &#125;
    /*
    * 这个最后就相当于
    * &lt;bean id=&quot;dataSource&quot; class=&quot;DruidSource&quot;&gt;
        配置
    *   &lt;/bean&gt;
    * */
    //注意读取配置文件的可以写在形参列表
    @Bean
    public DataSource createDataSource(@Value(&quot;$&#123;jdbc.user&#125;&quot;) String username,
                                       @Value(&quot;$&#123;jdbc.password&#125;&quot;)String password,
                                       @Value(&quot;$&#123;jdbc.url&#125;&quot;)String url,
                                       @Value(&quot;$&#123;jdbc.driver&#125;&quot;)String driverClassName)&#123;
        //使用Java代码实例化
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        dataSource.setUrl(url);
        dataSource.setDriverClassName(driverClassName);
        //返回结果即可
        return dataSource;
    &#125;
&#125;
</code></pre>
<p><strong>@Bean组件的高级使用</strong></p>
<ol>
<li><p><strong>@Bean生成BeanName问题</strong></p>
<pre><code>默认的bean的id为方法的名字
可以指定在Bean注解里面的使用name或者value属性进行赋值，value可以进行省略
</code></pre>
<p> @Bean注解源码：</p>
</li>
</ol>
<pre><code class="Java">public @interface Bean &#123;
    //前两个注解可以指定Bean的标识
    @AliasFor(&quot;name&quot;)
    String[] value() default &#123;&#125;;
    @AliasFor(&quot;value&quot;)
    String[] name() default &#123;&#125;;
  
    //autowireCandidate 属性来指示该 Bean 是否候选用于自动装配。
    //autowireCandidate 属性默认值为 true，表示该 Bean 是一个默认的装配目标，
    //可被候选用于自动装配。如果将 autowireCandidate 属性设置为 false，则说明该 Bean 不是默认的装配目标，不会被候选用于自动装配。
    boolean autowireCandidate() default true;

    //指定初始化方法
    String initMethod() default &quot;&quot;;
    //指定销毁方法
    String destroyMethod() default &quot;(inferred)&quot;;
&#125;
</code></pre>
<pre><code>指定@Bean的名称：
</code></pre>
<pre><code class="Java">@Configuration
public class AppConfig &#123;

  @Bean(&quot;myThing&quot;) //指定名称
  public Thing thing() &#123;
    return new Thing();
  &#125;
&#125;
</code></pre>
<pre><code>`@Bean` 注释注释方法。使用此方法在指定为方法返回值的类型的 `ApplicationContext` 中注册 Bean 定义。缺省情况下，Bean 名称与方法名称相同。下面的示例演示 `@Bean` 方法声明：
</code></pre>
<pre><code class="Java">@Configuration
public class AppConfig &#123;

  @Bean
  public TransferServiceImpl transferService() &#123;
    return new TransferServiceImpl();
  &#125;
&#125;
</code></pre>
<pre><code>前面的配置完全等同于下面的Spring XML：
</code></pre>
<pre><code class="Java">&lt;beans&gt;
  &lt;bean id=&quot;transferService&quot; class=&quot;com.acme.TransferServiceImpl&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<ol start="2">
<li><p><strong>@Bean 初始化和销毁方法指定</strong></p>
<p> <code>@Bean</code> 注解支持指定任意初始化和销毁回调方法，非常类似于 Spring XML 在 <code>bean</code> 元素上的 <code>init-method</code> 和 <code>destroy-method</code> 属性，如以下示例所示：</p>
</li>
</ol>
<pre><code class="Java">public class BeanOne &#123;

  public void init() &#123;
    // initialization logic
  &#125;
&#125;

public class BeanTwo &#123;

  public void cleanup() &#123;
    // destruction logic
  &#125;
&#125;

@Configuration
public class AppConfig &#123;

  @Bean(initMethod = &quot;init&quot;)
  public BeanOne beanOne() &#123;
    return new BeanOne();
  &#125;

  @Bean(destroyMethod = &quot;cleanup&quot;)
  public BeanTwo beanTwo() &#123;
    return new BeanTwo();
  &#125;
&#125;
</code></pre>
<ol start="3">
<li><p><strong>@Bean Scope作用域</strong></p>
<p> 可以指定使用 <code>@Bean</code> 注释定义的 bean 应具有特定范围。您可以使用在 Bean 作用域部分中指定的任何标准作用域。</p>
<p> 默认作用域为 <code>singleton</code> ，但您可以使用 <code>@Scope</code> 注释覆盖此范围，如以下示例所示：</p>
</li>
</ol>
<pre><code class="Java">@Configuration
public class MyConfiguration &#123;

  @Bean
  @Scope(scopeName = CofigurableBeanFactory.SCOPE_SINGLETON)
  public Encryptor encryptor() &#123;
    // ...
  &#125;
&#125;
</code></pre>
<ol start="4">
<li><p><strong>@Bean方法之间依赖</strong></p>
<p> 例如</p>
<pre><code class="java">package com.chenw.config;



/*
*
*   1.b包扫描注解配置类，代替XML配置文件
*   2.引用外部的配置文件
*   3.声明第三方依赖的bean组件
* */

import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;

/*
*1.添加configuration的注解
* 2.实现上面的功能注解
* */
@Configuration
@ComponentScan(&quot;com.chenw.ioc_01&quot;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
public class JavaConfiguration &#123;
    @Value(&quot;$&#123;chenw.url&#125;&quot;)
    private String url;
    @Value(&quot;$&#123;chenw.username&#125;&quot;)
    private String username;
    @Value(&quot;$&#123;chenw.password&#125;&quot;)
    private String password;
    @Value(&quot;$&#123;chenw.driver&#125;&quot;)
    private String driver;

    /*
    *   方法的返回值的类型 == bean组件的类型或则其他的接口和父类
    *   方法名字  = bean的id的标识
    *   在方法体实现自定义类的过程
    *   最后添加@Bean注解 真正的让配置类的方法创建的组件存储到ioc容器
    *
    * */
    @Bean
    public DruidDataSource dataSource()&#123;
        //具体实例化的方法
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        dataSource.setDriverClassName(driver);
        dataSource.setUrl(url);
        return dataSource;
    &#125;

    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123;
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        //两种方法
        //1.如果引用的组件也是使用@Bean注解，直接调用可以  | 本质上看是方法，其实是从ioc引用组件 | 不推荐
//        jdbcTemplate.setDataSource(dataSource());
        //2.利用形参列表传值,在形参列表写上对应的引用，或者多个引用，ioc会自动完成装配
        /*
            可能出现两种情况
        *   1.如果没有引用的
                注意形参蚕食注入，要求需要必须有对应的类型的组件，如果没有抛异常
        *   2.如果存在多个
                可以使用形成你名称 == 你需要的bean的id
        * */
        jdbcTemplate.setDataSource(dataSource);
        return  jdbcTemplate;
    &#125;
&#125;
</code></pre>
</li>
</ol>
<p><strong>扩展@Import注解的使用</strong></p>
<p><code>@Import</code> 注释允许从另一个配置类加载 <code>@Bean</code> 定义，如以下示例所示：</p>
<pre><code class="Java">@Configuration
public class ConfigA &#123;

  @Bean
  public A a() &#123;
    return new A();
  &#125;
&#125;

@Configuration
@Import(ConfigA.class)
public class ConfigB &#123;

  @Bean
  public B b() &#123;
    return new B();
  &#125;
&#125;
</code></pre>
<p>现在，在实例化上下文时不需要同时指定 <code>ConfigA.class</code> 和 <code>ConfigB.class</code> ，只需显式提供 <code>ConfigB</code> ，如以下示例所示：</p>
<pre><code class="Java">public static void main(String[] args) &#123;
  ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);

  // now both beans A and B will be available...
  A a = ctx.getBean(A.class);
  B b = ctx.getBean(B.class);
&#125;
</code></pre>
<p>此方法简化了容器实例化，因为只需要处理一个类，而不是要求您在构造期间记住可能大量的 <code>@Configuration</code> 类。</p>
<p><strong>基于注解和配置类的方式实现</strong></p>
<p>Dao层</p>
<pre><code class="java">接口
package com.chenw.dao;

import com.chenw.pojo.Student;

import java.util.List;

public interface StudentDao &#123;
    List&lt;Student&gt; queryAll();
&#125;
实现类
    
    
    
    
package com.chenw.dao.Impl;

import com.chenw.dao.StudentDao;
import com.chenw.pojo.Student;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;


@Repository
public class StudentDaoImpl implements StudentDao &#123;
    @Autowired
    private JdbcTemplate jdbcTemplate;
    @Override
    public List&lt;Student&gt; queryAll() &#123;
        String sql = &quot;select id ,name , age ,gender,class as classes from students&quot;;
        List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class));
        return studentList;
    &#125;
&#125;
</code></pre>
<p>service层</p>
<pre><code class="java">接口
package com.chenw.service;


import com.chenw.pojo.Student;

import java.util.List;

public interface StudentService &#123;

    /**
     * 查询全部学员业务
     * @return
     */
    List&lt;Student&gt; findAll();

&#125;



实现类
   package com.chenw.service.Impl;

import com.chenw.dao.StudentDao;
import com.chenw.pojo.Student;
import com.chenw.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class StudentServiceImpl  implements StudentService &#123;

    @Autowired
    private StudentDao studentDao;

    /**
     * 查询全部学员业务
     * @return
     */
    @Override
    public List&lt;Student&gt; findAll() &#123;

        List&lt;Student&gt; studentList =  studentDao.queryAll();

        return studentList;
    &#125;
&#125;
</code></pre>
<p>controller</p>
<pre><code class="java">package com.chenw.controller;

import com.chenw.pojo.Student;
import com.chenw.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

import java.util.List;

@Controller
public class StudentController &#123;

    @Autowired
    private StudentService studentService;

    public void  findAll()&#123;
       List&lt;Student&gt; studentList =  studentService.findAll();
        System.out.println(&quot;studentList = &quot; + studentList);
    &#125;
&#125;
</code></pre>
<p>配置类</p>
<pre><code class="java">package Config;


import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.jdbc.core.JdbcTemplate;

import javax.sql.DataSource;

@Configuration
@ComponentScan(&quot;com.chenw&quot;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
public class JavaConfig &#123;

    /**/
     @Bean
    public DruidDataSource dataSource(@Value(&quot;$&#123;chenw.username&#125;&quot; ) String username,
                                       @Value(&quot;$&#123;chenw.password&#125;&quot;)  String password,
                                      @Value(&quot;$&#123;chenw.url&#125;&quot;) String url,
                                      @Value(&quot;$&#123;chenw.driver&#125;&quot;) String driver
     )&#123;
         DruidDataSource dataSource = new DruidDataSource();
         dataSource.setUrl(url);
         dataSource.setPassword(password);
         dataSource.setDriverClassName(driver);
         dataSource.setUsername(username);
         return  dataSource;
     &#125;

     @Bean
     public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123;
         JdbcTemplate jdbcTemplate = new JdbcTemplate();
         jdbcTemplate.setDataSource(dataSource);
         return jdbcTemplate;
     &#125;
&#125;
</code></pre>
<p>测试</p>
<pre><code class="java">package com.chenw.test;

import Config.JavaConfig;
import com.chenw.controller.StudentController;
import org.junit.jupiter.api.Test;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class SpringTest &#123;
    @Test
    public void test()&#123;
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(JavaConfig.class);
        StudentController bean = applicationContext.getBean(StudentController.class);
        bean.findAll();
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240423104636325.png" alt="image-20240423104636325"></p>
<p><strong>总结</strong></p>
<p><strong>XML方式配置总结</strong></p>
<ol>
<li>所有内容写到xml格式配置文件中</li>
<li>声明bean通过&lt;bean标签</li>
<li>&lt;bean标签包含基本信息（id,class）和属性信息 &lt;property name value &#x2F; ref</li>
<li>引入外部的properties文件可以通过&lt;context:property-placeholder</li>
<li>IoC具体容器实现选择ClassPathXmlApplicationContext对象</li>
</ol>
<p><strong>XML+注解方式配置总结</strong></p>
<ol>
<li>注解负责标记IoC的类和进行属性装配</li>
<li>xml文件依然需要，需要通过&lt;context:component-scan标签指定注解范围</li>
<li>标记IoC注解：@Component,@Service,@Controller,@Repository </li>
<li>标记DI注解：@Autowired @Qualifier @Resource @Value</li>
<li>IoC具体容器实现选择ClassPathXmlApplicationContext对象</li>
</ol>
<p> <strong>完全注解方式配置总结</strong></p>
<ol>
<li>完全注解方式指的是去掉xml文件，使用配置类 + 注解实现</li>
<li>xml文件替换成使用@Configuration注解标记的类</li>
<li>标记IoC注解：@Component,@Service,@Controller,@Repository </li>
<li>标记DI注解：@Autowired @Qualifier @Resource @Value</li>
<li>&lt;context:component-scan标签指定注解范围使用@ComponentScan(basePackages &#x3D; {“com.atguigu.components”})替代</li>
<li>&lt;context:property-placeholder引入外部配置文件使用@PropertySource({“classpath:application.properties”,”classpath:jdbc.properties”})替代</li>
<li>&lt;bean 标签使用@Bean注解和方法实现</li>
<li>IoC具体容器实现选择AnnotationConfigApplicationContext对象</li>
</ol>
<p><strong>整合测试环境作用</strong></p>
<p>​	好处1：不需要自己创建IOC容器对象了</p>
<p>​	好处2：任何需要的bean都可以在测试类中直接享受自动装配</p>
<ol>
<li>导入相关依赖</li>
</ol>
<pre><code class="XML">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;6.0.6&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>整合测试注解使用</li>
</ol>
<pre><code class="java">package com.chenw.test;

import com.chenw.components.A;
import com.chenw.config.JavaConfig;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;


//@SpringJUnitConfig(locations = 指定xml文件， value = 指定配置类的)
@SpringJUnitConfig(value = JavaConfig.class)
public class SpringTest &#123;
    @Autowired
    private A a;
    @Test
    public void test()&#123;
        System.out.println(a);//com.chenw.components.A@b978d10
    &#125;

&#125;
</code></pre>
<p><strong>Spring AOP面向切面编程</strong></p>
<p>场景设定</p>
<ol>
<li><p>准备AOP项目</p>
<p> 项目名：spring-aop-annotation</p>
<p> pom.xml</p>
</li>
</ol>
<pre><code class="XML">&lt;dependencies&gt;
    &lt;!--spring context依赖--&gt;
    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;6.0.6&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!--junit5测试--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;


    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
        &lt;version&gt;6.0.6&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;
        &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;
        &lt;version&gt;2.1.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ol start="2">
<li>声明接口</li>
</ol>
<pre><code class="Java">/**
 *       + - * / 运算的标准接口!
 */
public interface Calculator &#123;
    
    int add(int i, int j);
    
    int sub(int i, int j);
    
    int mul(int i, int j);
    
    int div(int i, int j);
    
&#125;
</code></pre>
<ol start="3">
<li>接口实现</li>
</ol>
<pre><code class="Java">package com.atguigu.proxy;


/**
 * 实现计算接口,单纯添加 + - * / 实现! 掺杂其他功能!
 */
public class CalculatorPureImpl implements Calculator &#123;
    
    @Override
    public int add(int i, int j) &#123;
    
        int result = i + j;
    
        return result;
    &#125;
    
    @Override
    public int sub(int i, int j) &#123;
    
        int result = i - j;
    
        return result;
    &#125;
    
    @Override
    public int mul(int i, int j) &#123;
    
        int result = i * j;
    
        return result;
    &#125;
    
    @Override
    public int div(int i, int j) &#123;
    
        int result = i / j;
    
        return result;
    &#125;
&#125;
</code></pre>
<ol start="4">
<li><p>声明带日志接口实现</p>
<p> 新需求： 需要在每个方法中，添加控制台输出，输出参数和输出计算后的返回值！</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img002.f8e54219.png"></p>
</li>
</ol>
<pre><code class="Java">package com.atguigu.proxy;

/**
 * 在每个方法中,输出传入的参数和计算后的返回结果!
 */
public class CalculatorLogImpl implements Calculator &#123;
    
    @Override
    public int add(int i, int j) &#123;
    
        System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j);
        int result = i + j;
        System.out.println(&quot;方法内部 result = &quot; + result);
      
        return result;
    &#125;
    
    @Override
    public int sub(int i, int j) &#123;
    
        System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j);
    
        int result = i - j;
    
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    &#125;
    
    @Override
    public int mul(int i, int j) &#123;
    
        System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j);
    
        int result = i * j;
    
        System.out.println(&quot;方法内部 result = &quot; + result);
    
        return result;
    &#125;
    
    @Override
    public int div(int i, int j) &#123;
    
        System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j);
    
        int result = i / j;
    
        System.out.println(&quot;方法内部 result = &quot; + result);
        
        return result;
    &#125;
&#125;
</code></pre>
<ol start="5">
<li>代码问题分析<ol>
<li><p>代码缺陷</p>
<ul>
<li>对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力</li>
<li>附加功能代码重复，分散在各个业务功能方法中！冗余，且不方便统一维护！</li>
</ul>
</li>
<li><p>解决思路</p>
<p>   核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。</p>
<p>   将重复的代码统一提取，并且[[动态插入]]到每个业务方法！</p>
</li>
<li><p>技术困难</p>
<p> 解决问题的困难：提取重复附加功能代码到一个类中，可以实现</p>
<p> 但是如何将代码插入到各个方法中，我们不会，我们需要引用新技术！！！</p>
</li>
</ol>
</li>
</ol>
<p><strong>解决技术代理的问题</strong></p>
<pre><code>之前说过把重复操作的附加功能的代码提出来到一个单独的类，解耦合，然后动态插入，这样减少代码的使用还能解耦合，方便维护，代理模式就可以实现
</code></pre>
<ol>
<li><p><strong>代理模式</strong></p>
<p> 二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。</p>
<p> 无代理场景：</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img004.e76b3080.png"></p>
<p> 有代理场景：</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img005.74dd7746.png"></p>
<p> 生活中的代理：</p>
<ul>
<li>广告商找大明星拍广告需要经过经纪人</li>
<li>合作伙伴找大老板谈合作要约见面时间需要经过秘书</li>
<li>房产中介是买卖双方的代理</li>
<li>太监是大臣和皇上之间的代理</li>
</ul>
<p> 相关术语：</p>
<ul>
<li>代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。(中介)<ul>
<li>动词：指做代理这个动作，或这项工作</li>
<li>名词：扮演代理这个角色的类、对象、方法</li>
</ul>
</li>
<li>目标：<strong>被代理</strong>“套用”了核心逻辑代码的类、对象、方法。(房东)</li>
</ul>
<p> 代理在开发中实现的方式具体有两种：静态代理，[动态代理技术]</p>
</li>
<li><p><strong>静态代理</strong></p>
<p> 主动创建代理类：</p>
</li>
</ol>
<pre><code class="Java">public class CalculatorStaticProxy implements Calculator &#123;
    
    // 将被代理的目标对象声明为成员变量
    private Calculator target;
    
    public CalculatorStaticProxy(Calculator target) &#123;
        this.target = target;
    &#125;
    
    @Override
    public int add(int i, int j) &#123;
    
        // 附加功能由代理类中的代理方法来实现
        System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j);
    
        // 通过目标对象来实现核心业务逻辑
        int addResult = target.add(i, j);
    
        System.out.println(&quot;方法内部 result = &quot; + result);
    
        return addResult;
    &#125;
    ……
</code></pre>
<pre><code>静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。

提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。
</code></pre>
<ol start="3">
<li><p><strong>动态代理</strong></p>
<p> 动态代理技术分类</p>
<ul>
<li>JDK动态代理：JDK原生的实现方式，需要被代理的目标类必须<strong>实现接口</strong>！他会根据目标类的接口动态生成一个代理对象！代理对象和目标对象有相同的接口！（拜把子）</li>
<li>cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口！（认干爹）</li>
</ul>
<p> JDK动态代理技术实现（了解）</p>
<p>   <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img003.2fe524a2.png"></p>
<p>   代理工程：基于jdk代理技术，生成代理对象</p>
</li>
</ol>
<pre><code class="Java">public class ProxyFactory &#123;

    private Object target;

    public ProxyFactory(Object target) &#123;
        this.target = target;
    &#125;

    public Object getProxy()&#123;

        /**
         * newProxyInstance()：创建一个代理实例
         * 其中有三个参数：
         * 1、classLoader：加载动态生成的代理类的类加载器
         * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组
         * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法
         */
        ClassLoader classLoader = target.getClass().getClassLoader();
        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();
        InvocationHandler invocationHandler = new InvocationHandler() &#123;
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
                /**
                 * proxy：代理对象
                 * method：代理对象需要实现的方法，即其中需要重写的方法
                 * args：method所对应方法的参数
                 */
                Object result = null;
                try &#123;
                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，参数：&quot;+ Arrays.toString(args));
                    result = method.invoke(target, args);
                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，结果：&quot;+ result);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，异常：&quot;+e.getMessage());
                &#125; finally &#123;
                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，方法执行完毕&quot;);
                &#125;
                return result;
            &#125;
        &#125;;

        return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);
    &#125;
&#125;
</code></pre>
<pre><code>  测试代码：
</code></pre>
<pre><code class="Java">@Test
public void testDynamicProxy()&#123;
    ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl());
    Calculator proxy = (Calculator) factory.getProxy();
    proxy.div(1,0);
    //proxy.div(1,1);
&#125;

有一点需要记住
            Calculator proxy = (Calculator) factory.getProxy();这一个一定需要使用接口去接值，不能使用使用目标类去接值，因为它返回的是一个同一个接口的代理对象
</code></pre>
<ol start="4">
<li><p><strong>代理总结</strong></p>
<p> <strong>代理方式可以解决附加功能代码干扰核心代码和不方便统一维护的问题！</strong></p>
<p> 他主要是将附加功能代码提取到代理中执行，不干扰目标核心代码！</p>
<p> 但是我们也发现，无论使用静态代理和动态代理(jdk,cglib)，程序员的工作都比较繁琐！</p>
<p> 需要自己编写代理工厂等！</p>
<p> <strong>上面的代理的技术不用欸掌握，只是做了解</strong></p>
<p> 因为</p>
<pre><code>但是，提前剧透，我们在实际开发中，不需要编写代理代码，我们可以使用[Spring AOP]框架，

他会简化动态代理的实现！！！
</code></pre>
</li>
</ol>
<pre><code>AOP就是对代理的简化，也就是动态代理的简化
</code></pre>
<p><strong>面向切面编程思维（AOP）</strong></p>
<ol>
<li><p><strong>面向切面编程思想AOP</strong></p>
<p> AOP：Aspect Oriented Programming面向切面编程</p>
<p> AOP可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
<p> AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p>
<p> 使用AOP，可以在不修改原来代码的基础上添加新功能。</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image.png"></p>
</li>
<li><p><strong>AOP思想主要的应用场景</strong></p>
<p> AOP（面向切面编程）是一种编程范式，它通过将通用的横切关注点（如日志、事务、权限控制等）与业务逻辑分离，使得代码更加清晰、简洁、易于维护。AOP可以应用于各种场景，以下是一些常见的AOP应用场景：</p>
<ol>
<li>日志记录：在系统中记录日志是非常重要的，可以使用AOP来实现日志记录的功能，可以在方法执行前、执行后或异常抛出时记录日志。</li>
<li>事务处理：在数据库操作中使用事务可以保证数据的一致性，可以使用AOP来实现事务处理的功能，可以在方法开始前开启事务，在方法执行完毕后提交或回滚事务。</li>
<li>安全控制：在系统中包含某些需要安全控制的操作，如登录、修改密码、授权等，可以使用AOP来实现安全控制的功能。可以在方法执行前进行权限判断，如果用户没有权限，则抛出异常或转向到错误页面，以防止未经授权的访问。</li>
<li>性能监控：在系统运行过程中，有时需要对某些方法的性能进行监控，以找到系统的瓶颈并进行优化。可以使用AOP来实现性能监控的功能，可以在方法执行前记录时间戳，在方法执行完毕后计算方法执行时间并输出到日志中。</li>
<li>异常处理：系统中可能出现各种异常情况，如空指针异常、数据库连接异常等，可以使用AOP来实现异常处理的功能，在方法执行过程中，如果出现异常，则进行异常处理（如记录日志、发送邮件等）。</li>
<li>缓存控制：在系统中有些数据可以缓存起来以提高访问速度，可以使用AOP来实现缓存控制的功能，可以在方法执行前查询缓存中是否有数据，如果有则返回，否则执行方法并将方法返回值存入缓存中。</li>
<li>动态代理：AOP的实现方式之一是通过动态代理，可以代理某个类的所有方法，用于实现各种功能。</li>
</ol>
<p> 综上所述，AOP可以应用于各种场景，它的作用是将通用的横切关注点与业务逻辑分离，使得代码更加清晰、简洁、易于维护。</p>
</li>
<li><p><strong>AOP术语名词介绍</strong></p>
<p> 1-横切关注点</p>
<p> 从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。</p>
<p> 这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img007.9ad7afe5.png"></p>
<p> AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务、异常等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<p> 2-通知(增强)</p>
<p> 每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。</p>
<ul>
<li>前置通知：在被代理的目标方法前执行</li>
<li>返回通知：在被代理的目标方法成功结束后执行（<strong>寿终正寝</strong>）</li>
<li>异常通知：在被代理的目标方法异常结束后执行（<strong>死于非命</strong>）</li>
<li>后置通知：在被代理的目标方法最终结束后执行（<strong>盖棺定论</strong>）</li>
<li>环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</li>
</ul>
<p> <img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img008.ea600562.png"></p>
<p> 3-连接点 joinpoint</p>
<p> 这也是一个纯逻辑概念，不是语法定义的。</p>
<p> 指那些被拦截到的点。在 Spring 中，可以被动态代理拦截目标类的方法</p>
<p> <img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img010.5af189f7.png"></p>
<p> 4-切入点 pointcut</p>
<p> 定位连接点的方式，或者可以理解成被选中的连接点！</p>
<p> 是一个表达式，比如execution(* com.spring.service.impl.<em>.</em>(..))。符合条件的每个方法都是一个具体的连接点。</p>
<p> 5-切面 aspect</p>
<p> 切入点和通知的结合。是一个类。</p>
<p> <img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img009.a0b70cb3.png"></p>
<p> 6-目标 target</p>
<p> 被代理的目标对象。</p>
<p> 7-代理 proxy</p>
<p> 向目标对象应用通知之后创建的代理对象。</p>
<p> 8-织入 weave</p>
<p> 指把通知应用到目标上，生成代理对象的过程。可以在编译期织入，也可以在运行期织入，Spring采用后者。</p>
</li>
</ol>
<p>总的来说就是这样的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240423153840040.png" alt="image-20240423153840040"></p>
<p><strong>Spring AOP框架介绍和关系梳理</strong></p>
<ol>
<li>AOP一种区别于OOP的编程思维，用来完善和解决OOP的非核心代码冗余和不方便统一维护问题！</li>
<li>代理技术（动态代理|静态代理）是实现AOP思维编程的具体技术，但是自己使用动态代理实现代码比较繁琐！</li>
<li>Spring AOP框架，基于AOP编程思维，封装动态代理技术，简化动态代理技术实现的框架！SpringAOP内部帮助我们实现动态代理，我们只需写少量的配置，指定生效范围即可,即可完成面向切面思维编程的实现！</li>
</ol>
<p><strong>Spring AOP基于注解方式实现的细节</strong></p>
<p> <strong>Spring AOP底层技术组成</strong></p>
<p>  <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img006.84eb95b7.png"></p>
<ul>
<li>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。</li>
<li>cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。</li>
<li>AspectJ：早期的AOP实现的框架，<strong>SpringAOP借用了AspectJ中的AOP注解。所以我们还需要导入AspectJ的包，我们直接导入整合包spring-aspectj</strong></li>
</ul>
<p><strong>初步的实现</strong></p>
<ol>
<li>加入依赖</li>
<li><strong>实现的需求还是给计算的业务类，添加日志的功能</strong></li>
</ol>
<pre><code class="XML">&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
    &lt;version&gt;6.0.6&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
    &lt;version&gt;6.0.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>创建的测试的类</p>
<pre><code class="java">接口
package com.chenw.service;

public interface Calculator &#123;
    
    int add(int i, int j);
    
    int sub(int i, int j);
    
    int mul(int i, int j);
    
    int div(int i, int j);
    
&#125;
实现类
    package com.chenw.service.Impl;


import com.chenw.service.Calculator;
import org.springframework.stereotype.Component;

/**
 * 实现计算接口,单纯添加 + - * / 实现! 掺杂其他功能!
 */



/*
*
* aop -只针对ioc容器的对象 -》常见代理对象 -&gt; 代理对象储存到ioc容器的里面
*
* */
@Component
public class CalculatorPureImpl implements Calculator &#123;
    
    @Override
    public int add(int i, int j) &#123;
    
        int result = i + j;
    
        return result;
    &#125;
    
    @Override
    public int sub(int i, int j) &#123;
    
        int result = i - j;
    
        return result;
    &#125;
    
    @Override
    public int mul(int i, int j) &#123;
    
        int result = i * j;
    
        return result;
    &#125;
    
    @Override
    public int div(int i, int j) &#123;
    
        int result = i / j;
    
        return result;
    &#125;
&#125;
</code></pre>
<p>增强类</p>
<pre><code class="java">package com.chenw.advice;


import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

/*
*   增强类的内部可以存增强代码
*   定义储存增强代码
*       具体定义几个，是根据我们插入的位置决定
*       使用注解配置，指定插入目标方法的位置
*           前置  @Before
*           后置  @AfterReturning
*           异常  @AfterThrowing
*           最后  @After
*           环绕  @Around
*           例如 目标类的结构
*           try &#123;
*                   前置
*                   目标方法执行
*                   后置
*               &#125; catch()&#123;
*                           异常
*                          &#125; finally &#123;
*                                       最后
*                                      &#125;
*
*           3. 配置切点表达式
*           4.增强类也要放到ioc容器，
*                   加入ioc容器 @Component
*                   配置切面 @Aspectj = 切点 + 增强
*           5.开启aspectj注解的支持
* */
@Component
@Aspect
public class LogAdvice &#123;
    @Before(&quot;execution(* com.chenw.service.Impl.*.*(..))&quot;)
    public void start()&#123;
        System.out.println(&quot;方法开始了&quot;);
    &#125;
    @After(&quot;execution(* com.chenw.service.Impl.*.*(..))&quot;)
    public void after()&#123;
        System.out.println(&quot;方法结束了&quot;);
    &#125;
    @AfterThrowing(&quot;execution(* com.chenw.service.Impl.*.*(..))&quot;)
    public void error()&#123;
        System.out.println(&quot;方法出错了&quot;);
    &#125;
&#125;
</code></pre>
<p>配置类</p>
<pre><code class="java">package com.chenw.config;


import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@ComponentScan(&quot;com.chenw&quot;)

/*
*   在配置类开启aop注解的支持
*   等同于配置文件的
*   &lt;aop:aspectj-autoproxy/&gt;
* */
@EnableAspectJAutoProxy
public class JavaConfig &#123;
&#125;
</code></pre>
<p>如果使用XML配置文件的方式实现的话</p>
<pre><code class="xml">    &lt;context:component-scan base-package=&quot;com.chenw&quot;/&gt;
    &lt;!--在配置文件的里面开启aop的z注解支持--&gt;
        &lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">package com.chenw.test;


import com.chenw.config.JavaConfig;
import com.chenw.service.Calculator;
import com.chenw.service.Impl.CalculatorPureImpl;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;

@SpringJUnitConfig(value = JavaConfig.class)
public class SpringAopTest &#123;
    //oop - 代理 - jdk - 接口 -代理类 -代理对象和目标对象,是实现同一个接口的，而不是相同的对象或者继承，所以需要只当类型为接口
    @Autowired
    private Calculator calculator;

    @Test
    public void test()&#123;
        int add = calculator.add(1, 1);
        System.out.println(add);
    &#125;
&#125;
</code></pre>
<p>实现的结果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240423163637110.png" alt="image-20240423163637110"></p>
<p><strong>获取通知的细节信息</strong></p>
<ol>
<li><p><strong>JointPoint接口</strong></p>
<p> 需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参。</p>
<ul>
<li>要点1：JoinPoint 接口通过 getSignature() 方法获取目标方法的签名（方法声明时的完整信息）</li>
<li>要点2：通过目标方法签名对象获取方法名</li>
<li>要点3：通过 JoinPoint 对象获取外界调用目标方法时传入的实参列表组成的数组</li>
</ul>
</li>
</ol>
<pre><code class="Java">// @Before注解标记前置通知方法
// value属性：切入点表达式，告诉Spring当前通知方法要套用到哪个目标方法上
// 在前置通知方法形参位置声明一个JoinPoint类型的参数，Spring就会将这个对象传入
// 根据JoinPoint对象就可以获取目标方法名称、实际参数列表
@Before(value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;)
public void printLogBeforeCore(JoinPoint joinPoint) &#123;
    
    // 1.通过JoinPoint对象获取目标方法签名对象
    // 方法的签名：一个方法的全部声明信息
    Signature signature = joinPoint.getSignature();
    
    // 2.通过方法的签名对象获取目标方法的详细信息
    String methodName = signature.getName();
    System.out.println(&quot;methodName = &quot; + methodName);
    
    int modifiers = signature.getModifiers();
    System.out.println(&quot;modifiers = &quot; + modifiers);
    
    String declaringTypeName = signature.getDeclaringTypeName();
    System.out.println(&quot;declaringTypeName = &quot; + declaringTypeName);
    
    // 3.通过JoinPoint对象获取外界调用目标方法时传入的实参列表
    Object[] args = joinPoint.getArgs();
    
    // 4.由于数组直接打印看不到具体数据，所以转换为List集合
    List&lt;Object&gt; argList = Arrays.asList(args);
    
    System.out.println(&quot;[AOP前置通知] &quot; + methodName + &quot;方法开始了，参数列表：&quot; + argList);
&#125;
</code></pre>
<ol start="2">
<li><p><strong>方法返回值</strong></p>
<p> 在返回通知中，通过**@AfterReturning**注解的returning属性获取目标方法的返回值！</p>
</li>
</ol>
<pre><code class="Java">// @AfterReturning注解标记返回通知方法
// 在返回通知中获取目标方法返回值分两步：
// 第一步：在@AfterReturning注解中通过returning属性设置一个名称
// 第二步：使用returning属性设置的名称在通知方法中声明一个对应的形参
@AfterReturning(
        value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;,
        returning = &quot;targetMethodReturnValue&quot;
)
public void printLogAfterCoreSuccess(JoinPoint joinPoint, Object targetMethodReturnValue) &#123;
    
    String methodName = joinPoint.getSignature().getName();
    
    System.out.println(&quot;[AOP返回通知] &quot;+methodName+&quot;方法成功结束了，返回值是：&quot; + targetMethodReturnValue);
&#125;
</code></pre>
<ol start="3">
<li><p><strong>异常对象捕捉</strong></p>
<p> 在异常通知中，通过@AfterThrowing注解的throwing属性获取目标方法抛出的异常对象</p>
</li>
</ol>
<pre><code class="Java">// @AfterThrowing注解标记异常通知方法
// 在异常通知中获取目标方法抛出的异常分两步：
// 第一步：在@AfterThrowing注解中声明一个throwing属性设定形参名称
// 第二步：使用throwing属性指定的名称在通知方法声明形参，Spring会将目标方法抛出的异常对象从这里传给我们
@AfterThrowing(
        value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;,
        throwing = &quot;targetMethodException&quot;
)
public void printLogAfterCoreException(JoinPoint joinPoint, Throwable targetMethodException) &#123;
    
    String methodName = joinPoint.getSignature().getName();
    
    System.out.println(&quot;[AOP异常通知] &quot;+methodName+&quot;方法抛异常了，异常类型是：&quot; + targetMethodException.getClass().getName());
&#125;
</code></pre>
<p>例如</p>
<pre><code class="java">package com.chenw.advice;


import org.aopalliance.intercept.Joinpoint;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

import java.lang.reflect.Modifier;


/*
*   定义四个增强的方法，获取目标方法的信息，返回值，异常对象
*
* */
@Aspect
@Component
public class MyAdvice &#123;
    /*
    *   表达式里面第一个的 * 代表不考虑返回值和访问修饰符
    *   com..Impl 中间的..是跳过
    *   第一个的.*可以这个包下面的任意类
    *   第二个.*代表任意额方法
    *   最后的(..)意思是忽略参数
    *  TODO:增强方法中获取目标方法的信息
    *       1.全部增强方法中,获取目标方法的信息(方法名,参数，访问修饰符，所属类的信息)
    *               在方法的形参的里面添加 Joinpoint joinpoint     导入的包import org.aspectj.lang.JoinPoint;
    *               Joinpoint包含目标方法的信息
    *       2.返回的结果 -@Afterreturning
    *               (Object result)行参指定接收返回的结果
    *                @AfterReturning(value = &quot;execution(* com..Impl.*.*(..))&quot;,returning = &quot;result&quot;)
    *       3.获取异常的信息 -@AfterThrowing
    *                  形参(throwing = &quot;throwable&quot;)指定接收的异常信息
    *                   @AfterThrowing(value = &quot;execution(* com..Impl.*.*(..))&quot;,throwing = &quot;throwable&quot;)
    *                   加上指定的形参的名字
    * */
    @Before(&quot;execution(* com..Impl.*.*(..))&quot;)
    public void start(JoinPoint joinpoint)&#123;
        //获取方法属于的类的信息 getTarget获取类的对象
        String simpleName = joinpoint.getTarget().getClass().getSimpleName(); //获取类的名称
        ////获取访问修饰符
        int modifiers = joinpoint.getSignature().getModifiers();
        String s = Modifier.toString(modifiers);
        //获取目标方法的名字
        String name = joinpoint.getSignature().getName();
        //获取参数列表
        Object[] args = joinpoint.getArgs();//获取目标的参数
    &#125;

    @After(&quot;execution(* com..Impl.*.*(..))&quot;)
    public void after(JoinPoint joinpoint)&#123;

    &#125;
    @AfterThrowing(value = &quot;execution(* com..Impl.*.*(..))&quot;,throwing = &quot;throwable&quot;)
    public void afterThrowing(JoinPoint joinpoint,Throwable throwable)&#123;

    &#125;
    /*
    * 获取返回的参数
    *       需要指定第二个参数
    *       returning参数指定接受返回值的变量
    * */
    @AfterReturning(value = &quot;execution(* com..Impl.*.*(..))&quot;,returning = &quot;result&quot;)
    public void afterReturning(JoinPoint joinpoint,Object result)   &#123;

    &#125;
&#125;
</code></pre>
<p><strong>切点表达式的语法</strong></p>
<ol>
<li><p><strong>切点表达式作用</strong></p>
<p> AOP切点表达式（Pointcut Expression）是一种用于指定切点的语言，它可以通过定义匹配规则，来选择需要被切入的目标对象。</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img028.cb7f2153.png"></p>
</li>
<li><p><strong>切点表达式语法</strong></p>
<p> 切点表达式总结</p>
<p> <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img011.dde1a79a.png"></p>
<p> 语法细节</p>
<ul>
<li>第一位：execution( ) 固定开头</li>
<li>第二位：方法访问修饰符</li>
</ul>
</li>
</ol>
<pre><code class="Java">public private 直接描述对应修饰符即可
</code></pre>
<pre><code>- 第三位：方法返回值
</code></pre>
<pre><code class="Java">int String void 直接描述返回值类型
</code></pre>
<pre><code>    注意：

    特殊情况 不考虑 访问修饰符和返回值

      execution(* * ) 这是错误语法
      要考虑就都考虑所以一个*就代表修师傅和返回值都是任意的
      execution(*) == 你只要考虑返回值 或者 不考虑访问修饰符 相当于全部不考虑了
- 第四位：指定包的地址
</code></pre>
<pre><code class="Java"> 固定的包: com.atguigu.api | service | dao
 单层的任意命名: com.atguigu.*  = com.atguigu.api  com.atguigu.dao  * = 任意一层的任意命名
 任意层任意命名: com.. = com.atguigu.api.erdaye com.a.a.a.a.a.a.a  ..任意层,任意命名 用在包上!
 注意: ..不能用作包开头   public int .. 错误语法  com..
 找到任何包下: *..
</code></pre>
<pre><code>- 第五位：指定类名称
</code></pre>
<pre><code class="Java">固定名称: UserService
任意类名: *
部分任意: com..service.impl.*Impl //以Impl结尾的类 
任意包任意类: *..*
</code></pre>
<pre><code>- 第六位：指定方法名称
</code></pre>
<pre><code class="Java">语法和类名一致
任意访问修饰符,任意类的任意方法: * *..*.*
</code></pre>
<pre><code>- 第七位：方法参数
</code></pre>
<pre><code class="Java">第七位: 方法的参数描述
       具体值: (String,int) != (int,String) 没有参数 ()
       模糊值: 任意参数 有 或者 没有 (..)  ..任意参数的意识
       部分具体和模糊:
         第一个参数是字符串的方法 (String..)
         最后一个参数是字符串 (..String)
         字符串开头,int结尾 (String..int)
         包含int类型(..int..)
</code></pre>
<ol start="3">
<li><strong>切点表达式案例</strong></li>
</ol>
<pre><code class="Java">1.查询某包某类下，访问修饰符是公有，返回值是int的全部方法
        execution(public int com.chenw.service.Impl.CalculatorPureImpl.*(..))
2.查询某包下类中第一个参数是String的方法
        &quot;execution(* com.chenw.service.Impl.*(String..))&quot;
3.查询全部包下，无参数的方法！
        &quot;execution(* *..*.*())&quot;
4.查询com包下，以int参数类型结尾的方法
        &quot;execution(* com..*.*(..int))&quot;
5.查询指定包下，Service开头类的私有返回值int的无参数方法
        execution(private int com.chenw.service.Impl.Service*.*())
</code></pre>
<p><strong>重用(提取)切点表达式</strong></p>
<ol>
<li>重用切点表达式优点</li>
</ol>
<pre><code class="Java"> // @Before注解：声明当前方法是前置通知方法
// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上
@Before(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)
public void printLogBeforeCore() &#123;
    System.out.println(&quot;[AOP前置通知] 方法开始了&quot;);
&#125;

@AfterReturning(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)
public void printLogAfterSuccess() &#123;
    System.out.println(&quot;[AOP返回通知] 方法成功返回了&quot;);
&#125;

@AfterThrowing(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)
public void printLogAfterException() &#123;
    System.out.println(&quot;[AOP异常通知] 方法抛异常了&quot;);
&#125;

@After(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)
public void printLogFinallyEnd() &#123;
    System.out.println(&quot;[AOP后置通知] 方法最终结束了&quot;);
&#125;
</code></pre>
<pre><code>上面案例，是我们之前编写切点表达式的方式，发现， 所有增强方法的切点表达式相同！

出现了冗余，如果需要切换也不方便统一维护！

我们可以将切点提取，在增强上进行引用即可！
</code></pre>
<ol start="2">
<li><p>同一类内部引用</p>
<p> 提取</p>
</li>
</ol>
<pre><code class="Java">// 切入点表达式重用
@Pointcut(&quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int)))&quot;)
public void declarPointCut() &#123;&#125;
</code></pre>
<pre><code>注意：提取切点注解使用@Pointcut(切点表达式) ， 需要添加到一个无参数无返回值方法上即可！

引用
</code></pre>
<pre><code class="Java">@Before(value = &quot;declarPointCut()&quot;)
public void printLogBeforeCoreOperation(JoinPoint joinPoint) &#123;
</code></pre>
<ol start="3">
<li><p>不同类中引用</p>
<p> 不同类在引用切点，只需要添加类的全限定符+方法名即可！</p>
</li>
</ol>
<pre><code class="Java">    @Before(&quot;com.chenw.pointcut.MyPointCut.fc()&quot;)
    public void start(JoinPoint joinpoint)&#123;
    &#125;
</code></pre>
<ol start="4">
<li><p>切点统一管理</p>
<p> 建议：将切点表达式统一存储到一个类中进行集中管理和维护！</p>
</li>
</ol>
<pre><code class="Java">package com.chenw.pointcut;


import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

@Component
@Aspect

/*
* 这个类里面只存放切点
* */
public class MyPointCut &#123;

    @Pointcut(&quot;execution(* com..Impl.*.*(..))&quot;)
    public void fc()&#123;&#125;

    @Pointcut(&quot;execution(* com..Imp.*.*(..))&quot;)
    public void fc1()&#123;&#125;
&#125;
</code></pre>
<p><strong>环绕通知</strong></p>
<pre><code>之前介绍前四种
    前置
    后置
    异常
    最后
环绕
    环绕允许我们自定义位置
    例如下面，这样就可以自定义
</code></pre>
<pre><code class="java">package com.chenw.advice;


import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class TxAroundAdvice &#123;
    /*
    *   TODO:环绕通知需要你在通知中，定义目标方法的执行
    *   proceedingJoinPoint目标方法(获取目标方法信息,多了一个执行方法)
    *   返回值 目标方法的返回值
    * */
    @Around(&quot;com.chenw.advice.MyAdvice.pc()&quot;)
    public  Object transaction(ProceedingJoinPoint proceedingJoinPoint)&#123;
//        保证目标方法被执行,有参数需要传递参数，没有参数就不用传递了
        Object[] args = proceedingJoinPoint.getArgs();
        Object result = null;
        try &#123;
            //在这里面添加增强代码
            System.out.println(&quot;开启事物&quot;);
            result = proceedingJoinPoint.proceed(args);
            System.out.println(&quot;结束事物&quot;);
        &#125; catch (Throwable e) &#123;
            System.out.println(&quot;事物回滚&quot;);
            throw new RuntimeException(e);
        &#125;
        return  result;
    &#125;
&#125;
</code></pre>
<p><strong>切面的优先级</strong></p>
<p>相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。</p>
<ul>
<li>优先级高的切面：外面</li>
<li>优先级低的切面：里面</li>
</ul>
<p>使用 @Order 注解可以控制切面的优先级：</p>
<ul>
<li>@Order(较小的数)：优先级高</li>
<li>@Order(较大的数)：优先级低</li>
</ul>
<p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img012.b353bc56.png"></p>
<p>实际意义</p>
<p>实际开发时，如果有多个切面嵌套的情况，要慎重考虑。例如：如果事务切面优先级高，那么在缓存中命中数据的情况下，事务切面的操作都浪费了。</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img013.53c41dc7.png"></p>
<p>此时应该将缓存切面的优先级提高，在事务操作之前先检查缓存中是否存在目标数据。</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/img014.ee4ed40a.png"></p>
<p>例如在两个增强类里</p>
<pre><code class="java">@Component
@Aspect
@Order(10)
public class TxAdvice &#123;
    @Pointcut(&quot;execution(* com..Impl.*.*(..))&quot;)
    public void pc()&#123;&#125;
    @Before(&quot;pc()&quot;)
    public void begin()&#123;
        System.out.println(&quot;开启事物&quot;);
    &#125;
    @AfterReturning(&quot;pc()&quot;)
    public void commit()&#123;
        System.out.println(&quot;事物提交&quot;);
    &#125;
    @AfterThrowing(&quot;pc()&quot;)
    public void rollback()&#123;
        System.out.println(&quot;事物回滚&quot;);
    &#125;
&#125;



@Component
@Aspect
@Order(20)
public class LogAdvice &#123;
    @Before(&quot;execution(* com.chenw.service.Impl.*.*(..))&quot;)
    public void start()&#123;
        System.out.println(&quot;方法开始了&quot;);
    &#125;
    @After(&quot;execution(* com.chenw.service.Impl.*.*(..))&quot;)
    public void after()&#123;
        System.out.println(&quot;方法结束了&quot;);
    &#125;
    @AfterThrowing(&quot;execution(* com.chenw.service.Impl.*.*(..))&quot;)
    public void error()&#123;
        System.out.println(&quot;方法出错了&quot;);
    &#125;
&#125;
</code></pre>
<p>测试</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240423194145021.png" alt="image-20240423194145021"></p>
<p><strong>CGLib动态代理生效</strong></p>
<pre><code>之前说过
    如果该类有接口的话，spring aoc底层就会使用JDK动态代理，如果没有的话，底层使用的是CGLib代理
</code></pre>
<p>如果目标类没有实现接口</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240423200504202.png" alt="image-20240423200504202"></p>
<p>这里面需要去接值</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240423200529934.png" alt="image-20240423200529934"></p>
<p>执行结果依然是可以的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240423200559043.png" alt="image-20240423200559043"></p>
<p><strong>使用总结</strong></p>
<pre><code class="java">使用总结：

  a.  如果目标类有接口,选择使用jdk动态代理

  b.  如果目标类没有接口,选择cglib动态代理

  c.  如果有接口,接口接值

  d.  如果没有接口,类进行接值
</code></pre>
<p><strong>Spring AOP基于XML方式实现</strong></p>
<ol>
<li><p>准备工作</p>
<p> 加入依赖</p>
<p> 和基于注解的 AOP 时一样。</p>
<p> 准备代码</p>
<p> 把测试基于注解功能时的Java类复制到新module中，去除所有注解。</p>
</li>
<li><p>配置Spring配置文件</p>
</li>
</ol>
<pre><code class="XML">&lt;!-- 配置目标类的bean --&gt;
&lt;bean id=&quot;calculatorPure&quot; class=&quot;com.atguigu.aop.imp.CalculatorPureImpl&quot;/&gt;
    
&lt;!-- 配置切面类的bean --&gt;
&lt;bean id=&quot;logAspect&quot; class=&quot;com.atguigu.aop.aspect.LogAspect&quot;/&gt;
    
&lt;!-- 配置AOP --&gt;
&lt;aop:config&gt;
    
    &lt;!-- 配置切入点表达式 --&gt;
    &lt;aop:pointcut id=&quot;logPointCut&quot; expression=&quot;execution(* *..*.*(..))&quot;/&gt;
    
    &lt;!-- aop:aspect标签：配置切面 --&gt;
    &lt;!-- ref属性：关联切面类的bean --&gt;
    &lt;aop:aspect ref=&quot;logAspect&quot;&gt;
        &lt;!-- aop:before标签：配置前置通知 --&gt;
        &lt;!-- method属性：指定前置通知的方法名 --&gt;
        &lt;!-- pointcut-ref属性：引用切入点表达式 --&gt;
        &lt;aop:before method=&quot;printLogBeforeCore&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;
    
        &lt;!-- aop:after-returning标签：配置返回通知 --&gt;
        &lt;!-- returning属性：指定通知方法中用来接收目标方法返回值的参数名 --&gt;
        &lt;aop:after-returning
                method=&quot;printLogAfterCoreSuccess&quot;
                pointcut-ref=&quot;logPointCut&quot;
                returning=&quot;targetMethodReturnValue&quot;/&gt;
    
        &lt;!-- aop:after-throwing标签：配置异常通知 --&gt;
        &lt;!-- throwing属性：指定通知方法中用来接收目标方法抛出异常的异常对象的参数名 --&gt;
        &lt;aop:after-throwing
                method=&quot;printLogAfterCoreException&quot;
                pointcut-ref=&quot;logPointCut&quot;
                throwing=&quot;targetMethodException&quot;/&gt;
    
        &lt;!-- aop:after标签：配置后置通知 --&gt;
        &lt;aop:after method=&quot;printLogCoreFinallyEnd&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;
    
        &lt;!-- aop:around标签：配置环绕通知 --&gt;
        &lt;!--&lt;aop:around method=&quot;……&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;--&gt;
    &lt;/aop:aspect&gt;
    
&lt;/aop:config&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="Java">@SpringJUnitConfig(locations = &quot;classpath:spring-aop.xml&quot;)
public class AopTest &#123;

    @Autowired
    private Calculator calculator;

    @Test
    public void testCalculator()&#123;
        System.out.println(calculator);
        calculator.add(1,1);
    &#125;
&#125;
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 哈哈哈哈哈哈哈重生之我是兵王
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;chenw
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
