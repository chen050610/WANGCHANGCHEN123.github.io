
<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8" />
    <title>Java | 哈哈哈哈哈哈哈重生之我是兵王</title>
    <meta name="author" content="chenw" />
    <meta name="description" content="description" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
	<canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
	<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
	<script src="/js/fireworks.min.js"></script>
	<canvas id="background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
	<script src="/js/background.min.js"></script>
	<div id="cursor"></div>
	<link rel="stylesheet" href="/css/cursor.min.css">
	<script src="/js/cursor.min.js"></script>
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>哈哈哈哈哈哈哈重生之我是兵王</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;哈哈哈哈哈哈哈重生之我是兵王</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>Java</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/22
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <p>摘要</p>
<span id="more"></span>

<p>内容</p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>跨平台是java语言的趋势</p>
<p>java还是主流的编程语言</p>
<p>Java的各个版本</p>
<p>1.JavaSE：标准版，定位在个人计算机的应用，</p>
<p>2.JavaEE:企业版，定位在服务器</p>
<p>3.JavaME：微型版</p>
<p><strong>Java的运行机制</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322205212089.png" alt="image-20240322205212089"></p>
<p>Java既是编译型语言，又是解释性</p>
<p>例如 python就是解释性语言，直接通过python的解释器直接去运行</p>
<p><strong>什么是JVM？</strong></p>
<p>用于执行字节码虚拟计算机，跨平台的差异就是通过JVM</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322205502948.png" alt="image-20240322205502948"></p>
<p>java提供不同平台的虚拟机</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322205534797.png" alt="image-20240322205534797"></p>
<p><strong>开发人员我们一般使用JDK，因为我们需要编译和运行</strong></p>
<p><strong>一般java的游戏，就直接运行，只下载JRE就可以了</strong></p>
<p>创建的Java项目写在</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322213121539.png" alt="image-20240322213121539"></p>
<p>简单的Java代码</p>
<pre><code class="Java">public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
    &#125;
&#125;
</code></pre>
<p>在运行的时候，会自动帮你进行编译</p>
<p><strong>生成的java的编译的以后的文件在</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322213530098.png" alt="image-20240322213530098"></p>
<p>Java的基础语法</p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li><p>主函数 &amp;  程序的入口</p>
</li>
<li><p>文件名</p>
<pre><code>一个文件中只能有一个public的类，并且文件名必须和public的类名保持一致
如果文件中有多个类，文件名与public的类名保持一致
如果文件中有多个类 且无public类，文件名抗日一是任意的类
</code></pre>
</li>
<li><p>类名 首字母大写，驼峰的命名</p>
</li>
<li><p>类修饰符  public,default</p>
</li>
<li><p>类中的成员修饰符：public,private,protected,default</p>
</li>
<li><p>静态成员：无需实例化就可以直接调用</p>
<pre><code class="java">class Person  &#123;
    public static void  f1()&#123;
        //static静态的方法，无需实例就可以调用，也就只可以类调用
        System.out.println(&quot;111&quot;);
    &#125;
&#125;

public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
        Person.f1();//111
    &#125;
&#125;
</code></pre>
<ul>
<li><p>实例方法：需要实例以后在调用</p>
<pre><code class="java">class Person  &#123;
    public  void  f1()&#123;
        System.out.println(&quot;111&quot;);
    &#125;
&#125;

public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
        Person person = new Person();//实例对象的写法是这样的
        person.f1();//对象调用
    &#125;
&#125; 
</code></pre>
</li>
</ul>
</li>
<li><p>void代表方法没有返回值</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
        Person person = new Person();//实例对象的写法是这样的
        person.f1();//对象调用
    &#125;
</code></pre>
</li>
<li><p>参数,需要限制类型</p>
<pre><code>class Person  &#123;
    public  void  f1(string a , int b)&#123;
        System.out.println(&quot;111&quot;);
    &#125;
&#125;

public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
        Person person = new Person();//实例对象的写法是这样的
        person.f1(&#39;aaaa&#39;,123);//对象调用
    &#125;
&#125; 
</code></pre>
<p><strong>注释</strong></p>
<pre><code>//单行注释
/*
多行注释
*/
</code></pre>
</li>
</ul>
<p><strong>变量和常量</strong></p>
<pre><code>final相当于js里的const
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
    System.out.println(&quot;你好&quot;);
    String name = &quot;name&quot;;
    int number = 5;
    int a ;
    a= 18;
    //常量
    final int size = 18;
&#125;
</code></pre>
<p>不像js的动态语言，我们需要对数据的类型做出限制</p>
<p><strong>输入和输出</strong></p>
<p>输入需要外部的包，</p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        //引入的Scanner相当于一个类，System.in感觉时使用系统命令获取输入
        Scanner input  = new Scanner(System.in);
        String text  =  input.nextLine();
        //输出
        System.out.println(text);
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322220405957.png" alt="image-20240322220405957"></p>
<p>输出语句的不同</p>
<pre><code class="java">        //输出
        System.out.println(text);//输出最后会带换行
        System.out.print(text);//输出最后不带换行
</code></pre>
<p><strong>条件语句</strong></p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.print(&quot;&quot;);
        int age  = 19 ;
        if (age &lt; 18)&#123;
            System.out.println(&quot;少年&quot;);
        &#125; else if (age&gt;= 18 &amp;&amp; age &lt; 24)&#123;
            System.out.println(&quot;青年&quot;);
        &#125; else &#123;
            System.out.println(&quot;老年&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>switch case语句</strong></p>
<pre><code class="java">        System.out.print(&quot;&quot;);
        int age  = 19 ;
        switch (age)&#123;
            case 19:
                System.out.println(&quot;1111&quot;);
                break;
        &#125;
</code></pre>
<p><strong>循环语句</strong></p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        int count = 0 ;
        while (count &lt; 3)&#123;
            System.out.println(count);
            count++;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>do while循环</strong></p>
<p>至少执行一次</p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        int count = 0 ;
        do &#123;
            System.out.println(count);
            count++;
        &#125; while (count &lt; 3);
    &#125;
&#125;
</code></pre>
<p><strong>For循环</strong></p>
<pre><code class="java">        int count = 0 ;
        for (int i = 0 ; i &lt; 3 ; i++)&#123;
            System.out.println(i);
        &#125;
</code></pre>
<p><strong>数据类型</strong></p>
<p><strong>整数类型</strong></p>
<pre><code>byte 1个字节
short 2个字节
int 4个字节
long 8个字节
</code></pre>
<p>强制类型转化，大的类型往小的范围可能就会出错</p>
<pre><code class="java">byte i = 32 ; 
int a = (int) i;
</code></pre>
<p><strong>字符</strong></p>
<p>字符串的方法</p>
<pre><code class="java">        char  a = &#39;x&#39;;
        char  b = &#39;y&#39;;//字符只能用单引号
        String c = &quot;hahahaha&quot; ;

        String d = new String(&quot;王昌晨&quot;);

        char[] f = &#123;&#39;w&#39;,&#39;c&#39;,&#39;g&#39;&#125;;
        System.out.println(f);
</code></pre>
<pre><code class="java">        String name = &quot;wangchangchen&quot;;
        int count = name.length();//获取字符的长度
        for (int i = 0; i &lt; count; i++) &#123;
            char item = name.charAt(i);//获取当前位置的字符
        &#125;
        String a = name.trim();//去掉空白
        String[] b= name.split(&quot;c&quot;);//分割，返回的是数组
        String c= name.replace(&quot;w&quot;,&quot;d&quot;);//代换
        String d = name.substring(2,5);//切片
        boolean f = name.equals(&quot;wangchangchen&quot;);//进行字符串的比较
        boolean g = name.contains(&quot;ang&quot;);//数组中是否包含
        String k = name.concat(&quot;ahhah&quot;);//在后面进行拼接
</code></pre>
<p><strong>数组</strong></p>
<pre><code class="java">        int[] arr =new int[3];//定义三个数字的数组
        arr[0]=123;
        arr[1]=234;
        arr[2]=456;
        System.out.println(Arrays.toString(arr));


        String[] arr2 =new String[]&#123;&quot;hahah&quot;,&quot;hahah&quot;,&quot;ahah&quot;&#125;;
        System.out.println(Arrays.toString(arr2));

        String[] arr3 = &#123;&quot;haah&quot;,&quot;agaga&quot;,&quot;haha&quot;&#125;;
        System.out.println(Arrays.toString(arr3));

        for (int i = 0; i &lt; arr3.length; i++) &#123;
            System.out.println(arr3[i]);
        &#125;
</code></pre>
<p>注意：<strong>数组里面的个数一旦确定，不可以更改，类似于python里面的元组</strong></p>
<p><strong>对象</strong></p>
<ul>
<li><p>Java中所有的类也是默认继承基类Object这个类的，所以用基类可以反之子类的类型，下面这样写是不会报错的，因为String的类继承了Object的类</p>
<pre><code class="java">        String a = &quot;haha&quot;;
        Object b = &quot;haha&quot;;
        Object c = new String(&quot;haaha&quot;);
</code></pre>
<p>所以我们就可以常见任意类型的数组，所以要以后声明的数组是混合类型的就可以这样写</p>
<pre><code class="java">        Object[] arr = new Object[]&#123;&quot;java&quot;,11111,2222,&quot;lkcd&quot;&#125;;
        System.out.println(Arrays.toString(arr));//[java, 11111, 2222, lkcd]
</code></pre>
</li>
</ul>
<p>Object类型的字符串</p>
<pre><code class="java">        String v1 = new String(&quot;hahaha&quot;);
        v1.toUpperCase();
        System.out.println(v1);

        Object v2  = &quot;hahaha&quot;;
//只有强制类型转换以后才可以使用字符串的方法
        String data = (String)v2;
        data.toUpperCase()
</code></pre>
<p>传参的参数的类型未知，我们就可以这样写</p>
<pre><code class="java">    public static void func(Object a) &#123;
        System.out.println(a);
        if (a instanceof String) System.out.printf(&quot;String&quot;);
        if (a instanceof Integer) System.out.println(&quot;int&quot;);
    &#125;

    public static void main(String[] args) &#123;
        String v1 = new String(&quot;hahaha&quot;);
        v1.toUpperCase();
        System.out.println(v1);

        Object v2  = &quot;hahaha&quot;;
        String data = (String)v2;
        data.toUpperCase();
        func(&quot;hahahha&quot;);
    &#125;
</code></pre>
<ul>
<li>Java这种所有的类都继承Object，Object代指所有的类型</li>
</ul>
<p><strong>List系列</strong></p>
<ul>
<li>在Java中List不属于一种类型，在Java中List<strong>是一个接口</strong>，接口下面有两个常见的类型 （目的就是存放的动态的数据，可以添加删除）</li>
<li>ArrayList，（连续的内存地址的存储，里面放着的是内存地址而且内部还会自动扩容,可以添加，当超过的容量，创建新的内存地址，然后在保存）。</li>
<li>LinkedLink：（基于链表实现的，链表存储的）</li>
</ul>
<pre><code class="java">        ArrayList arr = new ArrayList();
        arr.add(&quot;hahaha&quot;);
        System.out.println(arr.getClass());//class java.util.ArrayLis
        System.out.println(arr);//[hahaha]
</code></pre>
<pre><code class="java">        LinkedList arr = new LinkedList();
        arr.add(&quot;hahaha&quot;);
        System.out.println(arr.getClass());//class java.util.LinkedList
        System.out.println(arr);//[hahaha]
</code></pre>
<p>用起来都是一样的，就是存储的方式不同,刚才提到list是一个接口，接口下面有如上的数据类型</p>
<ul>
<li><p>接口:使用来约束实现他的类，约束它里面的成员必须有什么，定义有点像TS</p>
<pre><code class="java">interface List&#123;
    public void add(Object)//不写具体的实现
&#125;
//这个类实现接口List，此时这里必须有add的方法
class ArrayList implements  List &#123;
   public void add(Object data)&#123;
       //实现添加数据的代码
   &#125;
&#125;
</code></pre>
<pre><code class="java">**我们用接口名称代指实现接口的类也是可以的**       
        List arr = new LinkedList();
        arr.add(&quot;hahaha&quot;);
        System.out.println(arr.getClass());//class java.util.LinkedList
        System.out.println(arr);//[hahaha]
</code></pre>
<p>创建的时候指定类型</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        List&lt;String&gt; arr = new LinkedList&lt;String&gt;();
        arr.add(&quot;hahaha&quot;);
        arr.add(1111);//这一行报错
        System.out.println(arr.getClass());//class java.util.LinkedList
        System.out.println(arr);//[hahaha]
    &#125;
</code></pre>
<p><strong>默认的是Object，里面的类型可以混着</strong></p>
</li>
<li><p>获取列表的方法和属性</p>
<pre><code class="Java">    public static void main(String[] args) &#123;
        List&lt;String&gt; arr = new LinkedList&lt;String&gt;();
        arr.add(&quot;hahaha&quot;);
        System.out.println(arr.getClass());//class java.util.LinkedList
        System.out.println(arr);//[hahaha]
        System.out.println(arr.get(0));//获取列表里的值

        arr.set(0,&quot;123&quot;);
        System.out.println(arr);//[123]

        arr.add(&quot;456&quot;);
        arr.remove(&quot;123&quot;);
        System.out.println(arr);//[456]
        arr.remove(0);
        System.out.println(arr);//[]

        System.out.println(arr.size());//0

        arr.add(&quot;2112&quot;);
        System.out.println(arr.contains(&quot;2112&quot;));//true

        arr.add(&quot;9999&quot;);
        for (Object item : arr)&#123;
            System.out.println(item);//2112,9999
        &#125;

        for (int i = 0; i &lt; arr.size(); i++) &#123;
            Object item = arr.get(i);
            System.out.println(item);//2112,9999
        &#125;

    &#125;
</code></pre>
</li>
<li><p>通过迭代器进行遍历</p>
<pre><code class="java">        List&lt;Object&gt; arr = new LinkedList&lt;&gt;(Arrays.asList(&quot;123&quot;,&quot;456&quot;,&quot;789&quot;));//快速创建一个，就不用一个一个添加了
        Iterator it = arr.iterator();
        while (it.hasNext())&#123;
            System.out.println(it.hasNext()); //判断指向当前的数据是否为空
            Object item = it.next();
            System.out.println(item); //获取当前指向的数据
        &#125;
</code></pre>
</li>
</ul>
<p><strong>Set系列</strong></p>
<p>主要还是去重</p>
<p>Set还是一个接口，常见的实现这两个接口有两个类，用于实现不重复多元素的集合</p>
<ul>
<li>HashSet ，去重，无序，</li>
<li>TreeSet，去重，内部会默认的排序（ascii,uncode）,不同类型的不能比较</li>
</ul>
<pre><code class="java">        HashSet s  = new HashSet&lt;&gt;();
        s.add(&quot;111&quot;);
        s.add(&quot;111&quot;);
        s.add(&quot;2222&quot;);
        System.out.println(s);//[111, 2222]
</code></pre>
<p>简单的创建，<strong>注意这里的add外层包裹的是双括号</strong></p>
<pre><code class="java">        HashSet a = new HashSet()&#123;
            &#123;
                add(&quot;1111&quot;);
                add(&quot;222&quot;);
            &#125;;
        &#125;;
        System.out.println(a);//[222, 1111]
</code></pre>
<p>通过集合我们就可以实现交并差，使用的方法和列表的实现差不多</p>
<pre><code class="java">        Set a = new HashSet&lt;&gt;()&#123;&#123;
            add("java");
            add("666");
            add("B站");
        &#125;&#125;;
        Set b = new HashSet() &#123;&#123;
             add("B站");
             add("A站");
             add("C站");&#125;&#125;;
        Set c = new HashSet();
        c.addAll(a);//向空的集合添加，或者取并集
        System.out.println(c);//[java, 666, B站]

        //交集
        c.retainAll(b);//交集,这个返回值是布尔
        System.out.println(c);;//[B站]

        //并集
        c.addAll(a);
        System.out.println(a);//[java, 666, B站]

        //差集
        c.removeAll(a); //c-a
        System.out.println(c);//[]

        //差集
        b.removeAll(a); //b-a
        System.out.println(b);//[C站, A站]

        //循环
        for (Object item : a)&#123;
            System.out.println(item);//java     666       B站
        &#125;

        Iterator it = a.iterator();
        while(it.hasNext())&#123;
            System.out.println(it.next());//java  666   B站
        &#125;
</code></pre>
<p><strong>Map系列</strong></p>
<p>Map是一个接口，常见实现这个接口有两个类，用于存储键值对</p>
<ul>
<li>HashMap : 无序；</li>
<li>Treepmap: 有序，根据key进行排序</li>
</ul>
<pre><code class="java">用法和之前的set和list的差不多
        Map a = new HashMap&lt;&gt;();
        a.put(&quot;name&quot; , &quot;demo&quot;);
        a.put(&quot;age&quot; , &quot;18&quot;);
        System.out.println(a);//&#123;name=demo, age=18&#125;


        Map&lt;String,String&gt; b = new HashMap&lt;String,String&gt;();
        b.put(&quot;name&quot; , &quot;demo&quot;);
        b.put(&quot;age&quot; , &quot;18&quot;);
        System.out.println(b);//&#123;name=demo, age=18&#125;


        //可以向setu快速的创建
        HashMap c = new HashMap&lt;&gt;()&#123;
            &#123;
                put(&quot;name&quot;,&quot;wang&quot;);
                put(&quot;age&quot;,&quot;18&quot;);
            &#125;
        &#125;;
        System.out.println(c);
</code></pre>
<pre><code class="java">        Map a = new HashMap&lt;&gt;();
        a.put(&quot;name&quot; , &quot;demo&quot;);
        a.put(&quot;age&quot; , &quot;18&quot;);
        System.out.println(a);//&#123;name=demo, age=18&#125;


        Map&lt;String,String&gt; b = new HashMap&lt;String,String&gt;();
        b.put(&quot;name&quot; , &quot;demo&quot;);
        b.put(&quot;age&quot; , &quot;18&quot;);
        System.out.println(b);//&#123;name=demo, age=18&#125;


        //可以向setu快速的创建
        HashMap c = new HashMap&lt;&gt;()&#123;
            &#123;
                put(&quot;name&quot;,&quot;wang&quot;);
                put(&quot;age&quot;,&quot;18&quot;);
            &#125;
        &#125;;
        System.out.println(c);

        System.out.println(c.size());

        System.out.println(c.get(&quot;name&quot;));

        c.replace(&quot;name&quot;,&quot;chen&quot;);
        System.out.println(c);

        //没有迭代器，但是可以通过下面这个样子实现
        Set&lt;Map.Entry&lt;String,String&gt;&gt; d = c.entrySet();
        System.out.println(d);//[&quot;name=chen&quot;, &quot;age=18&quot;]
        Iterator it = d.iterator();
        while (it.hasNext())&#123;
             Map.Entry&lt;String,String&gt; e = (Map.Entry&lt;String, String&gt;)it.next();//在转为map
            System.out.println(e);//name=chen   age=18
            String k = e.getKey();//获取键名
            String l = e.getValue();//获取值
        &#125;

        //简单的写法
        Set r = b.entrySet();
        Iterator it2 = r.iterator();
        while (it2.hasNext())&#123;
            Map.Entry o = (Map.Entry)it2.next();
            System.out.println(o);
        &#125;
</code></pre>
<p>Map的EntrySet方法会获得实体，转为Set就可以使用迭代器</p>
<p><strong>类和面向对象</strong></p>
<ul>
<li>基本使用</li>
</ul>
<pre><code class="java">class Person &#123;
    public String name;
    public Integer age;
    //构造方法
    public Person()&#123;
        this.name = &quot;chen&quot;;
        this.age = 18 ;
    &#125;
    //一个类中可以有多个构造方法，但是保证参数的不同的才可以
    public Person(String name)&#123;
        this.name = name;
        this.age = 18 ;
    &#125;
    public Person(String name , int age)&#123;
        this.name = name;
        this.age = age ;
    &#125;

    //方法的重载
    public void doSomething ()&#123;
        System.out.println(&quot;做一些事情&quot;);
    &#125;
    public void doSomething(String what)&#123;
        System.out.println(what);
    &#125;
    public void doSomething(String what , int age)&#123;
        System.out.println(age);
        System.out.println(this.name);
    &#125;
&#125;
</code></pre>
<ul>
<li><p>静态成员</p>
<pre><code class="java">class Person &#123;
    //静态变量,只能通过类的方法进行访问
    public static String content = &quot;爱笑&quot;;

    //静态方法
    public static void func()&#123;
        System.out.println(&quot;你好&quot;);
    &#125;
&#125;   
</code></pre>
</li>
</ul>
<p><strong>本质上静态的属于类，非静态的属于实例</strong></p>
<ul>
<li><p>继承， Java只能支持单继承，之前的pyhton和Js都是支持多继承的，Java的一个类只能继承一个父类</p>
<pre><code class="java">import java.lang.reflect.Array;
import java.util.*;

class Person &#123;
    public String name;
    public Integer age;
    public Person(String name , int age)&#123;
        this.name = name;
        this.age = age ;
    &#125;
&#125;
class Cool extends Person &#123;
    public String email;
    public  Cool(String name, int age ,String email)&#123;
        super(name, age);//使用父类的构造方法
        this.email = email;
    &#125;
&#125;
public class Hello &#123;
    public static void main(String[] args) &#123;
        Cool man = new Cool(&quot;wang&quot;,188,&quot;344455&quot;);
        System.out.println(man.email);//34455
        System.out.println(man.name);//wang
        System.out.println(man.age);//188
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>接口</strong></p>
<p>作用</p>
<ul>
<li>约束：实现他的类</li>
<li>泛指实现他的类</li>
</ul>
<pre><code class="Java">//实现其他的类
interface IMessage &#123;
    public void send();
&#125;

class WeChat implements IMessage&#123;
    public void send()&#123;
        System.out.println(&quot;发送&quot;);
    &#125;;
&#125;
</code></pre>
<pre><code class="java">//实现泛指其他的类，调用函数func，参数的类型设置类实现的接口，这样就可以传实现接口的类
interface IMessage &#123;
    public void send();
&#125;

class WeChat implements IMessage&#123;
    public void send()&#123;
        System.out.println(&quot;发送微信&quot;);
    &#125;;
&#125;

class  DingDing implements IMessage&#123;
    public void send()&#123;
        System.out.println(&quot;发送钉钉&quot;);
    &#125;;
&#125;


public class chen1 &#123;
    public static void func(IMessage a)&#123;
        a.send();
    &#125;
    public static void main(String[] args) &#123;
        WeChat a = new WeChat();
        func(a);
    &#125;
&#125;
</code></pre>
<p><strong>注意</strong></p>
<p><strong>Java中不支持多继承，但是可以支持多接口</strong></p>
<p><strong>抽象</strong></p>
<p><strong>抽象类，既能实现接口又能实现继承</strong></p>
<pre><code class="Java">abstract class Person1 &#123;
    //继承的子类必须有实现这个函数
    public abstract void func(String name);
    //子类也能继承这个方法
    public void func2()&#123;
        System.out.println(22222);
    &#125;
&#125;
class Hututu extends Person1 &#123;
    public void func(String name)&#123;
        System.out.println(name);
    &#125;
&#125;


public class chen1 &#123;
    public static void main(String[] args) &#123;
        Hututu hututu  = new Hututu();
        hututu.func(&quot;hututu&quot;);//hututu
        hututu.func2();//22222
    &#125;
&#125;
</code></pre>
<p><strong>包的概念</strong></p>
<p>新建包的文件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323165138897.png" alt="image-20240323165138897"></p>
<p>代码</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323165157520.png" alt="image-20240323165157520"></p>
<p>再在其他的地方导入</p>
<pre><code class="java">import java.lang.reflect.Array;
import java.util.*;
import utils.Helper;//导入包
public class Hello &#123;
    public static void main(String[] args) &#123;
        //调用包的里面的类的静态方法
        System.out.println(Helper.func());//hahahaha
    &#125;
&#125;
</code></pre>
<p><strong>包中类的修饰符</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323165801124.png" alt="image-20240323165801124"></p>
<ul>
<li><p>public，公共（任意人能调用包中的）</p>
</li>
<li><p>default，只能在当前包中调用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323170034173.png" alt="image-20240323170034173"></p>
</li>
</ul>
<p>这个只能在同一个包中调用，</p>
<p><strong>类修饰符</strong></p>
<p>之前学过</p>
<ul>
<li>public，所有都可以访问</li>
<li>private，只能在当前的类中访问</li>
<li>protected，只有在当前的类和当前的类的子类可以调用</li>
</ul>
<h2 id="基础的补充"><a href="#基础的补充" class="headerlink" title="基础的补充"></a>基础的补充</h2><p><strong>递归</strong></p>
<p>例子计算阶乘</p>
<ul>
<li><p>定义递归头 什么时候不调用自身的方法</p>
</li>
<li><p>递归体：什么时候调用自身的方法</p>
<pre><code class="Java">public class Helper &#123;
    public static long func(int n)&#123;
        if (n == 1)&#123;
            return 1;
        &#125; else &#123;
            return n * func(n - 1);
        &#125;
    &#125;;
    public static void main(String[] args) &#123;
        System.out.println(func(3));
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>内存分析</strong></p>
<p>栈主要放的是main方法的代码，堆里面放着的是类，里面有类的属性，方法保存在方法区</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323203251941.png" alt="image-20240323203251941"></p>
<p><strong>注意一点，实例对象的时候没有构造函数。默认的赋值是0和null，属性值的显性初始化‘，就是在类里面不通过构造器，而是通过 a &#x3D; 11,这样初始化</strong></p>
<p><strong>构造器</strong></p>
<ul>
<li>构造器通过new关键字调用</li>
<li>构造器虽然有返回值，但是在定义的构造器的时候不能定义构造器的返回类型，不能return在构造里面使用</li>
<li>构造器的名称和类名保持一致</li>
<li>如果没有构造器，会默认的定义一个无参的构造方法</li>
</ul>
<p>Java<strong>虚拟机内存分析</strong></p>
<p>虚拟机栈的特点</p>
<p><strong>每一个方法调用都会创建一个栈帧，虚拟机为每一个线程创建一个栈，栈属于线程的私有，不能实现线程的共享，栈的特点是先进后出，后进先出</strong></p>
<p><strong>堆的特点</strong></p>
<ul>
<li><p>用于存储创好的对象和数组</p>
</li>
<li><p>只有一个堆，被所有的线程共享</p>
</li>
<li><p>栈是一个不连续的内存共享</p>
</li>
<li><p>堆被所有的线程所共享 ，堆会被分为年生带和老年代，用于垃圾的回收</p>
</li>
</ul>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323203251941.png" alt="image-20240323203251941"></p>
<p><strong>垃圾回收的算法</strong></p>
<ul>
<li>引用计数法：堆中的每个对象都对应一个引用计数器，当引用指向这个对象，引用加一，当为0 的时候java进行回收，缺点就是循环引用就会导致清空不了</li>
</ul>
<p>例子，这样的引入的值一直不为0这样就不会清楚<img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323210136655.png" alt="image-20240323210136655"></p>
<ul>
<li>引用可达法：程序把所有的引用关系看做一张图，从一个节点的Gc Root开始，寻找引用的节点以后，继续寻找这个节点的引用节点吗，当所有的节点寻找完毕以后，剩余的节点则被认为是没有被引用的节点</li>
</ul>
<p><strong>通用的分代垃圾回收机制</strong></p>
<p>永久代就是我刚在的方法区，存放一些常量什么的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323211008599.png" alt="image-20240323211008599"></p>
<p>this<strong>的关键字</strong></p>
<ul>
<li>普通方法，this总是指向调用该方法的对象</li>
<li>构造方法，this指向正要初始化的对象</li>
<li>this（）调用重载的构造方法，避免相同的初始化代码，但只能在构造方法里面使用，并且必须位于构造方法的第一位</li>
<li>this不能用于静态方法（其实向上面的图，static放在方法去里面，只能方法区里面去引入堆里面的东西，显然是不行的）</li>
</ul>
<pre><code class="java">package utils;
class Person1 &#123;
    Person1()&#123;
        //this这里是对象的地址
        System.out.println(&quot;正在初始化对象&quot;+this);//正在初始化对象utils.Person1@682a0b20
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person1 xiaoming = new Person1();

    &#125;
&#125;
</code></pre>
<p>通过this构造</p>
<pre><code class="Java">package utils;
class Person1 &#123;
    public String name;
    public int age;
    Person1(String name , int age)&#123;
//        name = name  //这样因为作用域的问题
        this.name = name ;
        this.age = age ;
        //this这里是对象的地址
        System.out.println(&quot;正在初始化对象&quot;+this);//正在初始化对象utils.Person1@682a0b20
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person1 xiaoming = new Person1(&quot;wang&quot;,18);
        System.out.println(xiaoming.name); //wang
        System.out.println(xiaoming.age);  //18
    &#125;
&#125;
</code></pre>
<p>this（），还可以带参数</p>
<pre><code class="Java">package utils;
class Person1 &#123;
    public String name;
    public int age;
    Person1()&#123;
        System.out.println(&quot;wwww&quot;);//wwww
    &#125;;
    Person1(String name , int age)&#123;
        //this()调用无参构造器，而且必须位于第一行
        this();
        this.name = name ;
        this.age = age ;
        System.out.println(&quot;正在初始化对象&quot;+this);//正在初始化对象utils.Person1@682a0b20
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person1 xiaoming = new Person1(&quot;wang&quot;,18);
        System.out.println(xiaoming.name); //wang
        System.out.println(xiaoming.age);  //18
    &#125;
&#125;
</code></pre>
<p><strong>static关键字</strong></p>
<p>这里面的代码</p>
<p>代码的开始定义一个静态的name，但是在构造器里面，有使用了name，就导致实例对象里面也有name的属性 了</p>
<pre><code class="java">package utils;
class Person1 &#123;
    static String name;
    Person1(String a)&#123;
    name = a ;
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person1 shuai = new Person1(&quot;nini&quot;);
        
        System.out.println(shuai.name);//nini
        System.out.println(Person1.name);//nini
    &#125;
&#125;
</code></pre>
<p>正确给静态的属性赋值的方法，调用的时机在类被加载的时候。</p>
<pre><code class="java">package utils;
public class Helper &#123;
    static String name;
    static &#123;
        System.out.println(&quot;执行初始化的工作&quot;);//执行初始化的工作
        name = &quot;王昌晨&quot;;
        printName();

    &#125;
    public static void printName()&#123;
        System.out.println(name);//王昌晨
    &#125;
    public static void main(String[] args) &#123;
    &#125;
&#125;
</code></pre>
<p>敲的时候出现一些问题，问了一下ai</p>
<pre><code class="java">package utils;
public class Helper &#123;
    static String name;
    static &#123;
        System.out.println(&quot;执行初始化的工作&quot;);//执行初始化的工作
        name = &quot;王昌晨&quot;;
        printName();
    &#125;
    public static void printName()&#123;
        System.out.println(name);//王昌晨
    &#125;
    public static void main(String[] args) &#123;
        Helper p = new Helper();
        System.out.println(p.name);/**
        虽然 name 属性被声明为 static，但是在 main 方法中通过实例对象访问静态属性 name 是合法的，这是因为静态成员虽然属于类而不属于实例对象，但在 Java 中仍然可以通过实例对象访问静态成员。

当你使用实例对象访问静态成员时，实际上是通过该实例对象来引用静态成员，编译器会在后台进行转换，将实例对象替换为对应的类名。因此，尽管最佳实践是通过类名直接访问静态成员，但是通过实例对象访问静态成员在语法上是合法的。

所以，在你的代码中，虽然在 main 方法中通过实例对象 p 访问静态属性 name，实际上会被转换为 Helper.name，因此可以正常访问并输出静态属性 name 的值。**/
    &#125;
&#125;
</code></pre>
<p>静态初始化 的执行顺序</p>
<pre><code>因为所有的类都继承Object
*上溯到Object类，先执行Object的静态初始化模块，在向下执行子类的静态初始化块，直至类的静态初始化
*构造方法的执行顺序也是一样的，这就是为什么在子类的构造器里面的super的方法
</code></pre>
<p><strong>包机制</strong></p>
<ul>
<li><p>用于管理类和类重名的问题</p>
</li>
<li><p>Java中常见的包	</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323220021699.png" alt="image-20240323220021699"></p>
</li>
</ul>
<p>导入的报名重名</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323220302005.png" alt="image-20240323220302005"></p>
<p>最好写齐路径</p>
<p>下面不会全部导入，会先检查用到这个文件的哪些类，然后再导入</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323220335026.png" alt="image-20240323220335026"></p>
<p><strong>静态导入</strong></p>
<p>导入包下面的所有的静态的属性</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323220509419.png" alt="image-20240323220509419"></p>
<p><strong>方法的重写</strong></p>
<p><strong>三个要点</strong></p>
<ul>
<li><p>1.方法名，形参，形参列表相同</p>
</li>
<li><p>2.返回值类型和声明异常类型，子类小于父类</p>
<pre><code class="Java">package utils;
class Person &#123;
    public Person func()&#123;
        System.out.println(&quot;1111&quot;);
        return new Person();
    &#125;
&#125;

class Li extends Person&#123;
    public Li func()&#123;
        System.out.println(&quot;222&quot;);
        return new Li();
    &#125;
&#125;

public class Helper &#123;

    public static void main(String[] args) &#123;
        
    &#125;
&#125;
</code></pre>
</li>
<li><p>3.访问权限，子类大于等于父类</p>
</li>
</ul>
<p><strong>final关键字</strong></p>
<ul>
<li><p>修饰变量</p>
</li>
<li><p>修饰方法：该方法不可以被子类重写，但是可以重载</p>
<pre><code class="java">public final void study()&#123;&#125;
</code></pre>
</li>
<li><p>修饰类：修饰类不能被继承，比如：Math,String</p>
<pre><code class="java">public final class A &#123;&#125;
</code></pre>
</li>
</ul>
<p><strong>组合</strong></p>
<p><strong>除了继承，组合也能实现代码的复用，组合的核心是将父类对象作为子类的属性</strong></p>
<pre><code class="Java">package utils;
class Person &#123;
    public String name;
    public int age;
    Person()&#123;
        name = &quot;hahaha&quot;;
        age = 18;
    &#125;
    public Person func()&#123;
        System.out.println(&quot;1111&quot;);
        return new Person();
    &#125;
&#125;

class Li &#123;
    Person chen = new Person();
    Li()&#123;
        System.out.println(chen.age);
        System.out.println(chen.name);
    &#125;
&#125;

public class Helper &#123;

    public static void main(String[] args) &#123;
        Li li = new Li();
    &#125;
&#125;
</code></pre>
<p><strong>Object类的详解</strong></p>
<ul>
<li>Object是所有类的父类</li>
<li>IDEA的快捷键<ul>
<li>类结构试图 alt+7</li>
<li>查看类的源码 ctrl+左键</li>
<li>自动生成构造器，get，set，equai方法 alt+insert</li>
<li>查看错误 alt+enter</li>
<li>快捷键常见代码片段<ul>
<li>main public static void main</li>
<li>sout System.out.printf()</li>
<li>soutm  System.out.printf（描述所在类中的，所在的方法）</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="java">        System.out.println(&quot;Person.func&quot;);//Person类里的func函数
</code></pre>
<p><strong>Object的equals方法</strong></p>
<pre><code>== 比较双方是否相同，普通的数据类型判断值，引用类型的判断的是地址
equals默认的比较两个对象地址是否相同
</code></pre>
<p>我们可以重写equal方法实现判断其他的</p>
<p><strong>super关键字</strong></p>
<ul>
<li><p>可以看作父类对象的引用，可以通过super来访问父类中被子类覆盖的方法和属性</p>
</li>
<li><p>使用super调用普通方法，语句没有位置限制，可以在子类中随意的调用</p>
</li>
<li><p>在一个类中，若是构造方法的第一行没有调用super或者是this；Java默认调用super含义是调用父类无参数的构造方法</p>
<pre><code class="java">package utils;
class Person &#123;
    public String name;
    public int age;
    public  void func()&#123;
        name = &quot;wang&quot;;
        age = 18;
        System.out.println(&quot;Person_age&quot;+age);
    &#125;
&#125;

class xiao extends Person&#123;
    public String name;
    public int age;
    public void func()&#123;
        super.func();
        age = 19;
        System.out.println(&quot;xiao_age&quot;+age);
        System.out.println(age);
        System.out.println(super.age);
    &#125;
&#125;

public class Helper &#123;

    public static void main(String[] args) &#123;
        xiao he = new xiao();
        he.func();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>程序的执行顺序</strong></p>
<p>构造方法的第一句总是super来调用父类的构造方法，，所以一直相声追溯，知道object</p>
<p><strong>封装</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324094833900.png" alt="image-20240324094833900"></p>
<ul>
<li><p>属性一般使用private访问权限，一般在开发中，我们把类中的属性都设为私有属性，然后通过相应的get和set的方法进行修改和读取。这些方法是public修饰（注意boolen类型的get方法是is开头）</p>
</li>
<li><p>方法：一些只用本类的辅助性方法可以用private修饰，希望其他类调用方法用public</p>
<pre><code class="java">//快速生成的get阿set的方法用 alt+insert
package utils;
class Person &#123;
    private String name;
    private int  age;
    private Boolean man;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public Boolean getMan() &#123;
        return man;
    &#125;

    public void setMan(Boolean man) &#123;
        this.man = man;
    &#125;
&#125;

public class Helper &#123;

    public static void main(String[] args) &#123;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>多态的要点</strong></p>
<ul>
<li>多态方法 的多态，不是属性</li>
<li>多态的存在三个条件，继承，方法重写，父类指向子类对象</li>
<li>父类引用子类的对象。用父类引用调用子类重写的方法</li>
</ul>
<pre><code class="Java">package utils;
class Animal&#123;

    public void shout ()&#123;
        System.out.println(&quot;叫一声&quot;);
    &#125;
&#125;
class Dog extends Animal&#123;
    public void shout()&#123;
        System.out.println(&quot;汪汪&quot;);
    &#125;
&#125;

class Cat extends Animal&#123;
    public void shout()&#123;
        System.out.println(&quot;喵喵&quot;);
    &#125;
&#125;

public class Helper &#123;
     public static void diao(Animal animal)&#123;//这里实现父类引用子类对象Animal animal
        animal.shout();
    &#125;

    public static void main(String[] args) &#123;
        Dog dog = new Dog();
        diao(dog);
    &#125;
&#125;
</code></pre>
<p><strong>再补充点</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324101703654.png" alt="image-20240324101703654"></p>
<ul>
<li><code>animal</code> 是 <code>Animal</code> 类型的引用，但是在运行时却指向了 <code>Dog</code> 类的实例，因此调用 <code>shout()</code> 方法时会调用 <code>Dog</code> 类中的 <code>shout()</code> 方法。</li>
<li><code>Animal</code> 类型的引用 <code>dog</code> 指向了 <code>Dog</code> 类的实例，然后尝试调用 <code>shout1()</code> 方法，但是 <code>Animal</code> 类并没有定义 <code>shout1()</code> 方法，因此编译器会报错</li>
</ul>
<p><strong>对象的转型</strong></p>
<ul>
<li><p>向上转型：就是刚下上面说过的父类引用子类对象</p>
<pre><code>Animal是父类
Dog是子类
Animal dog = new Dog();//父类引用子类对象
</code></pre>
</li>
<li><p>向下转型</p>
<pre><code class="Java">package utils;
class Animal&#123;

    public void shout ()&#123;
        System.out.println(&quot;叫一声&quot;);
    &#125;
&#125;
class Dog extends Animal&#123;
    public void shout()&#123;
        System.out.println(&quot;汪汪&quot;);
    &#125;
    public void shout1()&#123;
        System.out.println(&quot;汪汪&quot;);
    &#125;
&#125;

public class Helper &#123;
     public static void diao(Animal animal)&#123;//这里实现父类引用子类对象Animal animal
        animal.shout();
    &#125;

    public static void main(String[] args) &#123;
         Animal animal = new Dog();//自动向上转型为Animal
        animal.shout();//汪汪
        animal.shout1();//代码错误，因为animal没有shout
        ((Dog) animal).shout1();//向下转型

    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>转型前后都是一个对象</strong></p>
<p><strong>接口定义静态方法和默认方法</strong></p>
<p>默认方法用default修饰</p>
<pre><code class="Java">public interface Test &#123;
    void printInfo();
    default void moren()&#123;
        System.out.println(&quot;默认方法&quot;);
    &#125;
&#125;
class Testclass implements Test&#123;
    @Override
    public void printInfo() &#123;

    &#125;
&#125;
</code></pre>
<p>静态的方法，<strong>注意接口的静态方法和子类一点关系也没有，不会有父子类的那样的关系，接口的静态方法只能通过接口进行调用和实现接口的类没有一点关系</strong></p>
<pre><code class="java">public interface Test &#123;
    void printInfo();
    default void moren()&#123;
        System.out.println(&quot;默认方法&quot;);
    &#125;
    public static void func()&#123;
        System.out.println(&quot;hahaha&quot;);
    &#125;
&#125;
class Testclass implements Test&#123;
    @Override
    public void printInfo() &#123;
        Test.func();//hahaha
        Testclass.func();//报错	
    &#125;
    
&#125;
</code></pre>
<p>字符串的一些api</p>
<pre><code class="java">String s1=&quot;core Java&quot;;
String s2=&quot;core Java&quot;;
s1.charAt()//查看下标为几 的字符
s1.length();
s1.equals(s2)//检查相等
s1.equalIgnoreCase(s2);//忽略大小写
s1.indexOf(&quot;Java&quot;);//字符串是否包含Java，位置，如果没有返回-1
s1.replace(&#39;&#39;,&#39;&amp;&#39;);//将空格替换成&amp;
s1.substring(4,7);
s1.substring(4)//提取字符串从4到字符串结尾
</code></pre>
<p><strong>内部类</strong></p>
<ul>
<li>内部类提供更好的封装，只能外部类直接访问，不允许同一个包其他类直接访问</li>
<li>内部类可以直接访问外部类的私有属性，内部类被当作其他外部类成员，但外部类不能访问内部类的属性</li>
</ul>
<p>		</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324104900955.png" alt="image-20240324104900955"></p>
<p><strong>非静态内部类</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324105114585.png" alt="image-20240324105114585"></p>
<pre><code class="java">package utils;
class Outer &#123;
    private String name = &quot;王昌晨&quot;;
    public void show()&#123;
        System.out.println(&quot;Outer_name&quot;+name);
        //在外部类实例内部类
        Inner a = new Inner();
    &#125;
    public class Inner&#123;
        private String name = &quot;兵王&quot;;
        public void show()&#123;
            System.out.println(&quot;Inner_name&quot;+name);
            System.out.println(Outer.this.name);//访问外部类
            Outer.this.show();
        &#125;
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        //外部类实例
        Outer out = new Outer();
        //内部类的实例
        Outer.Inner inner  = new Outer().new Inner();
    &#125;
&#125;
</code></pre>
<p><strong>静态内部类</strong></p>
<ul>
<li>静态内部类可以访问外部类的静态成员，不能直接访问外部类的普通成员</li>
<li>静态内部类可以看作外部类的一个静态成员</li>
</ul>
<pre><code class="Java">package utils;
class Outer &#123;
    private String name = &quot;王昌晨&quot;;
    private static int a = 1;
    private static int b = 3;
    public void show()&#123;
        System.out.println(&quot;Outer_name&quot;+name);
        //在外部类实例内部类
        Inner a = new Inner();
    &#125;
    public static class Inner&#123;
        private String name = &quot;兵王&quot;;
        public void show()&#123;
            System.out.println(&quot;Inner_name&quot;+name);
//            可以直接访问外部的成员的静态属性和方法
            System.out.println(a);//1
            System.out.println(b);//3

        &#125;
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        //外部类实例
        Outer out = new Outer();
        //静态类这么实例
        Outer.Inner a = new Outer.Inner();
        a.show();

    &#125;
&#125;
</code></pre>
<p><strong>匿名的匿名类</strong></p>
<ul>
<li>适用于那种只需要使用一次的类，b比如：键盘监听操作等，</li>
</ul>
<p>如下面的这段代码，我们如果想要调用Person里的B方法，必须需要传入实现接口A的对象，需要在写一个实现A接口的类，有点麻烦，可以写匿名类</p>
<pre><code class="Java">package utils;
class Person &#123;
    public void B(A f)&#123;
        f.func();
    &#125;
&#125;
interface A &#123;
    void func();
&#125;
class B implements A&#123;
    @Override
    public void func() &#123;
        System.out.println(&quot;hahaha&quot;);
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person h = new Person();
        h.B(new B());
    &#125;
&#125;
</code></pre>
<pre><code class="Java">package utils;
class Person &#123;
    public void B(A f)&#123;
        f.func();
    &#125;
&#125;
interface A &#123;
    void func();
&#125;
public class Helper &#123;
    public static void main(String[] args) &#123;
        Person h = new Person();
        //直接new A就会有代码提示，下面的就是实力一个实现接口A的类
        h.B(new A() &#123;
            @Override
            public void func() &#123;
                System.out.println(&quot;hehehe&quot;);
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre>
<p><strong>方法的内部类</strong></p>
<ul>
<li>只能在方法里面使用</li>
<li><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324111801398.png" alt="image-20240324111801398"></li>
</ul>
<p><strong>数组</strong></p>
<ul>
<li>数组是相同数据类型的有序集合</li>
<li>长度是确定的</li>
<li>元素类型是相同 的</li>
<li>数组对象是引用类型</li>
</ul>
<p>内存分析</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324113002955.png" alt="image-20240324113002955"></p>
<p><strong>静态初始化</strong></p>
<ul>
<li>除了通过new的关键字，还可以通过定义数组的同时就为数组分配空间并且赋值</li>
</ul>
<pre><code class="Java">package utils;
class Person &#123;
&#125;
public class Helper &#123;
    public static void main(String[] args) &#123;
        int[] a = &#123;1,2,3&#125;;
        Person[] b = &#123;new Person(),new Person()&#125;;
    &#125;
&#125;
</code></pre>
<p><strong>动态初始化</strong></p>
<pre><code class="Java">package utils;
class Person &#123;
&#125;
public class Helper &#123;
        int[] c = new int[3];
        c[0] = 1;
        c[1] = 2;
        c[2] = 3;
    &#125;
&#125;
</code></pre>
<p><strong>默认初始化</strong></p>
<pre><code class="Java">package utils;
class Person &#123;
&#125;
public class Helper &#123;
    public static void main(String[] args) &#123;
    int d[] = new int[2];//默认[0,0]
    boolean[] b = new boolean[2];//默认[false,false]

&#125;
</code></pre>
<p><strong>数组的两个遍历</strong></p>
<ul>
<li><p>使用For循环</p>
</li>
<li><p>for-each专门用于数组和集合所有的元素,在循环的过程中只能读取不能修改数组的值，for-each 仅用于简单的遍历，操作不了索引</p>
<pre><code class="Java">String[] ss = &#123;&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;&#125;;
for(String item : ss)&#123;
    System.out.println(item);
&#125;
</code></pre>
</li>
</ul>
<p><strong>异常</strong></p>
<ul>
<li><p>代码出现不正常的状态，异常是一个一个的类</p>
<p><strong>Throwable下面的两个子类</strong></p>
<ul>
<li>Error:错误，代码出现重大的错误</li>
<li>Exception：异常：代码出现小问题，异常分为两类<ul>
<li>编译时期异常，代码一些写一编译就暴红了（语法错误除外），Exception以及子类（除了RuntimeException之外）</li>
<li>运行时期异常：RuntimeException和他的子类，写代码不暴红，运行的时期爆红了<img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325143129953.png" alt="image-20240325143129953"></li>
</ul>
</li>
</ul>
<p>实例</p>
<p><strong>错误</strong></p>
</li>
<li><pre><code class="Java">package execption;

public class Demo &#123;
    public static void main(String[] args) &#123;
        method();
    &#125;

    public static void method() &#123;
        method();
    &#125;
&#125;
</code></pre>
<p>控制台报错</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325143434765.png" alt="image-20240325143434765"></p>
</li>
</ul>
<p><strong>运行时期异常</strong></p>
<pre><code class="Java">    public static void main(String[] args) &#123;
        int[] a= &#123;1,2,3&#125;;
        System.out.println(a[4]);
    &#125;
</code></pre>
<p>编译器没有飘红</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325143605424.png" alt="image-20240325143605424"></p>
<p>运行的时候</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325143635501.png" alt="image-20240325143635501"></p>
<p>发现是他的子类，所以是运行时期异常</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325143710714.png" alt="image-20240325143710714"></p>
<p><strong>编译时期异常</strong></p>
<p>下面的例子</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325144118255.png" alt="image-20240325144118255"></p>
<p>代码没有错，但是编译时期飘红 了，</p>
<p><strong>注意</strong></p>
<ul>
<li>编译时期飘红不是因为我们的代码写错 了</li>
<li>是因为该方法的底层给我们抛了一个错误，所以我们一调用这个方法一编译就飘红了</li>
</ul>
<p>异常出现的过程</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325145239439.png" alt="image-20240325145239439"></p>
<p><strong>创建异常对象</strong></p>
<p>创建异常对象只是为了后面学习如何处理异常</p>
<ul>
<li>1.关键字：throw：把异常对象显示出来</li>
<li>2.格式throw new 异常</li>
</ul>
<p>例</p>
<pre><code class="Java">package execption;

public class Demo1 &#123;
    public static void main(String[] args) &#123;
        String s = &quot;a.txt1&quot;;
        method(s);

    &#125;
    public static void method(String s)&#123;
        if (! s.endsWith(&quot;.txt&quot;))&#123;
            //故意创建异常对象，用throw说明这出有异常
            throw new NullPointerException();//这里出现异常没有人处理就会往上面抛，最后都没有人处理交给虚拟机，虚拟机终止程序，打印异常信息
            /**
             Exception in thread &quot;main&quot; java.lang.NullPointerException
             at execption.Demo1.method(Demo1.java:12)
             at execption.Demo1.main(Demo1.java:6)**/
        &#125;
        System.out.println(&quot;执行&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>异常处理的两种方法</strong></p>
<ul>
<li>throws：在方法参数和方法体之间的位置写<ul>
<li>格式：throws 异常</li>
<li>将异常往上面</li>
</ul>
</li>
</ul>
<p>例子</p>
<pre><code class="Java">package execption;

import java.io.FileNotFoundException;

public class Democracy
&#123;
    public static void main(String[] args)  &#123;
        String s = &quot;1.txt&quot;;
        add(s);
        delete(s);
        
    &#125;

    private static void delete(String s) &#123;
        System.out.println(&quot;删除&quot;);
    &#125;

    private static void add(String s)  &#123;
        if (! s.endsWith(&quot;.txt&quot;))&#123;
            //故意创建异常
            throw new FileNotFoundException(&quot;文件找不到&quot;);
        &#125;
        System.out.println(&quot;增加&quot;);
    &#125;
&#125;
</code></pre>
<p>直接new异常会报错，因为他是编译时期异常</p>
<p>所以使用throws向上抛，这样就可以了，这个异常处理的过程还是和默认的一样，最终还是往上面抛，最后给虚拟机，<strong>这样也会有问题，当一个出现我问题的时候，例如当add出现问题，程序就不会往下面走去到delete</strong></p>
<pre><code class="Java">package execption;

import java.io.FileNotFoundException;

public class Democracy
&#123;
    public static void main(String[] args) throws FileNotFoundException &#123;
        String s = &quot;1.txt&quot;;
        add(s);
        delete(s);
        
    &#125;

    private static void delete(String s) &#123;
        System.out.println(&quot;删除&quot;);
    &#125;

    private static void add(String s) throws FileNotFoundException  &#123;
        if (! s.endsWith(&quot;.txt&quot;))&#123;
            //故意创建异常
            throw new FileNotFoundException(&quot;文件找不到&quot;);
        &#125;
        System.out.println(&quot;增加&quot;);
    &#125;
&#125;
</code></pre>
<p>多个异常可以这样写</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325151526466.png" alt="image-20240325151526466"></p>
<ul>
<li><p>如果throws的多个异常之间有一个子父类的继承关系，我们直接可以throws 父类的异常</p>
</li>
<li><p>所以根据上面，有多个异常我们可以直接抛出他们最终的父类Exception</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325151726630.png" alt="image-20240325151726630"></p>
</li>
</ul>
<p><strong>第二种方法</strong></p>
<p><strong>try catch</strong></p>
<ul>
<li><p>格式</p>
<pre><code class="java">try &#123;
//可能出现的异常的代码
    
&#125; catch(异常 对象名)&#123;
    //处理异常的代码（把异常打印在控制台）--》将来将开发会把异常信息保存在日志文件中（用于查询）
&#125;
</code></pre>
<p>实例</p>
<p><strong>当我们程序出现异常，会被catch捕获到，然后在输出异常，然后继续往下面走</strong></p>
<pre><code class="Java">package execption;

import java.io.FileNotFoundException;

public class Democracy
&#123;
    public static void main(String[] args)&#123;
        String s = &quot;1.txt1&quot;;
        try &#123;
            add(s);
        &#125; catch (FileNotFoundException e)&#123;
            System.out.println(e);//java.io.FileNotFoundException: 文件找不到
        &#125;
        delete(s);//删除
    &#125;

    private static void delete(String s) &#123;
        System.out.println(&quot;删除&quot;);
    &#125;

    private static void add(String s) throws FileNotFoundException  &#123;
        if (! s.endsWith(&quot;.txt&quot;))&#123;
            //故意创建异常
            throw new FileNotFoundException(&quot;文件找不到&quot;);
        &#125;
        System.out.println(&quot;增加&quot;);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p>控制台的输出结果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325152527183.png" alt="image-20240325152527183"></p>
<p><strong>注意</strong>这段代码只捕获了FileNotFoundException的错误，但是没有捕获数组的那个错误，此时这个try catch是失效了</p>
<pre><code class="java">        try &#123;
            add(s);
            int[] a = null;
            System.out.println(a.length);
        &#125; catch (FileNotFoundException e)&#123;
            System.out.println(e);//java.io.FileNotFoundException: 文件找不到
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325152924929.png" alt="image-20240325152924929"></p>
<p><strong>有一个发现，当我们的add方法错误以后，直接就去走catch，这样       System.out.println(1111);这段代码就不会执行</strong></p>
<pre><code class="java">    public static void main(String[] args)&#123;
        String s = &quot;1.txt1&quot;;
        try &#123;
            add(s);
            System.out.println(1111);
        &#125; catch (FileNotFoundException e)&#123;
            System.out.println(e);//java.io.FileNotFoundException: 文件找不到
        &#125;
        delete(s);//删除
    &#125;
</code></pre>
<p>catch多个异常的格式，使用多个catch</p>
<pre><code class="Java">package execption;

import java.io.FileNotFoundException;
import java.io.IOException;

public class Democracy
&#123;
    public static void main(String[] args)&#123;
        String s = &quot;1.txt1&quot;;
        try &#123;
            add(s);
            System.out.println(1111);
        &#125; catch (FileNotFoundException e)&#123;
            System.out.println(e);//java.io.FileNotFoundException: 文件找不到
        &#125; catch (IOException e)&#123;
            System.out.println(e);
        &#125;
        delete(s);//删除
    &#125;

    private static void delete(String s) &#123;
        System.out.println(&quot;删除&quot;);
    &#125;

    private static void add(String s) throws IOException ,FileNotFoundException &#123;
        if (! s.endsWith(&quot;.txt&quot;))&#123;
            //故意创建异常
            throw new FileNotFoundException(&quot;文件找不到&quot;);
        &#125;
        if (s==null)&#123;
            throw new IOException(&quot;Io异常&quot;);
        &#125;
        System.out.println(&quot;增加&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>如果异常的有父子关系，直接用父类也是可以的</strong></p>
<p><strong>不知道的话，我们直接catch Exception</strong></p>
<p>我们还可以打印详细的</p>
<p>cu错误的信息打印在控制台，使用printStackTrace的方法</p>
<pre><code class="Java">        try &#123;
            add(s);
            System.out.println(1111);
        &#125; catch (FileNotFoundException e)&#123;
            e.printStackTrace();
        &#125; catch (IOException e)&#123;
            System.out.println(e);
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325181330429.png" alt="image-20240325181330429"></p>
<p><strong>finally关键字</strong></p>
<pre><code>注意和final区别开
1.代表的是不管是否触发了异常，都会执行的代码块
特殊情况：如果前面有代码System.exit(0)这个作用是终止Java虚拟机
2.使用配合try catch放在trycatch后面
</code></pre>
<p>例子</p>
<pre><code class="Java">try &#123;
    add(s);
    System.out.println(2222);
&#125; catch (FileNotFoundException e)&#123;
    e.printStackTrace();
&#125; catch (IOException e)&#123;
    System.out.println(e);
&#125; finally &#123;
    System.out.println(1111);
&#125;
</code></pre>
<p>之前说过try里面发生错误以后直接进入catch，然后就不会输出22222，</p>
<p>但是finally不管你有没有异常都会执行 的</p>
<p>下面将一些问题</p>
<ul>
<li>正常我们程序发生异常走进catch里面，里面有一个return,但是我们程序的执行顺序是先走的是finally，然后是catch里的内容</li>
</ul>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325182306317.png" alt="image-20240325182306317"></p>
<ul>
<li><p>所以我们在finally里面加上return，那么就会直接离开这个函数也不会执行catch里面的内容了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325182506837.png" alt="image-20240325182506837"></p>
</li>
</ul>
<p>注意执行的顺序</p>
<p><strong>try代码块，发现错误然后到finally，然后到catch里面的代码</strong></p>
<p><strong>finally的使用场景</strong></p>
<ul>
<li>关闭资源<ul>
<li>原因：如果没有使用 了，GC回收机制，用来回收堆内存的垃圾，释放内存，但是有一些对象GC回收不了，例如：连接对象（mysql）,io流对象，socket对象，这些GC回收不了，就需要我们手动进行回收，将来不能回收的对象new完以后，后续的操作不管异常还是好的，都要关闭</li>
</ul>
</li>
</ul>
<p><strong>抛异常的注意的事项</strong></p>
<ul>
<li><p>如果父类中的方法抛出了异常，那么子类的重写以后要不要抛？</p>
<pre><code>子类重写的方法可以抛也可以不抛
</code></pre>
</li>
<li><p>如果父类中的方法没有抛异常，那么子类重写方法的可不可以抛异常？</p>
</li>
</ul>
<pre><code>子类重写的方法不可以抛异常
</code></pre>
<p><strong>try catch和throws的使用时机</strong></p>
<ul>
<li><p>1.如果处理异常之后还要继续执行代码，那么就要使用try catch</p>
</li>
<li><p>2.如果方法之间是递进的调用，可以先throws，但是到最后用try catch做一个统一的错误处理</p>
</li>
</ul>
<p>比如说页面的架构，到后面一定使用这三个架构</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325184146232.png" alt="image-20240325184146232"></p>
<p>编译时期的异常是必须要处理</p>
<p>运行时期的异常没有必要处理，需要更改代码了</p>
<p><strong>自定义异常</strong></p>
<p>简单的创建方法</p>
<pre><code class="Java">public class Demo2 &#123;
    public static void main(String[] args) throws LoginUserException &#123;
        String username = &quot;root&quot;;

        Scanner input  = new Scanner(System.in);
        System.out.println(&quot;请输入您要登录的用户名:&quot;);
        String name = input.next();

        if (name.equals(username))&#123;
            System.out.println(&quot;登录失败&quot;);
        &#125; else &#123;
            throw new LoginUserException();
        &#125;


    &#125;
&#125;
</code></pre>
<p>然后我们需要去定义一个LoginUserException类，而且还要继承Exception</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325185420455.png" alt="image-20240325185420455"></p>
<p>这样就可以了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325185441928.png" alt="image-20240325185441928"></p>
<p>我们就还可以自定义异常的原因</p>
<pre><code class="Java">throw new LoginUserException(&quot;账号或密码错误&quot;);
            -------------------------------
使用构造方法
public class LoginUserException extends Exception &#123;
    public LoginUserException() &#123;
    &#125;
    public LoginUserException(String message) &#123;
        super(message);
    &#125;
&#125;
            
            
            
</code></pre>
<p>这样就可以了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325190118158.png" alt="image-20240325190118158"></p>
<p>设置异常的原因</p>
<p><strong>打印异常信息的三个方法</strong></p>
<pre><code>Throwable的方法
          try &#123;
                throw new LoginUserException(&quot;账号或密码错误&quot;);
            &#125; catch (Exception e)&#123;
                //异常加错误的原因，之前说过打印你一个对象默认调用了tostring的方法
                System.out.println(e);//execption.LoginUserException: 账号或密码错误
                System.out.println(e.toString());//execption.LoginUserException: 账号或密码错误
                System.out.println(e.getMessage());//账号或密码错误          只获取异常的信息
                e.printStackTrace();//飘红，信息完整
            &#125;
</code></pre>
<p><strong>说一下scanner的</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325185812928.png" alt="image-20240325185812928"></p>
<p><strong>Object类</strong></p>
<p><strong>toString方法</strong></p>
<p>类的源码</p>
<pre><code class="Java">    public String toString() &#123;
        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
    &#125;
</code></pre>
<p>示例</p>
<pre><code class="Java">package _object;

public class Person &#123;
    private String name;
    private int age;

    public Person() &#123;
    &#125;

    public Person(String name) &#123;
        this.name = name;
    &#125;

    public Person(int age) &#123;
        this.age = age;
    &#125;

    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;
&#125;
</code></pre>
<pre><code class="Java">package _object;

public class Test &#123;
    public static void main(String[] args) &#123;
        Person p1= new Person(&quot;王昌晨&quot;,18);
        System.out.println(p1);//_object.Person@3b07d329
        System.out.println(p1.toString());//_object.Person@3b07d329
    &#125;

&#125;
</code></pre>
<p><strong>总结</strong></p>
<pre><code>注意：
*如果没有重写object里的tostrig的方法，直接输出对象名会默认的调用tostring方法，tostring的方法会返回对象的地址值
</code></pre>
<p>有些问题</p>
<pre><code class="Java">        List a = new ArrayList();
        a.add(&quot;张三&quot;);
        a.add(&quot;王五&quot;);
        a.add(&quot;李四&quot;);
        System.out.println(a.toString());//[张三, 王五, 李四]
</code></pre>
<ul>
<li>输出的不是地址值,是因为重写了tostring的方法</li>
</ul>
<p>所以我们还可以重写tostring的方法在我们自己的类里面</p>
<pre><code class="java">    public String toString ()&#123;
        return name + age;
    &#125;
</code></pre>
<p>快速生成toString的方法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325104744357.png" alt="image-20240325104744357"></p>
<p><strong>Object的equals方法</strong></p>
<p>源代码</p>
<pre><code class="java">    public boolean equals(Object obj) &#123;
        return (this == obj);
    &#125;
</code></pre>
<p>返回的是boolean类型，比较的是两个地址值是否相等</p>
<pre><code class="java">        System.out.println(p1.equals(p2));//false
        System.out.println(p1.equals(p1));//true
</code></pre>
<p>底层的原理</p>
<pre><code>    public boolean equals(Object obj) &#123;
        return (this == obj);
    &#125;
    -----------------------------------------
    System.out.println(p1.equals(p2));//false
    *当p1调用obj的时候,这个this就是指向的p1，==在引用类型的比较的是地址值，在基础数据类型是比较数据的值
</code></pre>
<p>注意还是重写的问题</p>
<pre><code class="java">//我们使用实例的方法创建字符串
String name = new String(&quot;name&quot;);
String name1 = new String(&quot;name&quot;);
System.out.println(name.equals(name1));//true
因为String的equals的重写了，比较的是值
</code></pre>
<p>下面是重写的代码</p>
<pre><code class="Java">    public boolean equals(Object anObject) &#123;
        if (this == anObject) &#123;
            return true;
        &#125;
        return (anObject instanceof String aString)
                &amp;&amp; (!COMPACT_STRINGS || this.coder == aString.coder)
                &amp;&amp; StringLatin1.equals(value, aString.value);
    &#125;
</code></pre>
<p>我们也可以在重写一下</p>
<p>这是快捷键重写以后的</p>
<pre><code class="java">    @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &amp;&amp; Objects.equals(name, person.name);
    &#125;

    @Override
    public int hashCode() &#123;
        return Objects.hash(name, age);
    &#125;
</code></pre>
<pre><code class="Java">System.out.println(p1.equals(p2))
//当我们传入p2的时候，重写的类用父类引用子类 object 0 = p2;
//如果想要获取p2的里面的属性和方法需要向下转型
//        if (o == null || getClass() != o.getClass()) return false;这一步在判断传入的对象类型是否是当当前的类，如果传入一个字符串对象的话，强转就会出现问题
 //      if (this == o) return true;如果传入的是自己那么肯定是相等的，返回true
</code></pre>
<p><strong>Object的clone的方法</strong></p>
<pre><code>1.作用:复制一个属性值一样的新对象
2.使用:需要被克隆的对象实现cloneable的接口
        重写clone
</code></pre>
<p>过程</p>
<pre><code class="Java">Person的类实现public class Person implements Cloneable
重写clone方法    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;
    在主函数里面调用
            public static void main(String[] args) throws CloneNotSupportedException &#123;
        Person p = new Person(&quot;wang&quot;,18);
        Object o = p.clone();//克隆一个新对象,地址不一样，属性值是一样的
        Person p1 = (Person) o;
        System.out.println(p1.equals(p));//true

    &#125;
</code></pre>
<p><strong>在复习一下多态</strong></p>
<ul>
<li><p>不要从字面形式上理解多态的这两个子，要从形式上掌握</p>
</li>
<li><p>要知道多态的好处，多态的前提</p>
<pre><code>前提
a.必须有字符类的继承或者接口实现关系
b.必须有方法的重写（没有重写，多态没有意义）
c.父类引用指向子类对象
Fu fu = new zi();--&gt;理解成大数据类型接受一个小数据类型的数据，比如 double b = 10;
注意：
    多态下不能直接调用子类的特有功能
</code></pre>
</li>
</ul>
<p><strong>多态的好处</strong></p>
<pre><code>1.问题描述
    如果不使用多态，使用原始的方法new对象，既能调用子类重写的父类的方法，还能调用自己特有的成员，但是多态的new的对象只能调用子类重写的，不能调用子类的特有的成员那为什么还要用多态？
2.多态方式和原始方式new对象的优缺点
    原始方式:
        优点:既能调用重写的，还能调用父类非私有的，还能调用自己特有的
        缺点:扩展性差，就像之前的讲的，传递的参数可以写成父类
    多态方法:
        优点:扩展性强
        缺点:不能调用子类特有的功能
</code></pre>
<p><strong>多态的转型</strong></p>
<p>向上转型以后调用子类的特有的功能就要使用向下转型</p>
<pre><code>转型是出现的问题
左右两边类型不一样，就会出现类型转换异常
可以使用instanceOf进行判断然后再类型转换
</code></pre>
<p><strong>String补充</strong></p>
<pre><code class="Java">String s1 = &quot;10&quot;;
String s2 = &quot;10&quot;;
String s3 = new String(&quot;10&quot;);
System.out.println(s1 == s2);//true
System.out.println(s1 == s3);//false
System.out.println(s2 == s3);//false
</code></pre>
<p>内存的分析</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325194042492.png" alt="image-20240325194042492"></p>
<pre><code class="Java">String a = new String(&quot;abc&quot;);//共有几个对象？ 一个new本身，一个abc
String b = new String(&quot;abc&quot;)//共创建今儿个对象？  如果之前没有创建abc，那么就会创建两个，有的话就只会创建new的对象，把abc之恶共享过来即可
</code></pre>
<p>内存分析</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325194436987.png" alt="image-20240325194436987"></p>
<pre><code class="Java">        String s = &quot;HelloWorld&quot;;
        String s1 = &quot;Hello&quot;;
        String s2 = &quot;World&quot;;
        String s4 = &quot;Hello&quot;+&quot;World&quot;;
        String s5 = s1 + &quot;World&quot;;
        String s6 = &quot;Hello&quot;+s2;
        String s7 = s1+s2;
        System.out.println(s == s4);//true
        System.out.println(s == s5);//false
        System.out.println(s == s6);//false
        System.out.println(s == s7);//false
</code></pre>
<p>为什么会出现上面的问题，直接反编译以后就能知道结果了</p>
<p><strong>String的常用的方法</strong></p>
<p><strong>注意在Java中String不是基本数据类型，而是一个类，</strong></p>
<p><strong>如果我们使用&#x3D;&#x3D;比较，之前说过当&#x3D;&#x3D; 比较引用的数据类型，比较的是地址，所以我们使用equals比较内容，</strong></p>
<pre><code>equals();比较字符串的内容
equalsIgnorecase();忽略大小写的
</code></pre>
<p>或者使用</p>
<pre><code class="Java">        String s2 = &quot;10&quot;;
        String s3 = new String(&quot;10&quot;);
        System.out.println(Objects.equals(s2,s3));//true
</code></pre>
<p>底层的源码，这个可以有效的防止防止空指针</p>
<pre><code class="Java">public static boolean equals(Object a, Object b) &#123;
    return (a == b) || (a != null &amp;&amp; a.equals(b));
&#125;
</code></pre>
<p>比如说</p>
<pre><code class="Java">String s2 = null;
String s3 = new String(&quot;10&quot;);
s2.equals(s3);//这一行就会报错
System.out.println(Objects.equals(s2,s3));
</code></pre>
<p>这样就会报错空指针异常</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325200556819.png" alt="image-20240325200556819"></p>
<pre><code>*length()//
*concat()//拼接返回一个新的字符串
*charAt()//根据索引获取响应的字符
*indexOf(String s);//返回字符串在大字符串第一次出现的位置
*subString(int begin);//从开始索引截到最后
*sunStrin(int begin, int end);//记住左闭右开
</code></pre>
<pre><code>toCharArray();//转为char数组
getBytes();//将字符串转为字节数组
replace(String s1, String s2);//替换
getBytes(String charsetName);//按照编码格式将字符串转为Bytes数组
</code></pre>
<pre><code>split(String regex)//分割
</code></pre>
<pre><code>contains()//
endwiths()
startsWith()
toLowerCase()
toUpperCase()
trim()
</code></pre>
<p><strong>StringBuilder</strong></p>
<ul>
<li>介绍<ul>
<li>一个可变的字符序列，此类提供一个和StringBuffer兼容的APi，但是线程不同步，但是效率高</li>
</ul>
</li>
<li>作用<ul>
<li>拼接字符串</li>
</ul>
</li>
<li>之前的拼接为什不行，为什么用StringBuilder拼接？<ul>
<li>因为之前string的拼接，每拼接一次就会产生一个新的字符串对象，就是上面举的例子,如果拼接过多占用堆的内存</li>
<li>StringBuilder底层自带一个缓冲区（没有被final修饰的bytes数组）拼接字符串以后都会在这个缓冲区保存，在拼接的过程中不会随意产生新对象</li>
</ul>
</li>
</ul>
<pre><code class="java">    String s = &quot;HelloWorld&quot;;
    String s1 = &quot;Hello&quot;;
    String s2 = &quot;World&quot;;
    String s4 = &quot;Hello&quot;+&quot;World&quot;;
    String s5 = s1 + &quot;World&quot;;
    String s6 = &quot;Hello&quot;+s2;
    String s7 = s1+s2;
    System.out.println(s == s4);//true
    System.out.println(s == s5);//false
    System.out.println(s == s6);//false
    System.out.println(s == s7);//false
</code></pre>
<ul>
<li>特点<ul>
<li>自带缓冲区，默认的长度为16，没有final修饰所以是可变的，如果超过16了，数组会自动的扩容，<ul>
<li>创建一个新长度的数组，将老数组的元素复制到新数组的里面，在将新数组的地址值重新赋给老数组</li>
<li>默认每次扩容老数组的2倍+2</li>
<li>如果超过2倍+2的，那么直接创建等大的内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>两种创建方法</p>
<pre><code class="Java">StringBuilder sb  = new StringBuilder();
sb.append(&quot;wei3588559&quot;);

StringBuilder sb2 = new StringBuilder(&quot;wei3588559&quot;);
</code></pre>
<p>append用来拼接字符串，返回一个StringBuilder</p>
<pre><code class="Java">StringBuilder sb2 = new StringBuilder(&quot;wei3588559&quot;);
StringBuilder sb3=sb2.append(&quot;haha&quot;);
System.out.println(sb2);//wei3588559haha
System.out.println(sb3);//wei3588559haha
System.out.println(sb3 == sb2);//true
</code></pre>
<p>我们还可以链式调用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325204030828.png" alt="image-20240325204030828"></p>
<p>reserve(),反转用法和append一样</p>
<p>toString（）：将StringBuilder对象转为String对象，为了可以使用String的方法</p>
<p>判断回文内容</p>
<pre><code class="Java">    public static void main(String[] args)  &#123;
        Scanner input  = new Scanner(System.in);
        String data = input.nextLine();
        StringBuilder str = new StringBuilder(data);
        str.reverse();
        String str2 = str.toString();//将StringBuilder转为String对象
        if (data.equals(str2))&#123;//注意这里的比较一定是字符串的对象，不能呢和是string和stringbuilder的比较，这样内容一样也是false
            System.out.println(&quot;是回文数&quot;);
        &#125; else &#123;
            System.out.println(&quot;不是回文数&quot;);
        &#125;
    &#125;
</code></pre>
<p>补充字符的equals方法</p>
<p>比较的时候一定比较的是字符串</p>
<pre><code class="Java">    public boolean equals(Object anObject) &#123;
        if (this == anObject) &#123;
            return true;
        &#125;
        return (anObject instanceof String aString)
                &amp;&amp; (!COMPACT_STRINGS || this.coder == aString.coder)
                &amp;&amp; StringLatin1.equals(value, aString.value);
    &#125;
</code></pre>
<pre><code>定义一个数组，以[元素1，元素2...],用StringBuilder拼接
</code></pre>
<p>String拼接的效率满，而且拼接一次就会产生一个新的字符串对象</p>
<p>StringBuilder和StringBuffer:</p>
<p>​	1.相同点：拼接的效率比StringBuffer高</p>
<p>​						但是线程不安全</p>
<p>​	2.Stringbuffer：效率比较低，线程安全</p>
<p><strong>Math类</strong></p>
<ul>
<li><p>特点：他的构造方法私有了</p>
<ul>
<li>方法都是静态的直接类名调用就可以</li>
</ul>
</li>
<li><p>数学工具类</p>
<pre><code>Math.abs(-10)//10
static int abs(int a) --&gt;求参数的绝对值
static double ceil(double a) --&gt;向上取整
static double floor(double a) --&gt;向下取整
static long round(double a) --&gt;四舍五入
static int max(int a , int b) --&gt;最大值
static int min(int a , int b) --&gt;最小值
</code></pre>
</li>
</ul>
<p><strong>BigInteger</strong></p>
<pre><code>操作数据的时候，将来的数据很大，大到比long还大，这种称为对象
作用:操作大的数字
BigInteger(String value)
方法
    add(BigInteger value);//加
    subtract(BigInteger value)//减
    multiply(BigInteger value) //×
    divide(BigInteger value)//  除
</code></pre>
<p><strong>BigDecimal</strong></p>
<p>floor的数据直接参加运算会出现精度损失的问题</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326124121160.png" alt="image-20240326124121160"></p>
<pre><code>**BigDecimal**解决精度损失的问题
构造方法
BigDEcimal(Stirng value) --&gt;value一定是数字的字符串
常用的方法
static BigDecimal valueOf(doubt value) --&gt;此方法 初始化小数可以传doule的数据
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326124552341.png" alt="image-20240326124552341"></p>
<p><strong>Date类</strong></p>
<pre><code class="Java">表示时间
        Date time = new Date();
        System.out.println(time);//Tue Mar 26 14:28:03 CST 2024
//有参的，从时间原点开始放
        Date time2 = new Date(10000l);
        System.out.println(time2);//Thu Jan 01 08:00:10 CST 1970
//方法，设置时间
        Date time = new Date();
        time.setTime(10000l);
        System.out.println(time);//Thu Jan 01 08:00:10 CST 1970
</code></pre>
<p><strong>Calendar类</strong></p>
<pre><code class="Java">1.概述:日历类，抽象类
2.获取的calendar里面的方法：
    static Calendar getInstance();
    ---------------------------------------
     Calendar calendar = Calendar.getInstance();
     System.out.println(calendar);
</code></pre>
<pre><code class="java">
        Calendar calendar = Calendar.getInstance();
        int year = calendar.get(Calendar.YEAR);
        System.out.println(year);//2004

        calendar.set(Calendar.YEAR,2008);
        System.out.println(calendar.get(Calendar.YEAR));//2008

     //的
        System.out.println(time1);//Thu Mar 26 14:44:44 CST 2009
</code></pre>
<p><strong>日期格式化类SimpleDateFormat</strong></p>
<pre><code>格式化日期
2.构造
simpleDateFormat(String pattern);//pattern代表模式，注意字母的大小写不要改变，但是中间的连接符是可以改变的
例如
    yyyy--MM--dd HH:mm:ss
</code></pre>
<p>格式的字母表示</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326144906530.png" alt="image-20240326144906530"></p>
<p>使用</p>
<pre><code class="java">        Date time = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        System.out.println(sdf.format(time) );
//sdf.format(time)将Date对象按照符合日期对格式的字符串
        System.out.println(sdf.parse(time2));//Tue Mar 26 14:56:55 CST 2024     parse的作用将格式化以后的转为date对象
注意因为parse方法底层抛了一个异常,所以我们还要往上面抛
</code></pre>
<p><strong>JDK8新日期类</strong></p>
<p><strong>LocalDate本地时间</strong></p>
<pre><code class="Java">        //通过LocalDate.now();创建对象
        LocalDate ld = LocalDate.now();
        System.out.println(ld);//2024-03-26

//自己设置时间
        LocalDate time = LocalDate.of(2000,3,30);
        System.out.println(time);
</code></pre>
<p><strong>LocalDateTime类</strong></p>
<pre><code>和上面的用法一样只不过更加精确
</code></pre>
<pre><code class="java">获取各个字段
        LocalDateTime time = LocalDateTime.now();
        System.out.println(time.getYear());//2024
        System.out.println(time.getMonth());//MARCH
        System.out.println(time.getMonthValue());//3
        System.out.println(time.getDayOfMonth());//

//设置
        LocalDate time2 =LocalDate.EPOCH.withYear(2000);
        System.out.println(time2);//2000-01-01
---------------------------------------------
    设置月份
        LocalDate time2 =LocalDate.EPOCH.withYear(2000);
        LocalDate time3=time2.withMonth(5);
        System.out.println(time3);//2000-05-01
--------------------------------------------------
    //我们可以将上面设置成链式调用
       LocalDate time2 =LocalDate.EPOCH.withYear(2000).withMonth(5);
        System.out.println(time2);//2000-05-01
</code></pre>
<p>每次使用都会返回一个新的LocalDate对象</p>
<pre><code class="Java">偏移量
    //Plus是向日期大的偏移
        LocalDate time2 =LocalDate.EPOCH.withYear(2000).withMonth(5).plusYears(1);
        System.out.println(time2);//2000-05-01
//minus是像日期小的偏移
        LocalDate time2 =LocalDate.EPOCH.withYear(2000).withMonth(5).minusYears(1);
        System.out.println(time2);//1999-05-01
</code></pre>
<p><strong>Period计算日期之间的偏差</strong></p>
<pre><code class="Java">static Period between(LocalDate d1, LocalDate d2)
----------------------------------------------------
        LocalDate d1 = LocalDate.of(2022,12,12);
        LocalDate d2 = LocalDate.of(2022,12,13);
        Period p =Period.between(d1,d2);
        System.out.println(p.getDays());//1
        System.out.println(p.getYears());//0
        System.out.println(p.getMonths());//0
</code></pre>
<p><strong>Duration计算偏差</strong></p>
<p>计算LocalDateTime的偏差</p>
<pre><code>static Duration between(Temporal startInclusive,Temporal endInclusive)//--&gt;计算时间差
Temporal是接口，实现类有LocalDate和LocalDateTime,所以参数可以是
实现对象，注意需要传递LocalDateTime,因为Duration是计算精确时间的

利用duration计算相差
toDays();
toHours();
toMinutes();
toMillis();//毫秒
</code></pre>
<pre><code class="java">        LocalDateTime d1 = LocalDateTime.of(2022,12,12,10,10,10,10);
        LocalDateTime d2 = LocalDateTime.of(2022,12,13,10,10,10,10);
        Duration duration  = Duration.between(d1,d2);
        System.out.println(duration.toDays());//1
        System.out.println(duration.toHours());//24
        System.out.println(duration.toMillis());//86400000
        System.out.println(duration.toMinutes());//1440
</code></pre>
<p><strong>注意这个计算不是直接减，而是根据时间</strong></p>
<p><strong>DateTimeFormatter日期格式化类</strong></p>
<pre><code>static DateTimeFormatter ofPattern (String pattern)--&gt;获取对象
方法：
String format(TemporalAccessor temporal)-&gt;将日期规则按照指定规则转为字符产
TemporalAccessor parse(CharSequence text) --&gt;和上面的相反


TemporalAccessor是一个接口子接口有Temporal，之前说过他的实现类有LocalDate和LocalDateTime,，所以可以传他们
CharSequence是string接口
</code></pre>
<p>使用</p>
<pre><code class="Java">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
LocalDateTime time = LocalDateTime.now();
System.out.println(time);
System.out.println(dtf.format(time));//2024-03-26 15:59:11

如果想将TemporalAccessor转为我们常见的LocalDateTime日期对象，就需要用到LocalDateTime里面的静态方法
    static LocalDateTime from (TemporalAccessor temporal)
    
    //所以把日期的字符串转为localdatetime
        TemporalAccessor temporalAccessor = dtf.parse(dtf.format(time));
        LocalDateTime localDateTime = LocalDateTime.from(temporalAccessor);
        System.out.println(localDateTime);
    
    
</code></pre>
<p><strong>System工具类</strong></p>
<pre><code>系统相关类
特点
    构造私有，不能使用构造方法new对象
    方法都是静态的
使用
    static long currentTimeMillis()//返回毫秒为单位的当前时间
        long i= System.currentTimeMillis();
        System.out.println(i);//1711452549818
    static void exit(int status)//终止当前的虚拟机
        System.exit(0);
    static void arraycopy(object src ,int srcPos , Object dest ,int desPos,int length) //数组的复制 
    src:原数组
    srcPos:从原数组的哪个索引开始复制
    dest:目标数组
    destPos:从目标数组的哪个位置开始粘贴
    length:复制的长度
    
</code></pre>
<pre><code class="java">       int[] arr = &#123;1,2,3,4,5,6&#125;;
        int[] arr2 = new int[10];
        System.arraycopy(arr,0,arr2,0,5);
        for (int i = 0; i &lt; arr2.length; i++) &#123;
            System.out.println(arr2[i]);
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326193738250.png" alt="image-20240326193738250"></p>
<p>有一个快捷键，这样快速生成遍历数组的方法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326193809404.png" alt="image-20240326193809404"></p>
<p><strong>Arrays数组工具类</strong></p>
<p><strong>记住，没有重写的数组的toString，打印数组是数组的地址值，所以需要toString的方法，和对象一样，使用对象 的toString的方法，只会打印对象的地址值，只有在对象的里面重写toString才可以</strong></p>
<pre><code>构造私有，方法静态
使用：类名直接调用
    static String toString(int[] a)//按照格式打印数组元素
    static int binarySearch(int[] a, int key) //二分查找
    static void sort(int[] a)//升序排列
    static int[] copyOf(int[] orginal ,int newLength)//数组的扩容
</code></pre>
<pre><code class="Java">        int[] a = &#123;1,2,3,4,5&#125;;
        System.out.println(Arrays.toString(a));//[1, 2, 3, 4, 5]
        int[] b = &#123;1,2,5,3,21,1&#125;;
        Arrays.sort(b);
        System.out.println(Arrays.toString(b));//[1, 1, 2, 3, 5, 21]

//二分查找前提是升序，传过去的一定是升序玩的数组
        int[] b = &#123;1,2,5,3,21,1&#125;;
        Arrays.sort(b);
        System.out.println(Arrays.binarySearch(b,2));//2
//数组的扩容
        int[] b = &#123;1,2,5,3,21,1&#125;;
        int[] c = Arrays.copyOf(b,10);
        System.out.println(Arrays.toString(c));//[1, 2, 5, 3, 21, 1, 0, 0, 0, 0]
</code></pre>
<p>**包装类	**</p>
<pre><code>就是基本数据类型对应的类（包装类），我们需要将基本数据类型转为包装类，从而让基本的数据类型拥有类的特性
为什么要学包装类？
    特点的场景。比如要调用方法传递包装类
    包装类转为基本数据类型，因为包装类不能使用+ - 等
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326195728471.png" alt="image-20240326195728471"></p>
<p>比如</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326200154630.png" alt="image-20240326200154630"></p>
<p>这里面需要Integer的类，就需要包装</p>
<p>但是我们传递一个基本数据类型，没有报错为什么？</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326200255602.png" alt="image-20240326200255602"></p>
<p><strong>因为这部操作虚拟机会帮你自动类型转换，转为Integer类</strong></p>
<p><strong>Interger包装类</strong></p>
<pre><code>概述：Interger是int的包装类
使用:构造方法：
Interger(int value);
Interger(String value)
例如
        Integer i = new Integer(1);
        Integer j = new Integer(&quot;10&quot;);
        System.out.println(i);//1
        System.out.println(j);//10
</code></pre>
<p>上面过时了</p>
<pre><code>1.装箱：将基本数据类型转为包装类
2.方法:Integer里的方法
static Integer valueOf(int i)
static Integer valueOf(String s)
这些操作叫做装箱
拆箱：将包装类转为基本的数据类型
 方法
 int intValue()
         Integer i = new Integer(1);
         int k = i.intValue();
</code></pre>
<ul>
<li>拆箱和装箱很多时候都是自动完成的</li>
<li><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326202631150.png" alt="image-20240326202631150"></li>
</ul>
<p>这一步就是在自动装箱</p>
<p>反编译就可以看出来</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326202824007.png" alt="image-20240326202824007"></p>
<p>提问</p>
<pre><code class="Java">        Integer i = 100;//自动装箱
        Integer j  =100;
        System.out.println(i == j);//比较的是地址 //true

        Integer k  =128;
        Integer l = 128;
        System.out.println(k == l);//false
</code></pre>
<p>这是为什么？	</p>
<p>底层的源码</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326203411680.png" alt="image-20240326203411680"></p>
<pre><code>100在这个范围以内，所以直接返回这个数组里面的数据，所以i和j同时指向数组里面的同一个元素
但是128不在这个范围以内，所以直接新建一个新的对象，所以两个k和l不是同一个对象，这个范围是在-128到127数组里面装着-128到127Integer对象
</code></pre>
<p><strong>基本数据类型往String转</strong></p>
<pre><code>1.拼接
    int a  = 1;
    String b = a + &#39;&#39;;	 
2.String的静态方法
static String valueOf(int i)
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326204541033.png" alt="image-20240326204541033"></p>
<ul>
<li>在实际开发中如何定义一个标准的Javabean</li>
</ul>
<pre><code>定义javabean的时候一般会将基本的数据类型变成包装类的类型
</code></pre>
<p>​	比如</p>
<pre><code class="java">public class User &#123;
    private Integer uid;
    private String name;
    private String password;
    public User(Integer uid, String name, String password) &#123;
        this.uid = uid;
        this.name = name;
        this.password = password;
    &#125;

    public User(String password) &#123;
        this.password = password;
    &#125;

    public User(Integer uid) &#123;
        this.uid = uid;
    &#125;
&#125;
</code></pre>
<pre><code>1.如果uid为Integer型(因为是对象没有值是null)，默认值为null
2.将来javabean中的数据和数据库联系起来，我们可以将javabean中数据添加到表中，如果uid为主键自增此时的sql语句不用我们单独维护赋值，添加sql语句就可以这样写；
insert into user(uid,username,password) values (null,&#39;1&#39;,&#39;1&#39;)
3.到时候，我们需要将javabean中封装的数据放在sql语句里面，uid能够自增，而且javabean为包装类型，默认值为null，这样不用单独维护uid的值，也不用给javabean中赋值，然后保存在数据库里面，咱们就可以使用uid的默认值
</code></pre>
<p><strong>多线程</strong></p>
<p>基础知识</p>
<pre><code>进程:在内存中执行的应用程序
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326212838603.png" alt="image-20240326212838603"></p>
<p>这里一个一个都是进程</p>
<pre><code>线程:进程中最小的执行单元
线程的作用:负责进程程序的运行
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326213347771.png" alt="image-20240326213347771"></p>
<p>使用场景，耗时操作就需要多线程</p>
<p>  我们同时同时就可以多件事，这样的话提高了cpu的利用率 </p>
<p><strong>并发和并行</strong></p>
<pre><code>并行:在同一时刻，有多个执行在多个Cpu上同时运行
比如:多个厨师在同时炒多个菜
</code></pre>
<pre><code>并发:在同一时刻，有多个指令在单个Cpu上交替找执行
比如：一个厨师在同时超多个菜
</code></pre>
<p>就是之前说过的同步和异步的概念</p>
<pre><code>细节：
1.之前的cpu是单核，但是在执行多个程序好像是在同时执行，原因是CPU在多个线程之间做高速切换，比如2和4线程，那么CPU可以同时运行4个线程，此时不用切换，但是如果超过了，cPU就要切换了，cpu执行程序的时候，既有并发既有并行
</code></pre>
<p>CPU<strong>的调度</strong></p>
<pre><code>分时调度:是让所有的线程轮流CPU使用权，并且平均分配每个线程占用CPU的时间片
抢占调度:多个线程轮流抢占CPU的使用权，哪个线程抢到了，哪个线程先执行，优先级高的纪律比较大，
</code></pre>
<p>我们JAVA就是抢占式调度</p>
<p><strong>主线程</strong></p>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 哈哈哈哈哈哈哈重生之我是兵王
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;chenw
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
