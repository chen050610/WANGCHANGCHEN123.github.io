
<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8" />
    <title>Java | 哈哈哈哈哈哈哈重生之我是兵王</title>
    <meta name="author" content="chenw" />
    <meta name="description" content="description" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
	<canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
	<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
	<script src="/js/fireworks.min.js"></script>
	<canvas id="background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
	<script src="/js/background.min.js"></script>
	<div id="cursor"></div>
	<link rel="stylesheet" href="/css/cursor.min.css">
	<script src="/js/cursor.min.js"></script>
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>哈哈哈哈哈哈哈重生之我是兵王</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;哈哈哈哈哈哈哈重生之我是兵王</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>Java</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/22
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <p>摘要</p>
<span id="more"></span>

<p>内容</p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>跨平台是java语言的趋势</p>
<p>java还是主流的编程语言</p>
<p>Java的各个版本</p>
<p>1.JavaSE：标准版，定位在个人计算机的应用，</p>
<p>2.JavaEE:企业版，定位在服务器</p>
<p>3.JavaME：微型版</p>
<p><strong>Java的运行机制</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322205212089.png" alt="image-20240322205212089"></p>
<p>Java既是编译型语言，又是解释性</p>
<p>例如 python就是解释性语言，直接通过python的解释器直接去运行</p>
<p><strong>什么是JVM？</strong></p>
<p>用于执行字节码虚拟计算机，跨平台的差异就是通过JVM</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322205502948.png" alt="image-20240322205502948"></p>
<p>java提供不同平台的虚拟机</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322205534797.png" alt="image-20240322205534797"></p>
<p><strong>开发人员我们一般使用JDK，因为我们需要编译和运行</strong></p>
<p><strong>一般java的游戏，就直接运行，只下载JRE就可以了</strong></p>
<p>创建的Java项目写在</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322213121539.png" alt="image-20240322213121539"></p>
<p>简单的Java代码</p>
<pre><code class="Java">public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
    &#125;
&#125;
</code></pre>
<p>在运行的时候，会自动帮你进行编译</p>
<p><strong>生成的java的编译的以后的文件在</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322213530098.png" alt="image-20240322213530098"></p>
<p>Java的基础语法</p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li><p>主函数 &amp;  程序的入口</p>
</li>
<li><p>文件名</p>
<pre><code>一个文件中只能有一个public的类，并且文件名必须和public的类名保持一致
如果文件中有多个类，文件名与public的类名保持一致
如果文件中有多个类 且无public类，文件名抗日一是任意的类
</code></pre>
</li>
<li><p>类名 首字母大写，驼峰的命名</p>
</li>
<li><p>类修饰符  public,default</p>
</li>
<li><p>类中的成员修饰符：public,private,protected,default</p>
</li>
<li><p>静态成员：无需实例化就可以直接调用</p>
<pre><code class="java">class Person  &#123;
    public static void  f1()&#123;
        //static静态的方法，无需实例就可以调用，也就只可以类调用
        System.out.println(&quot;111&quot;);
    &#125;
&#125;

public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
        Person.f1();//111
    &#125;
&#125;
</code></pre>
<ul>
<li><p>实例方法：需要实例以后在调用</p>
<pre><code class="java">class Person  &#123;
    public  void  f1()&#123;
        System.out.println(&quot;111&quot;);
    &#125;
&#125;

public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
        Person person = new Person();//实例对象的写法是这样的
        person.f1();//对象调用
    &#125;
&#125; 
</code></pre>
</li>
</ul>
</li>
<li><p>void代表方法没有返回值</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
        Person person = new Person();//实例对象的写法是这样的
        person.f1();//对象调用
    &#125;
</code></pre>
</li>
<li><p>参数,需要限制类型</p>
<pre><code>class Person  &#123;
    public  void  f1(string a , int b)&#123;
        System.out.println(&quot;111&quot;);
    &#125;
&#125;

public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
        Person person = new Person();//实例对象的写法是这样的
        person.f1(&#39;aaaa&#39;,123);//对象调用
    &#125;
&#125; 
</code></pre>
<p><strong>注释</strong></p>
<pre><code>//单行注释
/*
多行注释
*/
</code></pre>
</li>
</ul>
<p><strong>变量和常量</strong></p>
<pre><code>final相当于js里的const
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
    System.out.println(&quot;你好&quot;);
    String name = &quot;name&quot;;
    int number = 5;
    int a ;
    a= 18;
    //常量
    final int size = 18;
&#125;
</code></pre>
<p>不像js的动态语言，我们需要对数据的类型做出限制</p>
<p><strong>输入和输出</strong></p>
<p>输入需要外部的包，</p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        //引入的Scanner相当于一个类，System.in感觉时使用系统命令获取输入
        Scanner input  = new Scanner(System.in);
        String text  =  input.nextLine();
        //输出
        System.out.println(text);
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322220405957.png" alt="image-20240322220405957"></p>
<p>输出语句的不同</p>
<pre><code class="java">        //输出
        System.out.println(text);//输出最后会带换行
        System.out.print(text);//输出最后不带换行
</code></pre>
<p><strong>条件语句</strong></p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.print(&quot;&quot;);
        int age  = 19 ;
        if (age &lt; 18)&#123;
            System.out.println(&quot;少年&quot;);
        &#125; else if (age&gt;= 18 &amp;&amp; age &lt; 24)&#123;
            System.out.println(&quot;青年&quot;);
        &#125; else &#123;
            System.out.println(&quot;老年&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>switch case语句</strong></p>
<pre><code class="java">        System.out.print(&quot;&quot;);
        int age  = 19 ;
        switch (age)&#123;
            case 19:
                System.out.println(&quot;1111&quot;);
                break;
        &#125;
</code></pre>
<p><strong>循环语句</strong></p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        int count = 0 ;
        while (count &lt; 3)&#123;
            System.out.println(count);
            count++;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>do while循环</strong></p>
<p>至少执行一次</p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        int count = 0 ;
        do &#123;
            System.out.println(count);
            count++;
        &#125; while (count &lt; 3);
    &#125;
&#125;
</code></pre>
<p><strong>For循环</strong></p>
<pre><code class="java">        int count = 0 ;
        for (int i = 0 ; i &lt; 3 ; i++)&#123;
            System.out.println(i);
        &#125;
</code></pre>
<p><strong>数据类型</strong></p>
<p><strong>整数类型</strong></p>
<pre><code>byte 1个字节
short 2个字节
int 4个字节
long 8个字节
</code></pre>
<p>强制类型转化，大的类型往小的范围可能就会出错</p>
<pre><code class="java">byte i = 32 ; 
int a = (int) i;
</code></pre>
<p><strong>字符</strong></p>
<p>字符串的方法</p>
<pre><code class="java">        char  a = &#39;x&#39;;
        char  b = &#39;y&#39;;//字符只能用单引号
        String c = &quot;hahahaha&quot; ;

        String d = new String(&quot;王昌晨&quot;);

        char[] f = &#123;&#39;w&#39;,&#39;c&#39;,&#39;g&#39;&#125;;
        System.out.println(f);
</code></pre>
<pre><code class="java">        String name = &quot;wangchangchen&quot;;
        int count = name.length();//获取字符的长度
        for (int i = 0; i &lt; count; i++) &#123;
            char item = name.charAt(i);//获取当前位置的字符
        &#125;
        String a = name.trim();//去掉空白
        String[] b= name.split(&quot;c&quot;);//分割，返回的是数组
        String c= name.replace(&quot;w&quot;,&quot;d&quot;);//代换
        String d = name.substring(2,5);//切片
        boolean f = name.equals(&quot;wangchangchen&quot;);//进行字符串的比较
        boolean g = name.contains(&quot;ang&quot;);//数组中是否包含
        String k = name.concat(&quot;ahhah&quot;);//在后面进行拼接
</code></pre>
<p><strong>数组</strong></p>
<pre><code class="java">        int[] arr =new int[3];//定义三个数字的数组
        arr[0]=123;
        arr[1]=234;
        arr[2]=456;
        System.out.println(Arrays.toString(arr));


        String[] arr2 =new String[]&#123;&quot;hahah&quot;,&quot;hahah&quot;,&quot;ahah&quot;&#125;;
        System.out.println(Arrays.toString(arr2));

        String[] arr3 = &#123;&quot;haah&quot;,&quot;agaga&quot;,&quot;haha&quot;&#125;;
        System.out.println(Arrays.toString(arr3));

        for (int i = 0; i &lt; arr3.length; i++) &#123;
            System.out.println(arr3[i]);
        &#125;
</code></pre>
<p>注意：<strong>数组里面的个数一旦确定，不可以更改，类似于python里面的元组</strong></p>
<p><strong>对象</strong></p>
<ul>
<li><p>Java中所有的类也是默认继承基类Object这个类的，所以用基类可以反之子类的类型，下面这样写是不会报错的，因为String的类继承了Object的类</p>
<pre><code class="java">        String a = &quot;haha&quot;;
        Object b = &quot;haha&quot;;
        Object c = new String(&quot;haaha&quot;);
</code></pre>
<p>所以我们就可以常见任意类型的数组，所以要以后声明的数组是混合类型的就可以这样写</p>
<pre><code class="java">        Object[] arr = new Object[]&#123;&quot;java&quot;,11111,2222,&quot;lkcd&quot;&#125;;
        System.out.println(Arrays.toString(arr));//[java, 11111, 2222, lkcd]
</code></pre>
</li>
</ul>
<p>Object类型的字符串</p>
<pre><code class="java">        String v1 = new String(&quot;hahaha&quot;);
        v1.toUpperCase();
        System.out.println(v1);

        Object v2  = &quot;hahaha&quot;;
//只有强制类型转换以后才可以使用字符串的方法
        String data = (String)v2;
        data.toUpperCase()
</code></pre>
<p>传参的参数的类型未知，我们就可以这样写</p>
<pre><code class="java">    public static void func(Object a) &#123;
        System.out.println(a);
        if (a instanceof String) System.out.printf(&quot;String&quot;);
        if (a instanceof Integer) System.out.println(&quot;int&quot;);
    &#125;

    public static void main(String[] args) &#123;
        String v1 = new String(&quot;hahaha&quot;);
        v1.toUpperCase();
        System.out.println(v1);

        Object v2  = &quot;hahaha&quot;;
        String data = (String)v2;
        data.toUpperCase();
        func(&quot;hahahha&quot;);
    &#125;
</code></pre>
<ul>
<li>Java这种所有的类都继承Object，Object代指所有的类型</li>
</ul>
<p><strong>List系列</strong></p>
<ul>
<li>在Java中List不属于一种类型，在Java中List<strong>是一个接口</strong>，接口下面有两个常见的类型 （目的就是存放的动态的数据，可以添加删除）</li>
<li>ArrayList，（连续的内存地址的存储，里面放着的是内存地址而且内部还会自动扩容,可以添加，当超过的容量，创建新的内存地址，然后在保存）。</li>
<li>LinkedLink：（基于链表实现的，链表存储的）</li>
</ul>
<pre><code class="java">        ArrayList arr = new ArrayList();
        arr.add(&quot;hahaha&quot;);
        System.out.println(arr.getClass());//class java.util.ArrayLis
        System.out.println(arr);//[hahaha]
</code></pre>
<pre><code class="java">        LinkedList arr = new LinkedList();
        arr.add(&quot;hahaha&quot;);
        System.out.println(arr.getClass());//class java.util.LinkedList
        System.out.println(arr);//[hahaha]
</code></pre>
<p>用起来都是一样的，就是存储的方式不同,刚才提到list是一个接口，接口下面有如上的数据类型</p>
<ul>
<li><p>接口:使用来约束实现他的类，约束它里面的成员必须有什么，定义有点像TS</p>
<pre><code class="java">interface List&#123;
    public void add(Object)//不写具体的实现
&#125;
//这个类实现接口List，此时这里必须有add的方法
class ArrayList implements  List &#123;
   public void add(Object data)&#123;
       //实现添加数据的代码
   &#125;
&#125;
</code></pre>
<pre><code class="java">**我们用接口名称代指实现接口的类也是可以的**       
        List arr = new LinkedList();
        arr.add(&quot;hahaha&quot;);
        System.out.println(arr.getClass());//class java.util.LinkedList
        System.out.println(arr);//[hahaha]
</code></pre>
<p>创建的时候指定类型</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        List&lt;String&gt; arr = new LinkedList&lt;String&gt;();
        arr.add(&quot;hahaha&quot;);
        arr.add(1111);//这一行报错
        System.out.println(arr.getClass());//class java.util.LinkedList
        System.out.println(arr);//[hahaha]
    &#125;
</code></pre>
<p><strong>默认的是Object，里面的类型可以混着</strong></p>
</li>
<li><p>获取列表的方法和属性</p>
<pre><code class="Java">    public static void main(String[] args) &#123;
        List&lt;String&gt; arr = new LinkedList&lt;String&gt;();
        arr.add(&quot;hahaha&quot;);
        System.out.println(arr.getClass());//class java.util.LinkedList
        System.out.println(arr);//[hahaha]
        System.out.println(arr.get(0));//获取列表里的值

        arr.set(0,&quot;123&quot;);
        System.out.println(arr);//[123]

        arr.add(&quot;456&quot;);
        arr.remove(&quot;123&quot;);
        System.out.println(arr);//[456]
        arr.remove(0);
        System.out.println(arr);//[]

        System.out.println(arr.size());//0

        arr.add(&quot;2112&quot;);
        System.out.println(arr.contains(&quot;2112&quot;));//true

        arr.add(&quot;9999&quot;);
        for (Object item : arr)&#123;
            System.out.println(item);//2112,9999
        &#125;

        for (int i = 0; i &lt; arr.size(); i++) &#123;
            Object item = arr.get(i);
            System.out.println(item);//2112,9999
        &#125;

    &#125;
</code></pre>
</li>
<li><p>通过迭代器进行遍历</p>
<pre><code class="java">        List&lt;Object&gt; arr = new LinkedList&lt;&gt;(Arrays.asList(&quot;123&quot;,&quot;456&quot;,&quot;789&quot;));//快速创建一个，就不用一个一个添加了
        Iterator it = arr.iterator();
        while (it.hasNext())&#123;
            System.out.println(it.hasNext()); //判断指向当前的数据是否为空
            Object item = it.next();
            System.out.println(item); //获取当前指向的数据
        &#125;
</code></pre>
</li>
</ul>
<p><strong>Set系列</strong></p>
<p>主要还是去重</p>
<p>Set还是一个接口，常见的实现这两个接口有两个类，用于实现不重复多元素的集合</p>
<ul>
<li>HashSet ，去重，无序，</li>
<li>TreeSet，去重，内部会默认的排序（ascii,uncode）,不同类型的不能比较</li>
</ul>
<pre><code class="java">        HashSet s  = new HashSet&lt;&gt;();
        s.add(&quot;111&quot;);
        s.add(&quot;111&quot;);
        s.add(&quot;2222&quot;);
        System.out.println(s);//[111, 2222]
</code></pre>
<p>简单的创建，<strong>注意这里的add外层包裹的是双括号</strong></p>
<pre><code class="java">        HashSet a = new HashSet()&#123;
            &#123;
                add(&quot;1111&quot;);
                add(&quot;222&quot;);
            &#125;;
        &#125;;
        System.out.println(a);//[222, 1111]
</code></pre>
<p>通过集合我们就可以实现交并差，使用的方法和列表的实现差不多</p>
<pre><code class="java">        Set a = new HashSet&lt;&gt;()&#123;&#123;
            add("java");
            add("666");
            add("B站");
        &#125;&#125;;
        Set b = new HashSet() &#123;&#123;
             add("B站");
             add("A站");
             add("C站");&#125;&#125;;
        Set c = new HashSet();
        c.addAll(a);//向空的集合添加，或者取并集
        System.out.println(c);//[java, 666, B站]

        //交集
        c.retainAll(b);//交集,这个返回值是布尔
        System.out.println(c);;//[B站]

        //并集
        c.addAll(a);
        System.out.println(a);//[java, 666, B站]

        //差集
        c.removeAll(a); //c-a
        System.out.println(c);//[]

        //差集
        b.removeAll(a); //b-a
        System.out.println(b);//[C站, A站]

        //循环
        for (Object item : a)&#123;
            System.out.println(item);//java     666       B站
        &#125;

        Iterator it = a.iterator();
        while(it.hasNext())&#123;
            System.out.println(it.next());//java  666   B站
        &#125;
</code></pre>
<p><strong>Map系列</strong></p>
<p>Map是一个接口，常见实现这个接口有两个类，用于存储键值对</p>
<ul>
<li>HashMap : 无序；</li>
<li>Treepmap: 有序，根据key进行排序</li>
</ul>
<pre><code class="java">用法和之前的set和list的差不多
        Map a = new HashMap&lt;&gt;();
        a.put(&quot;name&quot; , &quot;demo&quot;);
        a.put(&quot;age&quot; , &quot;18&quot;);
        System.out.println(a);//&#123;name=demo, age=18&#125;


        Map&lt;String,String&gt; b = new HashMap&lt;String,String&gt;();
        b.put(&quot;name&quot; , &quot;demo&quot;);
        b.put(&quot;age&quot; , &quot;18&quot;);
        System.out.println(b);//&#123;name=demo, age=18&#125;


        //可以向setu快速的创建
        HashMap c = new HashMap&lt;&gt;()&#123;
            &#123;
                put(&quot;name&quot;,&quot;wang&quot;);
                put(&quot;age&quot;,&quot;18&quot;);
            &#125;
        &#125;;
        System.out.println(c);
</code></pre>
<pre><code class="java">        Map a = new HashMap&lt;&gt;();
        a.put(&quot;name&quot; , &quot;demo&quot;);
        a.put(&quot;age&quot; , &quot;18&quot;);
        System.out.println(a);//&#123;name=demo, age=18&#125;


        Map&lt;String,String&gt; b = new HashMap&lt;String,String&gt;();
        b.put(&quot;name&quot; , &quot;demo&quot;);
        b.put(&quot;age&quot; , &quot;18&quot;);
        System.out.println(b);//&#123;name=demo, age=18&#125;


        //可以向setu快速的创建
        HashMap c = new HashMap&lt;&gt;()&#123;
            &#123;
                put(&quot;name&quot;,&quot;wang&quot;);
                put(&quot;age&quot;,&quot;18&quot;);
            &#125;
        &#125;;
        System.out.println(c);

        System.out.println(c.size());

        System.out.println(c.get(&quot;name&quot;));

        c.replace(&quot;name&quot;,&quot;chen&quot;);
        System.out.println(c);

        //没有迭代器，但是可以通过下面这个样子实现
        Set&lt;Map.Entry&lt;String,String&gt;&gt; d = c.entrySet();
        System.out.println(d);//[&quot;name=chen&quot;, &quot;age=18&quot;]
        Iterator it = d.iterator();
        while (it.hasNext())&#123;
             Map.Entry&lt;String,String&gt; e = (Map.Entry&lt;String, String&gt;)it.next();//在转为map
            System.out.println(e);//name=chen   age=18
            String k = e.getKey();//获取键名
            String l = e.getValue();//获取值
        &#125;

        //简单的写法
        Set r = b.entrySet();
        Iterator it2 = r.iterator();
        while (it2.hasNext())&#123;
            Map.Entry o = (Map.Entry)it2.next();
            System.out.println(o);
        &#125;
</code></pre>
<p>Map的EntrySet方法会获得实体，转为Set就可以使用迭代器</p>
<p><strong>类和面向对象</strong></p>
<ul>
<li>基本使用</li>
</ul>
<pre><code class="java">class Person &#123;
    public String name;
    public Integer age;
    //构造方法
    public Person()&#123;
        this.name = &quot;chen&quot;;
        this.age = 18 ;
    &#125;
    //一个类中可以有多个构造方法，但是保证参数的不同的才可以
    public Person(String name)&#123;
        this.name = name;
        this.age = 18 ;
    &#125;
    public Person(String name , int age)&#123;
        this.name = name;
        this.age = age ;
    &#125;

    //方法的重载
    public void doSomething ()&#123;
        System.out.println(&quot;做一些事情&quot;);
    &#125;
    public void doSomething(String what)&#123;
        System.out.println(what);
    &#125;
    public void doSomething(String what , int age)&#123;
        System.out.println(age);
        System.out.println(this.name);
    &#125;
&#125;
</code></pre>
<ul>
<li><p>静态成员</p>
<pre><code class="java">class Person &#123;
    //静态变量,只能通过类的方法进行访问
    public static String content = &quot;爱笑&quot;;

    //静态方法
    public static void func()&#123;
        System.out.println(&quot;你好&quot;);
    &#125;
&#125;   
</code></pre>
</li>
</ul>
<p><strong>本质上静态的属于类，非静态的属于实例</strong></p>
<ul>
<li><p>继承， Java只能支持单继承，之前的pyhton和Js都是支持多继承的，Java的一个类只能继承一个父类</p>
<pre><code class="java">import java.lang.reflect.Array;
import java.util.*;

class Person &#123;
    public String name;
    public Integer age;
    public Person(String name , int age)&#123;
        this.name = name;
        this.age = age ;
    &#125;
&#125;
class Cool extends Person &#123;
    public String email;
    public  Cool(String name, int age ,String email)&#123;
        super(name, age);//使用父类的构造方法
        this.email = email;
    &#125;
&#125;
public class Hello &#123;
    public static void main(String[] args) &#123;
        Cool man = new Cool(&quot;wang&quot;,188,&quot;344455&quot;);
        System.out.println(man.email);//34455
        System.out.println(man.name);//wang
        System.out.println(man.age);//188
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>接口</strong></p>
<p>作用</p>
<ul>
<li>约束：实现他的类</li>
<li>泛指实现他的类</li>
</ul>
<pre><code class="Java">//实现其他的类
interface IMessage &#123;
    public void send();
&#125;

class WeChat implements IMessage&#123;
    public void send()&#123;
        System.out.println(&quot;发送&quot;);
    &#125;;
&#125;
</code></pre>
<pre><code class="java">//实现泛指其他的类，调用函数func，参数的类型设置类实现的接口，这样就可以传实现接口的类
interface IMessage &#123;
    public void send();
&#125;

class WeChat implements IMessage&#123;
    public void send()&#123;
        System.out.println(&quot;发送微信&quot;);
    &#125;;
&#125;

class  DingDing implements IMessage&#123;
    public void send()&#123;
        System.out.println(&quot;发送钉钉&quot;);
    &#125;;
&#125;


public class chen1 &#123;
    public static void func(IMessage a)&#123;
        a.send();
    &#125;
    public static void main(String[] args) &#123;
        WeChat a = new WeChat();
        func(a);
    &#125;
&#125;
</code></pre>
<p><strong>注意</strong></p>
<p><strong>Java中不支持多继承，但是可以支持多接口</strong></p>
<p><strong>抽象</strong></p>
<p><strong>抽象类，既能实现接口又能实现继承</strong></p>
<pre><code class="Java">abstract class Person1 &#123;
    //继承的子类必须有实现这个函数
    public abstract void func(String name);
    //子类也能继承这个方法
    public void func2()&#123;
        System.out.println(22222);
    &#125;
&#125;
class Hututu extends Person1 &#123;
    public void func(String name)&#123;
        System.out.println(name);
    &#125;
&#125;


public class chen1 &#123;
    public static void main(String[] args) &#123;
        Hututu hututu  = new Hututu();
        hututu.func(&quot;hututu&quot;);//hututu
        hututu.func2();//22222
    &#125;
&#125;
</code></pre>
<p><strong>包的概念</strong></p>
<p>新建包的文件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323165138897.png" alt="image-20240323165138897"></p>
<p>代码</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323165157520.png" alt="image-20240323165157520"></p>
<p>再在其他的地方导入</p>
<pre><code class="java">import java.lang.reflect.Array;
import java.util.*;
import utils.Helper;//导入包
public class Hello &#123;
    public static void main(String[] args) &#123;
        //调用包的里面的类的静态方法
        System.out.println(Helper.func());//hahahaha
    &#125;
&#125;
</code></pre>
<p><strong>包中类的修饰符</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323165801124.png" alt="image-20240323165801124"></p>
<ul>
<li><p>public，公共（任意人能调用包中的）</p>
</li>
<li><p>default，只能在当前包中调用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323170034173.png" alt="image-20240323170034173"></p>
</li>
</ul>
<p>这个只能在同一个包中调用，</p>
<p><strong>类修饰符</strong></p>
<p>之前学过</p>
<ul>
<li>public，所有都可以访问</li>
<li>private，只能在当前的类中访问</li>
<li>protected，只有在当前的类和当前的类的子类可以调用</li>
</ul>
<h2 id="基础的补充"><a href="#基础的补充" class="headerlink" title="基础的补充"></a>基础的补充</h2><p><strong>递归</strong></p>
<p>例子计算阶乘</p>
<ul>
<li><p>定义递归头 什么时候不调用自身的方法</p>
</li>
<li><p>递归体：什么时候调用自身的方法</p>
<pre><code class="Java">public class Helper &#123;
    public static long func(int n)&#123;
        if (n == 1)&#123;
            return 1;
        &#125; else &#123;
            return n * func(n - 1);
        &#125;
    &#125;;
    public static void main(String[] args) &#123;
        System.out.println(func(3));
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>内存分析</strong></p>
<p>栈主要放的是main方法的代码，堆里面放着的是类，里面有类的属性，方法保存在方法区</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323203251941.png" alt="image-20240323203251941"></p>
<p><strong>注意一点，实例对象的时候没有构造函数。默认的赋值是0和null，属性值的显性初始化‘，就是在类里面不通过构造器，而是通过 a &#x3D; 11,这样初始化</strong></p>
<p><strong>构造器</strong></p>
<ul>
<li>构造器通过new关键字调用</li>
<li>构造器虽然有返回值，但是在定义的构造器的时候不能定义构造器的返回类型，不能return在构造里面使用</li>
<li>构造器的名称和类名保持一致</li>
<li>如果没有构造器，会默认的定义一个无参的构造方法</li>
</ul>
<p>Java<strong>虚拟机内存分析</strong></p>
<p>虚拟机栈的特点</p>
<p><strong>每一个方法调用都会创建一个栈帧，虚拟机为每一个线程创建一个栈，栈属于线程的私有，不能实现线程的共享，栈的特点是先进后出，后进先出</strong></p>
<p><strong>堆的特点</strong></p>
<ul>
<li><p>用于存储创好的对象和数组</p>
</li>
<li><p>只有一个堆，被所有的线程共享</p>
</li>
<li><p>栈是一个不连续的内存共享</p>
</li>
<li><p>堆被所有的线程所共享 ，堆会被分为年生带和老年代，用于垃圾的回收</p>
</li>
</ul>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323203251941.png" alt="image-20240323203251941"></p>
<p><strong>垃圾回收的算法</strong></p>
<ul>
<li>引用计数法：堆中的每个对象都对应一个引用计数器，当引用指向这个对象，引用加一，当为0 的时候java进行回收，缺点就是循环引用就会导致清空不了</li>
</ul>
<p>例子，这样的引入的值一直不为0这样就不会清楚<img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323210136655.png" alt="image-20240323210136655"></p>
<ul>
<li>引用可达法：程序把所有的引用关系看做一张图，从一个节点的Gc Root开始，寻找引用的节点以后，继续寻找这个节点的引用节点吗，当所有的节点寻找完毕以后，剩余的节点则被认为是没有被引用的节点</li>
</ul>
<p><strong>通用的分代垃圾回收机制</strong></p>
<p>永久代就是我刚在的方法区，存放一些常量什么的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323211008599.png" alt="image-20240323211008599"></p>
<p>this<strong>的关键字</strong></p>
<ul>
<li>普通方法，this总是指向调用该方法的对象</li>
<li>构造方法，this指向正要初始化的对象</li>
<li>this（）调用重载的构造方法，避免相同的初始化代码，但只能在构造方法里面使用，并且必须位于构造方法的第一位</li>
<li>this不能用于静态方法（其实向上面的图，static放在方法去里面，只能方法区里面去引入堆里面的东西，显然是不行的）</li>
</ul>
<pre><code class="java">package utils;
class Person1 &#123;
    Person1()&#123;
        //this这里是对象的地址
        System.out.println(&quot;正在初始化对象&quot;+this);//正在初始化对象utils.Person1@682a0b20
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person1 xiaoming = new Person1();

    &#125;
&#125;
</code></pre>
<p>通过this构造</p>
<pre><code class="Java">package utils;
class Person1 &#123;
    public String name;
    public int age;
    Person1(String name , int age)&#123;
//        name = name  //这样因为作用域的问题
        this.name = name ;
        this.age = age ;
        //this这里是对象的地址
        System.out.println(&quot;正在初始化对象&quot;+this);//正在初始化对象utils.Person1@682a0b20
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person1 xiaoming = new Person1(&quot;wang&quot;,18);
        System.out.println(xiaoming.name); //wang
        System.out.println(xiaoming.age);  //18
    &#125;
&#125;
</code></pre>
<p>this（），还可以带参数</p>
<pre><code class="Java">package utils;
class Person1 &#123;
    public String name;
    public int age;
    Person1()&#123;
        System.out.println(&quot;wwww&quot;);//wwww
    &#125;;
    Person1(String name , int age)&#123;
        //this()调用无参构造器，而且必须位于第一行
        this();
        this.name = name ;
        this.age = age ;
        System.out.println(&quot;正在初始化对象&quot;+this);//正在初始化对象utils.Person1@682a0b20
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person1 xiaoming = new Person1(&quot;wang&quot;,18);
        System.out.println(xiaoming.name); //wang
        System.out.println(xiaoming.age);  //18
    &#125;
&#125;
</code></pre>
<p><strong>static关键字</strong></p>
<p>这里面的代码</p>
<p>代码的开始定义一个静态的name，但是在构造器里面，有使用了name，就导致实例对象里面也有name的属性 了</p>
<pre><code class="java">package utils;
class Person1 &#123;
    static String name;
    Person1(String a)&#123;
    name = a ;
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person1 shuai = new Person1(&quot;nini&quot;);
        
        System.out.println(shuai.name);//nini
        System.out.println(Person1.name);//nini
    &#125;
&#125;
</code></pre>
<p>正确给静态的属性赋值的方法，调用的时机在类被加载的时候。</p>
<pre><code class="java">package utils;
public class Helper &#123;
    static String name;
    static &#123;
        System.out.println(&quot;执行初始化的工作&quot;);//执行初始化的工作
        name = &quot;王昌晨&quot;;
        printName();

    &#125;
    public static void printName()&#123;
        System.out.println(name);//王昌晨
    &#125;
    public static void main(String[] args) &#123;
    &#125;
&#125;
</code></pre>
<p>敲的时候出现一些问题，问了一下ai</p>
<pre><code class="java">package utils;
public class Helper &#123;
    static String name;
    static &#123;
        System.out.println(&quot;执行初始化的工作&quot;);//执行初始化的工作
        name = &quot;王昌晨&quot;;
        printName();
    &#125;
    public static void printName()&#123;
        System.out.println(name);//王昌晨
    &#125;
    public static void main(String[] args) &#123;
        Helper p = new Helper();
        System.out.println(p.name);/**
        虽然 name 属性被声明为 static，但是在 main 方法中通过实例对象访问静态属性 name 是合法的，这是因为静态成员虽然属于类而不属于实例对象，但在 Java 中仍然可以通过实例对象访问静态成员。

当你使用实例对象访问静态成员时，实际上是通过该实例对象来引用静态成员，编译器会在后台进行转换，将实例对象替换为对应的类名。因此，尽管最佳实践是通过类名直接访问静态成员，但是通过实例对象访问静态成员在语法上是合法的。

所以，在你的代码中，虽然在 main 方法中通过实例对象 p 访问静态属性 name，实际上会被转换为 Helper.name，因此可以正常访问并输出静态属性 name 的值。**/
    &#125;
&#125;
</code></pre>
<p>静态初始化 的执行顺序</p>
<pre><code>因为所有的类都继承Object
*上溯到Object类，先执行Object的静态初始化模块，在向下执行子类的静态初始化块，直至类的静态初始化
*构造方法的执行顺序也是一样的，这就是为什么在子类的构造器里面的super的方法
</code></pre>
<p><strong>包机制</strong></p>
<ul>
<li><p>用于管理类和类重名的问题</p>
</li>
<li><p>Java中常见的包	</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323220021699.png" alt="image-20240323220021699"></p>
</li>
</ul>
<p>导入的报名重名</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323220302005.png" alt="image-20240323220302005"></p>
<p>最好写齐路径</p>
<p>下面不会全部导入，会先检查用到这个文件的哪些类，然后再导入</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323220335026.png" alt="image-20240323220335026"></p>
<p><strong>静态导入</strong></p>
<p>导入包下面的所有的静态的属性</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323220509419.png" alt="image-20240323220509419"></p>
<p><strong>方法的重写</strong></p>
<p><strong>三个要点</strong></p>
<ul>
<li><p>1.方法名，形参，形参列表相同</p>
</li>
<li><p>2.返回值类型和声明异常类型，子类小于父类</p>
<pre><code class="Java">package utils;
class Person &#123;
    public Person func()&#123;
        System.out.println(&quot;1111&quot;);
        return new Person();
    &#125;
&#125;

class Li extends Person&#123;
    public Li func()&#123;
        System.out.println(&quot;222&quot;);
        return new Li();
    &#125;
&#125;

public class Helper &#123;

    public static void main(String[] args) &#123;
        
    &#125;
&#125;
</code></pre>
</li>
<li><p>3.访问权限，子类大于等于父类</p>
</li>
</ul>
<p><strong>final关键字</strong></p>
<ul>
<li><p>修饰变量</p>
</li>
<li><p>修饰方法：该方法不可以被子类重写，但是可以重载</p>
<pre><code class="java">public final void study()&#123;&#125;
</code></pre>
</li>
<li><p>修饰类：修饰类不能被继承，比如：Math,String</p>
<pre><code class="java">public final class A &#123;&#125;
</code></pre>
</li>
</ul>
<p><strong>组合</strong></p>
<p><strong>除了继承，组合也能实现代码的复用，组合的核心是将父类对象作为子类的属性</strong></p>
<pre><code class="Java">package utils;
class Person &#123;
    public String name;
    public int age;
    Person()&#123;
        name = &quot;hahaha&quot;;
        age = 18;
    &#125;
    public Person func()&#123;
        System.out.println(&quot;1111&quot;);
        return new Person();
    &#125;
&#125;

class Li &#123;
    Person chen = new Person();
    Li()&#123;
        System.out.println(chen.age);
        System.out.println(chen.name);
    &#125;
&#125;

public class Helper &#123;

    public static void main(String[] args) &#123;
        Li li = new Li();
    &#125;
&#125;
</code></pre>
<p><strong>Object类的详解</strong></p>
<ul>
<li>Object是所有类的父类</li>
<li>IDEA的快捷键<ul>
<li>类结构试图 alt+7</li>
<li>查看类的源码 ctrl+左键</li>
<li>自动生成构造器，get，set，equai方法 alt+insert</li>
<li>查看错误 alt+enter</li>
<li>快捷键常见代码片段<ul>
<li>main public static void main</li>
<li>sout System.out.printf()</li>
<li>soutm  System.out.printf（描述所在类中的，所在的方法）</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="java">        System.out.println(&quot;Person.func&quot;);//Person类里的func函数
</code></pre>
<p><strong>Object的equals方法</strong></p>
<pre><code>== 比较双方是否相同，普通的数据类型判断值，引用类型的判断的是地址
equals默认的比较两个对象地址是否相同
</code></pre>
<p>我们可以重写equal方法实现判断其他的</p>
<p><strong>super关键字</strong></p>
<ul>
<li><p>可以看作父类对象的引用，可以通过super来访问父类中被子类覆盖的方法和属性</p>
</li>
<li><p>使用super调用普通方法，语句没有位置限制，可以在子类中随意的调用</p>
</li>
<li><p>在一个类中，若是构造方法的第一行没有调用super或者是this；Java默认调用super含义是调用父类无参数的构造方法</p>
<pre><code class="java">package utils;
class Person &#123;
    public String name;
    public int age;
    public  void func()&#123;
        name = &quot;wang&quot;;
        age = 18;
        System.out.println(&quot;Person_age&quot;+age);
    &#125;
&#125;

class xiao extends Person&#123;
    public String name;
    public int age;
    public void func()&#123;
        super.func();
        age = 19;
        System.out.println(&quot;xiao_age&quot;+age);
        System.out.println(age);
        System.out.println(super.age);
    &#125;
&#125;

public class Helper &#123;

    public static void main(String[] args) &#123;
        xiao he = new xiao();
        he.func();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>程序的执行顺序</strong></p>
<p>构造方法的第一句总是super来调用父类的构造方法，，所以一直相声追溯，知道object</p>
<p><strong>封装</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324094833900.png" alt="image-20240324094833900"></p>
<ul>
<li><p>属性一般使用private访问权限，一般在开发中，我们把类中的属性都设为私有属性，然后通过相应的get和set的方法进行修改和读取。这些方法是public修饰（注意boolen类型的get方法是is开头）</p>
</li>
<li><p>方法：一些只用本类的辅助性方法可以用private修饰，希望其他类调用方法用public</p>
<pre><code class="java">//快速生成的get阿set的方法用 alt+insert
package utils;
class Person &#123;
    private String name;
    private int  age;
    private Boolean man;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public Boolean getMan() &#123;
        return man;
    &#125;

    public void setMan(Boolean man) &#123;
        this.man = man;
    &#125;
&#125;

public class Helper &#123;

    public static void main(String[] args) &#123;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>多态的要点</strong></p>
<ul>
<li>多态方法 的多态，不是属性</li>
<li>多态的存在三个条件，继承，方法重写，父类指向子类对象</li>
<li>父类引用子类的对象。用父类引用调用子类重写的方法</li>
</ul>
<pre><code class="Java">package utils;
class Animal&#123;

    public void shout ()&#123;
        System.out.println(&quot;叫一声&quot;);
    &#125;
&#125;
class Dog extends Animal&#123;
    public void shout()&#123;
        System.out.println(&quot;汪汪&quot;);
    &#125;
&#125;

class Cat extends Animal&#123;
    public void shout()&#123;
        System.out.println(&quot;喵喵&quot;);
    &#125;
&#125;

public class Helper &#123;
     public static void diao(Animal animal)&#123;//这里实现父类引用子类对象Animal animal
        animal.shout();
    &#125;

    public static void main(String[] args) &#123;
        Dog dog = new Dog();
        diao(dog);
    &#125;
&#125;
</code></pre>
<p><strong>再补充点</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324101703654.png" alt="image-20240324101703654"></p>
<ul>
<li><code>animal</code> 是 <code>Animal</code> 类型的引用，但是在运行时却指向了 <code>Dog</code> 类的实例，因此调用 <code>shout()</code> 方法时会调用 <code>Dog</code> 类中的 <code>shout()</code> 方法。</li>
<li><code>Animal</code> 类型的引用 <code>dog</code> 指向了 <code>Dog</code> 类的实例，然后尝试调用 <code>shout1()</code> 方法，但是 <code>Animal</code> 类并没有定义 <code>shout1()</code> 方法，因此编译器会报错</li>
</ul>
<p><strong>对象的转型</strong></p>
<ul>
<li><p>向上转型：就是刚下上面说过的父类引用子类对象</p>
<pre><code>Animal是父类
Dog是子类
Animal dog = new Dog();//父类引用子类对象
</code></pre>
</li>
<li><p>向下转型</p>
<pre><code class="Java">package utils;
class Animal&#123;

    public void shout ()&#123;
        System.out.println(&quot;叫一声&quot;);
    &#125;
&#125;
class Dog extends Animal&#123;
    public void shout()&#123;
        System.out.println(&quot;汪汪&quot;);
    &#125;
    public void shout1()&#123;
        System.out.println(&quot;汪汪&quot;);
    &#125;
&#125;

public class Helper &#123;
     public static void diao(Animal animal)&#123;//这里实现父类引用子类对象Animal animal
        animal.shout();
    &#125;

    public static void main(String[] args) &#123;
         Animal animal = new Dog();//自动向上转型为Animal
        animal.shout();//汪汪
        animal.shout1();//代码错误，因为animal没有shout
        ((Dog) animal).shout1();//向下转型

    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>转型前后都是一个对象</strong></p>
<p><strong>接口定义静态方法和默认方法</strong></p>
<p>默认方法用default修饰</p>
<pre><code class="Java">public interface Test &#123;
    void printInfo();
    default void moren()&#123;
        System.out.println(&quot;默认方法&quot;);
    &#125;
&#125;
class Testclass implements Test&#123;
    @Override
    public void printInfo() &#123;

    &#125;
&#125;
</code></pre>
<p>静态的方法，<strong>注意接口的静态方法和子类一点关系也没有，不会有父子类的那样的关系，接口的静态方法只能通过接口进行调用和实现接口的类没有一点关系</strong></p>
<pre><code class="java">public interface Test &#123;
    void printInfo();
    default void moren()&#123;
        System.out.println(&quot;默认方法&quot;);
    &#125;
    public static void func()&#123;
        System.out.println(&quot;hahaha&quot;);
    &#125;
&#125;
class Testclass implements Test&#123;
    @Override
    public void printInfo() &#123;
        Test.func();//hahaha
        Testclass.func();//报错	
    &#125;
    
&#125;
</code></pre>
<p>字符串的一些api</p>
<pre><code class="java">String s1=&quot;core Java&quot;;
String s2=&quot;core Java&quot;;
s1.charAt()//查看下标为几 的字符
s1.length();
s1.equals(s2)//检查相等
s1.equalIgnoreCase(s2);//忽略大小写
s1.indexOf(&quot;Java&quot;);//字符串是否包含Java，位置，如果没有返回-1
s1.replace(&#39;&#39;,&#39;&amp;&#39;);//将空格替换成&amp;
s1.substring(4,7);
s1.substring(4)//提取字符串从4到字符串结尾
</code></pre>
<p><strong>内部类</strong></p>
<ul>
<li>内部类提供更好的封装，只能外部类直接访问，不允许同一个包其他类直接访问</li>
<li>内部类可以直接访问外部类的私有属性，内部类被当作其他外部类成员，但外部类不能访问内部类的属性</li>
</ul>
<p>		</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324104900955.png" alt="image-20240324104900955"></p>
<p><strong>非静态内部类</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324105114585.png" alt="image-20240324105114585"></p>
<pre><code class="java">package utils;
class Outer &#123;
    private String name = &quot;王昌晨&quot;;
    public void show()&#123;
        System.out.println(&quot;Outer_name&quot;+name);
        //在外部类实例内部类
        Inner a = new Inner();
    &#125;
    public class Inner&#123;
        private String name = &quot;兵王&quot;;
        public void show()&#123;
            System.out.println(&quot;Inner_name&quot;+name);
            System.out.println(Outer.this.name);//访问外部类
            Outer.this.show();
        &#125;
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        //外部类实例
        Outer out = new Outer();
        //内部类的实例
        Outer.Inner inner  = new Outer().new Inner();
    &#125;
&#125;
</code></pre>
<p><strong>静态内部类</strong></p>
<ul>
<li>静态内部类可以访问外部类的静态成员，不能直接访问外部类的普通成员</li>
<li>静态内部类可以看作外部类的一个静态成员</li>
</ul>
<pre><code class="Java">package utils;
class Outer &#123;
    private String name = &quot;王昌晨&quot;;
    private static int a = 1;
    private static int b = 3;
    public void show()&#123;
        System.out.println(&quot;Outer_name&quot;+name);
        //在外部类实例内部类
        Inner a = new Inner();
    &#125;
    public static class Inner&#123;
        private String name = &quot;兵王&quot;;
        public void show()&#123;
            System.out.println(&quot;Inner_name&quot;+name);
//            可以直接访问外部的成员的静态属性和方法
            System.out.println(a);//1
            System.out.println(b);//3

        &#125;
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        //外部类实例
        Outer out = new Outer();
        //静态类这么实例
        Outer.Inner a = new Outer.Inner();
        a.show();

    &#125;
&#125;
</code></pre>
<p><strong>匿名的匿名类</strong></p>
<ul>
<li>适用于那种只需要使用一次的类，b比如：键盘监听操作等，</li>
</ul>
<p>如下面的这段代码，我们如果想要调用Person里的B方法，必须需要传入实现接口A的对象，需要在写一个实现A接口的类，有点麻烦，可以写匿名类</p>
<pre><code class="Java">package utils;
class Person &#123;
    public void B(A f)&#123;
        f.func();
    &#125;
&#125;
interface A &#123;
    void func();
&#125;
class B implements A&#123;
    @Override
    public void func() &#123;
        System.out.println(&quot;hahaha&quot;);
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person h = new Person();
        h.B(new B());
    &#125;
&#125;
</code></pre>
<pre><code class="Java">package utils;
class Person &#123;
    public void B(A f)&#123;
        f.func();
    &#125;
&#125;
interface A &#123;
    void func();
&#125;
public class Helper &#123;
    public static void main(String[] args) &#123;
        Person h = new Person();
        //直接new A就会有代码提示，下面的就是实力一个实现接口A的类
        h.B(new A() &#123;
            @Override
            public void func() &#123;
                System.out.println(&quot;hehehe&quot;);
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre>
<p><strong>方法的内部类</strong></p>
<ul>
<li>只能在方法里面使用</li>
<li><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324111801398.png" alt="image-20240324111801398"></li>
</ul>
<p><strong>数组</strong></p>
<ul>
<li>数组是相同数据类型的有序集合</li>
<li>长度是确定的</li>
<li>元素类型是相同 的</li>
<li>数组对象是引用类型</li>
</ul>
<p>内存分析</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324113002955.png" alt="image-20240324113002955"></p>
<p><strong>静态初始化</strong></p>
<ul>
<li>除了通过new的关键字，还可以通过定义数组的同时就为数组分配空间并且赋值</li>
</ul>
<pre><code class="Java">package utils;
class Person &#123;
&#125;
public class Helper &#123;
    public static void main(String[] args) &#123;
        int[] a = &#123;1,2,3&#125;;
        Person[] b = &#123;new Person(),new Person()&#125;;
    &#125;
&#125;
</code></pre>
<p><strong>动态初始化</strong></p>
<pre><code class="Java">package utils;
class Person &#123;
&#125;
public class Helper &#123;
        int[] c = new int[3];
        c[0] = 1;
        c[1] = 2;
        c[2] = 3;
    &#125;
&#125;
</code></pre>
<p><strong>默认初始化</strong></p>
<pre><code class="Java">package utils;
class Person &#123;
&#125;
public class Helper &#123;
    public static void main(String[] args) &#123;
    int d[] = new int[2];//默认[0,0]
    boolean[] b = new boolean[2];//默认[false,false]

&#125;
</code></pre>
<p><strong>数组的两个遍历</strong></p>
<ul>
<li><p>使用For循环</p>
</li>
<li><p>for-each专门用于数组和集合所有的元素,在循环的过程中只能读取不能修改数组的值，for-each 仅用于简单的遍历，操作不了索引</p>
<pre><code class="Java">String[] ss = &#123;&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;&#125;;
for(String item : ss)&#123;
    System.out.println(item);
&#125;
</code></pre>
</li>
</ul>
<p><strong>异常</strong></p>
<ul>
<li><p>代码出现不正常的状态，异常是一个一个的类</p>
<p><strong>Throwable下面的两个子类</strong></p>
<ul>
<li>Error:错误，代码出现重大的错误</li>
<li>Exception：异常：代码出现小问题，异常分为两类<ul>
<li>编译时期异常，代码一些写一编译就暴红了（语法错误除外），Exception以及子类（除了RuntimeException之外）</li>
<li>运行时期异常：RuntimeException和他的子类，写代码不暴红，运行的时期爆红了<img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325143129953.png" alt="image-20240325143129953"></li>
</ul>
</li>
</ul>
<p>实例</p>
<p><strong>错误</strong></p>
</li>
<li><pre><code class="Java">package execption;

public class Demo &#123;
    public static void main(String[] args) &#123;
        method();
    &#125;

    public static void method() &#123;
        method();
    &#125;
&#125;
</code></pre>
<p>控制台报错</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325143434765.png" alt="image-20240325143434765"></p>
</li>
</ul>
<p><strong>运行时期异常</strong></p>
<pre><code class="Java">    public static void main(String[] args) &#123;
        int[] a= &#123;1,2,3&#125;;
        System.out.println(a[4]);
    &#125;
</code></pre>
<p>编译器没有飘红</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325143605424.png" alt="image-20240325143605424"></p>
<p>运行的时候</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325143635501.png" alt="image-20240325143635501"></p>
<p>发现是他的子类，所以是运行时期异常</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325143710714.png" alt="image-20240325143710714"></p>
<p><strong>编译时期异常</strong></p>
<p>下面的例子</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325144118255.png" alt="image-20240325144118255"></p>
<p>代码没有错，但是编译时期飘红 了，</p>
<p><strong>注意</strong></p>
<ul>
<li>编译时期飘红不是因为我们的代码写错 了</li>
<li>是因为该方法的底层给我们抛了一个错误，所以我们一调用这个方法一编译就飘红了</li>
</ul>
<p>异常出现的过程</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325145239439.png" alt="image-20240325145239439"></p>
<p><strong>创建异常对象</strong></p>
<p>创建异常对象只是为了后面学习如何处理异常</p>
<ul>
<li>1.关键字：throw：把异常对象显示出来</li>
<li>2.格式throw new 异常</li>
</ul>
<p>例</p>
<pre><code class="Java">package execption;

public class Demo1 &#123;
    public static void main(String[] args) &#123;
        String s = &quot;a.txt1&quot;;
        method(s);

    &#125;
    public static void method(String s)&#123;
        if (! s.endsWith(&quot;.txt&quot;))&#123;
            //故意创建异常对象，用throw说明这出有异常
            throw new NullPointerException();//这里出现异常没有人处理就会往上面抛，最后都没有人处理交给虚拟机，虚拟机终止程序，打印异常信息
            /**
             Exception in thread &quot;main&quot; java.lang.NullPointerException
             at execption.Demo1.method(Demo1.java:12)
             at execption.Demo1.main(Demo1.java:6)**/
        &#125;
        System.out.println(&quot;执行&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>异常处理的两种方法</strong></p>
<ul>
<li>throws：在方法参数和方法体之间的位置写<ul>
<li>格式：throws 异常</li>
<li>将异常往上面</li>
</ul>
</li>
</ul>
<p>例子</p>
<pre><code class="Java">package execption;

import java.io.FileNotFoundException;

public class Democracy
&#123;
    public static void main(String[] args)  &#123;
        String s = &quot;1.txt&quot;;
        add(s);
        delete(s);
        
    &#125;

    private static void delete(String s) &#123;
        System.out.println(&quot;删除&quot;);
    &#125;

    private static void add(String s)  &#123;
        if (! s.endsWith(&quot;.txt&quot;))&#123;
            //故意创建异常
            throw new FileNotFoundException(&quot;文件找不到&quot;);
        &#125;
        System.out.println(&quot;增加&quot;);
    &#125;
&#125;
</code></pre>
<p>直接new异常会报错，因为他是编译时期异常</p>
<p>所以使用throws向上抛，这样就可以了，这个异常处理的过程还是和默认的一样，最终还是往上面抛，最后给虚拟机，<strong>这样也会有问题，当一个出现我问题的时候，例如当add出现问题，程序就不会往下面走去到delete</strong></p>
<pre><code class="Java">package execption;

import java.io.FileNotFoundException;

public class Democracy
&#123;
    public static void main(String[] args) throws FileNotFoundException &#123;
        String s = &quot;1.txt&quot;;
        add(s);
        delete(s);
        
    &#125;

    private static void delete(String s) &#123;
        System.out.println(&quot;删除&quot;);
    &#125;

    private static void add(String s) throws FileNotFoundException  &#123;
        if (! s.endsWith(&quot;.txt&quot;))&#123;
            //故意创建异常
            throw new FileNotFoundException(&quot;文件找不到&quot;);
        &#125;
        System.out.println(&quot;增加&quot;);
    &#125;
&#125;
</code></pre>
<p>多个异常可以这样写</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325151526466.png" alt="image-20240325151526466"></p>
<ul>
<li><p>如果throws的多个异常之间有一个子父类的继承关系，我们直接可以throws 父类的异常</p>
</li>
<li><p>所以根据上面，有多个异常我们可以直接抛出他们最终的父类Exception</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325151726630.png" alt="image-20240325151726630"></p>
</li>
</ul>
<p><strong>第二种方法</strong></p>
<p><strong>try catch</strong></p>
<ul>
<li><p>格式</p>
<pre><code class="java">try &#123;
//可能出现的异常的代码
    
&#125; catch(异常 对象名)&#123;
    //处理异常的代码（把异常打印在控制台）--》将来将开发会把异常信息保存在日志文件中（用于查询）
&#125;
</code></pre>
<p>实例</p>
<p><strong>当我们程序出现异常，会被catch捕获到，然后在输出异常，然后继续往下面走</strong></p>
<pre><code class="Java">package execption;

import java.io.FileNotFoundException;

public class Democracy
&#123;
    public static void main(String[] args)&#123;
        String s = &quot;1.txt1&quot;;
        try &#123;
            add(s);
        &#125; catch (FileNotFoundException e)&#123;
            System.out.println(e);//java.io.FileNotFoundException: 文件找不到
        &#125;
        delete(s);//删除
    &#125;

    private static void delete(String s) &#123;
        System.out.println(&quot;删除&quot;);
    &#125;

    private static void add(String s) throws FileNotFoundException  &#123;
        if (! s.endsWith(&quot;.txt&quot;))&#123;
            //故意创建异常
            throw new FileNotFoundException(&quot;文件找不到&quot;);
        &#125;
        System.out.println(&quot;增加&quot;);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p>控制台的输出结果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325152527183.png" alt="image-20240325152527183"></p>
<p><strong>注意</strong>这段代码只捕获了FileNotFoundException的错误，但是没有捕获数组的那个错误，此时这个try catch是失效了</p>
<pre><code class="java">        try &#123;
            add(s);
            int[] a = null;
            System.out.println(a.length);
        &#125; catch (FileNotFoundException e)&#123;
            System.out.println(e);//java.io.FileNotFoundException: 文件找不到
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325152924929.png" alt="image-20240325152924929"></p>
<p><strong>有一个发现，当我们的add方法错误以后，直接就去走catch，这样       System.out.println(1111);这段代码就不会执行</strong></p>
<pre><code class="java">    public static void main(String[] args)&#123;
        String s = &quot;1.txt1&quot;;
        try &#123;
            add(s);
            System.out.println(1111);
        &#125; catch (FileNotFoundException e)&#123;
            System.out.println(e);//java.io.FileNotFoundException: 文件找不到
        &#125;
        delete(s);//删除
    &#125;
</code></pre>
<p>catch多个异常的格式，使用多个catch</p>
<pre><code class="Java">package execption;

import java.io.FileNotFoundException;
import java.io.IOException;

public class Democracy
&#123;
    public static void main(String[] args)&#123;
        String s = &quot;1.txt1&quot;;
        try &#123;
            add(s);
            System.out.println(1111);
        &#125; catch (FileNotFoundException e)&#123;
            System.out.println(e);//java.io.FileNotFoundException: 文件找不到
        &#125; catch (IOException e)&#123;
            System.out.println(e);
        &#125;
        delete(s);//删除
    &#125;

    private static void delete(String s) &#123;
        System.out.println(&quot;删除&quot;);
    &#125;

    private static void add(String s) throws IOException ,FileNotFoundException &#123;
        if (! s.endsWith(&quot;.txt&quot;))&#123;
            //故意创建异常
            throw new FileNotFoundException(&quot;文件找不到&quot;);
        &#125;
        if (s==null)&#123;
            throw new IOException(&quot;Io异常&quot;);
        &#125;
        System.out.println(&quot;增加&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>如果异常的有父子关系，直接用父类也是可以的</strong></p>
<p><strong>不知道的话，我们直接catch Exception</strong></p>
<p>我们还可以打印详细的</p>
<p>cu错误的信息打印在控制台，使用printStackTrace的方法</p>
<pre><code class="Java">        try &#123;
            add(s);
            System.out.println(1111);
        &#125; catch (FileNotFoundException e)&#123;
            e.printStackTrace();
        &#125; catch (IOException e)&#123;
            System.out.println(e);
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325181330429.png" alt="image-20240325181330429"></p>
<p><strong>finally关键字</strong></p>
<pre><code>注意和final区别开
1.代表的是不管是否触发了异常，都会执行的代码块
特殊情况：如果前面有代码System.exit(0)这个作用是终止Java虚拟机
2.使用配合try catch放在trycatch后面
</code></pre>
<p>例子</p>
<pre><code class="Java">try &#123;
    add(s);
    System.out.println(2222);
&#125; catch (FileNotFoundException e)&#123;
    e.printStackTrace();
&#125; catch (IOException e)&#123;
    System.out.println(e);
&#125; finally &#123;
    System.out.println(1111);
&#125;
</code></pre>
<p>之前说过try里面发生错误以后直接进入catch，然后就不会输出22222，</p>
<p>但是finally不管你有没有异常都会执行 的</p>
<p>下面将一些问题</p>
<ul>
<li>正常我们程序发生异常走进catch里面，里面有一个return,但是我们程序的执行顺序是先走的是finally，然后是catch里的内容</li>
</ul>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325182306317.png" alt="image-20240325182306317"></p>
<ul>
<li><p>所以我们在finally里面加上return，那么就会直接离开这个函数也不会执行catch里面的内容了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325182506837.png" alt="image-20240325182506837"></p>
</li>
</ul>
<p>注意执行的顺序</p>
<p><strong>try代码块，发现错误然后到finally，然后到catch里面的代码</strong></p>
<p><strong>finally的使用场景</strong></p>
<ul>
<li>关闭资源<ul>
<li>原因：如果没有使用 了，GC回收机制，用来回收堆内存的垃圾，释放内存，但是有一些对象GC回收不了，例如：连接对象（mysql）,io流对象，socket对象，这些GC回收不了，就需要我们手动进行回收，将来不能回收的对象new完以后，后续的操作不管异常还是好的，都要关闭</li>
</ul>
</li>
</ul>
<p><strong>抛异常的注意的事项</strong></p>
<ul>
<li><p>如果父类中的方法抛出了异常，那么子类的重写以后要不要抛？</p>
<pre><code>子类重写的方法可以抛也可以不抛
</code></pre>
</li>
<li><p>如果父类中的方法没有抛异常，那么子类重写方法的可不可以抛异常？</p>
</li>
</ul>
<pre><code>子类重写的方法不可以抛异常
</code></pre>
<p><strong>try catch和throws的使用时机</strong></p>
<ul>
<li><p>1.如果处理异常之后还要继续执行代码，那么就要使用try catch</p>
</li>
<li><p>2.如果方法之间是递进的调用，可以先throws，但是到最后用try catch做一个统一的错误处理</p>
</li>
</ul>
<p>比如说页面的架构，到后面一定使用这三个架构</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325184146232.png" alt="image-20240325184146232"></p>
<p>编译时期的异常是必须要处理</p>
<p>运行时期的异常没有必要处理，需要更改代码了</p>
<p><strong>自定义异常</strong></p>
<p>简单的创建方法</p>
<pre><code class="Java">public class Demo2 &#123;
    public static void main(String[] args) throws LoginUserException &#123;
        String username = &quot;root&quot;;

        Scanner input  = new Scanner(System.in);
        System.out.println(&quot;请输入您要登录的用户名:&quot;);
        String name = input.next();

        if (name.equals(username))&#123;
            System.out.println(&quot;登录失败&quot;);
        &#125; else &#123;
            throw new LoginUserException();
        &#125;


    &#125;
&#125;
</code></pre>
<p>然后我们需要去定义一个LoginUserException类，而且还要继承Exception</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325185420455.png" alt="image-20240325185420455"></p>
<p>这样就可以了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325185441928.png" alt="image-20240325185441928"></p>
<p>我们就还可以自定义异常的原因</p>
<pre><code class="Java">throw new LoginUserException(&quot;账号或密码错误&quot;);
            -------------------------------
使用构造方法
public class LoginUserException extends Exception &#123;
    public LoginUserException() &#123;
    &#125;
    public LoginUserException(String message) &#123;
        super(message);
    &#125;
&#125;
            
            
            
</code></pre>
<p>这样就可以了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325190118158.png" alt="image-20240325190118158"></p>
<p>设置异常的原因</p>
<p><strong>打印异常信息的三个方法</strong></p>
<pre><code>Throwable的方法
          try &#123;
                throw new LoginUserException(&quot;账号或密码错误&quot;);
            &#125; catch (Exception e)&#123;
                //异常加错误的原因，之前说过打印你一个对象默认调用了tostring的方法
                System.out.println(e);//execption.LoginUserException: 账号或密码错误
                System.out.println(e.toString());//execption.LoginUserException: 账号或密码错误
                System.out.println(e.getMessage());//账号或密码错误          只获取异常的信息
                e.printStackTrace();//飘红，信息完整
            &#125;
</code></pre>
<p><strong>说一下scanner的</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325185812928.png" alt="image-20240325185812928"></p>
<p><strong>Object类</strong></p>
<p><strong>toString方法</strong></p>
<p>类的源码</p>
<pre><code class="Java">    public String toString() &#123;
        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
    &#125;
</code></pre>
<p>示例</p>
<pre><code class="Java">package _object;

public class Person &#123;
    private String name;
    private int age;

    public Person() &#123;
    &#125;

    public Person(String name) &#123;
        this.name = name;
    &#125;

    public Person(int age) &#123;
        this.age = age;
    &#125;

    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;
&#125;
</code></pre>
<pre><code class="Java">package _object;

public class Test &#123;
    public static void main(String[] args) &#123;
        Person p1= new Person(&quot;王昌晨&quot;,18);
        System.out.println(p1);//_object.Person@3b07d329
        System.out.println(p1.toString());//_object.Person@3b07d329
    &#125;

&#125;
</code></pre>
<p><strong>总结</strong></p>
<pre><code>注意：
*如果没有重写object里的tostrig的方法，直接输出对象名会默认的调用tostring方法，tostring的方法会返回对象的地址值
</code></pre>
<p>有些问题</p>
<pre><code class="Java">        List a = new ArrayList();
        a.add(&quot;张三&quot;);
        a.add(&quot;王五&quot;);
        a.add(&quot;李四&quot;);
        System.out.println(a.toString());//[张三, 王五, 李四]
</code></pre>
<ul>
<li>输出的不是地址值,是因为重写了tostring的方法</li>
</ul>
<p>所以我们还可以重写tostring的方法在我们自己的类里面</p>
<pre><code class="java">    public String toString ()&#123;
        return name + age;
    &#125;
</code></pre>
<p>快速生成toString的方法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325104744357.png" alt="image-20240325104744357"></p>
<p><strong>Object的equals方法</strong></p>
<p>源代码</p>
<pre><code class="java">    public boolean equals(Object obj) &#123;
        return (this == obj);
    &#125;
</code></pre>
<p>返回的是boolean类型，比较的是两个地址值是否相等</p>
<pre><code class="java">        System.out.println(p1.equals(p2));//false
        System.out.println(p1.equals(p1));//true
</code></pre>
<p>底层的原理</p>
<pre><code>    public boolean equals(Object obj) &#123;
        return (this == obj);
    &#125;
    -----------------------------------------
    System.out.println(p1.equals(p2));//false
    *当p1调用obj的时候,这个this就是指向的p1，==在引用类型的比较的是地址值，在基础数据类型是比较数据的值
</code></pre>
<p>注意还是重写的问题</p>
<pre><code class="java">//我们使用实例的方法创建字符串
String name = new String(&quot;name&quot;);
String name1 = new String(&quot;name&quot;);
System.out.println(name.equals(name1));//true
因为String的equals的重写了，比较的是值
</code></pre>
<p>下面是重写的代码</p>
<pre><code class="Java">    public boolean equals(Object anObject) &#123;
        if (this == anObject) &#123;
            return true;
        &#125;
        return (anObject instanceof String aString)
                &amp;&amp; (!COMPACT_STRINGS || this.coder == aString.coder)
                &amp;&amp; StringLatin1.equals(value, aString.value);
    &#125;
</code></pre>
<p>我们也可以在重写一下</p>
<p>这是快捷键重写以后的</p>
<pre><code class="java">    @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &amp;&amp; Objects.equals(name, person.name);
    &#125;

    @Override
    public int hashCode() &#123;
        return Objects.hash(name, age);
    &#125;
</code></pre>
<pre><code class="Java">System.out.println(p1.equals(p2))
//当我们传入p2的时候，重写的类用父类引用子类 object 0 = p2;
//如果想要获取p2的里面的属性和方法需要向下转型
//        if (o == null || getClass() != o.getClass()) return false;这一步在判断传入的对象类型是否是当当前的类，如果传入一个字符串对象的话，强转就会出现问题
 //      if (this == o) return true;如果传入的是自己那么肯定是相等的，返回true
</code></pre>
<p><strong>Object的clone的方法</strong></p>
<pre><code>1.作用:复制一个属性值一样的新对象
2.使用:需要被克隆的对象实现cloneable的接口
        重写clone
</code></pre>
<p>过程</p>
<pre><code class="Java">Person的类实现public class Person implements Cloneable
重写clone方法    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;
    在主函数里面调用
            public static void main(String[] args) throws CloneNotSupportedException &#123;
        Person p = new Person(&quot;wang&quot;,18);
        Object o = p.clone();//克隆一个新对象,地址不一样，属性值是一样的
        Person p1 = (Person) o;
        System.out.println(p1.equals(p));//true

    &#125;
</code></pre>
<p><strong>在复习一下多态</strong></p>
<ul>
<li><p>不要从字面形式上理解多态的这两个子，要从形式上掌握</p>
</li>
<li><p>要知道多态的好处，多态的前提</p>
<pre><code>前提
    a.必须有字符类的继承或者接口实现关系
    b.必须有方法的重写（没有重写，多态没有意义）
    c.父类引用指向子类对象
Fu fu = new zi();--&gt;理解成大数据类型接受一个小数据类型的数据，比如 double b = 10;
注意：
    多态下不能直接调用子类的特有功能
</code></pre>
</li>
</ul>
<p><strong>多态的好处</strong></p>
<pre><code>1.问题描述
    如果不使用多态，使用原始的方法new对象，既能调用子类重写的父类的方法，还能调用自己特有的成员，但是多态的new的对象只能调用子类重写的，不能调用子类的特有的成员那为什么还要用多态？
2.多态方式和原始方式new对象的优缺点
    原始方式:
        优点:既能调用重写的，还能调用父类非私有的，还能调用自己特有的
        缺点:扩展性差，就像之前的讲的，传递的参数可以写成父类
    多态方法:
        优点:扩展性强
        缺点:不能调用子类特有的功能
</code></pre>
<p><strong>多态的转型</strong></p>
<p>向上转型以后调用子类的特有的功能就要使用向下转型</p>
<pre><code>转型是出现的问题
左右两边类型不一样，就会出现类型转换异常
可以使用instanceOf进行判断然后再类型转换
</code></pre>
<p><strong>String补充</strong></p>
<pre><code class="Java">String s1 = &quot;10&quot;;
String s2 = &quot;10&quot;;
String s3 = new String(&quot;10&quot;);
System.out.println(s1 == s2);//true
System.out.println(s1 == s3);//false
System.out.println(s2 == s3);//false
</code></pre>
<p>内存的分析</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325194042492.png" alt="image-20240325194042492"></p>
<pre><code class="Java">String a = new String(&quot;abc&quot;);//共有几个对象？ 一个new本身，一个abc
String b = new String(&quot;abc&quot;)//共创建今儿个对象？  如果之前没有创建abc，那么就会创建两个，有的话就只会创建new的对象，把abc之恶共享过来即可
</code></pre>
<p>内存分析</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325194436987.png" alt="image-20240325194436987"></p>
<pre><code class="Java">        String s = &quot;HelloWorld&quot;;
        String s1 = &quot;Hello&quot;;
        String s2 = &quot;World&quot;;
        String s4 = &quot;Hello&quot;+&quot;World&quot;;
        String s5 = s1 + &quot;World&quot;;
        String s6 = &quot;Hello&quot;+s2;
        String s7 = s1+s2;
        System.out.println(s == s4);//true
        System.out.println(s == s5);//false
        System.out.println(s == s6);//false
        System.out.println(s == s7);//false
</code></pre>
<p>为什么会出现上面的问题，直接反编译以后就能知道结果了</p>
<p><strong>String的常用的方法</strong></p>
<p><strong>注意在Java中String不是基本数据类型，而是一个类，</strong></p>
<p><strong>如果我们使用&#x3D;&#x3D;比较，之前说过当&#x3D;&#x3D; 比较引用的数据类型，比较的是地址，所以我们使用equals比较内容，</strong></p>
<pre><code>equals();//比较字符串的内容
equalsIgnorecase();//忽略大小写的
</code></pre>
<p>或者使用</p>
<pre><code class="Java">    String s2 = &quot;10&quot;;
    String s3 = new String(&quot;10&quot;);
    System.out.println(Objects.equals(s2,s3));//true
</code></pre>
<p>底层的源码，这个可以有效的防止防止空指针</p>
<pre><code class="Java">public static boolean equals(Object a, Object b) &#123;
    return (a == b) || (a != null &amp;&amp; a.equals(b));
&#125;
</code></pre>
<p>比如说</p>
<pre><code class="Java">String s2 = null;
String s3 = new String(&quot;10&quot;);
s2.equals(s3);//这一行就会报错
System.out.println(Objects.equals(s2,s3));
</code></pre>
<p>这样就会报错空指针异常</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325200556819.png" alt="image-20240325200556819"></p>
<pre><code>*length()//
*concat()//拼接返回一个新的字符串
*charAt()//根据索引获取响应的字符
*indexOf(String s);//返回字符串在大字符串第一次出现的位置
*subString(int begin);//从开始索引截到最后
*sunString(int begin, int end);//记住左闭右开
</code></pre>
<pre><code>toCharArray();//转为char数组
getBytes();//将字符串转为字节数组
replace(String s1, String s2);//替换
getBytes(String charsetName);//按照编码格式将字符串转为Bytes数组
</code></pre>
<pre><code>split(String regex);//分割
</code></pre>
<pre><code>contains()//
endwiths()
startsWith()
toLowerCase()
toUpperCase()
trim()
</code></pre>
<p><strong>StringBuilder</strong></p>
<ul>
<li>介绍<ul>
<li>一个可变的字符序列，此类提供一个和StringBuffer兼容的APi，但是线程不同步，但是效率高</li>
</ul>
</li>
<li>作用<ul>
<li>拼接字符串</li>
</ul>
</li>
<li>之前的拼接为什不行，为什么用StringBuilder拼接？<ul>
<li>因为之前string的拼接，每拼接一次就会产生一个新的字符串对象，就是上面举的例子,如果拼接过多占用堆的内存</li>
<li>StringBuilder底层自带一个缓冲区（没有被final修饰的bytes数组）拼接字符串以后都会在这个缓冲区保存，在拼接的过程中不会随意产生新对象</li>
</ul>
</li>
</ul>
<pre><code class="java">    String s = &quot;HelloWorld&quot;;
    String s1 = &quot;Hello&quot;;
    String s2 = &quot;World&quot;;
    String s4 = &quot;Hello&quot;+&quot;World&quot;;
    String s5 = s1 + &quot;World&quot;;
    String s6 = &quot;Hello&quot;+s2;
    String s7 = s1+s2;
    System.out.println(s == s4);//true
    System.out.println(s == s5);//false
    System.out.println(s == s6);//false
    System.out.println(s == s7);//false
</code></pre>
<ul>
<li>特点<ul>
<li>自带缓冲区，默认的长度为16，没有final修饰所以是可变的，如果超过16了，数组会自动的扩容，<ul>
<li>创建一个新长度的数组，将老数组的元素复制到新数组的里面，在将新数组的地址值重新赋给老数组</li>
<li>默认每次扩容老数组的2倍+2</li>
<li>如果超过2倍+2的，那么直接创建等大的内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>两种创建方法</p>
<pre><code class="Java">StringBuilder sb  = new StringBuilder();
sb.append(&quot;wei3588559&quot;);

StringBuilder sb2 = new StringBuilder(&quot;wei3588559&quot;);
</code></pre>
<p>append用来拼接字符串，返回一个StringBuilder</p>
<pre><code class="Java">StringBuilder sb2 = new StringBuilder(&quot;wei3588559&quot;);
StringBuilder sb3=sb2.append(&quot;haha&quot;);
System.out.println(sb2);//wei3588559haha
System.out.println(sb3);//wei3588559haha
System.out.println(sb3 == sb2);//true
</code></pre>
<p>我们还可以链式调用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325204030828.png" alt="image-20240325204030828"></p>
<p>reserve(),反转用法和append一样</p>
<p>toString（）：将StringBuilder对象转为String对象，为了可以使用String的方法</p>
<p>判断回文内容</p>
<pre><code class="Java">    public static void main(String[] args)  &#123;
        Scanner input  = new Scanner(System.in);
        String data = input.nextLine();
        StringBuilder str = new StringBuilder(data);
        str.reverse();
        String str2 = str.toString();//将StringBuilder转为String对象
        if (data.equals(str2))&#123;//注意这里的比较一定是字符串的对象，不能呢和是string和stringbuilder的比较，这样内容一样也是false
            System.out.println(&quot;是回文数&quot;);
        &#125; else &#123;
            System.out.println(&quot;不是回文数&quot;);
        &#125;
    &#125;
</code></pre>
<p>补充字符的equals方法</p>
<p>比较的时候一定比较的是字符串</p>
<pre><code class="Java">    public boolean equals(Object anObject) &#123;
        if (this == anObject) &#123;
            return true;
        &#125;
        return (anObject instanceof String aString)
                &amp;&amp; (!COMPACT_STRINGS || this.coder == aString.coder)
                &amp;&amp; StringLatin1.equals(value, aString.value);
    &#125;
</code></pre>
<pre><code>定义一个数组，以[元素1，元素2...],用StringBuilder拼接
</code></pre>
<p>String 拼接的效率满，而且拼接一次就会产生一个新的字符串对象</p>
<p>StringBuilder和StringBuffer:</p>
<p>​	1.相同点：拼接的效率比StringBuffer高</p>
<p>​						但是线程不安全</p>
<p>​	2.Stringbuffer：效率比较低，线程安全</p>
<p><strong>Math类</strong></p>
<ul>
<li><p>特点：他的构造方法私有了</p>
<ul>
<li>方法都是静态的直接类名调用就可以</li>
</ul>
</li>
<li><p>数学工具类</p>
<pre><code>Math.abs(-10)//10
static int abs(int a) --&gt;求参数的绝对值
static double ceil(double a) --&gt;向上取整
static double floor(double a) --&gt;向下取整
static long round(double a) --&gt;四舍五入
static int max(int a , int b) --&gt;最大值
static int min(int a , int b) --&gt;最小值
</code></pre>
</li>
</ul>
<p><strong>BigInteger</strong></p>
<pre><code>操作数据的时候，将来的数据很大，大到比long还大，这种称为对象
作用:操作大的数字
BigInteger(String value)
方法
    add(BigInteger value);//加
    subtract(BigInteger value)//减
    multiply(BigInteger value) //×
    divide(BigInteger value)//  除
</code></pre>
<p><strong>BigDecimal</strong></p>
<p>floor的数据直接参加运算会出现精度损失的问题</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326124121160.png" alt="image-20240326124121160"></p>
<pre><code>**BigDecimal**解决精度损失的问题
构造方法
BigDEcimal(Stirng value) --&gt;value一定是数字的字符串
常用的方法
static BigDecimal valueOf(doubt value) --&gt;此方法 初始化小数可以传doule的数据
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326124552341.png" alt="image-20240326124552341"></p>
<p><strong>Date类</strong></p>
<pre><code class="Java">表示时间
        Date time = new Date();
        System.out.println(time);//Tue Mar 26 14:28:03 CST 2024
//有参的，从时间原点开始放
        Date time2 = new Date(10000l);
        System.out.println(time2);//Thu Jan 01 08:00:10 CST 1970
//方法，设置时间
        Date time = new Date();
        time.setTime(10000l);
        System.out.println(time);//Thu Jan 01 08:00:10 CST 1970
</code></pre>
<p><strong>Calendar类</strong></p>
<pre><code class="Java">1.概述:日历类，抽象类
2.获取的calendar里面的方法：
    static Calendar getInstance();
    ---------------------------------------
     Calendar calendar = Calendar.getInstance();
     System.out.println(calendar);
</code></pre>
<pre><code class="java">
        Calendar calendar = Calendar.getInstance();
        int year = calendar.get(Calendar.YEAR);
        System.out.println(year);//2004

        calendar.set(Calendar.YEAR,2008);
        System.out.println(calendar.get(Calendar.YEAR));//2008

     //的
        System.out.println(time1);//Thu Mar 26 14:44:44 CST 2009
</code></pre>
<p><strong>日期格式化类SimpleDateFormat</strong></p>
<pre><code>格式化日期
2.构造
simpleDateFormat(String pattern);//pattern代表模式，注意字母的大小写不要改变，但是中间的连接符是可以改变的
例如
    yyyy--MM--dd HH:mm:ss
</code></pre>
<p>格式的字母表示</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326144906530.png" alt="image-20240326144906530"></p>
<p>使用</p>
<pre><code class="java">        Date time = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        System.out.println(sdf.format(time) );
//sdf.format(time)将Date对象按照符合日期对格式的字符串
        System.out.println(sdf.parse(time2));//Tue Mar 26 14:56:55 CST 2024     parse的作用将格式化以后的转为date对象
注意因为parse方法底层抛了一个异常,所以我们还要往上面抛
</code></pre>
<p><strong>JDK8新日期类</strong></p>
<p><strong>LocalDate本地时间</strong></p>
<pre><code class="Java">        //通过LocalDate.now();创建对象
        LocalDate ld = LocalDate.now();
        System.out.println(ld);//2024-03-26

//自己设置时间
        LocalDate time = LocalDate.of(2000,3,30);
        System.out.println(time);
</code></pre>
<p><strong>LocalDateTime类</strong></p>
<pre><code>和上面的用法一样只不过更加精确
</code></pre>
<pre><code class="java">获取各个字段
        LocalDateTime time = LocalDateTime.now();
        System.out.println(time.getYear());//2024
        System.out.println(time.getMonth());//MARCH
        System.out.println(time.getMonthValue());//3
        System.out.println(time.getDayOfMonth());//

//设置
        LocalDate time2 =LocalDate.EPOCH.withYear(2000);
        System.out.println(time2);//2000-01-01
---------------------------------------------
    设置月份
        LocalDate time2 =LocalDate.EPOCH.withYear(2000);
        LocalDate time3=time2.withMonth(5);
        System.out.println(time3);//2000-05-01
--------------------------------------------------
    //我们可以将上面设置成链式调用
       LocalDate time2 =LocalDate.EPOCH.withYear(2000).withMonth(5);
        System.out.println(time2);//2000-05-01
</code></pre>
<p>每次使用都会返回一个新的LocalDate对象</p>
<pre><code class="Java">偏移量
    //Plus是向日期大的偏移
        LocalDate time2 =LocalDate.EPOCH.withYear(2000).withMonth(5).plusYears(1);
        System.out.println(time2);//2000-05-01
//minus是像日期小的偏移
        LocalDate time2 =LocalDate.EPOCH.withYear(2000).withMonth(5).minusYears(1);
        System.out.println(time2);//1999-05-01
</code></pre>
<p><strong>Period计算日期之间的偏差</strong></p>
<pre><code class="Java">static Period between(LocalDate d1, LocalDate d2)
----------------------------------------------------
        LocalDate d1 = LocalDate.of(2022,12,12);
        LocalDate d2 = LocalDate.of(2022,12,13);
        Period p =Period.between(d1,d2);
        System.out.println(p.getDays());//1
        System.out.println(p.getYears());//0
        System.out.println(p.getMonths());//0
</code></pre>
<p><strong>Duration计算偏差</strong></p>
<p>计算LocalDateTime的偏差</p>
<pre><code>static Duration between(Temporal startInclusive,Temporal endInclusive)//--&gt;计算时间差
Temporal是接口，实现类有LocalDate和LocalDateTime,所以参数可以是
实现对象，注意需要传递LocalDateTime,因为Duration是计算精确时间的

利用duration计算相差
toDays();
toHours();
toMinutes();
toMillis();//毫秒
</code></pre>
<pre><code class="java">        LocalDateTime d1 = LocalDateTime.of(2022,12,12,10,10,10,10);
        LocalDateTime d2 = LocalDateTime.of(2022,12,13,10,10,10,10);
        Duration duration  = Duration.between(d1,d2);
        System.out.println(duration.toDays());//1
        System.out.println(duration.toHours());//24
        System.out.println(duration.toMillis());//86400000
        System.out.println(duration.toMinutes());//1440
</code></pre>
<p><strong>注意这个计算不是直接减，而是根据时间</strong></p>
<p><strong>DateTimeFormatter日期格式化类</strong></p>
<pre><code>static DateTimeFormatter ofPattern (String pattern)--&gt;获取对象
方法：
String format(TemporalAccessor temporal)-&gt;将日期规则按照指定规则转为字符产
TemporalAccessor parse(CharSequence text) --&gt;和上面的相反


TemporalAccessor是一个接口子接口有Temporal，之前说过他的实现类有LocalDate和LocalDateTime,，所以可以传他们
CharSequence是string接口
</code></pre>
<p>使用</p>
<pre><code class="Java">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
LocalDateTime time = LocalDateTime.now();
System.out.println(time);
System.out.println(dtf.format(time));//2024-03-26 15:59:11

如果想将TemporalAccessor转为我们常见的LocalDateTime日期对象，就需要用到LocalDateTime里面的静态方法
    static LocalDateTime from (TemporalAccessor temporal)
    
    //所以把日期的字符串转为localdatetime
        TemporalAccessor temporalAccessor = dtf.parse(dtf.format(time));
        LocalDateTime localDateTime = LocalDateTime.from(temporalAccessor);
        System.out.println(localDateTime);
    
    
</code></pre>
<p><strong>System工具类</strong></p>
<pre><code>系统相关类
特点
    构造私有，不能使用构造方法new对象
    方法都是静态的
使用
    static long currentTimeMillis()//返回毫秒为单位的当前时间
        long i= System.currentTimeMillis();
        System.out.println(i);//1711452549818
    static void exit(int status)//终止当前的虚拟机
        System.exit(0);
    static void arraycopy(object src ,int srcPos , Object dest ,int desPos,int length) //数组的复制 
    src:原数组
    srcPos:从原数组的哪个索引开始复制
    dest:目标数组
    destPos:从目标数组的哪个位置开始粘贴
    length:复制的长度
    
</code></pre>
<pre><code class="java">       int[] arr = &#123;1,2,3,4,5,6&#125;;
        int[] arr2 = new int[10];
        System.arraycopy(arr,0,arr2,0,5);
        for (int i = 0; i &lt; arr2.length; i++) &#123;
            System.out.println(arr2[i]);
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326193738250.png" alt="image-20240326193738250"></p>
<p>有一个快捷键，这样快速生成遍历数组的方法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326193809404.png" alt="image-20240326193809404"></p>
<p><strong>Arrays数组工具类</strong></p>
<p><strong>记住，没有重写的数组的toString，打印数组是数组的地址值，所以需要toString的方法，和对象一样，使用对象 的toString的方法，只会打印对象的地址值，只有在对象的里面重写toString才可以</strong></p>
<pre><code>构造私有，方法静态
使用：类名直接调用
    static String toString(int[] a)//按照格式打印数组元素
    static int binarySearch(int[] a, int key) //二分查找
    static void sort(int[] a)//升序排列
    static int[] copyOf(int[] orginal ,int newLength)//数组的扩容
</code></pre>
<pre><code class="Java">        int[] a = &#123;1,2,3,4,5&#125;;
        System.out.println(Arrays.toString(a));//[1, 2, 3, 4, 5]
        int[] b = &#123;1,2,5,3,21,1&#125;;
        Arrays.sort(b);
        System.out.println(Arrays.toString(b));//[1, 1, 2, 3, 5, 21]
//二分查找前提是升序，传过去的一定是升序玩的数组
        int[] b = &#123;1,2,5,3,21,1&#125;;
        Arrays.sort(b);
        System.out.println(Arrays.binarySearch(b,2));//2
//数组的扩容
        int[] b = &#123;1,2,5,3,21,1&#125;;
        int[] c = Arrays.copyOf(b,10);
        System.out.println(Arrays.toString(c));//[1, 2, 5, 3, 21, 1, 0, 0, 0, 0]
</code></pre>
<p>**包装类	**</p>
<pre><code>就是基本数据类型对应的类（包装类），我们需要将基本数据类型转为包装类，从而让基本的数据类型拥有类的特性
为什么要学包装类？
    特点的场景。比如要调用方法传递包装类
    包装类转为基本数据类型，因为包装类不能使用+ - 等
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326195728471.png" alt="image-20240326195728471"></p>
<p>比如</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326200154630.png" alt="image-20240326200154630"></p>
<p>这里面需要Integer的类，就需要包装</p>
<p>但是我们传递一个基本数据类型，没有报错为什么？</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326200255602.png" alt="image-20240326200255602"></p>
<p><strong>因为这部操作虚拟机会帮你自动类型转换，转为Integer类</strong></p>
<p><strong>Interger包装类</strong></p>
<pre><code>概述：Interger是int的包装类
使用:构造方法：
Interger(int value);
Interger(String value)
例如
        Integer i = new Integer(1);
        Integer j = new Integer(&quot;10&quot;);
        System.out.println(i);//1
        System.out.println(j);//10
</code></pre>
<p>上面过时了</p>
<pre><code>1.装箱：将基本数据类型转为包装类
2.方法:Integer里的方法
static Integer valueOf(int i)
static Integer valueOf(String s)
这些操作叫做装箱
拆箱：将包装类转为基本的数据类型
 方法
 int intValue()
         Integer i = new Integer(1);
         int k = i.intValue();
</code></pre>
<ul>
<li>拆箱和装箱很多时候都是自动完成的</li>
<li><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326202631150.png" alt="image-20240326202631150"></li>
</ul>
<p>这一步就是在自动装箱</p>
<p>反编译就可以看出来</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326202824007.png" alt="image-20240326202824007"></p>
<p>提问</p>
<pre><code class="Java">        Integer i = 100;//自动装箱
        Integer j = 100;
        System.out.println(i == j);//比较的是地址 //true

        Integer k  =128;
        Integer l = 128;
        System.out.println(k == l);//false
</code></pre>
<p>这是为什么？	</p>
<p>底层的源码</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326203411680.png" alt="image-20240326203411680"></p>
<pre><code>100在这个范围以内，所以直接返回这个数组里面的数据，所以i和j同时指向数组里面的同一个元素
但是128不在这个范围以内，所以直接新建一个新的对象，所以两个k和l不是同一个对象，这个范围是在-128到127数组里面装着-128到127Integer对象
</code></pre>
<p><strong>基本数据类型往String转</strong></p>
<pre><code>1.拼接
    int a  = 1;
    String b = a + &#39;&#39;;	 
2.String的静态方法
static String valueOf(int i)
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326204541033.png" alt="image-20240326204541033"></p>
<ul>
<li>在实际开发中如何定义一个标准的Javabean</li>
</ul>
<pre><code>定义javabean的时候一般会将基本的数据类型变成包装类的类型
</code></pre>
<p>​	比如</p>
<pre><code class="java">public class User &#123;
    private Integer uid;
    private String name;
    private String password;
    public User(Integer uid, String name, String password) &#123;
        this.uid = uid;
        this.name = name;
        this.password = password;
    &#125;

    public User(String password) &#123;
        this.password = password;
    &#125;

    public User(Integer uid) &#123;
        this.uid = uid;
    &#125;
&#125;
</code></pre>
<pre><code>1.如果uid为Integer型(因为是对象没有值是null)，默认值为null
2.将来javabean中的数据和数据库联系起来，我们可以将javabean中数据添加到表中，如果uid为主键自增此时的sql语句不用我们单独维护赋值，添加sql语句就可以这样写；
insert into user(uid,username,password) values (null,&#39;1&#39;,&#39;1&#39;)
3.到时候，我们需要将javabean中封装的数据放在sql语句里面，uid能够自增，而且javabean为包装类型，默认值为null，这样不用单独维护uid的值，也不用给javabean中赋值，然后保存在数据库里面，咱们就可以使用uid的默认值
</code></pre>
<p><strong>多线程</strong></p>
<p>基础知识</p>
<pre><code>进程:在内存中执行的应用程序
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326212838603.png" alt="image-20240326212838603"></p>
<p>这里一个一个都是进程</p>
<pre><code>线程:进程中最小的执行单元
线程的作用:负责进程程序的运行
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326213347771.png" alt="image-20240326213347771"></p>
<p>使用场景，耗时操作就需要多线程</p>
<p>  我们同时同时就可以多件事，这样的话提高了cpu的利用率 </p>
<p><strong>并发和并行</strong></p>
<pre><code>并行:在同一时刻，有多个执行在多个Cpu上同时运行
比如:多个厨师在同时炒多个菜
</code></pre>
<pre><code>并发:在同一时刻，有多个指令在单个Cpu上交替找执行
比如：一个厨师在同时超多个菜
</code></pre>
<p>就是之前说过的同步和异步的概念</p>
<pre><code>细节：
1.之前的cpu是单核，但是在执行多个程序好像是在同时执行，原因是CPU在多个线程之间做高速切换，比如2和4线程，那么CPU可以同时运行4个线程，此时不用切换，但是如果超过了，cPU就要切换了，cpu执行程序的时候，既有并发既有并行
</code></pre>
<p>CPU<strong>的调度</strong></p>
<pre><code>分时调度:是让所有的线程轮流CPU使用权，并且平均分配每个线程占用CPU的时间片
抢占调度:多个线程轮流抢占CPU的使用权，哪个线程抢到了，哪个线程先执行，优先级高的纪律比较大，
</code></pre>
<p>我们JAVA就是抢占式调度</p>
<p><strong>主线程</strong></p>
<p>就是main方法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327205244012.png" alt="image-20240327205244012"></p>
<p><strong>创建线程</strong></p>
<p><strong>第一种方法：继承Threads的类</strong></p>
<pre><code>1.定义一个类，继承Thread
2.重写run方法，在run方法中设置线程任务（所谓的线程任务指的就是此线程要执行 的具体代码）
3.创建自定义线程类的对象
4.调用Thread里的start的方法，开启线程，虚拟机自动调用run方法
</code></pre>
<p>例如</p>
<pre><code class="java">package lianxi_Thread;

public class MyThread extends Thread&#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 5; i++) &#123;
            System.out.println(&quot;Thread执行&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="Java">package lianxi_Thread;

public class Test &#123;
    public static void main(String[] args) &#123;
        //创建线程对象
        MyThread myThread = new MyThread();
//        调用start方法，开启线程，虚拟机自动调用run方法
        myThread.start();
        //主线程的任务
        for (int i = 0; i &lt; 5; i++) &#123;
            System.out.println(&quot;main&quot;+i);
        &#125;

    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327210425055.png" alt="image-20240327210425055"></p>
<p>输出和cpu的调度有关，哪个抢到执行权</p>
<p><strong>如果不开启线程，就是按照顺序执行的</strong></p>
<p><strong>多线程的运行原理</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327210754267.png" alt="image-20240327210754267"></p>
<p>当我们调用start的方法以后，就会在栈空间执行写在run方法里面的代码</p>
<p>注意</p>
<p><strong>start方法调用一次就可以</strong></p>
<p><strong>Thread的方法</strong></p>
<pre><code>void start() -&gt;开启线程自动调用run方法
void run() -&gt;设置线程任务，线程任务写在这里
String getName() -&gt;获取线程名字
void setName() -&gt;设置名字
static Thread currentThread() -&gt;获取正在执行的线程对象（此方法在哪个线程使用，获取的就是哪个线程对象）
static void sleep(long mills) -&gt;线程睡眠，设置时间，这个时间段里面，这个线程不会执行
</code></pre>
<p>例如</p>
<pre><code class="Java">package lianxi_Thread;

public class MyThread extends Thread&#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 100; i++) &#123;
            System.out.println(getName()+&quot;Thread&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package lianxi_Thread;

public class Test &#123;
    public static void main(String[] args) &#123;
        //创建线程对象
        MyThread myThread = new MyThread();
//        调用start方法，开启线程，虚拟机自动调用run方法
        myThread.setName(&quot;haha&quot;);
        myThread.start();
        for (int i = 0; i &lt; 100; i++) &#123;
            System.out.println(Thread.currentThread().getName()+&quot;main&quot;+i);
        &#125;

    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327212139128.png" alt="image-20240327212139128"></p>
<p><strong>前面就是我们的线程的名字</strong></p>
<p><strong>Thread.sleep</strong></p>
<pre><code class="Java">        MyThread myThread = new MyThread();
//        调用start方法，开启线程，虚拟机自动调用run方法
        myThread.setName(&quot;haha&quot;);
        myThread.start();
        try &#123;
            Thread.sleep(1000);
        &#125; catch (Exception e)&#123;
            System.out.println(e);
        &#125;
        for (int i = 0; i &lt; 100; i++) &#123;
            System.out.println(Thread.currentThread().getName()+&quot;main&quot;+i);
        &#125;
</code></pre>
<p>这里面还有一个问题</p>
<p>在其他的线程里面，不能使用throws向上抛出异常</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327212844355.png" alt="image-20240327212844355"></p>
<p>但是在主线程，可以抛出异常</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327212921665.png" alt="image-20240327212921665"></p>
<p>原因之前说过</p>
<pre><code class="java">public class MyThread extends Thread&#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 100; i++) &#123;
            Thread.sleep(1000);
            System.out.println(getName()+&quot;Thread&quot;+i);
        &#125;
    &#125;
&#125;
//因为上面run方法是重写父类的，但是父类没有抛这个异常，子类就不可以，所以只能使用try catch
</code></pre>
<p><strong>Thread的其他的方法</strong></p>
<pre><code class="Java">void setPriority(int newPriority) -&gt;线程的优先级，优先级越高的线程，抢到cpu使用率几率越大，
int getPriority()	-&gt;获取线程的优先级
void setDaemon(boolean on) -&gt;设置守护线程,当非守护线程执行完毕，守护线程就要结束
static void yield() -&gt;礼让线程让当前的线程让出cpu的使用权
void join() -&gt; 插入线程或者插队线程
</code></pre>
<pre><code>默认的优先级是5；
最小的优先级是1；
最大的优先级是10;
</code></pre>
<pre><code class="Java">MyThread myThread = new MyThread();
myThread.setName(&quot;线程1&quot;);
MyThread myThread1 = new MyThread();
myThread1.setName(&quot;线程2&quot;);


System.out.println(myThread1.getPriority());//5
System.out.println(myThread.getPriority());//5
myThread1.setPriority(1);
myThread.setPriority(10);

myThread1.start();
myThread.start();
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327221022276.png" alt="image-20240327221022276"></p>
<p>守护线程的使用</p>
<pre><code class="Java">package lianxi_Thread;

public class Test &#123;
    public static void main(String[] args)&#123;
        MyThread1 myThread1 = new MyThread1();
        myThread1.setName(&quot;线程1&quot;);
        MyThread2 myThread2 = new MyThread2();
        myThread2.setName(&quot;线程2&quot;);
        myThread1.setDaemon(true);
        myThread1.start();
        myThread2.start();
    &#125;
&#125;
</code></pre>
<pre><code class="Java">package lianxi_Thread;

public class MyThread1 extends Thread&#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 100; i++) &#123;
            System.out.println(getName()+&quot;:Thread&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package lianxi_Thread;

public class MyThread2 extends Thread&#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(getName()+&quot;:Thread&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code>守护线程设置100次循环，非守护线程设置10次，当我们的非守护线程执行完以后，守护线程就会停止
注意
守护线程不是立马结束的，当非守护线程执行完，会通知守护线程，这需要一点时间
</code></pre>
<p>使用场景</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327222327738.png" alt="image-20240327222327738"></p>
<p><strong>礼让线程</strong></p>
<pre><code>如果两个线程一起执行，可能执行一会a,在执行一会b，或者可能线程a执行完线程b在执行，那么如果我们想要均衡点，尽量让两个线程交替执行
</code></pre>
<pre><code class="Java">package lianxi_Thread;

public class MyThread1 extends Thread&#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(getName()+&quot;:Thread&quot;+i);
            Thread.yield();
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>注意只是尽可能的平衡，不是绝对的你来我往</strong></p>
<p><strong>插入线程</strong></p>
<p>就是插队</p>
<pre><code class="java">package lianxi_Thread;

public class Test &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        MyThread1 myThread1 = new MyThread1();
        myThread1.setName(&quot;线程1&quot;);

        myThread1.start();
        //表示把myThread1插入到当前的线程的前面。myThread1插在main线程之前
        myThread1.join();
        for (int i = 0; i &lt; 5; i++) &#123;
            System.out.println(&quot;main&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327223353863.png" alt="image-20240327223353863"></p>
<p><strong>第二种方法实现Runnable接口</strong></p>
<pre><code>1.因为Thread里面的run方法是实现Runnable接口，所以我们直接实现Runnable的接口就可以了
</code></pre>
<pre><code>创建类，实现Runnable接口
重写Run方法，设置线程任务
利用Thread的构造方法，Thread有一个这样得到构造函数Thread(Runnable target),将自定义的类作为参数传递到Thread构造中
调用Thread的start的方法，虚拟机自动调用run
</code></pre>
<p>例子</p>
<pre><code class="Java">package wei_Runnable;

public class MyRunnable implements Runnable &#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
         System.out.println(Thread.currentThread().getName()+i);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package wei_Runnable;

public class Test &#123;
    public static void main(String[] args) &#123;
        MyRunnable r = new MyRunnable();
        Thread t =  new Thread(r);
        
        t.start();
        
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(Thread.currentThread().getName()+i);
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328083338637.png" alt="image-20240328083338637"></p>
<p><strong>两种方式的区别</strong></p>
<pre><code>继承的Thread的只能支持单继承，有继承的局限性，
实现接口，既可以继承父类还可以实现接口
</code></pre>
<p><strong>第三种方式匿名内部类创建多线程</strong></p>
<pre><code>严格的来说不是第三种方法，而是匿名内部类是建立在实现Runnable的接口的基础上
</code></pre>
<pre><code class="java">        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                for (int i = 0; i &lt; 10; i++) &#123;
                    System.out.println(Thread.currentThread().getName()+i);
                &#125;
            &#125;
        &#125;).start();
</code></pre>
<pre><code class="java">        Thread t1 = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                for (int i = 0; i &lt; 10; i++) &#123;
                    System.out.println(Thread.currentThread().getName()+i);
                &#125;
            &#125;
        &#125;);
        t1.start()
</code></pre>
<p>如果想取名</p>
<pre><code class="java">Thread(Runnable a, String name);使用这个构造函数
</code></pre>
<p><strong>线程安全问题</strong></p>
<pre><code>当多个线程访问一个资源的时候，就是之前解释为什么Js是单线程，就是因为害怕，多个线程操作同一个dom元素，就会出现问题
</code></pre>
<p>例如</p>
<pre><code class="java">package wei_Runnable;

public class  MyRunnable implements Runnable &#123;
    int ticket = 100;

    @Override
    public void run() &#123;
        while (true)&#123;
            if (ticket &gt; 0)&#123;
                System.out.println(Thread.currentThread().getName()+&quot;买了&quot;+ticket+&quot;票&quot;);
                ticket--;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package wei_Runnable;

public class Test &#123;
    public static void main(String[] args) &#123;
        MyRunnable r = new MyRunnable();
        Thread t1 =  new Thread(r,&quot;张三&quot;);
        Thread t2 =  new Thread(r,&quot;李四&quot;);
        Thread t3 =  new Thread(r,&quot;王五&quot;);

        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;
</code></pre>
<p>执行，我们就发现，三个线程访问同一个资源发生了问题</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328085213139.png" alt="image-20240328085213139"></p>
<pre><code>原因：CPU在多个线程做告诉切换导致的
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328085439813.png" alt="image-20240328085439813"></p>
<ul>
<li>我们把这个三个线程当作小红，小蓝和小绿，当我们小红抢到执行权，输出以后，还没有执行ticket–，就因为cpu的高速切换，导致小红停在那里，然后小兰执行，此时的票还是100；</li>
</ul>
<p>解决这个问题。<strong>抽象一点，我们可以上锁</strong></p>
<p><strong>使用同步代码块</strong></p>
<pre><code class="java">格式
synchronized(任意对象)&#123;
    线程出现不安全的地方
&#125;
2.任意对象就是我们的锁对象
3.执行特点，一个线程拿到锁以后，会进入到同步代码块，再次期间，其他的线程拿不到锁，就进不去同步代码块，需要等待执行的线程，执行完毕以后，出了同步代码块执行，相当于释放锁，等待的线程才能抢到锁
</code></pre>
<p>例如</p>
<pre><code class="java">public class  MyRunnable implements Runnable &#123;
    int ticket = 100;
    Object o = new Object();

    @Override
    public void run() &#123;
        while (true)&#123;
            synchronized (o)&#123;
                if (ticket &gt; 0)&#123;
                    System.out.println(Thread.currentThread().getName()+&quot;买了&quot;+ticket+&quot;票&quot;);
                    ticket--;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code>随便创建一个对象，然后把有线程问题的代码放在里面
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328091016832.png" alt="image-20240328091016832"></p>
<p>这样就不会出现买同一张的票的情况</p>
<p>注意</p>
<pre><code class="java">            synchronized (new Object())&#123;
                if (ticket &gt; 0)&#123;
                    System.out.println(Thread.currentThread().getName()+&quot;买了&quot;+ticket+&quot;票&quot;);
                    ticket--;
                &#125;
</code></pre>
<pre><code>不能直接在这里面创建锁对象，只能有一个锁对象，每当我们，创建线程，调用run方法，就会出来一个新的锁对象，记住只能有一个锁
</code></pre>
<p><strong>解决方法二 	普通同步方法</strong></p>
<p>1.非静态的</p>
<pre><code>格式
    修饰符 synchronize 返回值类型 方法名(参数)&#123;
    方法体
    return 结果
    &#125;
    默认的锁对象是this
</code></pre>
<p>例子</p>
<pre><code class="java">package wei_Runnable;

public class  MyRunnable implements Runnable &#123;
    int ticket = 100;

    @Override
    public void run() &#123;
        while (true)&#123;
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                throw new RuntimeException(e);
            &#125;
            func();
        &#125;
    &#125;
    public synchronized void func()&#123;
        if (ticket &gt; 0)&#123;
            System.out.println(Thread.currentThread().getName()+&quot;买了&quot;+ticket+&quot;票&quot;);
            ticket--;
        &#125;
    &#125;
&#125;
</code></pre>
<p>2.静态的同步方法</p>
<pre><code>格式
修饰符 static sychronized 返回值类型 方法(参数)&#123;
    方法体
    return 结果
&#125;
默认锁:class对象
</code></pre>
<pre><code class="java">package wei_Runnable;

public class  MyRunnable implements Runnable &#123;
    static int ticket = 100;

    @Override
    public void run() &#123;
        while (true)&#123;
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                throw new RuntimeException(e);
            &#125;
            func();
        &#125;
    &#125;
    public static synchronized void func()&#123;
        if (ticket &gt; 0)&#123;
            System.out.println(Thread.currentThread().getName()+&quot;买了&quot;+ticket+&quot;票&quot;);
            ticket--;
        &#125;
    &#125;
&#125;
</code></pre>
<p>之前说过StringBuilder是线程不安全的，StringBuffer是线程安全的</p>
<p>因为StringBuffer的底层源码</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328092416232.png" alt="image-20240328092416232"></p>
<p>都是同步方法</p>
<p><strong>死锁</strong></p>
<pre><code>指两个或者两个以上的线程在执行的过程中由于竞争同步锁，而产生的一种堵塞的情况；如果没有外力的作用，他们将无法继续执行下去，这种情况叫做死锁
</code></pre>
<p>就是如下图的情况</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328135449157.png" alt="image-20240328135449157"></p>
<p>例子</p>
<p>创建两个锁对象</p>
<pre><code class="java">package sisuo;

public class Lock1 &#123;
    public static Lock1 lock1 = new Lock1();
&#125;
</code></pre>
<pre><code class="java">package sisuo;

public class Lock2 &#123;
    public static Lock2 lock2 = new Lock2();
&#125;
</code></pre>
<pre><code class="java">package sisuo;

public class DieLock implements Runnable &#123;
    private Boolean flag;

    public DieLock(Boolean flag) &#123;
        this.flag = flag;
    &#125;

    @Override
    public void run() &#123;
        if (flag)&#123;
            synchronized (Lock1.lock1)&#123;
                System.out.println(&quot;if...Lock1&quot;);
                synchronized (Lock2.lock2)&#123;
                    System.out.println(&quot;else...Lock2&quot;);
                &#125;
            &#125;
        &#125; else &#123;
            synchronized (Lock2.lock2)&#123;
                System.out.println(&quot;if...Lock2&quot;);
                synchronized (Lock1.lock1)&#123;
                    System.out.println(&quot;else...Lock1&quot;);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package sisuo;

public class Test &#123;
    public static void main(String[] args) &#123;
        DieLock dieLock1 = new DieLock(true);
        DieLock dieLock2 = new DieLock(false);

        new Thread(dieLock1).start();
        new Thread(dieLock2).start();
    &#125;
&#125;
</code></pre>
<p>这是我们发现死锁了 </p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328141112921.png" alt="image-20240328141112921"></p>
<pre><code class="java">解释一下
当开启我们的两个线程，第一个线程进入
                synchronized (Lock1.lock1)&#123;
                System.out.println(&quot;if...Lock1&quot;);
                synchronized (Lock2.lock2)&#123;
                    System.out.println(&quot;else...Lock2&quot;);
                &#125;
            
   第二个线程进入
                   synchronized (Lock2.lock2)&#123;
                System.out.println(&quot;if...Lock2&quot;);
                synchronized (Lock1.lock1)&#123;
                    System.out.println(&quot;else...Lock1&quot;);
                &#125;
            &#125;
    但是第一个线程要进入我们的锁二的时候，锁二的执行权还在第二个线程，第二个线程必须得进入锁一才可以继续运行，这是就出现这个问题
</code></pre>
<ul>
<li>其实如果线程一执行的抢到执行权快的话，有可能把两个锁都给拿到</li>
</ul>
<pre><code>锁嵌套尽量要避免
</code></pre>
<p><strong>线程的生命周期</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328142105507.png" alt="image-20240328142105507"></p>
<p>sleep和wait的区别</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328142544754.png" alt="image-20240328142544754"></p>
<p>wait和notify</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328142857290.png" alt="image-20240328142857290"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328142905586.png" alt="image-20240328142905586"></p>
<p>而且注意</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328143038677.png" alt="image-20240328143038677"></p>
<p><strong>等待唤醒</strong></p>
<pre><code>void wait()//线程等待过程中会释放锁，需要其他的其他的线程使用notify方法将其唤醒
void notify()//线程等待唤醒；如果有多条，随机唤醒一条
void notifyAll( )//唤醒所有的等待的线程
而且这些方法需要使用锁对象调用，所以需要用到同步代码块，而且必须是同一个锁对象
</code></pre>
<p>案例</p>
<pre><code>要求一个线程生产包子，一个线程吃包子，但是不能连续生产和消费，只能造一个吃一个
</code></pre>
<pre><code class="java">package baozipu;

public class Baozipu &#123;
    private int count;
    private boolean flag;

    public Baozipu(int count, Boolean flag) &#123;
        this.count = count;
        this.flag = flag;
    &#125;

    public Baozipu(Boolean flag) &#123;
        this.flag = flag;
    &#125;

    public Baozipu(int count) &#123;
        this.count = count;
    &#125;

    public Baozipu() &#123;
    &#125;

    public void getCount() &#123;
        System.out.println(&quot;消费了&quot;+count+&quot;包子&quot;);
    &#125;

    public void setCount() &#123;
        count++;
        System.out.println(&quot;生产了&quot;+count+&quot;包子&quot;);
    &#125;

    public Boolean getFlag() &#123;
        return flag;
    &#125;

    public void setFlag(Boolean flag) &#123;
        this.flag = flag;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package baozipu;

public class Consumer implements Runnable &#123;
    private Baozipu baozipu;

    public Consumer(Baozipu baozipu) &#123;
        this.baozipu = baozipu;
    &#125;

    @Override
    public void run() &#123;
        while(true)&#123;
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                throw new RuntimeException(e);
            &#125;
            //如果没有包子等待，让出线程给生产者
            synchronized (baozipu)&#123;
                if (baozipu.getFlag() == false)&#123;
                    try &#123;
                        baozipu.wait();
                    &#125; catch (InterruptedException e) &#123;
                        throw new RuntimeException(e);
                    &#125;
                &#125;
                //flag为false证明没有包子
                baozipu.getCount();
                //设置包子噗没有包子了
                baozipu.setFlag(false);
                //唤醒生产线程
                baozipu.notify();

            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package baozipu;

public class Product implements Runnable&#123;
    private Baozipu baozipu;

    public Product(Baozipu baozipu) &#123;
        this.baozipu = baozipu;
    &#125;

    @Override
    public void run() &#123;
        while(true)&#123;
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                throw new RuntimeException(e);
            &#125;
            //如果有包子让出线程给消费者
            synchronized (baozipu)&#123;
                if (baozipu.getFlag() == true)&#123;
                    try &#123;
                        baozipu.wait();
                    &#125; catch (InterruptedException e) &#123;
                        throw new RuntimeException(e);
                    &#125;
                &#125;
                //flag为false证明没有包子，生产包子
                baozipu.setCount();
                //生产完证明有包子
                baozipu.setFlag(true);
                //唤醒生产线程
                baozipu.notify();

            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package baozipu;

public class Test &#123;
    public static void main(String[] args) &#123;
        Baozipu baozipu = new Baozipu();

        Product product = new Product(baozipu);
        Consumer consumer = new Consumer(baozipu);


        new Thread(product).start();
        new Thread(consumer).start();
    &#125;
&#125;
</code></pre>
<p><strong>第二中解决线程不安全Lock锁</strong></p>
<pre><code>1.Lock是一个接口
2.实现类:ReaentrantLock
3.方法:
lock() //获得锁
unlock()//释放锁
</code></pre>
<p>使用</p>
<pre><code class="java">package wei_Runnable;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class  MyRunnable implements Runnable &#123;
    static int ticket = 100;
    Lock lock = new ReentrantLock();
    @Override
    public void run() &#123;
        while (true)&#123;
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                throw new RuntimeException(e);
            &#125;
            //获得锁
            lock.lock();
            if (ticket &gt; 0) &#123;
                System.out.println(Thread.currentThread().getName() + &quot;买了&quot; + ticket + &quot;票&quot;);
                ticket--;
            &#125;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<p>不管我们if里面是否发生了错误，我们都应该执行释放锁，所以我们可以包裹try catch然后用finally放释放锁的</p>
<p>有什么区别呢和synchronize</p>
<pre><code>synchronize:不管是同步代码还是同步方法，都需要在结束一对&#123;&#125;之后，释放锁对象
Lock,通过两个方法控制
</code></pre>
<p><strong>Callable接口</strong></p>
<pre><code>之前实现多线程继承Thread或者实现Runnable
第三种就是实现Callable接口
方法
 v call()-&gt;设置线程任务，类似于Run方法
 call和run方法的区别
 相同点：都是设置线程任务的
 不同点：call方法有返回值，而且有异常可以throws
         run方法没有返回值，而且有异常不可以throws
&lt;V&gt;
 叫做泛型，用于指定我们操作什么类型的数据 ，而且尖括号里面只能写引用数据类型，如果泛型不写默认是Object的数据
 实习Callable方法接口的时候，指定泛型是什么类型，重写的call方法的返回值就是什么类型的
 
 
 获取call方法的会返回值：FutureTask
 a.FutureTask&lt;V&gt;//实现一个接口FutureTask&lt;T&gt;
 b.FutureTask&lt;V&gt;有一个方法
     V get()//获取call的返回值 
</code></pre>
<p>使用</p>
<pre><code class="java">package chenw_callable;

import java.util.concurrent.Callable;

public class MyCallable implements Callable&lt;Integer&gt; &#123;
    @Override
    public Integer call() throws Exception &#123;
        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package chenw_callable;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class Test &#123;
    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        MyCallable myCallable = new MyCallable();
        FutureTask&lt;Integer&gt; integerFutureTask = new FutureTask&lt;&gt;(myCallable);
        //创建Thread对象-》
        Thread thread = new Thread(integerFutureTask);
        thread.start();
        //调用get方法获取call方法的返回值
        System.out.println(integerFutureTask.get());
    &#125;
&#125;
</code></pre>
<p><strong>线程池</strong></p>
<p><strong>实现多线程的方式之一</strong></p>
<pre><code>之前来一个线程任务，就需要创建一个线程对象去执行,用完还要销毁线程对象,如果线程任务多了，就要需要频繁创建线程对象和销毁对象，这样耗费内存资源，所以我们线程对象能不能循环利用，用的时候直接拿线程对象，用完还回去 
</code></pre>
<pre><code>创建线程池对象，指定池子最多有多少条线程对象
来了第一个线程任务，看池子中有没有线程对象，如果没有，创建线程对象，给现场任务用，用完还回去
</code></pre>
<p>使用</p>
<pre><code>创建线程池:用具类-&gt;Excutors
2.获取线程池对象Excutors中的静态方法
static ExcutorService newFindedThreadPool(int nThreads)
参数指定：指定线程池中最多的线程对象条数
返回值ExecutorService是线程池，用来管理线程对象
执行线程任务:ExecutorService 中的方法
Future&lt;?&gt; submit(Runnable task)//提交一个runnable的任务
Future&lt;?&gt; submit(callable&lt;T&gt; task)//提交一盒callable执行
4.submit的返回值：future接口
    用于接收run方法或者call方法的返回值，但是run方法没有返回值，所以可以不用Future接收，执行call方法需要Future进行接收
     Future里面有一个
     V get()，用于接受call方法的返回值
     
5.ExcutorService里面的方法：
    void shutdown()  关闭线程池，不会接受新的线程任务
</code></pre>
<p>例子</p>
<pre><code class="java">package wei_ThreadPool;

public class MyRunnable implements Runnable&#123;
    @Override
    public void run() &#123;
        System.out.println(Thread.currentThread().getName()+&quot;执行了&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package wei_ThreadPool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Test &#123;
    public static void main(String[] args) &#123;
        ExecutorService es= Executors.newFixedThreadPool(2);
        es.submit(new MyRunnable());
        es.submit(new MyRunnable());
        es.submit(new MyRunnable());
        es.shutdown();//关闭线程池
    &#125;
&#125;
</code></pre>
<p>执行结果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240329170346929.png" alt="image-20240329170346929"></p>
<pre><code>因为我们创建两个线程，所以当我们提交的第三个任务以后，首先线程池里面的线程1，2分别就会执行任务1和任务2，当我们其中的一个任务执行完以后，那么执行完以后的线程就会执行任务三
</code></pre>
<p>使用callable的方法实现</p>
<pre><code class="java">package wei_ThreadPool;

import java.util.concurrent.Callable;

public class MyCallable implements Callable &#123;
    @Override
    public Integer call() throws Exception &#123;
        return 1;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package wei_ThreadPool;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Test1 &#123;
    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        Future&lt;Object&gt; future=executorService.submit(new MyCallable());//call方法就会有返回值，我们可以看使用Future进行接受
        System.out.println(future.get());
        System.out.println();

    &#125;
&#125;
</code></pre>
<pre><code>因为call方法有返回值，所以我们可以使用future进行接受	
</code></pre>
<pre><code>练习设置线程池为2，一个线程输出字符串，一个线程求总和
</code></pre>
<pre><code class="Java">package ThreadPool_pratice;

import java.util.concurrent.Callable;

public class PrintString implements Callable&lt;String&gt; &#123;
    @Override
    public String call() throws Exception &#123;
        return &quot;那一夜你伤害了我&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="Java">package ThreadPool_pratice;

import java.util.concurrent.Callable;

public class PrintSum implements Callable&lt;Integer&gt; &#123;
    @Override
    public Integer call() throws Exception &#123;
        int sum = 0;
        for (int i = 0; i &lt; 100; i++) &#123;
            sum +=i;
        &#125;
        return sum;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package ThreadPool_pratice;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Test &#123;
    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        Future&lt;String&gt; future1=executorService.submit(new PrintString());
        Future&lt;Integer&gt; future2 = executorService.submit(new PrintSum());
        System.out.println(future1.get());
        System.out.println(future2.get());
        executorService.shutdown();
    &#125;
&#125;
</code></pre>
<p><strong>定时器Timer</strong></p>
<pre><code>构造
 Timer();//空参构造
方法
void schedule(TimeTask task,Data firstTime,long period)
    task:抽线类，是Runable的实现类
    firstTime:从什么时间开始执行
    period:每个多长时间执行一次，设置的是毫秒值
</code></pre>
<p>例子，使用匿名内部类</p>
<pre><code class="java">public class Demo &#123;
    public static void main(String[] args) &#123;
        Timer timer = new Timer();
        timer.schedule(new TimerTask() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;金莲对我说&quot;);
            &#125;
        &#125;,new Date(),2000);
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240329173026063.png" alt="image-20240329173026063"></p>
<p>这样每隔2秒就会执行</p>
<ul>
<li>这里面的timer就相当于js里面的setTimenterval</li>
</ul>
<p><strong>复习</strong></p>
<p><strong>集合</strong></p>
<p><strong>collection集合</strong></p>
<p><strong>单列集合框架</strong></p>
<pre><code>1.之前学过保存数据的有：变量，数组，但是数组定长，所以如果添加一个数据或者删除一个数据就要创建一个新的数组，所以学一个长度可变，就是集合
集合的特点
 只能保存引入数据类型的数据（如果传入的是基本的数据类型，就会对应的包装成相应的包装类）
 长度是可变的
 集合有大量的方法
分类
    单列集合:一个元素就一个组成部分list.add(value)
    双列集合：一个集合有两个部分构成:key和value，例如map.put(key,value)
</code></pre>
<ul>
<li>单列集合的顶级接口是Collection接口</li>
</ul>
<p>  <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240329181611468.png" alt="image-20240329181611468"></p>
<ul>
<li><p>list有三个实现类</p>
<ul>
<li>ArrayList:<ul>
<li>元素是有序的，按照什么顺序存的输出也是什么顺序</li>
<li>元素是可以重复的</li>
<li>每一个元素都有对应的索引</li>
<li>线程不安全</li>
<li>底层数据结构是数组，但是长度是可变的</li>
</ul>
</li>
<li>LikedList<ul>
<li>元素有序</li>
<li>元素可重复</li>
<li>有索引</li>
<li>线程不安全</li>
<li>底层数据结构：双向链表</li>
</ul>
</li>
<li>Vector<ul>
<li>元素有序</li>
<li>元素可以重复</li>
<li>有索引</li>
<li>线程安全 效率比较低</li>
<li>底层数据结构：数组</li>
</ul>
</li>
</ul>
</li>
<li><p>set接口有三个实现类</p>
<ul>
<li>HashSet<ul>
<li>元素无序</li>
<li>元素唯一</li>
<li>没有索引</li>
<li>线程不安全</li>
<li>底层数据结构哈希表</li>
</ul>
</li>
<li>LikedSet(<strong>继承于HashSet</strong>)<ul>
<li>继承与HashSet，其他的特点一致，但是他的元素是有序的</li>
<li>有序的原因是：他的底层结构是哈希表加上双向链表</li>
</ul>
</li>
<li>treeSet<ul>
<li>可以对元素进行排序</li>
<li>元素唯一</li>
<li>没有索引</li>
<li>线程不安全</li>
<li>底层数据结构<ul>
<li>红黑树</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>集合的框架</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240330161805160.png" alt="image-20240330161805160"></p>
<ul>
<li>LinkList本质上没有索引，但是java为其提供很多根据索引操作元素的方法</li>
</ul>
<p><strong>Collection接口</strong></p>
<pre><code>1.单列集合的顶级接口
2.使用:
    Collection&lt;E&gt; 对象名 = new 实现类对象&lt;E&gt;()
    E是泛型，决定集合中能够存储什么类型的数据，可以统一元素类型
    泛型中只能写引用数据类型，如果不写默认Object，这样所有的数据类型都可以存储
    注意之前说过，集合里面的数据类型是引用数据类型，就是因为泛型的原因
    &lt;Integer&gt;这样存储的就数字
这里的泛型的细节：
    我们等号前面的泛型必须写，等号后面的泛型可以不写，jvm里面有一段话，可推导的代码，就可以省略
常用代码
    boolean add(E e):将给定的元素添加到当前集合中（我们一般调用add的时候，不用boolean，因为add一定成功）
    boolean addAll(Colleaction&lt;? extend E&gt; c):将另一个集合元素添加到当前的集合中
    void clear():清除集合中的所有元素
    boolean contains(object o)//判断当前的集合是否有该元素
    boolean isEmpty()判断当前集合是否有元素
    boolean remove(object o)将指定的元素从集合中删去
    int size()返回集合的元素个数
    Object[] toArray()  将集合的元素储存在数组中
</code></pre>
<p>例子</p>
<pre><code class="Java">package wei_Collection;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Objects;

public class Test &#123;
    public static void main(String[] args) &#123;
        Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();
        collection.add(&quot;消炎&quot;);
        collection.add(&quot;小云儿&quot;);
        System.out.println(collection);//[消炎, 小云儿]

        Collection&lt;String&gt; collection1 = new ArrayList&lt;&gt;();
        collection1.add(&quot;zhang&quot;);
        collection1.add(&quot;wu&quot;);
        collection1.add(&quot;ji&quot;);
        collection.addAll(collection1);
        System.out.println(collection);//[消炎, 小云儿, zhang, wu, ji]

        collection1.clear();
        System.out.println(collection1);//[]

        System.out.println(collection.contains(&quot;zhang&quot;));//true

        System.out.println(collection1.isEmpty());//true

        collection.remove(&quot;zhang&quot;);
        System.out.println(collection);//[消炎, 小云儿, wu, ji]

        System.out.println(collection.size());//4

        Object[] arr = collection.toArray();
        System.out.println(Arrays.toString(arr));//[消炎, 小云儿, wu, ji]
    &#125;
&#125;
</code></pre>
<p><strong>迭代器</strong></p>
<pre><code>概述Interator
主要作用：Collection中的方法获取
Interator&lt;E&gt; interator()
方法
boolean hasNext() -&gt;判断集合有没有下一个元素
E next() -&gt;获取下一个元素
</code></pre>
<pre><code class="java">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;haha&quot;);
        list.add(&quot;nihao&quot;);
        Iterator&lt;String&gt; iterator = list.iterator();
        while(iterator.hasNext())&#123;
            System.out.println(iterator.next());//haha//nihao
        &#125;
</code></pre>
<p><strong>迭代器迭代过程</strong></p>
<p><strong>迭代器原理分析</strong></p>
<pre><code class="Java">Iterator是一个接口，等号右边一定是他的实现类对象
问题 Interator接受的到底是哪个实现类对象呢？-》ArrayList的是Itr对象
    public Iterator&lt;E&gt; iterator() &#123;
        return new Itr();
    &#125;
    private class Itr implements Iterator&lt;E&gt;
</code></pre>
<p><strong>并发修改异常</strong></p>
<p><strong>ConcurrentModificationException</strong></p>
<p>出现异常的原因</p>
<pre><code class="java">ArrayList&lt;String&gt; xiyou = new ArrayList&lt;&gt;();
xiyou.add(&quot;猪八戒&quot;);
xiyou.add(&quot;孙悟空&quot;);
xiyou.add(&quot;沙僧&quot;);
xiyou.add(&quot;白龙马&quot;);
Iterator&lt;String&gt; iterator1 = xiyou.iterator();
while (iterator1.hasNext())&#123;
    String item = iterator1.next();
    if (Objects.equals(item,&quot;猪八戒&quot;))&#123;
        xiyou.add(&quot;haha&quot;);
    &#125;
&#125;
</code></pre>
<p>这个出现的原因</p>
<p>发现问题出现在这里</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240330192316090.png" alt="image-20240330192316090"></p>
<p>我们查看一下底层的源码</p>
<pre><code class="java">在我们执行
        Iterator&lt;String&gt; iterator1 = xiyou.iterator();
这句话的时候，下面的关键的代码
    当我们创建迭代器对象的的时候初始化，实际操作次数和预期操作次数相等
    modCount是实际操作次数
    expectedModCount 是预期的操作次数
    private class Itr implements Iterator&lt;E&gt; &#123;
        int expectedModCount = modCount;
        public E next() &#123;
            checkForComodification();
        &#125;
        我们再看checkForComodification函数，这里在判断预期次数和实际次数是否相等，不相等抛出异常
     final void checkForComodification() &#123;
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        &#125;
        再看add方法，这里面使得我们的实际的操作次数++，而且这个不会赋给预期操作次数，因为初始化的时候才会赋值，这样就就会使得我们的预期操作次数和实际操作次数不相等，
     public boolean add(E e) &#123;
        modCount++;
        add(e, elementData, size);
        return true;
    &#125;
</code></pre>
<ul>
<li>结论我们调用add方法，而add方法底层只给modcount++ 但是在调用next并没有给修改的后的modcount赋给expectmodcout导致这个问题</li>
</ul>
<p>解决的方法</p>
<p>listInterator</p>
<pre><code class="Java">ArrayList&lt;String&gt; xiyou = new ArrayList&lt;&gt;();
xiyou.add(&quot;猪八戒&quot;);
xiyou.add(&quot;孙悟空&quot;);
xiyou.add(&quot;沙僧&quot;);
xiyou.add(&quot;白龙马&quot;);
ListIterator&lt;String&gt; iterator1 = xiyou.listIterator();
while (iterator1.hasNext())&#123;
    String item = iterator1.next();
    if (Objects.equals(item,&quot;猪八戒&quot;))&#123;
        iterator1.add(&quot;haha&quot;);
    &#125;
&#125;
System.out.println(xiyou);//[猪八戒, haha, 孙悟空, 沙僧, 白龙马]
</code></pre>
<ul>
<li>使用迭代器的时候不要修改数据的长度</li>
</ul>
<p><strong>数据结构</strong></p>
<pre><code>数据结构是一种具有一定逻辑关系	，在计算机中应用某种储存结构，并且封装了相应操作的数据元素集合，他还包含三方面内容，逻辑关系，存储关系和操作
</code></pre>
<p><strong>为什么需要数据结构</strong></p>
<pre><code>随着程序的变得更复杂还丰富，几百万的数据就会出现，面对这么打的数据进行搜素，插入，或者排序操作越来越慢，数据结构就是解决这种问题
</code></pre>
<p><strong>栈结构</strong></p>
<pre><code>特点:
    先进后出：例如手枪压子弹
好处:
</code></pre>
<p><strong>队列</strong></p>
<pre><code>特点：先进先出
例如:过安检
</code></pre>
<p><strong>数组</strong></p>
<pre><code>特点：有索引，所以查询快，增删慢
查询快因为有索引，我们可以通过索引操作元素
增删慢的原因
    添加删除元素：创建新数组，将老数组复制到新数组
</code></pre>
<p><strong>链表</strong></p>
<pre><code>在集合中涉及两种链表
单项链表
    节点：一个节点分为两部分
    第一部分：数据域（存数据）
    第二部分：指针域（保存下一个节点地址）
    特点：前面的节点记录后面节点的地址，后面的节点地址不记录前面节点的地址
双向链表
    分为三部分
    第一部分：指针域（保存上一个节点的地址）
    第二个部分：数据域（保存的数据）
    第三部分：指针域（保存下一个节点地址）
    特点 查询慢增删快
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240330201444471.png" alt="image-20240330201444471"></p>
<p><strong>List接口</strong></p>
<pre><code>Collection的子接口
常见的实现类
    ArrayLink,LinkedList Vector
方法
 前面的Colection的方法都试用
 void add(int index,)
 E remove(int index)//根据索引移除
 E set(int index ,E element)//将指定的索引位置上的元素，修改为后面的元素,返回值s替换的元素
 E Get(int index,E element) //根据索引获取元素
</code></pre>
<p>遍历的快捷键</p>
<pre><code>集合名+fori
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 哈哈哈哈哈哈哈重生之我是兵王
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;chenw
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
