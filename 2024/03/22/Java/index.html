
<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8" />
    <title>Java | 哈哈哈哈哈哈哈重生之我是兵王</title>
    <meta name="author" content="chenw" />
    <meta name="description" content="description" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
	<canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
	<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
	<script src="/js/fireworks.min.js"></script>
	<canvas id="background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
	<script src="/js/background.min.js"></script>
	<div id="cursor"></div>
	<link rel="stylesheet" href="/css/cursor.min.css">
	<script src="/js/cursor.min.js"></script>
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>哈哈哈哈哈哈哈重生之我是兵王</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;哈哈哈哈哈哈哈重生之我是兵王</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>Java</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/22
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <p>摘要</p>
<span id="more"></span>

<p>内容</p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>跨平台是java语言的趋势</p>
<p>java还是主流的编程语言</p>
<p>Java的各个版本</p>
<p>1.JavaSE：标准版，定位在个人计算机的应用，</p>
<p>2.JavaEE:企业版，定位在服务器</p>
<p>3.JavaME：微型版</p>
<p><strong>Java的运行机制</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322205212089.png" alt="image-20240322205212089"></p>
<p>Java既是编译型语言，又是解释性</p>
<p>例如 python就是解释性语言，直接通过python的解释器直接去运行</p>
<p><strong>什么是JVM？</strong></p>
<p>用于执行字节码虚拟计算机，跨平台的差异就是通过JVM</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322205502948.png" alt="image-20240322205502948"></p>
<p>java提供不同平台的虚拟机</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322205534797.png" alt="image-20240322205534797"></p>
<p><strong>开发人员我们一般使用JDK，因为我们需要编译和运行</strong></p>
<p><strong>一般java的游戏，就直接运行，只下载JRE就可以了</strong></p>
<p>创建的Java项目写在</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322213121539.png" alt="image-20240322213121539"></p>
<p>简单的Java代码</p>
<pre><code class="Java">public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
    &#125;
&#125;
</code></pre>
<p>在运行的时候，会自动帮你进行编译</p>
<p><strong>生成的java的编译的以后的文件在</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322213530098.png" alt="image-20240322213530098"></p>
<p>Java的基础语法</p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li><p>主函数 &amp;  程序的入口</p>
</li>
<li><p>文件名</p>
<pre><code>一个文件中只能有一个public的类，并且文件名必须和public的类名保持一致
如果文件中有多个类，文件名与public的类名保持一致
如果文件中有多个类 且无public类，文件名抗日一是任意的类
</code></pre>
</li>
<li><p>类名 首字母大写，驼峰的命名</p>
</li>
<li><p>类修饰符  public,default</p>
</li>
<li><p>类中的成员修饰符：public,private,protected,default</p>
</li>
<li><p>静态成员：无需实例化就可以直接调用</p>
<pre><code class="java">class Person  &#123;
    public static void  f1()&#123;
        //static静态的方法，无需实例就可以调用，也就只可以类调用
        System.out.println(&quot;111&quot;);
    &#125;
&#125;

public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
        Person.f1();//111
    &#125;
&#125;
</code></pre>
<ul>
<li><p>实例方法：需要实例以后在调用</p>
<pre><code class="java">class Person  &#123;
    public  void  f1()&#123;
        System.out.println(&quot;111&quot;);
    &#125;
&#125;

public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
        Person person = new Person();//实例对象的写法是这样的
        person.f1();//对象调用
    &#125;
&#125; 
</code></pre>
</li>
</ul>
</li>
<li><p>void代表方法没有返回值</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
        Person person = new Person();//实例对象的写法是这样的
        person.f1();//对象调用
    &#125;
</code></pre>
</li>
<li><p>参数,需要限制类型</p>
<pre><code>class Person  &#123;
    public  void  f1(string a , int b)&#123;
        System.out.println(&quot;111&quot;);
    &#125;
&#125;

public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
        Person person = new Person();//实例对象的写法是这样的
        person.f1(&#39;aaaa&#39;,123);//对象调用
    &#125;
&#125; 
</code></pre>
<p><strong>注释</strong></p>
<pre><code>//单行注释
/*
多行注释
*/
</code></pre>
</li>
</ul>
<p><strong>变量和常量</strong></p>
<pre><code>final相当于js里的const
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
    System.out.println(&quot;你好&quot;);
    String name = &quot;name&quot;;
    int number = 5;
    int a ;
    a= 18;
    //常量
    final int size = 18;
&#125;
</code></pre>
<p>不像js的动态语言，我们需要对数据的类型做出限制</p>
<p><strong>输入和输出</strong></p>
<p>输入需要外部的包，</p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        //引入的Scanner相当于一个类，System.in感觉时使用系统命令获取输入
        Scanner input  = new Scanner(System.in);
        String text  =  input.nextLine();
        //输出
        System.out.println(text);
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322220405957.png" alt="image-20240322220405957"></p>
<p>输出语句的不同</p>
<pre><code class="java">        //输出
        System.out.println(text);//输出最后会带换行
        System.out.print(text);//输出最后不带换行
</code></pre>
<p><strong>条件语句</strong></p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.print(&quot;&quot;);
        int age  = 19 ;
        if (age &lt; 18)&#123;
            System.out.println(&quot;少年&quot;);
        &#125; else if (age&gt;= 18 &amp;&amp; age &lt; 24)&#123;
            System.out.println(&quot;青年&quot;);
        &#125; else &#123;
            System.out.println(&quot;老年&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>switch case语句</strong></p>
<pre><code class="java">        System.out.print(&quot;&quot;);
        int age  = 19 ;
        switch (age)&#123;
            case 19:
                System.out.println(&quot;1111&quot;);
                break;
        &#125;
</code></pre>
<p><strong>循环语句</strong></p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        int count = 0 ;
        while (count &lt; 3)&#123;
            System.out.println(count);
            count++;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>do while循环</strong></p>
<p>至少执行一次</p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        int count = 0 ;
        do &#123;
            System.out.println(count);
            count++;
        &#125; while (count &lt; 3);
    &#125;
&#125;
</code></pre>
<p><strong>For循环</strong></p>
<pre><code class="java">        int count = 0 ;
        for (int i = 0 ; i &lt; 3 ; i++)&#123;
            System.out.println(i);
        &#125;
</code></pre>
<p><strong>数据类型</strong></p>
<p><strong>整数类型</strong></p>
<pre><code>byte 1个字节
short 2个字节
int 4个字节
long 8个字节
</code></pre>
<p>强制类型转化，大的类型往小的范围可能就会出错</p>
<pre><code class="java">byte i = 32 ; 
int a = (int) i;
</code></pre>
<p><strong>字符</strong></p>
<p>字符串的方法</p>
<pre><code class="java">        char  a = &#39;x&#39;;
        char  b = &#39;y&#39;;//字符只能用单引号
        String c = &quot;hahahaha&quot; ;

        String d = new String(&quot;王昌晨&quot;);

        char[] f = &#123;&#39;w&#39;,&#39;c&#39;,&#39;g&#39;&#125;;
        System.out.println(f);
</code></pre>
<pre><code class="java">        String name = &quot;wangchangchen&quot;;
        int count = name.length();//获取字符的长度
        for (int i = 0; i &lt; count; i++) &#123;
            char item = name.charAt(i);//获取当前位置的字符
        &#125;
        String a = name.trim();//去掉空白
        String[] b= name.split(&quot;c&quot;);//分割，返回的是数组
        String c= name.replace(&quot;w&quot;,&quot;d&quot;);//代换
        String d = name.substring(2,5);//切片
        boolean f = name.equals(&quot;wangchangchen&quot;);//进行字符串的比较
        boolean g = name.contains(&quot;ang&quot;);//数组中是否包含
        String k = name.concat(&quot;ahhah&quot;);//在后面进行拼接
</code></pre>
<p><strong>数组</strong></p>
<pre><code class="java">        int[] arr =new int[3];//定义三个数字的数组
        arr[0]=123;
        arr[1]=234;
        arr[2]=456;
        System.out.println(Arrays.toString(arr));


        String[] arr2 =new String[]&#123;&quot;hahah&quot;,&quot;hahah&quot;,&quot;ahah&quot;&#125;;
        System.out.println(Arrays.toString(arr2));

        String[] arr3 = &#123;&quot;haah&quot;,&quot;agaga&quot;,&quot;haha&quot;&#125;;
        System.out.println(Arrays.toString(arr3));

        for (int i = 0; i &lt; arr3.length; i++) &#123;
            System.out.println(arr3[i]);
        &#125;
</code></pre>
<p>注意：<strong>数组里面的个数一旦确定，不可以更改，类似于python里面的元组</strong></p>
<p><strong>对象</strong></p>
<ul>
<li><p>Java中所有的类也是默认继承基类Object这个类的，所以用基类可以反之子类的类型，下面这样写是不会报错的，因为String的类继承了Object的类</p>
<pre><code class="java">        String a = &quot;haha&quot;;
        Object b = &quot;haha&quot;;
        Object c = new String(&quot;haaha&quot;);
</code></pre>
<p>所以我们就可以常见任意类型的数组，所以要以后声明的数组是混合类型的就可以这样写</p>
<pre><code class="java">        Object[] arr = new Object[]&#123;&quot;java&quot;,11111,2222,&quot;lkcd&quot;&#125;;
        System.out.println(Arrays.toString(arr));//[java, 11111, 2222, lkcd]
</code></pre>
</li>
</ul>
<p>Object类型的字符串</p>
<pre><code class="java">        String v1 = new String(&quot;hahaha&quot;);
        v1.toUpperCase();
        System.out.println(v1);

        Object v2  = &quot;hahaha&quot;;
//只有强制类型转换以后才可以使用字符串的方法
        String data = (String)v2;
        data.toUpperCase()
</code></pre>
<p>传参的参数的类型未知，我们就可以这样写</p>
<pre><code class="java">    public static void func(Object a) &#123;
        System.out.println(a);
        if (a instanceof String) System.out.printf(&quot;String&quot;);
        if (a instanceof Integer) System.out.println(&quot;int&quot;);
    &#125;

    public static void main(String[] args) &#123;
        String v1 = new String(&quot;hahaha&quot;);
        v1.toUpperCase();
        System.out.println(v1);

        Object v2  = &quot;hahaha&quot;;
        String data = (String)v2;
        data.toUpperCase();
        func(&quot;hahahha&quot;);
    &#125;
</code></pre>
<ul>
<li>Java这种所有的类都继承Object，Object代指所有的类型</li>
</ul>
<p><strong>List系列</strong></p>
<ul>
<li>在Java中List不属于一种类型，在Java中List<strong>是一个接口</strong>，接口下面有两个常见的类型 （目的就是存放的动态的数据，可以添加删除）</li>
<li>ArrayList，（连续的内存地址的存储，里面放着的是内存地址而且内部还会自动扩容,可以添加，当超过的容量，创建新的内存地址，然后在保存）。</li>
<li>LinkedLink：（基于链表实现的，链表存储的）</li>
</ul>
<pre><code class="java">        ArrayList arr = new ArrayList();
        arr.add(&quot;hahaha&quot;);
        System.out.println(arr.getClass());//class java.util.ArrayLis
        System.out.println(arr);//[hahaha]
</code></pre>
<pre><code class="java">        LinkedList arr = new LinkedList();
        arr.add(&quot;hahaha&quot;);
        System.out.println(arr.getClass());//class java.util.LinkedList
        System.out.println(arr);//[hahaha]
</code></pre>
<p>用起来都是一样的，就是存储的方式不同,刚才提到list是一个接口，接口下面有如上的数据类型</p>
<ul>
<li><p>接口:使用来约束实现他的类，约束它里面的成员必须有什么，定义有点像TS</p>
<pre><code class="java">interface List&#123;
    public void add(Object)//不写具体的实现
&#125;
//这个类实现接口List，此时这里必须有add的方法
class ArrayList implements  List &#123;
   public void add(Object data)&#123;
       //实现添加数据的代码
   &#125;
&#125;
</code></pre>
<pre><code class="java">**我们用接口名称代指实现接口的类也是可以的**       
        List arr = new LinkedList();
        arr.add(&quot;hahaha&quot;);
        System.out.println(arr.getClass());//class java.util.LinkedList
        System.out.println(arr);//[hahaha]
</code></pre>
<p>创建的时候指定类型</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        List&lt;String&gt; arr = new LinkedList&lt;String&gt;();
        arr.add(&quot;hahaha&quot;);
        arr.add(1111);//这一行报错
        System.out.println(arr.getClass());//class java.util.LinkedList
        System.out.println(arr);//[hahaha]
    &#125;
</code></pre>
<p><strong>默认的是Object，里面的类型可以混着</strong></p>
</li>
<li><p>获取列表的方法和属性</p>
<pre><code class="Java">    public static void main(String[] args) &#123;
        List&lt;String&gt; arr = new LinkedList&lt;String&gt;();
        arr.add(&quot;hahaha&quot;);
        System.out.println(arr.getClass());//class java.util.LinkedList
        System.out.println(arr);//[hahaha]
        System.out.println(arr.get(0));//获取列表里的值

        arr.set(0,&quot;123&quot;);
        System.out.println(arr);//[123]

        arr.add(&quot;456&quot;);
        arr.remove(&quot;123&quot;);
        System.out.println(arr);//[456]
        arr.remove(0);
        System.out.println(arr);//[]

        System.out.println(arr.size());//0

        arr.add(&quot;2112&quot;);
        System.out.println(arr.contains(&quot;2112&quot;));//true

        arr.add(&quot;9999&quot;);
        for (Object item : arr)&#123;
            System.out.println(item);//2112,9999
        &#125;

        for (int i = 0; i &lt; arr.size(); i++) &#123;
            Object item = arr.get(i);
            System.out.println(item);//2112,9999
        &#125;

    &#125;
</code></pre>
</li>
<li><p>通过迭代器进行遍历</p>
<pre><code class="java">        List&lt;Object&gt; arr = new LinkedList&lt;&gt;(Arrays.asList(&quot;123&quot;,&quot;456&quot;,&quot;789&quot;));//快速创建一个，就不用一个一个添加了
        Iterator it = arr.iterator();
        while (it.hasNext())&#123;
            System.out.println(it.hasNext()); //判断指向当前的数据是否为空
            Object item = it.next();
            System.out.println(item); //获取当前指向的数据
        &#125;
</code></pre>
</li>
</ul>
<p><strong>Set系列</strong></p>
<p>主要还是去重</p>
<p>Set还是一个接口，常见的实现这两个接口有两个类，用于实现不重复多元素的集合</p>
<ul>
<li>HashSet ，去重，无序，</li>
<li>TreeSet，去重，内部会默认的排序（ascii,uncode）,不同类型的不能比较</li>
</ul>
<pre><code class="java">        HashSet s  = new HashSet&lt;&gt;();
        s.add(&quot;111&quot;);
        s.add(&quot;111&quot;);
        s.add(&quot;2222&quot;);
        System.out.println(s);//[111, 2222]
</code></pre>
<p>简单的创建，<strong>注意这里的add外层包裹的是双括号</strong></p>
<pre><code class="java">        HashSet a = new HashSet()&#123;
            &#123;
                add(&quot;1111&quot;);
                add(&quot;222&quot;);
            &#125;;
        &#125;;
        System.out.println(a);//[222, 1111]
</code></pre>
<p>通过集合我们就可以实现交并差，使用的方法和列表的实现差不多</p>
<pre><code class="java">        Set a = new HashSet&lt;&gt;()&#123;&#123;
            add("java");
            add("666");
            add("B站");
        &#125;&#125;;
        Set b = new HashSet() &#123;&#123;
             add("B站");
             add("A站");
             add("C站");&#125;&#125;;
        Set c = new HashSet();
        c.addAll(a);//向空的集合添加，或者取并集
        System.out.println(c);//[java, 666, B站]

        //交集
        c.retainAll(b);//交集,这个返回值是布尔
        System.out.println(c);;//[B站]

        //并集
        c.addAll(a);
        System.out.println(a);//[java, 666, B站]

        //差集
        c.removeAll(a); //c-a
        System.out.println(c);//[]

        //差集
        b.removeAll(a); //b-a
        System.out.println(b);//[C站, A站]

        //循环
        for (Object item : a)&#123;
            System.out.println(item);//java     666       B站
        &#125;

        Iterator it = a.iterator();
        while(it.hasNext())&#123;
            System.out.println(it.next());//java  666   B站
        &#125;
</code></pre>
<p><strong>Map系列</strong></p>
<p>Map是一个接口，常见实现这个接口有两个类，用于存储键值对</p>
<ul>
<li>HashMap : 无序；</li>
<li>Treepmap: 有序，根据key进行排序</li>
</ul>
<pre><code class="java">用法和之前的set和list的差不多
        Map a = new HashMap&lt;&gt;();
        a.put(&quot;name&quot; , &quot;demo&quot;);
        a.put(&quot;age&quot; , &quot;18&quot;);
        System.out.println(a);//&#123;name=demo, age=18&#125;


        Map&lt;String,String&gt; b = new HashMap&lt;String,String&gt;();
        b.put(&quot;name&quot; , &quot;demo&quot;);
        b.put(&quot;age&quot; , &quot;18&quot;);
        System.out.println(b);//&#123;name=demo, age=18&#125;


        //可以向setu快速的创建
        HashMap c = new HashMap&lt;&gt;()&#123;
            &#123;
                put(&quot;name&quot;,&quot;wang&quot;);
                put(&quot;age&quot;,&quot;18&quot;);
            &#125;
        &#125;;
        System.out.println(c);
</code></pre>
<pre><code class="java">        Map a = new HashMap&lt;&gt;();
        a.put(&quot;name&quot; , &quot;demo&quot;);
        a.put(&quot;age&quot; , &quot;18&quot;);
        System.out.println(a);//&#123;name=demo, age=18&#125;


        Map&lt;String,String&gt; b = new HashMap&lt;String,String&gt;();
        b.put(&quot;name&quot; , &quot;demo&quot;);
        b.put(&quot;age&quot; , &quot;18&quot;);
        System.out.println(b);//&#123;name=demo, age=18&#125;


        //可以向setu快速的创建
        HashMap c = new HashMap&lt;&gt;()&#123;
            &#123;
                put(&quot;name&quot;,&quot;wang&quot;);
                put(&quot;age&quot;,&quot;18&quot;);
            &#125;
        &#125;;
        System.out.println(c);

        System.out.println(c.size());

        System.out.println(c.get(&quot;name&quot;));

        c.replace(&quot;name&quot;,&quot;chen&quot;);
        System.out.println(c);

        //没有迭代器，但是可以通过下面这个样子实现
        Set&lt;Map.Entry&lt;String,String&gt;&gt; d = c.entrySet();
        System.out.println(d);//[&quot;name=chen&quot;, &quot;age=18&quot;]
        Iterator it = d.iterator();
        while (it.hasNext())&#123;
             Map.Entry&lt;String,String&gt; e = (Map.Entry&lt;String, String&gt;)it.next();//在转为map
            System.out.println(e);//name=chen   age=18
            String k = e.getKey();//获取键名
            String l = e.getValue();//获取值
        &#125;

        //简单的写法
        Set r = b.entrySet();
        Iterator it2 = r.iterator();
        while (it2.hasNext())&#123;
            Map.Entry o = (Map.Entry)it2.next();
            System.out.println(o);
        &#125;
</code></pre>
<p>Map的EntrySet方法会获得实体，转为Set就可以使用迭代器</p>
<p><strong>类和面向对象</strong></p>
<ul>
<li>基本使用</li>
</ul>
<pre><code class="java">class Person &#123;
    public String name;
    public Integer age;
    //构造方法
    public Person()&#123;
        this.name = &quot;chen&quot;;
        this.age = 18 ;
    &#125;
    //一个类中可以有多个构造方法，但是保证参数的不同的才可以
    public Person(String name)&#123;
        this.name = name;
        this.age = 18 ;
    &#125;
    public Person(String name , int age)&#123;
        this.name = name;
        this.age = age ;
    &#125;

    //方法的重载
    public void doSomething ()&#123;
        System.out.println(&quot;做一些事情&quot;);
    &#125;
    public void doSomething(String what)&#123;
        System.out.println(what);
    &#125;
    public void doSomething(String what , int age)&#123;
        System.out.println(age);
        System.out.println(this.name);
    &#125;
&#125;
</code></pre>
<ul>
<li><p>静态成员</p>
<pre><code class="java">class Person &#123;
    //静态变量,只能通过类的方法进行访问
    public static String content = &quot;爱笑&quot;;

    //静态方法
    public static void func()&#123;
        System.out.println(&quot;你好&quot;);
    &#125;
&#125;   
</code></pre>
</li>
</ul>
<p><strong>本质上静态的属于类，非静态的属于实例</strong></p>
<ul>
<li><p>继承， Java只能支持单继承，之前的pyhton和Js都是支持多继承的，Java的一个类只能继承一个父类</p>
<pre><code class="java">import java.lang.reflect.Array;
import java.util.*;

class Person &#123;
    public String name;
    public Integer age;
    public Person(String name , int age)&#123;
        this.name = name;
        this.age = age ;
    &#125;
&#125;
class Cool extends Person &#123;
    public String email;
    public  Cool(String name, int age ,String email)&#123;
        super(name, age);//使用父类的构造方法
        this.email = email;
    &#125;
&#125;
public class Hello &#123;
    public static void main(String[] args) &#123;
        Cool man = new Cool(&quot;wang&quot;,188,&quot;344455&quot;);
        System.out.println(man.email);//34455
        System.out.println(man.name);//wang
        System.out.println(man.age);//188
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>接口</strong></p>
<p>作用</p>
<ul>
<li>约束：实现他的类</li>
<li>泛指实现他的类</li>
</ul>
<pre><code class="Java">//实现其他的类
interface IMessage &#123;
    public void send();
&#125;

class WeChat implements IMessage&#123;
    public void send()&#123;
        System.out.println(&quot;发送&quot;);
    &#125;;
&#125;
</code></pre>
<pre><code class="java">//实现泛指其他的类，调用函数func，参数的类型设置类实现的接口，这样就可以传实现接口的类
interface IMessage &#123;
    public void send();
&#125;

class WeChat implements IMessage&#123;
    public void send()&#123;
        System.out.println(&quot;发送微信&quot;);
    &#125;;
&#125;

class  DingDing implements IMessage&#123;
    public void send()&#123;
        System.out.println(&quot;发送钉钉&quot;);
    &#125;;
&#125;


public class chen1 &#123;
    public static void func(IMessage a)&#123;
        a.send();
    &#125;
    public static void main(String[] args) &#123;
        WeChat a = new WeChat();
        func(a);
    &#125;
&#125;
</code></pre>
<p><strong>注意</strong></p>
<p><strong>Java中不支持多继承，但是可以支持多接口</strong></p>
<p><strong>抽象</strong></p>
<p><strong>抽象类，既能实现接口又能实现继承</strong></p>
<pre><code class="Java">abstract class Person1 &#123;
    //继承的子类必须有实现这个函数
    public abstract void func(String name);
    //子类也能继承这个方法
    public void func2()&#123;
        System.out.println(22222);
    &#125;
&#125;
class Hututu extends Person1 &#123;
    public void func(String name)&#123;
        System.out.println(name);
    &#125;
&#125;


public class chen1 &#123;
    public static void main(String[] args) &#123;
        Hututu hututu  = new Hututu();
        hututu.func(&quot;hututu&quot;);//hututu
        hututu.func2();//22222
    &#125;
&#125;
</code></pre>
<p><strong>包的概念</strong></p>
<p>新建包的文件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323165138897.png" alt="image-20240323165138897"></p>
<p>代码</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323165157520.png" alt="image-20240323165157520"></p>
<p>再在其他的地方导入</p>
<pre><code class="java">import java.lang.reflect.Array;
import java.util.*;
import utils.Helper;//导入包
public class Hello &#123;
    public static void main(String[] args) &#123;
        //调用包的里面的类的静态方法
        System.out.println(Helper.func());//hahahaha
    &#125;
&#125;
</code></pre>
<p><strong>包中类的修饰符</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323165801124.png" alt="image-20240323165801124"></p>
<ul>
<li><p>public，公共（任意人能调用包中的）</p>
</li>
<li><p>default，只能在当前包中调用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323170034173.png" alt="image-20240323170034173"></p>
</li>
</ul>
<p>这个只能在同一个包中调用，</p>
<p><strong>类修饰符</strong></p>
<p>之前学过</p>
<ul>
<li>public，所有都可以访问</li>
<li>private，只能在当前的类中访问</li>
<li>protected，只有在当前的类和当前的类的子类可以调用</li>
</ul>
<h2 id="基础的补充"><a href="#基础的补充" class="headerlink" title="基础的补充"></a>基础的补充</h2><p><strong>递归</strong></p>
<p>例子计算阶乘</p>
<ul>
<li><p>定义递归头 什么时候不调用自身的方法</p>
</li>
<li><p>递归体：什么时候调用自身的方法</p>
<pre><code class="Java">public class Helper &#123;
    public static long func(int n)&#123;
        if (n == 1)&#123;
            return 1;
        &#125; else &#123;
            return n * func(n - 1);
        &#125;
    &#125;;
    public static void main(String[] args) &#123;
        System.out.println(func(3));
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>内存分析</strong></p>
<p>栈主要放的是main方法的代码，堆里面放着的是类，里面有类的属性，方法保存在方法区</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323203251941.png" alt="image-20240323203251941"></p>
<p><strong>注意一点，实例对象的时候没有构造函数。默认的赋值是0和null，属性值的显性初始化‘，就是在类里面不通过构造器，而是通过 a &#x3D; 11,这样初始化</strong></p>
<p><strong>构造器</strong></p>
<ul>
<li>构造器通过new关键字调用</li>
<li>构造器虽然有返回值，但是在定义的构造器的时候不能定义构造器的返回类型，不能return在构造里面使用</li>
<li>构造器的名称和类名保持一致</li>
<li>如果没有构造器，会默认的定义一个无参的构造方法</li>
</ul>
<p>Java<strong>虚拟机内存分析</strong></p>
<p>虚拟机栈的特点</p>
<p><strong>每一个方法调用都会创建一个栈帧，虚拟机为每一个线程创建一个栈，栈属于线程的私有，不能实现线程的共享，栈的特点是先进后出，后进先出</strong></p>
<p><strong>堆的特点</strong></p>
<ul>
<li><p>用于存储创好的对象和数组</p>
</li>
<li><p>只有一个堆，被所有的线程共享</p>
</li>
<li><p>栈是一个不连续的内存共享</p>
</li>
<li><p>堆被所有的线程所共享 ，堆会被分为年生带和老年代，用于垃圾的回收</p>
</li>
</ul>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323203251941.png" alt="image-20240323203251941"></p>
<p><strong>垃圾回收的算法</strong></p>
<ul>
<li>引用计数法：堆中的每个对象都对应一个引用计数器，当引用指向这个对象，引用加一，当为0 的时候java进行回收，缺点就是循环引用就会导致清空不了</li>
</ul>
<p>例子，这样的引入的值一直不为0这样就不会清楚<img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323210136655.png" alt="image-20240323210136655"></p>
<ul>
<li>引用可达法：程序把所有的引用关系看做一张图，从一个节点的Gc Root开始，寻找引用的节点以后，继续寻找这个节点的引用节点吗，当所有的节点寻找完毕以后，剩余的节点则被认为是没有被引用的节点</li>
</ul>
<p><strong>通用的分代垃圾回收机制</strong></p>
<p>永久代就是我刚在的方法区，存放一些常量什么的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323211008599.png" alt="image-20240323211008599"></p>
<p>this<strong>的关键字</strong></p>
<ul>
<li>普通方法，this总是指向调用该方法的对象</li>
<li>构造方法，this指向正要初始化的对象</li>
<li>this（）调用重载的构造方法，避免相同的初始化代码，但只能在构造方法里面使用，并且必须位于构造方法的第一位</li>
<li>this不能用于静态方法（其实向上面的图，static放在方法去里面，只能方法区里面去引入堆里面的东西，显然是不行的）</li>
</ul>
<pre><code class="java">package utils;
class Person1 &#123;
    Person1()&#123;
        //this这里是对象的地址
        System.out.println(&quot;正在初始化对象&quot;+this);//正在初始化对象utils.Person1@682a0b20
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person1 xiaoming = new Person1();

    &#125;
&#125;
</code></pre>
<p>通过this构造</p>
<pre><code class="Java">package utils;
class Person1 &#123;
    public String name;
    public int age;
    Person1(String name , int age)&#123;
//        name = name  //这样因为作用域的问题
        this.name = name ;
        this.age = age ;
        //this这里是对象的地址
        System.out.println(&quot;正在初始化对象&quot;+this);//正在初始化对象utils.Person1@682a0b20
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person1 xiaoming = new Person1(&quot;wang&quot;,18);
        System.out.println(xiaoming.name); //wang
        System.out.println(xiaoming.age);  //18
    &#125;
&#125;
</code></pre>
<p>this（），还可以带参数</p>
<pre><code class="Java">package utils;
class Person1 &#123;
    public String name;
    public int age;
    Person1()&#123;
        System.out.println(&quot;wwww&quot;);//wwww
    &#125;;
    Person1(String name , int age)&#123;
        //this()调用无参构造器，而且必须位于第一行
        this();
        this.name = name ;
        this.age = age ;
        System.out.println(&quot;正在初始化对象&quot;+this);//正在初始化对象utils.Person1@682a0b20
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person1 xiaoming = new Person1(&quot;wang&quot;,18);
        System.out.println(xiaoming.name); //wang
        System.out.println(xiaoming.age);  //18
    &#125;
&#125;
</code></pre>
<p><strong>static关键字</strong></p>
<p>这里面的代码</p>
<p>代码的开始定义一个静态的name，但是在构造器里面，有使用了name，就导致实例对象里面也有name的属性 了</p>
<pre><code class="java">package utils;
class Person1 &#123;
    static String name;
    Person1(String a)&#123;
    name = a ;
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person1 shuai = new Person1(&quot;nini&quot;);
        
        System.out.println(shuai.name);//nini
        System.out.println(Person1.name);//nini
    &#125;
&#125;
</code></pre>
<p>正确给静态的属性赋值的方法，调用的时机在类被加载的时候。</p>
<pre><code class="java">package utils;
public class Helper &#123;
    static String name;
    static &#123;
        System.out.println(&quot;执行初始化的工作&quot;);//执行初始化的工作
        name = &quot;王昌晨&quot;;
        printName();

    &#125;
    public static void printName()&#123;
        System.out.println(name);//王昌晨
    &#125;
    public static void main(String[] args) &#123;
    &#125;
&#125;
</code></pre>
<p>敲的时候出现一些问题，问了一下ai</p>
<pre><code class="java">package utils;
public class Helper &#123;
    static String name;
    static &#123;
        System.out.println(&quot;执行初始化的工作&quot;);//执行初始化的工作
        name = &quot;王昌晨&quot;;
        printName();
    &#125;
    public static void printName()&#123;
        System.out.println(name);//王昌晨
    &#125;
    public static void main(String[] args) &#123;
        Helper p = new Helper();
        System.out.println(p.name);/**
        虽然 name 属性被声明为 static，但是在 main 方法中通过实例对象访问静态属性 name 是合法的，这是因为静态成员虽然属于类而不属于实例对象，但在 Java 中仍然可以通过实例对象访问静态成员。

当你使用实例对象访问静态成员时，实际上是通过该实例对象来引用静态成员，编译器会在后台进行转换，将实例对象替换为对应的类名。因此，尽管最佳实践是通过类名直接访问静态成员，但是通过实例对象访问静态成员在语法上是合法的。

所以，在你的代码中，虽然在 main 方法中通过实例对象 p 访问静态属性 name，实际上会被转换为 Helper.name，因此可以正常访问并输出静态属性 name 的值。**/
    &#125;
&#125;
</code></pre>
<p>静态初始化 的执行顺序</p>
<pre><code>因为所有的类都继承Object
*上溯到Object类，先执行Object的静态初始化模块，在向下执行子类的静态初始化块，直至类的静态初始化
*构造方法的执行顺序也是一样的，这就是为什么在子类的构造器里面的super的方法
</code></pre>
<p><strong>包机制</strong></p>
<ul>
<li><p>用于管理类和类重名的问题</p>
</li>
<li><p>Java中常见的包	</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323220021699.png" alt="image-20240323220021699"></p>
</li>
</ul>
<p>导入的报名重名</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323220302005.png" alt="image-20240323220302005"></p>
<p>最好写齐路径</p>
<p>下面不会全部导入，会先检查用到这个文件的哪些类，然后再导入</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323220335026.png" alt="image-20240323220335026"></p>
<p><strong>静态导入</strong></p>
<p>导入包下面的所有的静态的属性</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323220509419.png" alt="image-20240323220509419"></p>
<p><strong>方法的重写</strong></p>
<p><strong>三个要点</strong></p>
<ul>
<li><p>1.方法名，形参，形参列表相同</p>
</li>
<li><p>2.返回值类型和声明异常类型，子类小于父类</p>
<pre><code class="Java">package utils;
class Person &#123;
    public Person func()&#123;
        System.out.println(&quot;1111&quot;);
        return new Person();
    &#125;
&#125;

class Li extends Person&#123;
    public Li func()&#123;
        System.out.println(&quot;222&quot;);
        return new Li();
    &#125;
&#125;

public class Helper &#123;

    public static void main(String[] args) &#123;
        
    &#125;
&#125;
</code></pre>
</li>
<li><p>3.访问权限，子类大于等于父类</p>
</li>
</ul>
<p><strong>final关键字</strong></p>
<ul>
<li><p>修饰变量</p>
</li>
<li><p>修饰方法：该方法不可以被子类重写，但是可以重载</p>
<pre><code class="java">public final void study()&#123;&#125;
</code></pre>
</li>
<li><p>修饰类：修饰类不能被继承，比如：Math,String</p>
<pre><code class="java">public final class A &#123;&#125;
</code></pre>
</li>
</ul>
<p><strong>组合</strong></p>
<p><strong>除了继承，组合也能实现代码的复用，组合的核心是将父类对象作为子类的属性</strong></p>
<pre><code class="Java">package utils;
class Person &#123;
    public String name;
    public int age;
    Person()&#123;
        name = &quot;hahaha&quot;;
        age = 18;
    &#125;
    public Person func()&#123;
        System.out.println(&quot;1111&quot;);
        return new Person();
    &#125;
&#125;

class Li &#123;
    Person chen = new Person();
    Li()&#123;
        System.out.println(chen.age);
        System.out.println(chen.name);
    &#125;
&#125;

public class Helper &#123;

    public static void main(String[] args) &#123;
        Li li = new Li();
    &#125;
&#125;
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 哈哈哈哈哈哈哈重生之我是兵王
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;chenw
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
