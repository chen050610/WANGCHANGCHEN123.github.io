
<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8" />
    <title>React | 哈哈哈哈哈哈哈重生之我是兵王</title>
    <meta name="author" content="chenw" />
    <meta name="description" content="description" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
	<canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
	<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
	<script src="/js/fireworks.min.js"></script>
	<canvas id="background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
	<script src="/js/background.min.js"></script>
	<div id="cursor"></div>
	<link rel="stylesheet" href="/css/cursor.min.css">
	<script src="/js/cursor.min.js"></script>
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>哈哈哈哈哈哈哈重生之我是兵王</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;哈哈哈哈哈哈哈重生之我是兵王</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>React</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/7
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <p>摘要</p>
<span id="more"></span>

<p>内容</p>
<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p><strong>尚硅谷react全家桶</strong></p>
<p><strong>开发者</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307183403208.png" alt="image-20240307183403208"></p>
<p>为什么要学习呢？</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307183521107.png" alt="image-20240307183521107"></p>
<p>jquery</p>
<p><strong>react的特点</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307183628824.png" alt="image-20240307183628824"></p>
<p><strong>react native</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307183651762.png" alt="image-20240307183651762"></p>
<p>所以指定客户端的开发也可以开发手机app</p>
<p>和vue的一样</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307183732623.png" alt="image-20240307183732623"></p>
<p>之前的query和原生的js操作的都是真实的DOM</p>
<h2 id="React的入门、"><a href="#React的入门、" class="headerlink" title="React的入门、"></a><strong>React的入门</strong>、</h2><p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307184027693.png" alt="image-20240307184027693"></p>
<p>diffing就是对比的算法和之前的vue的diffin的算法一样</p>
<p><strong>下载react</strong>先学习旧版本</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307184251576.png" alt="image-20240307184251576"></p>
<p>babel有两个功能</p>
<p>1.就是使es6转为es5</p>
<p>2.使jsx转为js</p>
<p>开始学习</p>
<p>引入需要的包</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307184710573.png" alt="image-20240307184710573"></p>
<p>简单的使用方法</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    //因为使用的不是js的语言而是jsx，所有需要Babel进行解析
    //1.创建虚拟dom
    const VDOM = &lt;h1&gt;hello,react&lt;/h1&gt; //这里不可以使用引号，因为这里不是字符串，这里已经不是js的语法了
    //2.熏染虚拟dom到页面
    //调用引入的方法
    ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))//react没有提供选择器
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注意</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
    //因为使用的不是js的语言而是jsx，所有需要Babel进行解析
    //1.创建虚拟dom
    const VDOM = &lt;h1&gt;hello,react&lt;/h1&gt; //这里不可以使用引号，因为这里不是字符串，这里已经不是js的语法了
    const VDOM2 = &lt;h1&gt;hello,react2&lt;/h1&gt; //这里不可以使用引号，因为这里不是字符串，这里已经不是js的语法了
    //2.熏染虚拟dom到页面
    //调用引入的方法
    ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))//react没有提供选择器
    ReactDOM.render(VDOM2,document.getElementById(&#39;test&#39;))//react没有提供选择器
&lt;/script&gt;
</code></pre>
<p>这里提供和两个并没有追加的功能</p>
<p><strong>为什么我们要使用jsx呢？</strong></p>
<p>使用jsx创建id的属性</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
   
    //因为使用的不是js的语言而是jsx，所有需要Babel进行解析
    //1.创建虚拟dom
    const VDOM = &lt;h1 id=&#39;title&#39;&gt;hello,react&lt;/h1&gt; //这里不可以使用引号，因为这里不是字符串，这里已经不是js的语法了
    //2.熏染虚拟dom到页面
    //调用引入的方法
    ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))//react没有提供选择器
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>使用js</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    const VDOM = React.createElement(&#39;h1&#39;,&#123;id:&#39;title&#39;&#125;,&#39;hello world&#39;)
    //2.熏染虚拟dom到页面
    //调用引入的方法
    ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))//react没有提供选择器
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>那如果还有一个要求</p>
<p>在h1下面在创建一个span的标签，这个jsx可以直接写</p>
<p>但是使用js的话</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    const VDOM = React.createElement(&#39;h1&#39;,&#123;id:&#39;title&#39;&#125;,React.createElement(&#39;span&#39;,&#123;&#125;,&#39;hello&#39;))
    //2.熏染虚拟dom到页面
    //调用引入的方法
    ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))//react没有提供选择器
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果有很多个话就会太繁琐了</p>
<p>为更加明显我们一般</p>
<pre><code class="js">v&lt;script type=&quot;text/babel&quot;&gt;
    //因为使用的不是js的语言而是jsx，所有需要Babel进行解析
    //1.创建虚拟dom
    const VDOM = (
        &lt;h1 id=&#39;title&#39;&gt;
            hello,react
        &lt;/h1&gt;
    ) //这里不可以使用引号，因为这里不是字符串，这里已经不是js的语法了
    //2.熏染虚拟dom到页面
    //调用引入的方法
    ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))//react没有提供选择器
&lt;/script&gt;
</code></pre>
<p>这样的书写</p>
<p>那么这个括号里的代码经过babel的翻译变成什么样子呢？</p>
<p>其实就是我们使用js创建dom的写法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307191233743.png" alt="image-20240307191233743"></p>
<p>就相当于语法糖</p>
<p>我们在输出一下</p>
<p>这个VDOM是什么东西</p>
<p><img src="/react.assets/image-20240307191423213.png" alt="image-20240307191423213"></p>
<p>就是一般对象</p>
<p>所以虚拟的dom比较轻</p>
<p>相比较真是的dom里面的有很多的属性和方法</p>
<p>因为虚拟dom是React在使用，无需dom那么多</p>
<h2 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h2><p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307191800226.png" alt="image-20240307191800226"></p>
<p>xml早期用于储存数据和传输数据</p>
<p>之前</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307191858186.png" alt="image-20240307191858186"></p>
<p>但是json以后就使用json</p>
<p><strong>jsx的语法规则</strong></p>
<p>定义虚拟dom的时候不要使用‘’</p>
<p>2.标签混入js表达式要使用{}</p>
<p>3.在jsx中应用样式的类名需要使用classnName 而不是class了</p>
<p>4.使用内敛样式的时候需要两个括号，第一个括号js表达式</p>
<p>第二个括号是使用对象的形式，如果名字是多个单词的需要使用小驼峰</p>
<p>例如fontSize</p>
<p>5.只能有一个根标签</p>
<p>6.标签必须闭合</p>
<p>7.小写字母开头则将其转为html的同名标签</p>
<p>大写的字母开头的标签就当作组件了</p>
<pre><code class="jsx">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;hello&lt;/title&gt;
    &lt;style&gt;
        .title&#123;
            background: orange;
            width: 200px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    const id = &#39;title&#39;
    const name = &#39;haha&#39;
    const VDOM = (
        &lt;div&gt;
            &lt;h1 id=&#123;id&#125; className=&quot;title&quot;&gt;
            &lt;span style=&#123;&#123;color:'white'&#125;&#125;&gt;
                &#123;name&#125;
            &lt;/span&gt;
            &lt;/h1&gt;
            &lt;input type=&quot;text&quot;/&gt;
        &lt;/div&gt;
    )
    ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))//react没有提供选择器
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这样写的话</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;hello&lt;/title&gt;
    &lt;style&gt;
        .title&#123;
            background: orange;
            width: 200px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    const data = [&#39;Angular&#39;,&#39;React&#39;,&#39;Vue&#39;]
const VDOM = (
    &lt;div&gt;
        &lt;h1&gt;前端三大框架&lt;/h1&gt;
        &lt;ul&gt;
            &#123;data&#125;
        &lt;/ul&gt;
    &lt;/div&gt;
)
ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>会帮助你遍历</p>
<p>但不是里li标签的形式</p>
<p>但是如果数据写成</p>
<pre><code class="js">const data = [&lt;li&gt;Angular&lt;/li&gt;,&lt;li&gt;React&lt;/li&gt;,&lt;li&gt;vue&lt;/li&gt;]
</code></pre>
<p>这样是可以的</p>
<p>注意{}这里面只可以使用表达式</p>
<p>不可以放代码</p>
<p>就比如for和if都是不能往里面放的</p>
<p>所以一定区分js表达式和js代码</p>
<p>liru<img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307194939064.png" alt="image-20240307194939064"></p>
<p>这些里面都有返回值</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307195021453.png" alt="image-20240307195021453"></p>
<p>所以可以这么写</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;hello&lt;/title&gt;
    &lt;style&gt;
        .title&#123;
            background: orange;
            width: 200px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    // const data = [&lt;li&gt;Angular&lt;/li&gt;,&lt;li&gt;React&lt;/li&gt;,&lt;li&gt;vue&lt;/li&gt;]
    const data = [&#39;Angular&#39;,&#39;React&#39;,&#39;Vue&#39;]
const VDOM = (
    &lt;div&gt;
        &lt;h1&gt;前端三大框架&lt;/h1&gt;
        &lt;ul&gt;
            &#123;
                data.map((item)=&gt;&#123;
                    return &lt;li&gt;&#123;item&#125;&lt;/li&gt;
                &#125;)
            &#125;
        &lt;/ul&gt;
    &lt;/div&gt;
)
ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>但是注意这里的li需要做好key因为diffing的算法就是通过key进行对比的</p>
<p>就可以这么写</p>
<pre><code class="js">    &lt;div&gt;
        &lt;h1&gt;前端三大框架&lt;/h1&gt;
        &lt;ul&gt;
            &#123;
                data.map((item,index)=&gt;&#123;
                    return &lt;li key=&quot;index&quot;&gt;&#123;item&#125;&lt;/li&gt;
                &#125;)
            &#125;
        &lt;/ul&gt;
    &lt;/div&gt;
</code></pre>
<p>但是这样也会有问题，后面再说</p>
<h2 id="React面对组件编程"><a href="#React面对组件编程" class="headerlink" title="React面对组件编程"></a>React面对组件编程</h2><p>开发者工具的调试工具</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307200440946.png" alt="image-20240307200440946"></p>
<p>这里的components是记录组件的</p>
<p>这里的profiler是分析一些东西 </p>
<p><strong>组件有两种定义的方法</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307200622358.png" alt="image-20240307200622358"></p>
<p>函数式组件的几个要点</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;函数式组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    // 1.创建函数式组件，一般用于简单组件的定义
    const Demo = ()=&gt; &lt;h2&gt;我是使用函数定义的组件&lt;/h2&gt;
    ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>1.函数必须将组件的内容返回出来</p>
<p>2.在上面说过组标签的开头需要大写</p>
<p>3.而且参数里面需要写组件的标签的形式</p>
<p>就像上面一样，而且必须闭合</p>
<p>这样以后开发者工具里面也会有 了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307201813085.png" alt="image-20240307201813085"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307201826264.png" alt="image-20240307201826264"></p>
<p>下面是React的版本</p>
<p>有几个问题</p>
<p>这里的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307201904789.png" alt="image-20240307201904789"></p>
<p>Demo是React帮你调用的</p>
<p>那如果不是箭头函数那这里的this指向谁？</p>
<p>答案是undefine</p>
<p>因为</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307202050218.png" alt="image-20240307202050218"></p>
<p>babel翻译这句话以后开启了严格模式</p>
<p>我们可以去babel的官网去试验一下</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307202152593.png" alt="image-20240307202152593"></p>
<p>同时也验证了jsx通过babel翻译以后成js的形式</p>
<p>执行ReactDom.render以后发生了什么？</p>
<p>1.React解析组件标签，找到了组件</p>
<p>2.发现组件使用函数定义的，随后调用该函数。将返回的虚拟的dom转为真实的dom，然后呈现在页面</p>
<p><strong>类组件</strong></p>
<p>class里面的方法定义不需要使用function</p>
<p>一般方法都在类的原型对象上面,只要不写成赋值函数，那么就会在原型对象上</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307203205647.png" alt="image-20240307203205647"></p>
<p>又复习了一下类的</p>
<p>如果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307203457359.png" alt="image-20240307203457359"></p>
<p>子类在定义构造器</p>
<p>就需要使用super方法调用父亲的构造器</p>
<p>所以这么写</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307203610881.png" alt="image-20240307203610881"></p>
<p>而且super需要放在最前面</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307203731293.png" alt="image-20240307203731293"></p>
<p>这里的stident的实例对象调用speak的方法</p>
<p>但是student的原型对象上面并没没有这样的方法</p>
<p>所有就要顺着原型链往上面找</p>
<p>然后多态</p>
<p>重写父类的方法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307203914984.png" alt="image-20240307203914984"></p>
<p>类似组件的开始</p>
<p>注意点</p>
<p>1.必须继承React里面的类</p>
<p>2.必须使用render函数，使用return返回需要的东西</p>
<p>3.当执行玩render以后发现是类的就是使用new 该类的实例，并且通过该实例调用render的方法，<strong>而且这里面的this就是组件实例对象</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307205032993.png" alt="image-20240307205032993"></p>
<p>这里面props和refs和state特别的重要</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;函数式组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
// 1。创建类是组件
class MyComponent extends React.Component &#123;
    render()&#123;
        console.log(this)
        return  &lt;h2&gt;使用类定义的组件，试用于复杂的组件&lt;/h2&gt;
    &#125;
&#125;
ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>就可以这样的</p>
<p><strong>对state理解</strong></p>
<p>复杂组件和简单组件区别</p>
<p>就是看有没有状态</p>
<p><strong>组件的状态驱动着页面展示</strong></p>
<p>数据就放在状态里面</p>
<p>数据的改变就会驱动着页面的展示</p>
<h3 id="组件第三个核心属性"><a href="#组件第三个核心属性" class="headerlink" title="组件第三个核心属性"></a>组件第三个核心属性</h3><p><strong>state</strong></p>
<p>只有类定义的才有状态</p>
<p>初始化state</p>
<p>借助构造器初始化状态</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;函数式组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
            this.state = &#123;
                isHot:true,
                name:&#39;&#39;
            &#125;
        &#125;
        render()&#123;
            console.log(this)//这里的this就是实例对象
            return  &lt;h1&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;
    &#125;
    ReactDOM.render(&lt;Weather/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>那么react如何做事件绑定呢？</p>
<p>原生js实现</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307210717008.png" alt="image-20240307210717008"></p>
<p>React的事件绑定一般使用第三种</p>
<p><strong>但是有注意点 和原理啊的事件名称不一样</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307210934602.png" alt="image-20240307210934602"></p>
<p>这里注意一个点</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308095633925.png" alt="image-20240308095633925"></p>
<p>在类里面定义的方法那么在类里面调用不了‘</p>
<p>只能由实例调用所有调用的时候需要加入</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308095731667.png" alt="image-20240308095731667"></p>
<p>这样才可以调用</p>
<p><strong>类中方法this的指向</strong></p>
<p>实例对象</p>
<p>如果直接这样的调用就会出现问题</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;函数式组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
            this.state = &#123;
                isHot:true,
                name:&#39;&#39;
            &#125;
        &#125;
        changeWeather()&#123;
            console.log(this)
        &#125;
        render()&#123;
            console.log(this)//这里的this就是实例对象
            return  &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;

    &#125;
    ReactDOM.render(&lt;Weather/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>因为这里的点击onclick’以后调用函数不是通过实例调用的而是直引用</p>
<p>类中的方法默认开启了局部的严格模式，所有changeweather的this就是为严格模式</p>
<p>这样我们就可以通过bind的方法获取到了组件实例对象的this</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;函数式组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
            this.state = &#123;
                isHot:true,
                name:&#39;&#39;
            &#125;
            this.changeWeather = this.changeWeather.bind(this)
        &#125;
        changeWeather()&#123;
            console.log(this)
        &#125;
        render()&#123;
            console.log(this)//这里的this就是实例对象
            return  &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;

    &#125;
    ReactDOM.render(&lt;Weather/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308101452414.png" alt="image-20240308101452414"></p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;函数式组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
            this.state = &#123;
                isHot:true,
                name:&#39;&#39;
            &#125;
            this.changeWeather = this.changeWeather.bind(this)
        &#125;
        changeWeather()&#123;
            // state不可以直接更改需要借助api
            // this.state.isHot = !this.state.isHot
            // console.log(this.state.isHot)
        &#125;
        render()&#123;
            console.log(this)//这里的this就是实例对象
            return  &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;

    &#125;
    ReactDOM.render(&lt;Weather/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>我们要修改state的状态不可以直接修改</p>
<p>如果直接修改的话不会引state的改变</p>
<p>我们顺着原型链找到类继承react里面的setState这里面的可以帮助你修改</p>
<p>所以修正以后的代码</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;函数式组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
            this.state = &#123;
                isHot:true,
                name:&#39;&#39;
            &#125;
            this.changeWeather = this.changeWeather.bind(this)//这里bind会返回一个函数
        &#125;
        changeWeather()&#123;
            // state不可以直接更改需要借助api
            // this.state.isHot = !this.state.isHot
            // console.log(this.state.isHot)
            this.setState(&#123;isHot:!this.state.isHot&#125;)
        &#125;
        render()&#123;
            console.log(this)//这里的this就是实例对象
            return  &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;

    &#125;
    ReactDOM.render(&lt;Weather/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>然后就有一个疑问setstate就合并的动作还是覆盖的动作</p>
<p>当然就是合并替换</p>
<p>那执行conscructor和render的分别调用几次？</p>
<p>1.conscructor调用1次</p>
<p>2.render调用1+n次，改变几次页面就更新几次</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;函数式组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
            this.state = &#123;
                isHot:true,
                name:&#39;&#39;
            &#125;
            this.changeWeather = this.changeWeather.bind(this)//这里bind会返回一个函数
        &#125;
        changeWeather()&#123;
            // state不可以直接更改需要借助api
            // this.state.isHot = !this.state.isHot
            // console.log(this.state.isHot)
            this.setState(&#123;isHot:!this.state.isHot&#125;)
        &#125;
        render()&#123;
            return  &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;

    &#125;
    ReactDOM.render(&lt;Weather/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这些代码太复杂，其实可以精简点 </p>
<p>对于刚才的总结一下</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308103016788.png" alt="image-20240308103016788"></p>
<hr>
<p><strong>对于上面的代码，constructor里面的this指向是没问题的，这里面的render的this的指向，是因为React自动帮你实例组件实例对象，然后调用这个render方法，所以要这里的this的指向是组件实例对象，但是类里面的定义的函数，因为调用它是出现在类里面的回调的里面，所以这里的this是undfined，所以要改变这样就需要使用bind的方法，</strong></p>
<pre><code class="js">使用
this.demo=this.changeWeather.bind(this)//这里面就会返回一个方法，里面的this就是指向实例对象
onClick=&#123;this.demo&#125;
</code></pre>
<p>现在就有一个问题</p>
<p>如果作为事件的回调调用类里面的方法</p>
<p>如果这么写,岂不是很复杂</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308103747721.png" alt="image-20240308103747721"></p>
<p>所以又精简的写法</p>
<p>这在提一下类，如果我们在实例对象</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308104111622.png" alt="image-20240308104111622"></p>
<p>这里的wheel是定制</p>
<p>其实我们 不用非得在构造器里面写</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308104203094.png" alt="image-20240308104203094"></p>
<p><strong>记住不要声明变量</strong></p>
<pre><code class="js">a=1//在类里面这样写的意思是给car的实例对象追加一个属性名文a，值为1
</code></pre>
<p>所以之前的代码精简成</p>
<p>其实完全可以这样写</p>
<pre><code class="js">    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
            this.changeWeather = this.changeWeather.bind(this)//这里bind会返回一个函数
        &#125;
        state = &#123;
            isHot:true,
            name:&#39;&#39;
        &#125;
</code></pre>
<p>所以这个我们也可以省略掉</p>
<pre><code>this.changeWeather = this.changeWeather.bind(this)
</code></pre>
<p>但是需要这么写</p>
<p>一步一步的来</p>
<p>首先我们</p>
<p><strong>因为我们写成函数赋值的形式，所以这个函数就不会再函数的原型对象上面，其实就是上面的赋值语句一样 changeWeather当做a function (){<br>            this.setState({isHot:!this.state.isHot})<br>        }，当作值，但是有问题这里的this的指向是undefine的因为组件实例不会调用它，他是个回调的函数</strong></p>
<pre><code class="js">    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
        &#125;
        state = &#123;
            isHot:true,
            name:&#39;&#39;
        &#125;
        changeWeather = function ()&#123;
            this.setState(&#123;isHot:!this.state.isHot&#125;)
        &#125;
        render()&#123;
            return  &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;

    &#125;
</code></pre>
<p>但是如果我们写成箭头函数的话，这样我们的箭头函数本身没有this’就回去上一层去找</p>
<pre><code class="js">    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
        &#125;
        state = &#123;
            isHot:true,
            name:&#39;&#39;
        &#125;
        changeWeather= ()=&gt;&#123;
            this.setState(&#123;isHot:!this.state.isHot&#125;)
        &#125;
        render()&#123;
            return  &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;

    &#125;
</code></pre>
<p>然后再精简一下构造器删掉</p>
<pre><code class="js">    class Weather extends React.Component &#123;
        state = &#123;
            isHot:true,
            name:&#39;&#39;
        &#125;
        changeWeather = ()=&gt;&#123;
            this.setState(&#123;isHot:!this.state.isHot&#125;)
        &#125;
        render()&#123;
            return  &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;

    &#125;
</code></pre>
<p><strong>自定义的方法，要用赋值语句+箭头函数</strong></p>
<p><strong>还有一个注意的，类中使用赋值语句定义一个方法的话，不会放在类中的原型对像，还有这个函数会被添加到类的实例上，而不是放在类的原型对象上。这意味着每个类的实例将拥有自己的这个函数副本，而不是共享同一个函数。</strong></p>
<p>*<em>注意</em></p>
<p>1.state只能使用对象的形式定义</p>
<p>2.组件被称为状态机，通过更新state，熏染render刷新页面</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308110156037.png" alt="image-20240308110156037"></p>
<h3 id="props的基本使用"><a href="#props的基本使用" class="headerlink" title="props的基本使用"></a>props的基本使用</h3><p>基本的使用</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
  class Person extends React.Component &#123;
      state = &#123;
          name:&#39;tom&#39;,
          age:18,
          sex:&#39;女&#39;
      &#125;
    render()&#123;
      return(
          &lt;ul&gt;
              &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt;
              &lt;li&gt;&#123;this.props.age&#125;&lt;/li&gt;
              &lt;li&gt;&#123;this.props.sex&#125;&lt;/li&gt;
          &lt;/ul&gt;

      )
    &#125;

  &#125;
  ReactDOM.render(&lt;Person name=&#39;tom&#39; age=&#39;18&#39; sex=&#39;女&#39;/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p>或者使用解构赋值将props里面的内容给结构出来</p>
<p>现在还有问题</p>
<p>如果要传递的数据很多怎么办</p>
<p>如果这些数据是我们请求接口访问到的那怎么动态的传过去</p>
<pre><code class="js"> const p = &#123;name:&#39;tom&#39;,age:&#39;18&#39;,sex: &#39;女&#39;&#125;
  ReactDOM.render(&lt;Person name=&#123;p.name&#125; age=&#123;p.age&#125; sex=&#123;p.sex&#125;/&gt;,document.getElementById(&#39;test&#39;))
</code></pre>
<p>可以这么写</p>
<p>但是React提供更简单的</p>
<p>这样的</p>
<pre><code class="js">  const p = &#123;name:&#39;tom&#39;,age:&#39;18&#39;,sex: &#39;女&#39;&#125;
  ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&#39;test&#39;))
</code></pre>
<p>有点疑问三点运算符不是不能使用在对象身上吗，除非定义一个对象的迭代器，三点运算符的那个底层原理就是使用了迭代器才能遍历</p>
<p>卧槽学到一个新的语法</p>
<pre><code class="js">//其实对象可以使用三点运算符，只不过适用于对象的字面量的赋值
/例如
const person = &#123;
    name:&#39;hahah&#39;,
    age:&quot;11&quot;
&#125;
const person2 = &#123;...person&#125;
</code></pre>
<p>之前学过直接把person付给person1只是地址的引用</p>
<p>还有深拷贝和浅拷贝</p>
<p>浅拷贝或者使用</p>
<pre><code class="js">const originalObject = &#123; a: 1, b: 2 &#125;;
const shallowCopyObject = Object.assign(&#123;&#125;, originalObject);

console.log(shallowCopyObject); // &#123; a: 1, b: 2 &#125;
console.log(originalObject === shallowCopyObject); // false
</code></pre>
<p>那提到之前的简写的方法</p>
<pre><code class="js">  const p = &#123;name:&#39;tom&#39;,age:&#39;18&#39;,sex: &#39;女&#39;&#125;
  ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&#39;test&#39;))
</code></pre>
<p>千万不要我上面的误导了</p>
<p>上面只是复习一下</p>
<p>首先简写的{}这个作用还是js的表达式，原生的js对象不可以使用三点运算符但是这个里面是可以使用的，原因我也不知道</p>
<p>因为babel可以让你使用三点运算符解构对象</p>
<p>但是不可以随便用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308130931802.png" alt="image-20240308130931802"></p>
<p>之前用于传递数据</p>
<p><strong>再增加点语法的知识</strong></p>
<pre><code class="js">const person = &#123;
    name:&#39;hahah&#39;,
    age:&quot;11&quot;
&#125;
const person2 = &#123;...person,name:&#39;王昌晨&#39;&#125;//在复制的同时修改东西
</code></pre>
<p>还有一写问题</p>
<p>如果传递过去数字类型的数据应该怎么办</p>
<p>1.使用简写的形式直接传过去</p>
<pre><code class="js">  const p = &#123;name:&#39;tom&#39;,age:18,sex: &#39;女&#39;&#125;
  ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&#39;test&#39;))//age定义成数字的在传过去
</code></pre>
<p>2.使用{}代码是js的表达式和vue的里面有点像，只不过vue里面是属性的前面加上:,代表是js表达式，而不是字符串</p>
<pre><code class="js">  ReactDOM.render(&lt;Person age:&#123;18&#125;/&gt;,document.getElementById(&#39;test&#39;))
</code></pre>
<p><strong>默认值的设置</strong></p>
<p><strong>必要性的设置</strong></p>
<pre><code class="js">&lt;!--引入proto-types,用于类型标签属性值的限制--&gt;
&lt;script src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
  class Person extends React.Component &#123;
      state = &#123;
          name:&#39;tom&#39;,
          age:18,
          sex:&#39;女&#39;
      &#125;
    render()&#123;
      return(
          &lt;ul&gt;
              &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt;
              &lt;li&gt;&#123;this.props.age&#125;&lt;/li&gt;
              &lt;li&gt;&#123;this.props.sex&#125;&lt;/li&gt;
          &lt;/ul&gt;

      )
    &#125;
  &#125;
  Person.propTypes = &#123;
      name:PropTypes.string.isRequired,
      sex:PropTypes.string
  &#125;
  Person.defaultProps = &#123;
      sex:&#39;不难不女&#39;
  &#125;
  const p = &#123;name:&#39;tom&#39;,age:&#39;18&#39;&#125;
  ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p>解释一下</p>
<pre><code class="js">  Person.propTypes = &#123;
      name:PropTypes.string.isRequired,
      sex:PropTypes.string
  &#125;
</code></pre>
<p>这里的Person是实例对象，里面由propTypes限制属性传递的类型</p>
<p>在调用PropTypes后面限制类型和是否必要的</p>
<pre><code class="js">  Person.defaultProps = &#123;
      sex:&#39;不难不女&#39;
  &#125;
</code></pre>
<p>这个是设置默认值</p>
<p>如果要是传递函数呢？</p>
<p>这里的就要说一下为什么</p>
<pre><code class="js">  Person.propTypes = &#123;
      name:PropTypes.string.isRequired,
      sex:PropTypes.string
  &#125;
</code></pre>
<p>为什么这里的string开头为什么是大写，就是为了避免和内置的冲突</p>
<p>所以函数为了不冲突，使用func</p>
<p>所以这么写</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
  class Person extends React.Component &#123;
      state = &#123;
          name:&#39;tom&#39;,
          age:18,
          sex:&#39;女&#39;
      &#125;
    render()&#123;
      return(
          &lt;ul&gt;
              &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt;
              &lt;li&gt;&#123;this.props.age&#125;&lt;/li&gt;
              &lt;li&gt;&#123;this.props.sex&#125;&lt;/li&gt;
          &lt;/ul&gt;

      )
    &#125;
  &#125;
  Person.propTypes = &#123;
      name:PropTypes.string.isRequired,
      sex:PropTypes.string,
      speak:PropTypes.func
  &#125;
  Person.defaultProps = &#123;
      sex:&#39;不难不女&#39;
  &#125;
  const p = &#123;name:&#39;tom&#39;,age:&#39;18&#39;&#125;
  const speak = ()=&gt;&#123;
      console.log(&#39;hahah&#39;)
  &#125;
  ReactDOM.render(&lt;Person &#123;...p&#125; speak=&#123;speak&#125;/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p><strong>注意事项</strong></p>
<p>这里的props和vue里面一样</p>
<p>只是只读的</p>
<p>props的简写形式</p>
<p>现在我们把限制属性值和默认值都放在类的外边</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308135744587.png" alt="image-20240308135744587"></p>
<p>写在类的里面完全可以</p>
<p>这样我们先举个例子</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308135920715.png" alt="image-20240308135920715"></p>
<p>我们把demo写在外面属实复杂了</p>
<p>我们直接写在里面</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308140005909.png" alt="image-20240308140005909"></p>
<p>但是这样就加在类的实例对象身上了</p>
<p>就比如下面的，只有实例身上才有</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308140313305.png" alt="image-20240308140313305"></p>
<p>如果加在类本身的话，需要使用static修饰，这就是静态属性和静态方法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308140407091.png" alt="image-20240308140407091"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308140050714.png" alt="image-20240308140050714"></p>
<p>所以加在类里面需要</p>
<pre><code class="js">  class Person extends React.Component &#123;
      state = &#123;
          name:&#39;tom&#39;,
          age:18,
          sex:&#39;女&#39;
      &#125;
      static propTypes = &#123;
          name:PropTypes.string.isRequired,
          sex:PropTypes.string,
          speak:PropTypes.func
      &#125;
      static defaultProps = &#123;
          sex:&#39;不难不女&#39;
      &#125;
    render()&#123;
      return(
          &lt;ul&gt;
              &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt;
              &lt;li&gt;&#123;this.props.age&#125;&lt;/li&gt;
              &lt;li&gt;&#123;this.props.sex&#125;&lt;/li&gt;
          &lt;/ul&gt;

      )
    &#125;
  &#125;
</code></pre>
<p>这样写</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>之前我们说构造器里面有个props的</p>
<pre><code class="js">constructor(props) &#123;
    super(props);
    console.log(this.props)
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308141348090.png" alt="image-20240308141348090"></p>
<p>就是我们props传递的</p>
<p>有几个问题</p>
<p>这个构造器有什用？</p>
<p>之前没有简写的作用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308141549600.png" alt="image-20240308141549600"></p>
<p>这是注意点</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308141626702.png" alt="image-20240308141626702"></p>
<p>详细点就是</p>
<p>如果在继承的子类里面，使用构造器，但是没有接收props并且也没有通过super传递，那么this.props的值就是undefined</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308141953032.png" alt="image-20240308141953032"></p>
<p>之前说过的函数式的组件</p>
<p>因为函数所以没有this，所以使用不了state和refs，</p>
<p>但是可以使用props，因为函数是由有参数的</p>
<p>这样也是可以实现的</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
 function Person(props)&#123;
     console.log(props)
     return (
         &lt;ul&gt;
             &lt;li&gt;&#123;props.name&#125;&lt;/li&gt;
             &lt;li&gt;&#123;props.age&#125;&lt;/li&gt;
             &lt;li&gt;&#123;props.sex&#125;&lt;/li&gt;
         &lt;/ul&gt;
     )
 &#125;
  const p = &#123;name:&#39;tom&#39;,age:&#39;18&#39;&#125;
  ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p>这里的props是一个对象</p>
<p>而且还可以做一些限制</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
 function Person(props)&#123;
     console.log(props)
     return (
         &lt;ul&gt;
             &lt;li&gt;&#123;props.name&#125;&lt;/li&gt;
             &lt;li&gt;&#123;props.age&#125;&lt;/li&gt;
             &lt;li&gt;&#123;props.sex&#125;&lt;/li&gt;
         &lt;/ul&gt;
     )
 &#125;
 Person.propTypes = &#123;
     name:PropTypes.string.isRequired,
 &#125;
 Person.defaultProps = &#123;
     sex:&#39;不难不女&#39;
 &#125;
  const p = &#123;name:&#39;tom&#39;,age:&#39;18&#39;&#125;
  ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308143005798.png" alt="image-20240308143005798"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308143024636.png" alt="image-20240308143024636"></p>
<h3 id="refs和事件处理"><a href="#refs和事件处理" class="headerlink" title="refs和事件处理"></a>refs和事件处理</h3><p>简单的使用refs打节点，获取节点的dom元素，下面是字符串类型的ref</p>
<pre><code class="js">    class Demo extends React.Component &#123;
        showData = ()=&gt;&#123;
            alert(this.refs.input1.value)//z这里拿到的就是真实的dom
        &#125;
        render()&#123;
            return  (
                &lt;div&gt;
                    &lt;input ref=&quot;input1&quot; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;&amp;nbsp;
                    &lt;button ref=&quot;button1&quot; style=&#123;&#123;width:'100px'&#125;&#125; onClick=&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;/button&gt;&amp;nbsp;
                    &lt;input ref=&quot;input2&quot; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
</code></pre>
<p>可以使用解构赋值提取解构出来的dom’元素</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
    class Demo extends React.Component &#123;
        showData = ()=&gt;&#123;
            alert(this.refs.input1.value)//z这里拿到的就是真实的dom
        &#125;
        demo2 = ()=&gt;&#123;
            alert(this.refs.input2.value)
        &#125;
        render()&#123;
            return  (
                &lt;div&gt;
                    &lt;input ref=&quot;input1&quot; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;&amp;nbsp;
                    &lt;button ref=&quot;button1&quot; style=&#123;&#123;width:'100px'&#125;&#125; onClick=&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;/button&gt;&amp;nbsp;
                    &lt;input ref=&quot;input2&quot; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p>上面是ref字符串形式的，已经快被淘汰 了</p>
<p>为什么要被淘汰了呢？官网里面有答案</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308145011084.png" alt="image-20240308145011084"></p>
<p>说明白就是效率的问题</p>
<p>如果ref写多了就会出现效率问题</p>
<p>所以不推荐</p>
<p>下面是新的ref</p>
<p><strong>回调函数形式的ref createref</strong></p>
<p>这是回调的形式</p>
<pre><code class="js">    class Demo extends React.Component &#123;
        showData = ()=&gt;&#123;
            alert(this.refs.input1.value)//z这里拿到的就是真实的dom
        &#125;
        demo2 = ()=&gt;&#123;
            alert(this.refs.input2.value)
        &#125;
        render()&#123;
            return  (
                &lt;div&gt;
                    &lt;input ref=&quot;input1&quot; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;&amp;nbsp;
                    &lt;button ref=&quot;button1&quot; style=&#123;&#123;width:'100px'&#125;&#125; onClick=&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;/button&gt;&amp;nbsp;
                    &lt;input ref=&#123;(a)=&gt;&#123;
                        console.log(a)&#125;&#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
</code></pre>
<p>我们打印一下</p>
<p>发现就是我们所处的节点</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308145640245.png" alt="image-20240308145640245"></p>
<p>所以在升级一下</p>
<pre><code class="js">    class Demo extends React.Component &#123;
        showData = () =&gt;&#123;
            alert(this.refs.input1.value)//z这里拿到的就是真实的dom
        &#125;
        demo2 = ()=&gt;&#123;
            alert(this.input2.value)
        &#125;
        render()&#123;
            return  (
                &lt;div&gt;
                    &lt;input ref=&quot;input1&quot; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;&amp;nbsp;
                    &lt;button ref=&quot;button1&quot; style=&#123;&#123;width:'100px'&#125;&#125; onClick=&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;/button&gt;&amp;nbsp;
                    &lt;input ref=&#123;(currentNode)=&gt;&#123;
                       this.input2 = currentNode&#125;&#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
</code></pre>
<p>这样我们就是实现通过回调函数的方法获取标签额实例</p>
<p><strong>这里讲解一下，这里面，因为回调函数是箭头函数，自身没有this找到了外一层，就是render，所以this就是组建的实例对象</strong></p>
<p>探讨一下ref里面的回调调用次数的问题</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
    class Demo extends React.Component &#123;
        demo2 = ()=&gt;&#123;
            alert(this.input2.value)
        &#125;
        render()&#123;
            return  (
                &lt;div&gt;
                    &lt;input ref=&#123;(currentNode)=&gt;&#123;
                       this.input2 = currentNode&#125;&#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p>这里面的</p>
<pre><code class="js">               &lt;input ref=&#123;(currentNode)=&gt;&#123;
                       this.input2 = currentNode&#125;&#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
</code></pre>
<p>执行几次呢？</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308152628767.png" alt="image-20240308152628767"></p>
<p>我们通过下面的代码可以清楚的看见能使用几次</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
    class Demo extends React.Component &#123;
        state = &#123;
            isHot:false
        &#125;
        demo1 = ()=&gt;&#123;
            this.setState(&#123;isHot:!this.state.isHot&#125;)
        &#125;
        demo2 = ()=&gt;&#123;
            alert(this.input2.value)
        &#125;
        render()&#123;
            return  (
                &lt;div&gt;
                    &lt;h1 onClick=&#123;this.demo1&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
                    &lt;input ref=&#123;(currentNode)=&gt;&#123;
                       this.input2 = currentNode
                        console.log(&#39;@&#39;,currentNode)
                    &#125;&#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p>每当我们使用更新天气的就会刷新页面，</p>
<p>这个时候我们就会发现实际上调用两次</p>
<p>第一次的调用函数的参数为0</p>
<p>第二次调用才获取的标签</p>
<p>原因在这里</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308153630656.png" alt="image-20240308153630656"></p>
<p>为了有一次清空的操作</p>
<p>React熏染到这个回调时候，先设置参数为null，清空的操作，然后网参数传递</p>
<p>然后继续</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308153926882.png" alt="image-20240308153926882"></p>
<p>看起来有点困难其实很简单，其实就是把回调函数写在类的里面</p>
<pre><code class="js">class Demo extends React.Component &#123;
    state = &#123;
        isHot:false
    &#125;
    demo1 = ()=&gt;&#123;
        this.setState(&#123;isHot:!this.state.isHot&#125;)
    &#125;
    demo2 = ()=&gt;&#123;
        alert(this.input2.value)
    &#125;
    render()&#123;
        return  (
            &lt;div&gt;
                &lt;h1 onClick=&#123;this.demo1&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
                &lt;input ref=&#123; this.saveInput &#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                &#123;/*&lt;input ref=&#123;(currentNode)=&gt;&#123;
                   this.input2 = currentNode
                    console.log(&#39;@&#39;,currentNode)
                &#125;&#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;*/&#125;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>
<p>下面写法就可以保证不执行那么多次，因为没有放在render里，而是放在类的里面</p>
<pre><code class="js">    class Demo extends React.Component &#123;
        state = &#123;
            isHot:false
        &#125;
        demo1 = ()=&gt;&#123;
            this.setState(&#123;isHot:!this.state.isHot&#125;)
        &#125;
        demo2 = ()=&gt;&#123;
            alert(this.input2.value)
        &#125;
        saveInput = (currentNode) =&gt; &#123;
            this.input2 = currentNode
            console.log(&#39;@&#39;,currentNode)
        &#125;
        render()&#123;
            return  (
                &lt;div&gt;
                    &lt;h1 onClick=&#123;this.demo1&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
                    &lt;input ref=&#123; this.saveInput &#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                    &#123;/*&lt;input ref=&#123;(currentNode)=&gt;&#123;
                       this.input2 = currentNode
                        console.log(&#39;@&#39;,currentNode)
                    &#125;&#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;*/&#125;
                &lt;/div&gt;
            )
        &#125;
    &#125;
</code></pre>
<p><strong>以后写内敛的回调函数和写内绑定的回调函数其实区别不大，影响也不大，但是内敛的写法还是偏多的</strong></p>
<p>jsx的注释</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308154038486.png" alt="image-20240308154038486"></p>
<p>其实一个快捷键解决了</p>
<p>算了快捷键也是不好用的、</p>
<p>所以还是这样的注释把</p>
<p>下面的ref的定义方法是最新的</p>
<p><strong>使用createRef的api</strong></p>
<p>​	使用createRef实现的基本操作</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
    class Demo extends React.Component &#123;
        state = &#123;
            isHot:false
        &#125;
        demo1 = ()=&gt;&#123;
            this.setState(&#123;isHot:!this.state.isHot&#125;)
        &#125;
        demo2 = ()=&gt;&#123;
            console.log(this.myRef.current)//这个属性里面保存着标签
        &#125;
/React.createRef可调用以后返回一个容器,该容器可以储存被ref标记的节点
        myRef = React.createRef()
        render()&#123;
            return  (
                &lt;div&gt;
                    &lt;h1 onClick=&#123;this.demo1&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
                    &#123;/*当执行到这里,React会把当前ref所在的节点储存在这个容器里面,这既不是回调函数了*/&#125;
                    &lt;input ref=&#123; this.myRef &#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                &lt;/div&gt;
            )
        &#125;
</code></pre>
<p>有个注意的事项</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308160709778.png" alt="image-20240308160709778"></p>
<p>这里面只能定义一个ref，否则的话后面就会把前面的挤掉</p>
<p>但是可以创建多个容器</p>
<p>像这样的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308160826935.png" alt="image-20240308160826935"></p>
<p>这种形式的ref是react官推荐的</p>
<p>总结一下</p>
<p><strong>字符串类型的ref，回调类型的ref(内联绑定，内绑定)，cretaeRef的ref</strong></p>
<p><strong>事件处理</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308161508099.png" alt="image-20240308161508099"></p>
<p>为什么React为什么要二次封装事件，</p>
<p>是为了更好的兼容性</p>
<p>其实</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308161619064.png" alt="image-20240308161619064"></p>
<p>我们给button和input添加的事件处理最后都绑在了外侧的div上</p>
<p>为什么呢？</p>
<p>因为事件委托的原理是事件冒泡</p>
<p>就比如</p>
<pre><code class="js">&lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p><strong>我们想要实现点击每个li标签就会有事件的触发，</strong></p>
<p><strong>我们可以在最外测ul上绑定事件，</strong></p>
<p><strong>因为点击li最后事件冒泡还是会到ul上触发事件</strong></p>
<p><strong>这就是事件委托，委托到最外层的事件，为了就是高效</strong></p>
<p><strong>通过event.target得到发生事件的dom元素</strong></p>
<p>之前文档说不要使用ref，不管是什么类型的</p>
<p>其实我们刚才上面的案列，都可以不适用ref</p>
<p>那怎么用？</p>
<p><strong>我们通过event.target的方法通过触发的事件获取，如下</strong></p>
<pre><code class="js">class Demo extends React.Component &#123;
    state = &#123;
        isHot:false
    &#125;
    demo1 = ()=&gt;&#123;
        this.setState(&#123;isHot:!this.state.isHot&#125;)
    &#125;
    demo2 = (event)=&gt;&#123;
        console.log(event.target)//这个属性里面保存着标签
    &#125;
    //React.createRef可调用以后返回一个容器,该容器可以储存被ref标记的节点
    myRef= React.createRef()
    render()&#123;
        return  (
            &lt;div&gt;
                &lt;h1 onClick=&#123;this.demo1&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
                &#123;/*当执行到这里,React会把当前ref所在的节点储存在这个容器里面,这既不是回调函数了*/&#125;
                &lt;input  onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>
<p><strong>通过event.target可以获取到触发事件的dom元素</strong></p>
<p><strong>总的来说ref尽量能避免就避免</strong></p>
<h2 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h2><p>这里就有两个概念</p>
<p>1.非受控组件</p>
<p>2.受控组件</p>
<p>先说非受控组件</p>
<p>​	</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;!--引入proto-types,用于类型标签属性值的限制--&gt;
&lt;script src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
  class Demo extends React.Component &#123;
    handleForm = (event)=&gt;&#123;
      event.preventDefault()//阻止页面的默认事件
      alert(&#39;您的用户名为&#39;+this.username.value+&#39;您的密码为&#39;+this.password.value)
    &#125;
    render()&#123;
      return  (
              &lt;div&gt;
                &lt;form action=&quot;https://www.baidu.com&quot; onSubmit=&#123;this.handleForm&#125;&gt;
                  用户名 &lt;input ref=&#123;c=&gt;this.username = c&#125; type=&quot;text&quot; placeholder=&quot;请输入账号&quot; name=&quot;username&quot;/&gt;&amp;nbsp;
                  密码 &lt;input ref=&#123;c=&gt;this.password = c&#125; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; name=&quot;password&quot;/&gt;&amp;nbsp;
                  &lt;button &gt;登录&lt;/button&gt;
                &lt;/form&gt;
              &lt;/div&gt;
      )
    &#125;
  &#125;
  ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>上面的代码</p>
<p>当我们输入用户名和密码，再点击提交的时候，</p>
<p>然后调用回调函数，就会分别去取我们节点的属性值username和password</p>
<p><strong>像这样我们现用先现取的标签的值，我们就称其为非受控组件</strong></p>
<p>这里暂停一下</p>
<p>这里感觉vue里面的v-model真是方便，双向绑定数据</p>
<p><strong>那受控组件该怎么写呢?</strong></p>
<p>下面就是受控组件的实列</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;!--引入proto-types,用于类型标签属性值的限制--&gt;
&lt;script src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
  class Demo extends React.Component &#123;
    state=&#123;
      username:&quot;&quot;,
      password:&quot;&quot;//在这里我们可以初始化值
    &#125;
    demo = (event)=&gt;&#123;
      //只要改变就会调用
      console.log(event.target.value)
      this.setState(&#123;username:event.target.value&#125;)//只要我们该表就会更改state的状态值
    &#125;
    demo2 = (event)=&gt;&#123;
      //只要改变就会调用
      console.log(event.target.value)
      this.setState(&#123;password:event.target.value&#125;)//只要我们该表就会更改state的状态值
    &#125;
    handleForm = (event)=&gt;&#123;
      event.preventDefault()//阻止页面的默认事件
      alert(&#39;您的用户名为&#39;+this.state.username+&#39;您的密码为&#39;+this.state.password)
    &#125;
    render()&#123;
      return  (
              &lt;div&gt;
                &lt;form action=&quot;https://www.baidu.com&quot; onSubmit=&#123;this.handleForm&#125;&gt;
                  用户名 &lt;input onChange=&#123;this.demo&#125; type=&quot;text&quot; placeholder=&quot;请输入账号&quot; name=&quot;username&quot;/&gt;&amp;nbsp;
                  密码 &lt;input onChange=&#123;this.demo2&#125; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; name=&quot;password&quot;/&gt;&amp;nbsp;
                  &lt;button &gt;登录&lt;/button&gt;
                &lt;/form&gt;
              &lt;/div&gt;
      )
    &#125;
  &#125;
  ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>当我们输入框的内容发生了就会调用回调</p>
<p>通过回调我们可以实时的将数据通过setState更新到state里面</p>
<p>就相当于vue里的双向绑定</p>
<p>受控组件还有一个优势就是减少了ref的使用</p>
<p>非受控组件刚才的例子一直在使用ref收取表单的数据</p>
<h3 id="组件的声明周期"><a href="#组件的声明周期" class="headerlink" title="组件的声明周期"></a>组件的声明周期</h3><p><strong>高阶函数和函数的柯里化</strong></p>
<p>如果我们继续上面的例子</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308173823123.png" alt="image-20240308173823123"></p>
<p>如果有很多项怎么办?</p>
<p>那么可以通过参数进行界定</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308174015960.png" alt="image-20240308174015960"></p>
<p>但是上面这样的写写法是不对的因为后面有小括号,这样获取的是返回值</p>
<p>所以我们我们可以把返回值定义成一个函数</p>
<p>补充点对象相关的知识</p>
<pre><code class="js">let a = &#39;name&#39;
let obj = &#123;&#125;
obj[a]=&#39;tom&#39;//&#123;name:&#39;tom&#39;&#125;
</code></pre>
<p>所以我们可以写成这样</p>
<pre><code class="js">  class Demo extends React.Component &#123;
    state=&#123;
      username:&quot;&quot;,
      password:&quot;&quot;//在这里我们可以初始化值
    &#125;
    demo = (data)=&gt;&#123;
      console.log(data)
      return (event)=&gt;&#123;
        console.log([data],event.target.value)
      &#125;
    &#125;
    // handleForm = (event)=&gt;&#123;
    //   event.preventDefault()//阻止页面的默认事件
    //   alert(&#39;您的用户名为&#39;+this.state.username+&#39;您的密码为&#39;+this.state.password)
    // &#125;
    render()&#123;
      return  (
              &lt;div&gt;
                &lt;form action=&quot;https://www.baidu.com&quot; onSubmit=&#123;this.handleForm&#125;&gt;
                  用户名 &lt;input onChange=&#123;this.demo(&#39;username&#39;)&#125; type=&quot;text&quot; placeholder=&quot;请输入账号&quot; name=&quot;username&quot;/&gt;&amp;nbsp;
                  密码 &lt;input onChange=&#123;this.demo(&#39;password&#39;)&#125; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; name=&quot;password&quot;/&gt;&amp;nbsp;
                  &lt;button &gt;登录&lt;/button&gt;
                &lt;/form&gt;
              &lt;/div&gt;
      )
    &#125;
  &#125;
</code></pre>
<p>这时候物品们就可以引入高阶函数的定义了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308180409931.png" alt="image-20240308180409931"></p>
<p>常见的高阶函数有:promise,settimeout,因为这两个的参数 函数</p>
<p><strong>函数的柯里化</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308180807412.png" alt="image-20240308180807412"></p>
<p>简单的例子</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308180929289.png" alt="image-20240308180929289"></p>
<p>其实不用函数柯比化也能实现上面的代码</p>
<pre><code class="js">  class Demo extends React.Component &#123;
    state=&#123;
      username:&quot;&quot;,
      password:&quot;&quot;//在这里我们可以初始化值
    &#125;
    demo = (data)=&gt;&#123;
      console.log(data)
      return (event)=&gt;&#123;
        console.log([data],event.target.value)

      &#125;
    &#125;
    // handleForm = (event)=&gt;&#123;
    //   event.preventDefault()//阻止页面的默认事件
    //   alert(&#39;您的用户名为&#39;+this.state.username+&#39;您的密码为&#39;+this.state.password)
    // &#125;
    render()&#123;
      return  (
              &lt;div&gt;
                &lt;form action=&quot;https://www.baidu.com&quot; onSubmit=&#123;this.handleForm&#125;&gt;
                  用户名 &lt;input onChange=&#123;this.demo(&#39;username&#39;)&#125; type=&quot;text&quot; placeholder=&quot;请输入账号&quot; name=&quot;username&quot;/&gt;&amp;nbsp;
                  密码 &lt;input onChange=&#123;this.demo(&#39;password&#39;)&#125; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; name=&quot;password&quot;/&gt;&amp;nbsp;
                  &lt;button &gt;登录&lt;/button&gt;
                &lt;/form&gt;
              &lt;/div&gt;
      )
    &#125;
  &#125;
</code></pre>
<p>上面使用函数的科比话</p>
<p>不用函数的柯比化接收到参数</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
  class Demo extends React.Component &#123;
    state=&#123;
      username:&quot;&quot;,
      password:&quot;&quot;//在这里我们可以初始化值
    &#125;
    demo = (data,value)=&gt;&#123;
      this.setState(&#123;[data]:value&#125;)
    &#125;
    handleForm = (event)=&gt;&#123;
      event.preventDefault()//阻止页面的默认事件
      alert(&#39;您的用户名为&#39;+this.state.username+&#39;您的密码为&#39;+this.state.password)
    &#125;
    render()&#123;
      return  (
              &lt;div&gt;
                &lt;form action=&quot;https://www.baidu.com&quot; onSubmit=&#123;this.handleForm&#125;&gt;
                  用户名 &lt;input onChange=&#123;(event)=&gt;&#123;this.demo(&#39;username&#39;,event.target.value)&#125;&#125; type=&quot;text&quot; placeholder=&quot;请输入账号&quot; name=&quot;username&quot;/&gt;&amp;nbsp;
                  密码 &lt;input onChange=&#123;(event)=&gt;&#123;this.demo(&#39;password&#39;,event.target.value)&#125;&#125; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; name=&quot;password&quot;/&gt;&amp;nbsp;
                  &lt;button &gt;登录&lt;/button&gt;
                &lt;/form&gt;
              &lt;/div&gt;
      )
    &#125;
  &#125;
  ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p>这样我们就可以实现</p>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>首先组建的卸载</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;!--引入proto-types,用于类型标签属性值的限制--&gt;
&lt;script src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Life extends React.Component&#123;
        death=()=&gt;&#123;
          ReactDOM.unmountComponentAtNode(document.getElementById(&#39;test&#39;))
        &#125;
        render()&#123;
            return (
                &lt;div&gt;
                    &lt;h2&gt;React学不会怎么办&lt;/h2&gt;
                    &lt;button onClick=&#123;this.death&#125;&gt;不活了&lt;/button&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;Life/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>使用unmountComponentAtNode可以使某个组件卸载</p>
<p>组件挂载的声明周期钩子</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;!--引入proto-types,用于类型标签属性值的限制--&gt;
&lt;script src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Life extends React.Component&#123;
        state=&#123;
            opacity:0.5
        &#125;

        death=()=&gt;&#123;
            ReactDOM.unmountComponentAtNode(document.getElementById(&#39;test&#39;))
        &#125;
        componentDidMount()&#123;// 这里的构造只调用一次,和render函数一样,组件实例化以后,REact会自己帮你调用
            setInterval(()=&gt;&#123;
                let &#123;opacity&#125; = this.state
                opacity -= 0.1
                if (opacity&lt;=0) opacity = 1
                this.setState(&#123;opacity:opacity&#125;)
            &#125;,200)
        &#125;
        render()&#123;
            return (
                &lt;div&gt;
                    &lt;h2 style=&#123;&#123;opacity:this.state.opacity&#125;&#125;&gt;React学不会怎么办&lt;/h2&gt;
                    &lt;button onClick=&#123;this.death&#125;&gt;不活了&lt;/button&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;Life/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>只在组件完成挂载以后开始执行 </p>
<p>componentDidMount:组件挂载完毕调用</p>
<p>render:初始化渲染,数据更新以后</p>
<p>但是在卸载组件的时候上面的代码会出问题,</p>
<p>因为在卸载组件之前没有把定时器卸载掉</p>
<p>所以修改完以后</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;!--引入proto-types,用于类型标签属性值的限制--&gt;
&lt;script src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Life extends React.Component&#123;
        state=&#123;
            opacity:0.5
        &#125;

        death=()=&gt;&#123;
            clearInterval(this.timer)
            ReactDOM.unmountComponentAtNode(document.getElementById(&#39;test&#39;))
        &#125;
        componentDidMount()&#123;// 这里的构造只调用一次,和render函数一样,组件实例化以后,REact会自己帮你调用
            this.timer=setInterval(()=&gt;&#123;
                let &#123;opacity&#125; = this.state
                opacity -= 0.1
                if (opacity&lt;=0) opacity = 1
                this.setState(&#123;opacity:opacity&#125;)
            &#125;,200)
        &#125;
        render()&#123;
            return (
                &lt;div&gt;
                    &lt;h2 style=&#123;&#123;opacity:this.state.opacity&#125;&#125;&gt;React学不会怎么办&lt;/h2&gt;
                    &lt;button onClick=&#123;this.death&#125;&gt;不活了&lt;/button&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;Life/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>其实还可以写在组件将要写在卸载还没有卸载的时候</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;!--引入proto-types,用于类型标签属性值的限制--&gt;
&lt;script src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Life extends React.Component&#123;
        state=&#123;
            opacity:0.5
        &#125;

        death=()=&gt;&#123;

            ReactDOM.unmountComponentAtNode(document.getElementById(&#39;test&#39;))
        &#125;
        componentDidMount()&#123;// 这里的构造只调用一次,和render函数一样,组件实例化以后,REact会自己帮你调用
            this.timer=setInterval(()=&gt;&#123;
                let &#123;opacity&#125; = this.state
                opacity -= 0.1
                if (opacity&lt;=0) opacity = 1
                this.setState(&#123;opacity:opacity&#125;)
            &#125;,200)
        &#125;
        componentWillUnmount()&#123;
            clearInterval(this.timer)
        &#125;
        render()&#123;
            return (
                &lt;div&gt;
                    &lt;h2 style=&#123;&#123;opacity:this.state.opacity&#125;&#125;&gt;React学不会怎么办&lt;/h2&gt;
                    &lt;button onClick=&#123;this.death&#125;&gt;不活了&lt;/button&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;Life/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>使用componentWillUnmount这个钩子在快要卸载的时候调用</p>
<p><strong>React的生命周期</strong></p>
<p>&#x2F;<img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F(%E6%97%A7).png" alt="react生命周期(旧)"></p>
<p>其实render也是一个生命周期钩子函数，上面的 生命周期是旧版本的</p>
<p>先测试左边的的钩子</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
    class Count extends React.Component&#123;
        constructor(props) &#123;
            super(props);
            console.log(&#39;Count-constructor&#39;)
            this.state=&#123;
                count:0,
            &#125;
        &#125;
        //组建的将要挂载,在render的前面
        componentWillMount()&#123;
            console.log(&#39;Count-componentWillMount&#39;)
        &#125;
        render()&#123;
            console.log(&#39;Count-render&#39;)
            const &#123;count&#125; = this.state
            return (
                &lt;div&gt;
                    &lt;h2&gt;当前求和为:&#123;count&#125;&lt;/h2&gt;
                    &lt;button onClick=&#123;this.add&#125;&gt;当前求和为:&lt;/button&gt;
                &lt;/div&gt;
            )
        &#125;
        //组件已经挂载完毕，已经通过render渲染在页面上了
        componentDidMount()&#123;
            console.log(&#39;Count-componentDidMount&#39;)
        &#125;
        add = ()=&gt;&#123;
            const &#123;count&#125; = this.state
            this.setState(&#123;count:count+1&#125;)
        &#125;
    &#125;
    ReactDOM.render(&lt;Count/&gt;,document.getElementById(&#39;test&#39;))
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309093729432.png" alt="image-20240309093729432"></p>
<p>上面的顺序已经验证了</p>
<p>组件的卸载生命周期钩子</p>
<pre><code class="js">            ReactDOM.unmountComponentAtNode(&#39;test&#39;)
</code></pre>
<p>调用这个以后就会卸载组件</p>
<p>然后就会调用</p>
<pre><code class="js">        componentWillUnmount()&#123;
            console.log(&#39;Conut-componentWillUnmount&#39;)
        &#125;
</code></pre>
<p>这个生命周期</p>
<p>然后再讲讲更新的钩子</p>
<p>主要有三个流程</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309094242736.png" alt="ie-20240309094242736"></p>
<p>先说一下2这条线</p>
<p>调用setState以后</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309094628518.png" alt="image-20240309094628518"></p>
<p>讲一下这个钩子</p>
<p><strong>当我们使用setState更改状态以后，就会调用上面的钩子，这个如果没有写就会默认帮你调用。</strong></p>
<p><strong>返回值使boolen类型的，如果钩子返回的是true，那么后面的更新的钩子 都可以走下去，</strong></p>
<p><strong>如果false，更新的操作就会停在这里了，不写默认返回真</strong></p>
<pre><code class="js">        shouldComponentUpdate()&#123;
            console.log(&#39;Count-shouldComponentUpdate&#39;)
            return true
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309095036994.png" alt="image-20240309095036994"></p>
<p>如果是false</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309095108314.png" alt="image-20240309095108314"></p>
<p>render不会调用，</p>
<p><strong>简单地的就是控制组件更新的阀门</strong></p>
<p>然后是</p>
<p>组件将要更新</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309095237631.png" alt="image-20240309095237631"></p>
<pre><code class="js">        //这一步在render的前面，实在更新的之前
        componentWillUpdate()&#123;
            console.log(&#39;Cout-componentWillUpdate&#39;)
        &#125;
</code></pre>
<p>然后是</p>
<p>组件更新完毕的钩子</p>
<pre><code class="js">        //组件更新完成以后，render的后面
        componentDidUpdate()&#123;
            console.log(&#39;Cout-componentDidUpdate&#39;)
        &#125;
</code></pre>
<p>执行的效果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309095603118.png" alt="image-20240309095603118"></p>
<p>然后我们在看这条线</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309100705256.png" alt="image-20240309100705256"></p>
<p>调用forceUpdate的</p>
<p>这个是强制更新，不对 状态里面的数据进行更改，也能更新，这个流程会绕过阀门shouldcomponentupdate</p>
<p>当我们调用</p>
<pre><code class="js">        //轻质更新
        force=()=&gt;&#123;
            this.forceUpdate()
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309101111562.png" alt="image-20240309101111562"></p>
<p>不受阀门的控制</p>
<p>接下来第一条线</p>
<p>这一条线需要父子关系</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309101857230.png" alt="image-20240309101857230"></p>
<p>当我们父组件执行render以后，子组件就会响应componentWillReceiveProps,子组件将要接到props</p>
<p>这个钩子当我们传递数据给子组件，子组件里面就会调用这个钩子</p>
<p>如下</p>
<pre><code class="js">    class A extends React.Component&#123;
        state=&#123;
            carName:&#39;奔驰&#39;
        &#125;
        changeCar=()=&gt;&#123;
            this.setState(&#123;carName:&#39;奥托&#39;&#125;)
        &#125;
        render()&#123;
            return(
                &lt;div&gt;
                    &lt;div&gt;A组件&lt;/div&gt;
                    &lt;button onClick=&#123;this.changeCar&#125;&gt;换车&lt;/button&gt;
                    &lt;B carName=&#123;this.state.carName&#125;&gt;&lt;/B&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    class B extends React.Component&#123;
        componentWillReceiveProps()&#123;
            console.log(&#39;B-componentWillReceiveProps&#39;)
        &#125;
        render()&#123;
            return(
                &lt;div&gt;
                    &lt;p&gt;B组件，接收到&#123;this.props.carName&#125;&lt;/p&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;A/&gt;,document.getElementById(&#39;test&#39;))
</code></pre>
<p>但是这个componentWillReceiveProps有个弊端就是第一次传递props就不会调用。</p>
<p>什么意思呢？</p>
<p><strong>就是上面我们初始的时候就给B组件把state里面的carName传递过去，b组件显示了，数据已经通过props传过去但是却没有调用</strong></p>
<p><strong>componentWillReceiveProps，只有更新state里的state里的carName以后才会调用</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309103003362.png" alt="image-20240309103003362"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309103115494.png" alt="image-20240309103115494"></p>
<p>常用的钩子</p>
<p>**componentDidMount()**常用于做一些初始化的东西，例如开启定时器，发送网络请求，订阅消息</p>
<p>**componentWillUnmount()**一般做收尾的东西，例如关闭定时器</p>
<p>上面是旧版的生命周期</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F(%E6%96%B0).png" alt="react生命周期(新)"></p>
<p>有些生命周期已经改名了但是还可以使用</p>
<p>不过会有报错</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309104918803.png" alt="image-20240309104918803"></p>
<p>但是在18版本必须写改名以后的</p>
<p>我们把名字改下，新版本下面三个需要加上前缀</p>
<pre><code class="js">UNSAFE_componentWillMount()&#123;
    console.log(&#39;Count-componentWillMount&#39;)
&#125;
UNSAFE_componentWillUpdate()&#123;
    console.log(&#39;Cout-componentWillUpdate&#39;)
&#125;
UNSAFE_componentWillReceiveProps()&#123;
    console.log(&#39;B-componentWillReceiveProps&#39;)
&#125;
</code></pre>
<p>这样就可以</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309105212538.png" alt="image-20240309105212538"></p>
<p>所有的带will的除了<strong>componentWillUnmount</strong>都得加上<strong>UNSAFE</strong></p>
<p>为什么要这样呢？</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309105619178.png" alt="image-20240309105619178"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309105627220.png" alt="image-20240309105627220"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309105720027.png" alt="image-20240309105720027"></p>
<p>这几个钩子，经常被人滥用，这几个钩子经常不用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309105902373.png" alt="image-20240309105902373"></p>
<p>除了这个区别还有别的吗？</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309110039854.png" alt="image-20240309110039854"></p>
<p>对吧旧版本没有经过UNSAFE_componentWillUpdate，UNSAFE_componentWillMount，但是还是会掉用</p>
<p>用上图的一个新的钩子替代了他们</p>
<p>更新的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309110319172.png" alt="image-20240309110319172"></p>
<p>注意更新渲染以后有新增一个钩子</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309110405193.png" alt="image-20240309110405193"></p>
<p>getSnapshotBeforeUpdate</p>
<p>相比之下</p>
<p>新版本的钩子</p>
<hr>
<p><strong>将要废弃了三个钩子分别为UNSAFE_componentWillMount，UNSAFE_componentWillUpdate，UNSAFE_componentWillReceiveProps，注意是将要，新增getSnapshotBeforeUpdate，getDerivedStateFormProps</strong></p>
<p><strong>getDerivedStateFromProps</strong></p>
<p>不能定义给是使用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309111212958.png" alt="image-20240309111212958"></p>
<p>需要static</p>
<p>还是不行</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309111307893.png" alt="image-20240309111307893"></p>
<p>需要返回null或者状态的那个对象</p>
<p>返回null对功能没有影响</p>
<p>如果返回状态对象的话</p>
<pre><code class="js">constructor(props) &#123;
    super(props);
    console.log(&#39;Count-constructor&#39;)
    this.state=&#123;
        count:0,
    &#125;
&#125;
//构造器以后
static getDerivedStateFromProps()&#123;
    console.log(&#39;getDerivedStateFromProps&#39;)
    return &#123;count:100,&#125;
&#125;
</code></pre>
<p>这样更新state就会影响了，以后用于改不了，其他的不受影响</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309111535487.png" alt="image-20240309111535487"></p>
<p>而且这里的还能接收到props</p>
<p>这就能解释他的名字了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309111705341.png" alt="image-20240309111705341"></p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
    class Count extends React.Component&#123;
        constructor(props) &#123;
            super(props);
            console.log(&#39;Count-constructor&#39;)
            this.state=&#123;
                count:0,
            &#125;
        &#125;
        //构造器以后
        static getDerivedStateFromProps(props)&#123;
            console.log(&#39;getDerivedStateFromProps=&gt;&#39;+ props)
            return props
        &#125;
        render()&#123;
            console.log(&#39;Count-render&#39;)
            const &#123;count&#125; = this.state
            return (
                &lt;div&gt;
                    &lt;h2&gt;当前求和为:&#123;count&#125;&lt;/h2&gt;
                    &lt;button onClick=&#123;this.add&#125;&gt;当前求和为:&lt;/button&gt;
                    &lt;button onClick=&#123;this.death&#125;&gt;卸载组件&lt;/button&gt;
                    &lt;button onClick=&#123;this.force&#125;&gt;不更改任何状态中的数据，强制更新&lt;/button&gt;
                &lt;/div&gt;
            )
        &#125;
        //组件已经挂载完毕，已经通过render渲染在页面上了
        componentDidMount()&#123;
            console.log(&#39;Count-componentDidMount&#39;)
        &#125;
        //组件卸载前调用这个函数
        componentWillUnmount()&#123;
            console.log(&#39;Conut-componentWillUnmount&#39;)
        &#125;
        shouldComponentUpdate()&#123;
            console.log(&#39;Count-shouldComponentUpdate&#39;)
            return true
        &#125;
        //组件更新完成以后，rnder的后面
        componentDidUpdate()&#123;
            console.log(&#39;Cout-componentDidUpdate&#39;)
        &#125;
        add = ()=&gt;&#123;
            const &#123;count&#125; = this.state
            this.setState(&#123;count:count+1&#125;)
        &#125;
        death = ()=&gt;&#123;
            ReactDOM.unmountComponentAtNode(&#39;test&#39;)
        &#125;
        //轻质更新
        force=()=&gt;&#123;
            this.forceUpdate()
        &#125;
    &#125;
    ReactDOM.render(&lt;Count age=&#39;100&#39;/&gt;,document.getElementById(&#39;test&#39;))
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309111831207.png" alt="image-20240309111831207"></p>
<p><strong>这样就实现了</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309111923036.png" alt="image-20240309111923036"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309111941448.png" alt="image-20240309111941448"></p>
<p>还有一个参数state</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309112012045.png" alt="image-20240309112012045"></p>
<p><strong>getSnapshotBeforeUpdate</strong></p>
<pre><code class="js">getSnapshotBeforeUpdate()&#123;
    console.log(&#39;getSnapshotBeforeUpdate&#39;)
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310083727159.png" alt="image-20240310083727159"></p>
<p>如果不返回值就会报错</p>
<p>提示说快照值或者 一个null值</p>
<p>这个快照之可以是任意的值 </p>
<p>但是这里的返回值去哪里了？<br>先说一下componentDidupdate</p>
<p>这里的参数</p>
<pre><code class="js">        componentDidUpdate(preProps,preState)&#123;
            console.log(&#39;Cout-componentDidUpdate&#39;,preProps,preState)
        &#125;
</code></pre>
<p>这里的参数分别为，</p>
<p>传过来的props和上一次的的state，注意不是最新的</p>
<p>接着上面的话题</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310084437340.png" alt="image-20240310084437340"></p>
<p>所以它有三个参数</p>
<pre><code class="js">componentDidUpdate(preProps,preState,snapshotValue)&#123;
    console.log(&#39;Cout-componentDidUpdate&#39;,preProps,preState,snapshotValue)
&#125;
</code></pre>
<p>那这个有什么用呢？</p>
<p><strong>为了记录之前的数据，加入之前有10个人，更新以后有11个人，如果逆向获取之前的10个人的数据，我们就可以使用快照记录下之前的数据</strong></p>
<p>作用就是</p>
<p><strong>在更新的时候获取快照</strong></p>
<p>新版生命周期的总结</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310085826926.png" alt="image-20240310085826926"></p>
<h2 id="Dom的diffing算法"><a href="#Dom的diffing算法" class="headerlink" title="Dom的diffing算法"></a>Dom的diffing算法</h2><p>验证React的diffing的算法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310090136662.png" alt="image-20240310090136662"></p>
<p>每个一秒更细state的数据</p>
<p>因为模板里面的h1和input没有发生改变，但是span的发生变化，所以其他的渲染一次，但是span里面一直在熏染</p>
<p>如果里面的span还有input的话，里面的input不会更新熏染</p>
<p>这里重新复习一下vue和react的key的作用原理</p>
<p>这个代码</p>
<pre><code class="js">    class Person extends React.Component &#123;
        state=&#123;
            persons:[
                &#123;id:1,name:&quot;黎明&quot;&#125;,
                &#123;id:2,name:&quot;小白&quot;&#125;,
                &#123;id:3,name:&quot;小黑&quot;&#125;,
                &#123;id:4,name:&#39;小红&#39;&#125;,
            ]
        &#125;
        addPerson = ()=&gt;&#123;
            const &#123;persons&#125; = this.state
            const p = &#123;id:persons.length+1,name:&quot;小王&quot;&#125;
            this.setState(&#123;persons:[p,...persons]&#125;)
        &#125;
        render()&#123;
            return (
                &lt;div&gt;
                    &lt;h2&gt;展示人员信息&lt;/h2&gt;
                    &lt;button onClick=&#123;this.addPerson&#125;&gt;添加一个小王&lt;/button&gt;
                    &lt;ul&gt;
                        &#123;
                            this.state.persons.map((item,index)=&gt;&lt;li key=&quot;index&quot;&gt;&#123;item.name&#125;&lt;/li&gt;)
                        &#125;
                    &lt;/ul&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;Person&gt;&lt;/Person&gt;,document.getElementById(&#39;test&#39;))
</code></pre>
<p>上面的代码存在严重的效率问题</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310091527249.png" alt="image-20240310091527249"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310091616022.png" alt="image-20240310091616022"></p>
<p><strong>新的虚拟DOM生新的虚拟DOM，然后和旧的虚拟DOM进行比较，然后比较玩以后在生成新的虚拟DOM，记住对比的是虚拟dom</strong></p>
<p>比较过程是这样的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310091847370.png" alt="image-20240310091847370"></p>
<p>我们根据上面的例子看一下</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310093424684.png" alt="image-20240310093424684"></p>
<p><strong>根据diffing算法，先取和旧的虚拟DOM相同的，首先是0 ，但是数据发生改变了，所以需要重新更新dom，接下去的一样，但是我们只是更新了一条数据，所以上面的代码有效率问题，如果上面的小王是往后面的放就不会出现这个问题</strong></p>
<p>如果我们有2000条数据，但是我们只更新一条，还是往前面加，这样我们的2001数据都得更新，</p>
<p>所以我们换个值当最索引值做key，我们就可以拿数据里面的id当作id</p>
<p>上面的问题，当我们的出现大佬输入的节点就会更严重</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310094215984.png" alt="image-20240310094215984"></p>
<p>这样的而原因就是因为</p>
<p><strong>当小王插入以后，key为0，小张的变为1，之前的小张为0 ，里面的输入框因为前后的diffing对比以后没有发生改变，所以input框不会更新还会再原来的位置</strong></p>
<p>如果上面是往后面的加，就不会造成上面的问题</p>
<p>总结</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310094918754.png" alt="image-20240310094918754"></p>
<p>如何避免呢？</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310095020295.png" alt="image-20240310095020295"></p>
<h2 id="初始化React脚手架"><a href="#初始化React脚手架" class="headerlink" title="初始化React脚手架"></a>初始化React<strong>脚手架</strong></h2><p>作用:快速安全的编写基于某种技术</p>
<p>使用webpack搭建的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310095419651.png" alt="image-20240310095419651"></p>
<p>创建的过程</p>
<p>1.首先安装库，我使用的pnpm</p>
<pre><code class="bash">pnpm i -g create-react-app
</code></pre>
<p>2.然后创建脚手架项目</p>
<pre><code class="bash">create-react-app hello_react
</code></pre>
<p>然后就创建完成了</p>
<pre><code>补充一点知识，做移动端的app
Android 一般使用java
IOS 一般使用oc swift
</code></pre>
<p><strong>加壳技术就是在把pc端的网页加个壳，就会有apk的文件，就可以安在手机上，其实不是一个应用，只是一个壳，当用户点击是就是打开一个壳，壳里面里面内嵌一个网页，这就是应用加壳技术，一般小型软件可以</strong></p>
<p>再说一下noscript的标签</p>
<p>当浏览器不支持js就会显示里面的内容</p>
<p>robots的文件，规定哪些可以爬取，哪些不可以爬取</p>
<p>在入口文件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310105538811.png" alt="image-20240310105538811"></p>
<p>渲染的时候外层包裹的的标签是检查app组件是否有错误，</p>
<p>比如react要淘汰的字符串了的ref类型，就会检查出来</p>
<p>再补充点</p>
<p>在webpack里面一切皆模块</p>
<p>图片也可以这样的引入</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310105830110.png" alt="image-20240310105830110"></p>
<p>下面的文件是用于记录页面行性能</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310105909326.png" alt="image-20240310105909326"></p>
<p>我们可以简写一下</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310113950842.png" alt="image-20240310113950842"></p>
<p>更简单的是，注意这是es6的语法，不是从react里面解构出来</p>
<p>正常是从React里面解构的</p>
<pre><code class="js">import React ,&#123;Component&#125;from &quot;react&quot;;
</code></pre>
<p>还有一个注意点</p>
<p>如果我们项目的目录下有组件的文件，有一些功能性的文件的话</p>
<p>有时候我们可能导致很乱</p>
<p><strong>1.我们可以将组组建的文件名字大写</strong></p>
<p><strong>2.我们可以把js后缀改为jsx，因为React里可以使用jsx</strong></p>
<p>就可以这样</p>
<p>另外在别的文件引入的话也可以进行省略后面的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310151256413.png" alt="image-20240310151256413"></p>
<p>后面的jsx也可以省略</p>
<p>app里面也是可以更改的</p>
<p>如果名字是index的话就可以直接省略</p>
<p>样式的模块化（一般不使用）</p>
<p>可以增长知识</p>
<pre><code class="js">import React,&#123;Component&#125;  from &quot;react&quot;
import hello  from &#39;./Hello.module.css&#39;
export default class Hello extends Component &#123;
    render()&#123;
        return (
            &lt;div&gt;
                &lt;h1 className=&#123;hello.title&#125;&gt;hello,react&lt;/h1&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>
<pre><code class="js">.title&#123;
    background-color: orange;
&#125;
</code></pre>
<p>然后把css的文件名字改成这样</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310152101136.png" alt="image-20240310152101136"></p>
<p>我们可以使用代码片段快速的生成一个</p>
<p>使用</p>
<pre><code>rcc
</code></pre>
<p>就会快速创建一个类组件的组件</p>
<p>使用</p>
<pre><code>rfc
</code></pre>
<p>就会快速创建一个函数式组件的组件</p>
<p><strong>一般成型的模块的往上面放,j就是使用的第三库的包</strong></p>
<p><strong>一般自己写的组件往下面放，样式放在最后</strong></p>
<pre><code class="js">defaultchecked，这个相比于checked，是可以取消勾选的，checked是更改不了的，得要change
</code></pre>
<p>event对象里面还有</p>
<pre><code class="js">class Header extends Component &#123;
    handleKeyUp = (event)=&gt;&#123;
        console.log(event.target.value,event.keyCode)
&#125;
    render() &#123;
        return (
            &lt;div className=&quot;todo-header&quot;&gt;
                &lt;input type=&quot;text&quot; placeholder=&quot;请输入你的任务名称，按回车键确认&quot; onKeyUp=&#123;this.handleKeyUp&#125;/&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;
</code></pre>
<p>event里面的keyCode键盘吗，可以通过这个来判断是否回车</p>
<p>这里的子组件向父组件传递就可以使用函数的形式进行传递。和vue里面的一样</p>
<p>如下</p>
<p>父组件</p>
<pre><code class="js">    a = (value)=&gt;&#123;
        console.log(value)
    &#125;
    render() &#123;
        const &#123;todos&#125; = this.state
        return (
            &lt;div&gt;
                &lt;div className=&quot;todo-container&quot;&gt;
                    &lt;div className=&quot;todo-wrap&quot;&gt;
                        &lt;Header a=&#123;this.a&#125;/&gt;
                        &lt;List todos=&#123;todos&#125;/&gt;
                        &lt;Footer/&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;
</code></pre>
<p>子组件</p>
<pre><code class="js">    handleKeyUp = (event)=&gt;&#123;
        const a = this.props.a
        const &#123;target , keyCode&#125; = event
        if (keyCode !== 13) return
        console.log(target.value, keyCode)
        a(target.value)

&#125;
</code></pre>
<p>之前说过的技巧</p>
<pre><code class="js">const person = &#123;name:&#39;11&#39;,age:19&#125;
const  person1 = &#123;...person,name:&#39;666&#39;&#125;
console.log( person1 )//&#123;name:&quot;666&quot;,age:19&#125;
</code></pre>
<p>之前的代码</p>
<pre><code class="js">    shouldChecked = (value,item)=&gt;&#123;
        console.log(value,item)        
        const newTodos = this.state.todos.map((item1)=&gt;&#123;
            if (item1 === item)&#123;
                item1.done = value
            &#125;
            return item1
        &#125;)
        console.log(newTodos)
        this.setState(&#123;todos:newTodos&#125;)
    &#125;
</code></pre>
<p>我可以完全写成这样</p>
<pre><code class="js">    shouldChecked = (value,item)=&gt;&#123;
        console.log(value,item)
        const newTodos = this.state.todos.map((item1)=&gt;&#123;
            // if (item1 === item)&#123;
            //     item1.done = value
            // &#125;
            // return item1
            if (item1 ===item)&#123;
                return &#123;...item1,done:value&#125;
            &#125; else return item1
        &#125;)
        console.log(newTodos)
        this.setState(&#123;todos:newTodos&#125;)
    &#125;
</code></pre>
<p>脚手架里面没有配置PropTypes所以需要自己安装</p>
<pre><code>PropTypes用于对prop传过来的数据做检查的
</code></pre>
<p>指令</p>
<pre><code class="bash">pnpm i prop-types
</code></pre>
<pre><code class="jsx">   import PropTypes from &quot;prop-types&quot;
   static propTypes =&#123;
        addTodo:PropTypes.func.isRequired
    &#125;//卸载类的里面
</code></pre>
<p>删除的操作还可以优化一下</p>
<pre><code class="js">    deleteTodo = (event)=&gt;&#123;
        if (window.confirm(&#39;确定删除吗？&#39;))&#123;
            console.log(this.props.item)
            this.props.deleteTodo(this.props.item)
        &#125;
    &#125;
</code></pre>
<p><strong>原生的js这里不需要写window，但是React的里面需要加上window</strong></p>
<p>我们在实现</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310194050185.png" alt="image-20240310194050185"></p>
<p>通过勾选然后实时的改变，就需要app组件向footer组件传递todos</p>
<p>这里就用到getDerivedStateFromPropsz这个钩子</p>
<p>在熏染前调用</p>
<pre><code class="jsx">   state = &#123;
        finished:null,
        all:null
    &#125;    
static getDerivedStateFromProps(props,state)&#123;
        const newTodos = props.todos.filter((item)=&gt;&#123;
            return item.done === true
        &#125;)
        return &#123;
            finished: newTodos.length,
            all: props.todos.length
        &#125;
    &#125;
</code></pre>
<p>这样state的数据都却决于饿哦们传递过来的数据的长度</p>
<p>注意这是静态方法，需要是使用static</p>
<p><strong>其实更简单的方法就是把上面的操作（薰染前计算）写在render里面</strong></p>
<p>这里强调defaultChecked的用法</p>
<p><strong>defaultChecked只有第一次有效</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310195018692.png" alt="image-20240310195018692"></p>
<p>这里的是我用defaultChecked定义的</p>
<p>开始没有全部的勾选，</p>
<p>但是当我们全部勾选上</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310195139432.png" alt="image-20240310195139432"></p>
<p>他也不会有效了</p>
<p>这就是第一次有效</p>
<p>所以使用checked但是需要配合onChange使用</p>
<p><strong>状态提升</strong></p>
<p>把子组件需要的状态写在夫组件里面</p>
<p>状态在哪里修改状态的方法就在哪里</p>
<h3 id="React里面发送ajax请求"><a href="#React里面发送ajax请求" class="headerlink" title="React里面发送ajax请求"></a>React里面发送ajax请求</h3><p>使用axios进行发送ajax请求</p>
<p> 在使用ajax发送数据的时候出现了跨域的问题</p>
<p>所以需要配置代理服务器</p>
<p>这里讲一下为什么代理服务器可以解决就跨域、</p>
<p><strong>我们创建一个和客户端一样端口号的服务器，然后，假如说我们的客户端的端口号是3000，服务器的端口号是5000，然后我们需要向，代理服务器发送请求，这个代理服务器就会就把刚才的请求转发给5000，然后5000，就可以把响应给代理的3000端口，这里之前就会有疑问，为什么5000能给3000代理响应，不应该还是跨域吗， 因为，这个代理没有ajax引擎，之前的客户端的3000端口被拦截是因为有ajax引擎，这样响应的数据被拦在外面，同源策略不会限制</strong></p>
<p>配置代理的方法</p>
<p>把你的package.json文件里面加入</p>
<pre><code class="js">  &quot;proxy&quot;: &quot;http://localhost:5000&quot;
</code></pre>
<p>这个是你要请求的地址</p>
<p>然后</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240311105551434.png" alt="image-20240311105551434"></p>
<p>所以我们请求的地址也得是代理服务器的地址</p>
<pre><code class="js">    getInfo = ()=&gt;&#123;
        axios.get(&#39;http://localhost:3000/students&#39;).then((response)=&gt;&#123;
            console.log(response.data)
        &#125;,(error)=&gt;&#123;
            &#39;失败了&#39;
        &#125;)
    &#125;
</code></pre>
<p>这里有一个注意点，</p>
<p>如果3000端口有的请求地址有的话，就不会请求服务器了</p>
<p>例如</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240311105922021.png" alt="image-20240311105922021"></p>
<p>在我们的3000端口下有index.html，所以代理服务器就不会请求服务器了，</p>
<p>如果public里面有students那么也不会给服务器5000了，</p>
<p>上面的写法不太好</p>
<p>我们还有一种情况，如果，我们请求两个地址，一个5000端口，一个5001端口，那么上面</p>
<pre><code class="js">&quot;proxy&quot;: &quot;http://localhost:5000&quot;
</code></pre>
<p>这样就配置死了</p>
<p><strong>所以配置多个代理的方法</strong>（这种方法实验了很多次 还是不好用）</p>
<p>这个博客可以看一下</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ZLJ_999/article/details/124169675">react跨域 http-proxy-middleware 无效还是404_http-proxy-middleware 403-CSDN博客</a></p>
<p>1.在src目录下创建setupProxy(react脚手架会发现这个文件，然后把这个文件的配置加到webpackd的配置里，webpack里面使用都是cjs的语法)</p>
<p>2.这个文件里面只能使用cjs的语法写，就是（common js）</p>
<p>3.在setupProxy里面的代码</p>
<pre><code class="js">const &#123;createProxyMiddleware&#125; = require(&#39;http-proxy-middleware&#39;)


module.exports = function (app)&#123;
    app.use(
        createProxyMiddleware(&#39;api1&#39;,&#123;//遇见api1的前缀就会触发该代理配置HOST就是请求的地址
            target:&#39;http://localhost:5000&#39;,//请求转给谁
            changeOrigin:true,////控制服务器收到的响应头中HOST字段的值，这个就可以欺骗服务器。，如果服务器对请求的地址做出限制，只允许5000访问的，那么这个就排上用场了，3000请求的，请求头里面的就是HOST就是5000，不加也不会有太大的问题
            pathRewrite:&#123;&#39;^/api1&#39;:&#39;&#39;&#125;
        &#125;)
    )
&#125;
</code></pre>
<p>然后请求的地址也要更改下</p>
<pre><code class="js">    getInfo = ()=&gt;&#123;
        axios.get(&#39;http://localhost:3000/api1/students&#39;).then((response)=&gt;&#123;
            console.log(response.data)
        &#125;,(error)=&gt;&#123;
            &#39;失败了&#39;
        &#125;)
    &#125;
</code></pre>
<p>这里的api1机会匹配到setupProxy里面的api1，多个是同样的道理，但是我的实验 很多次也是没有用的</p>
<p>在Express里面可以通过</p>
<p>**req.get(‘’)**获取相应的请求头的值</p>
<p><strong>或者在服务端开启跨域</strong></p>
<pre><code class="js">const cors = require(&#39;cors&#39;)
app.use(cors())
</code></pre>
<p><strong>Github案例</strong></p>
<p>注意解构赋值</p>
<pre><code class="js">    info = (&#123;target:&#123;value&#125;&#125;)=&gt;&#123;
        console.log(value)
        console.log(target)
    &#125;
</code></pre>
<p>这里是解构不出target的,只能解构出value</p>
<p>这里在补充一个知识</p>
<p>三元表达式可以连着写</p>
<p>就像这样的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240311200413605.png" alt="image-20240311200413605"></p>
<p>这样就可以充当if的功能，而且还能写在代码块</p>
<h2 id="组件间的通信"><a href="#组件间的通信" class="headerlink" title="组件间的通信"></a>组件间的通信</h2><p><strong>1.消息订阅和发布</strong></p>
<p><strong>PubSubjs</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/mroderick/PubSubJS">mroderick&#x2F;PubSubJS: Dependency free publish&#x2F;subscribe for JavaScript (github.com)</a></p>
<p>和vue里面的mitt和pubsub的使用方法一样的</p>
<p>这是消息的接收方</p>
<p>这里的message就是前面的消息的名称，后面就是消息的数据</p>
<pre><code class="js">PubSub.subscribe(&#39;userInfo&#39;,(message,data)=&gt;&#123;
    console.log(message,data)
&#125;)
</code></pre>
<p>这里是消息的发送方</p>
<pre><code class="js"> PubSub.publish(&#39;userInfo&#39;,this.state.userInfo)
</code></pre>
<p>这里说一下我遇到的问题</p>
<p>就是当我使用subscribe接收数据以后</p>
<pre><code class="js">let data1=[]
PubSub.subscribe(&#39;userInfo&#39;,(message,data)=&gt;&#123;
    // this.setState(&#123;userInfo:data&#125;)
    data1=data
&#125;)
</code></pre>
<p>我没有使用state来保存数据</p>
<p>然后后面我遍历这个数据data1，发现页面一致没有显示，</p>
<p>后分析得出，这里必须把数据写在state里面，要么这里的数据更改以后，不会引起render的重新熏染，因为只用state里面的数据发生改变，才可以重新熏染，</p>
<p>所以写成这样</p>
<pre><code class="js">        PubSub.subscribe(&#39;userInfo&#39;,(message,data)=&gt;&#123;
            this.setState(&#123;userInfo:data&#125;)
        &#125;)
</code></pre>
<h2 id="Fecth"><a href="#Fecth" class="headerlink" title="Fecth"></a><strong>Fecth</strong></h2><p>之前学过的jQuery和axios发送ajax请求都是对XHR的封装</p>
<p>fecth也是发送ajax 的，但是它可以理解为他是和xhr并列的，这个是内置的，而且不是第三方库，而且这个是promise风格的，能够解决回调地狱，</p>
<p>这篇文章讲的好</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003810652">javascript - 传统 Ajax 已死，Fetch 永生 - 会影 - SegmentFault 思否</a></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240311205628687.png" alt="image-20240311205628687"></p>
<p>这个关注分离是什么意思呢？</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240311205717212.png" alt="image-20240311205717212"></p>
<p>下面演示</p>
<pre><code class="js">        fetch(`https://api.github.com/search/users?q=$&#123;this.state.name&#125;`).then((res)=&gt;&#123;
            console.log(&#39;联系服务器成功&#39;,res)
        &#125;,(err)=&gt;&#123;
            console.log(&#39;练习服务器失败&#39;,err)
        &#125;)
</code></pre>
<p>这里面成功返回的数据</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240311210412873.png" alt="image-20240311210412873"></p>
<p>发现并没有我们需要数据</p>
<p>如果我们更改地址再次进行访问，这次会调用错误的回调吗？</p>
<p>我们发现还是调用的是成功的回调，</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240311210735749.png" alt="image-20240311210735749"></p>
<p>为什么呢？</p>
<p>因为你请求这个服务器的ip，但是这个服务器没有这个路由，服务器业委会给你响应404</p>
<p>那怎么调用这个错误的回调呢？</p>
<p>使用离线的功能</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240311210957487.png" alt="image-20240311210957487"></p>
<p>这样就会调用失败的回调</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240311211104307.png" alt="image-20240311211104307"></p>
<p>那接着上面的话题怎么向服务器要数据，上面只是向服务器建立联系</p>
<p>我们发现Response上面有一个json()的方法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240311211359052.png" alt="image-20240311211359052"></p>
<p>输出一下response.jsonde 内容</p>
<pre><code class="js">        fetch(`https://api.github.com/search/u?q=$&#123;this.state.name&#125;`).then((Response)=&gt;&#123;
            console.log(&#39;联系服务器成功&#39;,Response.json())
        &#125;,(err)=&gt;&#123;
            console.log(&#39;练习服务器失败&#39;,err)
        &#125;)
</code></pre>
<p>发现个promise对象，其实服务器返回你的数据就在里面，</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240311211600404.png" alt="image-20240311211600404"></p>
<p>然后之前学过链式调用，如果这里面返回的是成功的Promise</p>
<pre><code class="js">return Response.json()
</code></pre>
<p>这里再复习一下</p>
<pre><code>1.如果then返回的是非promise的值，那么.then返回的是成功的Promise，并且成功的值为返回的值
2.如果返回的是prmise的话，那么这个.then返回的值就是promise，值为返回的promise的值
3.如果回调中抛出异常，那么返回失败的promise，值为抛出异常的值
</code></pre>
<p>这里就可以这么写</p>
<pre><code class="js">        fetch(`https://api.github.com/search/users?q=$&#123;this.state.name&#125;`).then((response)=&gt;&#123;
            return response.json()
        &#125;,(err)=&gt;&#123;
            console.log(&#39;练习服务器失败&#39;,err)
            return Promise.reject(err)
        &#125;).then(
            (response)=&gt;&#123;
                console.log(&#39;获取数据成功&#39;,response)&#125;,
            (err)=&gt;&#123;
                console.log(&#39;获取数据失败&#39;,err)
            &#125;
        )
</code></pre>
<p>这样就可以获取数据</p>
<p>注意这里的response.json()不可以打印，打印的话就会报错</p>
<p>其实上面的回调有点鸡肋失败的回调写了很多次</p>
<p>所以我们可以最后优化以后的</p>
<pre><code class="js">        fetch(`https://api.github.com/search/users?q=$&#123;this.state.name&#125;`).then((response)=&gt;&#123;
            return response.json()
        &#125;).then(
            (response)=&gt;&#123;
                console.log(&#39;获取数据成功&#39;,response)&#125;
        ).catch(
            (error)=&gt;&#123;
                console.log(error)&#125;
        )
</code></pre>
<p>最后用catch处理失败的，</p>
<p>或者使用await的方法</p>
<pre><code class="js">try &#123;
    const res = await fetch(`https://api.github.com/search/users?q=$&#123;this.state.name&#125;`)
    const result = await res.json()
    console.log(result)
&#125; catch (e) &#123;
    console.log(e)
&#125;
</code></pre>
<p>上面的就是实现关注分离了，</p>
<p>先告诉你成没成功连到服务器，然后数据回来就可以</p>
<p>但是他的兼容性低老版本的浏览器不支持</p>
<p>这个的使用的场景非常少，了解就可以</p>
<p><strong>在使用的PUsub的地方再强调一下需要使用</strong></p>
<p><strong>componentWillUmount，取消订阅</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240312150152857.png" alt="image-20240312150152857"></p>
<h2 id="React的路由"><a href="#React的路由" class="headerlink" title="React的路由"></a>React的路由</h2><p>之前写的都是SPA意思就是单页面的应用</p>
<p>使用路由的技术</p>
<p><strong>前端路由的讲解</strong></p>
<p>前端路由的基石</p>
<p>我们知道有DOM和BOM</p>
<p>BOM里面就有浏览器的历史记录，前端路由借助的就是他的history</p>
<p>我们记住第三方库去history去操作</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;前端路由的基石_history&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;http://www.atguigu.com&quot; onclick=&quot;return push(&#39;/test1&#39;) &quot;&gt;push test1&lt;/a&gt;&lt;br&gt;&lt;br&gt;
    &lt;button onClick=&quot;push(&#39;/test2&#39;)&quot;&gt;push test2&lt;/button&gt;&lt;br&gt;&lt;br&gt;
    &lt;button onClick=&quot;replace(&#39;/test3&#39;)&quot;&gt;replace test3&lt;/button&gt;&lt;br&gt;&lt;br&gt;
    &lt;button onClick=&quot;back()&quot;&gt;&amp;lt;= 回退&lt;/button&gt;
    &lt;button onClick=&quot;forword()&quot;&gt;前进 =&amp;gt;&lt;/button&gt;

    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/history/4.7.2/history.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        // let history = History.createBrowserHistory() //方法一，直接使用H5推出的history身上的API
        let history = History.createHashHistory() //方法二，hash值（锚点）

        function push (path) &#123;
            history.push(path)
            return false
        &#125;

        function replace (path) &#123;
            history.replace(path)
        &#125;

        function back() &#123;
            history.goBack()
        &#125;

        function forword() &#123;
            history.goForward()
        &#125;

        history.listen((location) =&gt; &#123;
            console.log(&#39;请求路由路径变化了&#39;, location)
        &#125;)
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这里面的第三方库就可以就是对BOM里面的history的封装，</p>
<p>如果使用原生的会很繁琐</p>
<pre><code class="js">    &lt;a href=&quot;http://www.atguigu.com&quot; onclick=&quot;return push(&#39;/test1&#39;) &quot;&gt;push test1&lt;/a&gt;&lt;br&gt;&lt;br&gt;
            function push (path) &#123;
            history.push(path)
            return false//就不会跳转，但是会将浏览器的地址栏改为/test
                1
        &#125;
</code></pre>
<p>上面的就是大概的react路由的原理。路由跳转，还可以监控路由跳转的路径</p>
<p><strong>浏览器的历史记录就是一个栈的结构</strong></p>
<p>push是像栈顶推入一条数据</p>
<p>replace是直接替换当前的数据</p>
<p>路由有两种工作模式</p>
<p>方法一：直接使用H5推出的history身上的api</p>
<pre><code class="js">let history = History.createBrowserHistory()
</code></pre>
<p>方法二：使用hash模式（锚点）</p>
<pre><code class="js">    let history = History.createHashHistory()
</code></pre>
<p>第二种的兼容性比较好</p>
<h3 id="路由技术的使用"><a href="#路由技术的使用" class="headerlink" title="路由技术的使用"></a>路由技术的使用</h3><p>需要使用react-router库，这个有三种实现，分别给三种方式实现</p>
<p>1.web</p>
<p>2.native（react的原生应用）</p>
<p>3.any</p>
<p>我们需要使用react-router-dom</p>
<p>这里先讲解5版本的react-router-dom</p>
<p>先说一下基本的使用</p>
<pre><code class="js">import React, &#123;Component&#125; from &#39;react&#39;;
import &#123;Link,BrowserRouter&#125; from &#39;react-router-dom&#39;
在render里面
                            &lt;BrowserRouter&gt;
                                &lt;Link className=&quot;list-group-item&quot; to=&#39;/about&#39;&gt;About&lt;/Link&gt;
                                &lt;Link className=&quot;list-group-item&quot; to=&#39;/home&#39;&gt;Home&lt;/Link&gt;
                            &lt;/BrowserRouter&gt;
</code></pre>
<p>说一下错误的写法</p>
<pre><code class="js">&lt;BrowserRouter&gt;
                                &lt;Link className=&quot;list-group-item&quot; to=&#39;/about&#39;&gt;About&lt;/Link&gt;
                                &lt;Link className=&quot;list-group-item&quot; to=&#39;/home&#39;&gt;Home&lt;/Link&gt;
                            &lt;/BrowserRouter&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div className=&quot;col-xs-6&quot;&gt;
                        &lt;div className=&quot;panel&quot;&gt;
                            &lt;div className=&quot;panel-body&quot;&gt;
                                &#123;/*注册路由*/&#125;
                                &lt;BrowserRouter&gt;
                                    &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;
                                    &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;
                                &lt;/BrowserRouter&gt;
</code></pre>
<p>这里面使用了两个BrowserRouter，标签，一个路由器只能有一个路由器管理</p>
<p>所以一劳永逸的方法就是</p>
<p>在index的文件里面</p>
<pre><code class="js">import React from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;
import App from &#39;./app&#39;
import &#123;BrowserRouter&#125; from &#39;react-router-dom&#39;


ReactDOM.render(
    &lt;BrowserRouter&gt;
        &lt;App/&gt;
    &lt;/BrowserRouter&gt;
    ,document.getElementById(&#39;root&#39;))
</code></pre>
<p>在这里面进行包裹</p>
<p>最后app里面的代码</p>
<pre><code class="js">import React, &#123;Component&#125; from &#39;react&#39;;
import &#123;Link,BrowserRouter,Route&#125; from &#39;react-router-dom&#39;
import Home from &quot;./components/Home&quot;;
import About from &quot;./components/About&quot;;

class App extends Component &#123;
    render() &#123;
        return (
            &lt;div&gt;
                &lt;div className=&quot;row&quot;&gt;
                    &lt;div className=&quot;col-xs-offset-2 col-xs-8&quot;&gt;
                        &lt;div className=&quot;page-header&quot;&gt;&lt;h2&gt;React Router Demo&lt;/h2&gt;&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=&quot;row&quot;&gt;
                    &lt;div className=&quot;col-xs-2 col-xs-offset-2&quot;&gt;
                        &lt;div className=&quot;list-group&quot;&gt;
                            &#123;/*原生的html里面使用a标签跳转不同的页面*/&#125;
                            &#123;/*&lt;a className=&quot;list-group-item&quot; href=&quot;./about.html&quot;&gt;About&lt;/a&gt;*/&#125;
                            &#123;/*&lt;a className=&quot;list-group-item active&quot; href=&quot;./home.html&quot;&gt;Home&lt;/a&gt;*/&#125;
                            &#123;/*在react里面使用路由链接切换组件*/&#125;
                            &lt;Link className=&quot;list-group-item&quot; to=&#39;/about&#39;&gt;About&lt;/Link&gt;
                            &lt;Link className=&quot;list-group-item&quot; to=&#39;/home&#39;&gt;Home&lt;/Link&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div className=&quot;col-xs-6&quot;&gt;
                        &lt;div className=&quot;panel&quot;&gt;
                            &lt;div className=&quot;panel-body&quot;&gt;
                                &#123;/*注册路由*/&#125;
                                &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;
                                &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;

export default App;
</code></pre>
<p>基本的使用</p>
<p>之前说过hash模式的router#后面的 都不会作为资源发送给服务器</p>
<p><strong>路由组件和一般组件的区别</strong></p>
<p>一般组件的props，如果父组件不传递，就不会收到东西 </p>
<p>但是路由组件就会默认传递一些东西</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240312161902484.png" alt="image-20240312161902484"></p>
<p>总结</p>
<p><strong>1.写法不同</strong></p>
<p>​		一般组件：<Demo/></p>
<p>​		路由组件：<Demo path='路径' component={引入的组件}></p>
<p><strong>2.一般存放的位置不同</strong></p>
<p><strong>3.接收到的props不同</strong></p>
<p>​		一般组件：写组件标签传递什么，就能收到什么</p>
<p>​		路由组件：接收到三个固定的属性，如下</p>
<ol>
<li><p><strong>history</strong>: </p>
</li>
<li><ol>
<li><strong>action</strong>: “PUSH”</li>
<li><strong>block</strong>: <em>ƒ block(prompt)</em></li>
<li><strong>createHref</strong>: <em>ƒ createHref(location)</em></li>
<li><strong>go</strong>: <em>ƒ go(n)</em></li>
<li><strong>goBack</strong>: <em>ƒ goBack()</em></li>
<li><strong>goForward</strong>: <em>ƒ goForward()</em></li>
<li><strong>length</strong>: 16</li>
<li><strong>listen</strong>: <em>ƒ listen(listener)</em></li>
<li><strong>location</strong>: {pathname: ‘&#x2F;about’, search: ‘’, hash: ‘’, state: undefined, key: ‘5r9fyc’}</li>
<li><strong>push</strong>: <em>ƒ push(path, state)</em></li>
<li><strong>replace</strong>: <em>ƒ replace(path, state)</em></li>
</ol>
</li>
<li><p><strong>location</strong>: </p>
</li>
<li><ol>
<li><strong>hash</strong>: “”</li>
<li><strong>key</strong>: “5r9fyc”</li>
<li><strong>pathname</strong>: “&#x2F;about”</li>
<li><strong>search</strong>: “”</li>
<li><strong>state</strong>: undefined</li>
</ol>
</li>
<li><p><strong>match</strong>: </p>
</li>
<li><ol>
<li><strong>isExact</strong>: true</li>
<li><strong>params</strong>: {}</li>
<li><strong>path</strong>: “&#x2F;about”</li>
<li><strong>url</strong>: “&#x2F;about”</li>
</ol>
</li>
</ol>
<p>其中我们发现这里面的history里面的location和loca是一样的</p>
<ol>
<li><strong>history</strong>: 里面常用的有：go，goback，goForward,push,replace</li>
</ol>
<p>​	<strong>2.location:</strong> 里面的pathname,search，state</p>
<p>​	<strong>3.match</strong>:里的params，path， url</p>
<p> 之前的案列实现动态active的效果</p>
<pre><code class="js">                            &lt;NavLink className=&quot;list-group-item&quot; to=&#39;/about&#39;&gt;About&lt;/NavLink&gt;
                            &lt;NavLink className=&quot;list-group-item&quot; to=&#39;/home&#39;&gt;Home&lt;/NavLink&gt;
</code></pre>
<p>但是这样的默认的是向类名里面加入active</p>
<p>如果拟引入其他的框架，不是bootscrap，又可以高亮效果不是active，此时就需要属性</p>
<pre><code class="js">    &lt;NavLink activeClassName=&#39;demo&#39; className=&quot;list-group-item&quot; to=&#39;/about&#39;&gt;About&lt;/NavLink&gt;
                            &lt;NavLink activeClassName=&#39;demo&#39; className=&quot;list-group-item&quot; to=&#39;/home&#39;&gt;Home&lt;/NavLink&gt;
</code></pre>
<p>这样追加的类名是你自己定义的</p>
<p>不过在6版本的router里面取消了activeClassname的属性</p>
<p><strong>对Link进行二次封装</strong></p>
<p>其实没啥用感觉，还增加代码量</p>
<pre><code class="js">import MyNavLink from &quot;./components/MyNavLink&quot;;    
&lt;MyNavLink to=&quot;/about&quot; title=&quot;About&quot;&gt;About&lt;/MyNavLink&gt;
                            &lt;MyNavLink to=&quot;/home&quot; title=&#39;Home&#39;&gt;Home&lt;/MyNavLink&gt;
</code></pre>
<pre><code class="js">import React, &#123;Component&#125; from &#39;react&#39;;
import &#123;NavLink&#125; from &#39;react-router-dom&#39;

class MyNavLink extends Component &#123;
    render() &#123;
        const &#123;to,title&#125; = this.props
        return (
            &lt;div&gt;
                &lt;NavLink activeClassName=&#39;active&#39; className=&quot;list-group-item&quot; to=&#123;to&#125;&gt;&#123;title&#125;&lt;/NavLink&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;

export default MyNavLink;
</code></pre>
<p>我们不想通过在添加一个属性title来传递我的标签体的内容</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240312165631089.png" alt="image-20240312165631089"></p>
<p>那应该怎么办？</p>
<p>标签体也是一种特殊的标签属性，也可以通过props来传递</p>
<p>打印一下刚才封装好的props</p>
<pre><code class="js">class MyNavLink extends Component &#123;
    render() &#123;
        const &#123;to,title&#125; = this.props
        console.log(this.props)
        return (
            &lt;div&gt;
                &lt;NavLink activeClassName=&#39;active&#39; className=&quot;list-group-item&quot; to=&#123;to&#125;&gt;&#123;title&#125;&lt;/NavLink&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;
</code></pre>
<p>我们发现</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240312170007025.png" alt="image-20240312170007025"></p>
<p>标签体的内容在children的属性里</p>
<p>所以就可以这么写</p>
<pre><code class="js">    render() &#123;
        const &#123;to,title&#125; = this.props
        console.log(this.props)
        return (
            &lt;div&gt;
                &lt;NavLink activeClassName=&#39;active&#39; className=&quot;list-group-item&quot; to=&#123;to&#125;&gt;&#123;this.props.children&#125;&lt;/NavLink&gt;
            &lt;/div&gt;
        );
    &#125;
</code></pre>
<p>但是还有很简单的方法</p>
<p><strong>刚才说过标签体里面的内容是一种特殊的标签属性，就是children，我们就可以在children属性里面加入标签体的内容</strong></p>
<p>就像这样</p>
<pre><code class="js">                &lt;NavLink activeClassName=&#39;active&#39; className=&quot;list-group-item&quot; to=&#123;to&#125; children=&#123;children&#125;&gt;&lt;/NavLink&gt;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240312171256736.png" alt="image-20240312171256736"></p>
<p>现在有一个疑问，如果我们在注册路由的时候，给一个地址绑定多个组件那么会怎么样</p>
<pre><code class="js">                                &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;
                                &lt;Route path=&quot;/home&quot; component=&#123;Test&#125;/&gt;
</code></pre>
<p>答案是追加的，两个都会生效，代码执行的过程的中，当监测到路由变化到home，就会匹配对应的路由。当匹配玩第一个以后，还会继续匹配，所以这样就会出现效率问题。如果有很多的路由，就会一直向下匹配，直到没有</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240312172226589.png" alt="image-20240312172226589"></p>
<p>使用switch就不会匹配一个就不会继续下面继续匹配了</p>
<pre><code class="js">                                &lt;Switch&gt;
                                    &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;
                                    &lt;Route path=&quot;/home&quot; component=&#123;Test&#125;/&gt;
                                    &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;
                                &lt;/Switch&gt;
</code></pre>
<p>使用switch包裹</p>
<p>现在有个问题</p>
<pre><code class="js"> &lt;div&gt;
                &lt;div className=&quot;row&quot;&gt;
                    &lt;div className=&quot;col-xs-offset-2 col-xs-8&quot;&gt;
                        &lt;div className=&quot;page-header&quot;&gt;&lt;h2&gt;React Router Demo&lt;/h2&gt;&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=&quot;row&quot;&gt;
                    &lt;div className=&quot;col-xs-2 col-xs-offset-2&quot;&gt;
                        &lt;div className=&quot;list-group&quot;&gt;
                            &#123;/*原生的html里面使用a标签跳转不同的页面*/&#125;
                            &#123;/*&lt;a className=&quot;list-group-item&quot; href=&quot;./about.html&quot;&gt;About&lt;/a&gt;*/&#125;
                            &#123;/*&lt;a className=&quot;list-group-item active&quot; href=&quot;./home.html&quot;&gt;Home&lt;/a&gt;*/&#125;
                            &#123;/*在react里面使用路由链接切换组件*/&#125;
                            &lt;MyNavLink to=&quot;/wang/about&quot; title=&quot;About&quot;&gt;About&lt;/MyNavLink&gt;
                            &lt;MyNavLink to=&quot;/wang/home&quot; title=&#39;Home&#39;&gt;Home&lt;/MyNavLink&gt;
                            &#123;/*&lt;NavLink activeClassName=&#39;active&#39; className=&quot;list-group-item&quot; to=&#39;/about&#39;&gt;About&lt;/NavLink&gt;*/&#125;
                            &#123;/*&lt;NavLink activeClassName=&#39;active&#39; className=&quot;list-group-item&quot; to=&#39;/home&#39;&gt;Home&lt;/NavLink&gt;*/&#125;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div className=&quot;col-xs-6&quot;&gt;
                        &lt;div className=&quot;panel&quot;&gt;
                            &lt;div className=&quot;panel-body&quot;&gt;
                                &#123;/*注册路由*/&#125;
                                &lt;Switch&gt;
                                    &lt;Route path=&quot;/wang/home&quot; component=&#123;Home&#125;/&gt;
                                    &lt;Route path=&quot;/wang/about&quot; component=&#123;About&#125;/&gt;
                                &lt;/Switch&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
</code></pre>
<p>这里面的路由</p>
<pre><code>/wang/about
</code></pre>
<p>使用这个我们就会发现问题</p>
<p>当我们刷新的时候</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240313195857185.png" alt="image-20240313195857185"></p>
<p>组件的样式消失了</p>
<p>因为刷新的时候我们的地址</p>
<p>我们请求的bootstrap的地址</p>
<pre><code>http://localhost:3000/wang/css/bootstrap.css
正常的是
http://localhost:3000/css/bootstrap.css
</code></pre>
<p>这就是样式消息的原因</p>
<p>有三种解决方法</p>
<p>第一种</p>
<pre><code class="html">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/bootstrap.css&quot;&gt;
    把这个改为,删掉点
     &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bootstrap.css&quot;&gt;
</code></pre>
<p>原因是.&#x2F;是从当前的路径开始找，我们访问</p>
<pre><code>/wang/about，当前路径就认为是wang，所以就会出现这个问题
</code></pre>
<p>第二种使用,这个%PUBLIC_URL%就是绝对的路径</p>
<pre><code> &lt;link rel=&quot;stylesheet&quot; href=&quot;%PUBLIC_URL%/css/bootstrap.css&quot;&gt;
</code></pre>
<p><strong>%PUBLIC_URL%这个只有在React里可以使用</strong></p>
<p>第三种，</p>
<p>我们使用Hash的router</p>
<pre><code class="js">import &#123;HashRouter&#125; from &#39;react-router-dom&#39;


ReactDOM.render(
    &lt;HashRouter&gt;
        &lt;App/&gt;
    &lt;/HashRouter&gt;
    ,document.getElementById(&#39;root&#39;))
</code></pre>
<p>因为Hash外层的#后面的路径只会当最前端的资源，所以不会记住</p>
<p>这里提示一下，包管理器不要混合的用，容易造成包的丢失</p>
<p>路由的精准匹配和模糊匹配</p>
<p>当我们</p>
<pre><code class="js">                            &lt;MyNavLink to=&quot;/about&quot; title=&quot;About&quot;&gt;About&lt;/MyNavLink&gt;
                            &lt;MyNavLink to=&quot;/home/a/b&quot; title=&#39;Home&#39;&gt;Home&lt;/MyNavLink&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div className=&quot;col-xs-6&quot;&gt;
                        &lt;div className=&quot;panel&quot;&gt;
                            &lt;div className=&quot;panel-body&quot;&gt;
                                &#123;/*注册路由*/&#125;
                                &lt;Switch&gt;
                                    &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;
                                    &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;
</code></pre>
<p>这里访问home，会正常的显示，这就是路由的模糊匹配</p>
<p>如果反过来的话就不行了，</p>
<pre><code>匹配的规则就是
to=&quot;/home/a/b&quot; 会先向下匹配home
</code></pre>
<p>那如果我们想要开启精准匹配呢？</p>
<p>使用exact</p>
<p>在这里开启精准的匹配</p>
<pre><code class="js">                            &lt;MyNavLink to=&quot;/about&quot; title=&quot;About&quot;&gt;About&lt;/MyNavLink&gt;
                            &lt;MyNavLink to=&quot;/home/a/b&quot; title=&#39;Home&#39;&gt;Home&lt;/MyNavLink&gt;
          
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div className=&quot;col-xs-6&quot;&gt;
                        &lt;div className=&quot;panel&quot;&gt;
                            &lt;div className=&quot;panel-body&quot;&gt;
                                &#123;/*注册路由*/&#125;
                                &lt;Switch&gt;
                                    &lt;Route exact=&#123;true&#125; path=&quot;/home&quot; component=&#123;Home&#125;/&gt;
                                    &lt;Route exact=&#123;true&#125; path=&quot;/about&quot; component=&#123;About&#125;/&gt;
                                &lt;/Switch&gt;
</code></pre>
<p>这样模糊匹配就会失效，必须要完美匹配</p>
<p>总结</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240313202838547.png" alt="image-20240313202838547"></p>
<p>严格匹配不要缩编乱开</p>
<p><strong>重定向</strong></p>
<p>Redirect放在注册路由的最下方，当上面的路由匹配上就会走Redirect的</p>
<pre><code class="js">                                &#123;/*注册路由*/&#125;
                                &lt;Switch&gt;
                                    &lt;Route exact=&#123;true&#125; path=&quot;/home&quot; component=&#123;Home&#125;/&gt;
                                    &lt;Route exact=&#123;true&#125; path=&quot;/about&quot; component=&#123;About&#125;/&gt;
                                    &lt;Redirect to=&quot;/home&quot;&gt;&lt;/Redirect&gt;
                                &lt;/Switch&gt;
</code></pre>
<p>这样当我们打开浏览器，访问‘&#x2F;’，的时候就会重定向到home里面</p>
<p><strong>嵌套路由（多级路由）</strong></p>
<pre><code class="js"> &lt;div&gt;
                &lt;h3&gt;我是Home的内容&lt;/h3&gt;
                &lt;div&gt;
                    &lt;ul className=&quot;nav nav-tabs&quot;&gt;
                        &lt;li&gt;
                            &lt;MyNavLink to=&#39;/home/news&#39;&gt;News&lt;/MyNavLink&gt;
                        &lt;/li&gt;
                        &lt;li&gt;
                            &lt;MyNavLink to=&#39;/home/message&#39;&gt;message&lt;/MyNavLink&gt;
                        &lt;/li&gt;
                    &lt;/ul&gt;
                    &lt;Switch&gt;
                        &#123;/*注册路由*/&#125;
                        &lt;Route path=&#39;/home/news&#39; component=&#123;News&#125;&gt;&lt;/Route&gt;
                        &lt;Route path=&#39;/home/message&#39; component=&#123;Message&#125;&gt;&lt;/Route&gt;
                    &lt;/Switch&gt;
                &lt;/div&gt;
            &lt;/div&gt;
</code></pre>
<p>嵌套路由的基本的使用，注意前面的注册路由的，不要使用精准匹配</p>
<p>因为，</p>
<pre><code>&lt;MyNavLink to=&#39;/home/news&#39;&gt;News&lt;/MyNavLink&gt;
</code></pre>
<p>当我们访问&#x2F;home&#x2F;news的时候，这里的路由的匹配规则是，先去最先注册的路由的地方去匹配</p>
<p>就会到这里</p>
<pre><code class="js">                                    &lt;Route exact path=&quot;/home&quot; component=&#123;Home&#125;/&gt;
                                    &lt;Route  path=&quot;/about&quot; component=&#123;About&#125;/&gt;
                                    &lt;Redirect to=&quot;/about&quot;&gt;&lt;/Redirect&gt;
</code></pre>
<p>这样就模糊匹配到了home，这样home组件才不会丢，然后到home主页，就继续匹配，如果开启了开启了严格模式，</p>
<pre><code class="js"> &lt;Route exact path=&quot;/home&quot; component=&#123;Home&#125;/&gt;
</code></pre>
<p>这样就不会模糊匹配到home主页就会向后面走</p>
<p>最后走向Redirect</p>
<pre><code class="js"> &lt;Redirect to=&quot;/about&quot;&gt;&lt;/Redirect&gt;
</code></pre>
<p>实现在home组件里面重定向到news</p>
<pre><code class="js">                        &lt;Route path=&#39;/home/news&#39; component=&#123;News&#125;&gt;&lt;/Route&gt;
                        &lt;Route path=&#39;/home/message&#39; component=&#123;Message&#125;&gt;&lt;/Route&gt;
                        &lt;Redirect to=&#39;/home/news&#39;&gt;&lt;/Redirect&gt;
</code></pre>
<p>当我们home组件挂载的时候，&#x2F;home就回去匹配，没有匹配到就会到news</p>
<p>总的来说</p>
<p>注意精准模式，还要带上父级路由的路径，路由的匹配的是按照注册组件的顺序， 不限于当前组件</p>
<p><strong>向路由组件传递参数数据</strong></p>
<p>第一种params参数</p>
<p>注意这里的模板字符串，模板字符串是js的，所以需要加上{}</p>
<pre><code class="js">            &lt;div&gt;
                &lt;ul&gt;
                    &#123;
                        this.state.messageArr.map((item)=&gt;&#123;
                            return (
                                &lt;li key=&#123;item.id&#125;&gt;
                                    &#123;/*params参数*/&#125;
                                    &lt;Link to=&#123;`/home/message/detail/$&#123;item.id&#125;/$&#123;item.title&#125;`&#125;&gt;&#123;item.title&#125;&lt;/Link&gt;
                                &lt;/li&gt;
                            )
                        &#125;)
                    &#125;
                &lt;/ul&gt;
                &lt;hr/&gt;
                &#123;/*声明接收params参数*/&#125;
                &lt;Route path=&#39;/home/message/detail/:id/:title&#39; component=&#123;Detail&#125; &gt;&lt;/Route&gt;
            &lt;/div&gt;
</code></pre>
<p>我们传递的组件</p>
<p>在props里面的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240313215538654.png" alt="image-20240313215538654"></p>
<p>match里面</p>
<p>然后在子路由组件里面</p>
<pre><code class="js">class Detail extends Component &#123;
    render() &#123;
        const &#123;match:&#123;params&#125;&#125; = this.props
        console.log(params)
        return (
            &lt;ul&gt;
                &lt;li&gt;ID:t&lt;/li&gt;
                &lt;li&gt;TITLE:&lt;/li&gt;
                &lt;li&gt;CONTENT:&lt;/li&gt;
            &lt;/ul&gt;
        );
    &#125;
&#125;
</code></pre>
<p>这里的params就是我们传递的参数</p>
<p>2.传递search参数</p>
<p>携带参数的形式有点像query参数形式</p>
<p>在这里</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240313220744952.png" alt="image-20240313220744952"></p>
<p>没有给你对象，需要你自己整理成对象</p>
<p>需要使用</p>
<pre><code class="js">import QueryString from &#39;query-string&#39;
</code></pre>
<p>这个库就可以实现，urlencoded的和对象的相互转换，就是我上面说 的</p>
<p>这样就会转为urlencoded的形式</p>
<pre><code class="js">        let obj = &#123;name:111,age:19&#125;
        console.log(QueryString.stringify(obj))
</code></pre>
<p>这样转为对向的形式</p>
<pre><code class="js">        let obj = &#123;name:111,age:19&#125;
        console.log(QueryString.stringify(obj))
        let res = QueryString.stringify(obj)
        console.log(QueryString.parse(res))
</code></pre>
<p>和内置的JSON的方法类似</p>
<pre><code class="js">这样就可以实现了
        console.log(this.props)
        const search = this.props.location.search
        console.log(QueryString.parse(search))//&#123;id: &#39;002&#39;, title: &#39;消息二&#39;&#125;
        const &#123;id,title&#125;=QueryString.parse(search)
        console.log(id,title)
        return (
            &lt;ul&gt;
                &lt;li&gt;ID:&#123;id&#125;&lt;/li&gt;
                &lt;li&gt;TITLE:&#123;title&#125;&lt;/li&gt;
                &lt;li&gt;CONTENT:&lt;/li&gt;
            &lt;/ul&gt;
        );
</code></pre>
<p>总结：<br>3.传递state参数</p>
<p>之前的参数都是在地址栏上，prams和search参数地址栏上都有显示</p>
<p>state参数地址栏是隐藏的</p>
<p>state参数的基本使用</p>
<pre><code class="js">                                    &lt;Link to=&#123;&#123;
                                        pathname:'/home/message/detail',
                                        state:&#123;id:item.id,title:item.title&#125;
                                    &#125;&#125;&gt;&#123;item.title&#125;&lt;/Link&gt;
                &lt;Route path=&#39;/home/message/detail/&#39; component=&#123;Detail&#125; &gt;&lt;/Route&gt;
</code></pre>
<p>注意上面的to后面的要写成对象 的形式，参数如上面的例子</p>
<p>在注册的时候，不用向param一样</p>
<p>接收的话</p>
<p>我们发现参数在location里面的state</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240314142920162.png" alt="image-20240314142920162"></p>
<pre><code class="js">        const &#123;state&#125; = this.props.location
        console.log(this.props)
        return (
            &lt;ul&gt;
                &lt;li&gt;ID:&#123;state.id&#125;&lt;/li&gt;
                &lt;li&gt;TITLE:&#123;state.title&#125;&lt;/li&gt;
                &lt;li&gt;CONTENT:&lt;/li&gt;
            &lt;/ul&gt;
        );
</code></pre>
<p>这样就可以了</p>
<p>但是这种用法也会有问题，因为他的数据没有放在地址栏里面，所以他是通过一些操作，把数据是在缓存里面的，如果我们清除存储刷新，就会报错</p>
<p>所以我们在接收的时候可以默认指定空兑对象</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240314143523690.png" alt="image-20240314143523690"></p>
<p>这里回忆一下es6的Null判断运算符和链式判断运算符</p>
<p>NUll判断符</p>
<pre><code class="js">const headerText = response.settings.headerText || &#39;Hello, world!&#39;;
//下面的写法、
const headerText = response.settings.headerText ?? &#39;Hello, world!&#39;;
</code></pre>
<p>这样如果前面的数据是0或者false就不会出现问题</p>
<p>链式判断运算符</p>
<pre><code class="js">const firstName = (message
  &amp;&amp; message.body
  &amp;&amp; message.body.user
  &amp;&amp; message.body.user.firstName) || &#39;default&#39;;
  //
  const firstName = message?.body?.user?.firstName || &#39;default&#39;;
</code></pre>
<p>这样写起来更加方便</p>
<p>之前前面的两种也可以使用对象的形式，只能用pathname，</p>
<p>说实话，这样是更加麻烦了</p>
<p><strong>push和replace</strong></p>
<p>浏览器默认是push</p>
<p>开启replace</p>
<p>需要这样，和vue里面打开replace的方法一样</p>
<pre><code class="js">&lt;Link replace to=&#123;&#123;
    pathname:'/home/message/detail',
    state:&#123;id:item.id,title:item.title&#125;
&#125;&#125;&gt;&#123;item.title&#125;&lt;/Link
</code></pre>
<p>这样跳转到</p>
<pre><code>/home/message/detail
</code></pre>
<p>就是replace的模式</p>
<p><strong>编程式路由的导航</strong></p>
<p>实现</p>
<pre><code class="js">    pushShow  = (id,title)=&gt;&#123;
        this.props.history.push(`/home/message/detail/$&#123;id&#125;/$&#123;title&#125;`)
    &#125;
    replaceShow = (id,title)=&gt;&#123;
        // console.log(this.props)
        this.props.history.replace(`/home/message/detail/$&#123;id&#125;/$&#123;title&#125;`)
    &#125;
     &lt;Link to=&#123;`/home/message/detail/$&#123;item.id&#125;/$&#123;item.title&#125;`&#125;&gt;&#123;item.title&#125;&lt;/Link&gt;&amp;nbsp;
                                    &lt;button  onClick=&#123;()=&gt;this.pushShow(item.id,item.title)&#125;&gt;push&lt;/button&gt;&amp;nbsp;
                                    &lt;button onClick=&#123;()=&gt;this.replaceShow(item.id,item.title)&#125;&gt;replace&lt;/button&gt;
</code></pre>
<p>传递params参数</p>
<p>传递search参数也还是和原来的一样</p>
<p>但是传递state需要改变下</p>
<pre><code class="js">      this.props.history.replace(`/home/message/detail/`,&#123;id:id,title:title&#125;)
</code></pre>
<p>后面加上state的数据</p>
<p>history里面的还有几个api控制前进后退</p>
<pre><code class="js">goBack()
goForward()
</code></pre>
<pre><code class="js">    go = ()=&gt;&#123;
        this.props.history.goForward()
    &#125;
    back = ()=&gt;&#123;
        this.props.history.goBack()
    &#125;
      &lt;button  onClick=&#123;()=&gt;this.pushShow(item.id,item.title)&#125;&gt;push&lt;/button&gt;&amp;nbsp;
                                    &lt;button onClick=&#123;()=&gt;this.replaceShow(item.id,item.title)&#125;&gt;replace&lt;/button&gt;
</code></pre>
<p>还有一个</p>
<pre><code>go(n)//这个api接收到数字，表示前进几步，里面还可以写负值
</code></pre>
<p>总结</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240314153413005.png" alt="image-20240314153413005"></p>
<p>但是这些props都是在路由组件里面可以获取的到，那么非路由组件怎么获取的到？</p>
<p>我们在非路由组件里面可以这么写</p>
<pre><code class="js">import React, &#123;Component&#125; from &#39;react&#39;;
import &#123;withRouter&#125; from &#39;react-router-dom&#39;

class Title extends Component &#123;
    go = ()=&gt;&#123;

    &#125;
    back = ()=&gt;&#123;

    &#125;
    render() &#123;
        console.log(this.props)
        return (
            &lt;div&gt;
                &lt;h3&gt;我是Home的内容&lt;/h3&gt;
                &lt;button onClick=&#123;this.go&#125;&gt;前进&lt;/button&gt;
                &lt;button onClick=&#123;this.back&#125;&gt;前进&lt;/button&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;

export default withRouter(Title);
</code></pre>
<pre><code class="js">withRouter(Title)
</code></pre>
<p>这样加工完，这个组件的props里面就有路由组件的props的一些属性和方法，这样就可以使用了 </p>
<p><strong>withRouter</strong>返回是一个新的组件，</p>
<p><strong>BrowerRouter和HashRouter的区别</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240314181004398.png" alt="image-20240314181004398"></p>
<p>因为hashrouter没有保存state数据到本地的api所以就会导致state参数的丢失</p>
<p>还是BrowerRouter的多一点</p>
<h2 id="ui-antd组件库学习"><a href="#ui-antd组件库学习" class="headerlink" title="ui-antd组件库学习"></a>ui-antd组件库学习</h2><p>React组件库andt</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240314183712146.png" alt="image-20240314183712146"></p>
<p>安装</p>
<pre><code class="bash"> pnpm i antd
</code></pre>
<p>基本使用</p>
<pre><code class="js">import &#123; Button &#125; from &#39;antd&#39;
&lt;Button type=&quot;primary&quot;&gt;Primary Button&lt;/Button&gt;
</code></pre>
<p>和之前的vue组件库element的ui库使用差不多</p>
<p>样式的按需引入</p>
<p>使用的时候直接去搜吧</p>
<p>这里讲的版本太低了</p>
<h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><p>这个比较重要</p>
<p>管理状态的库</p>
<p>作用：集中管理react应用中多个组件的共享的状态</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240314190651374.png" alt="image-20240314190651374"></p>
<p>就和vue里面的pinia和vuex的功能是一样的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240314191213787.png" alt="image-20240314191213787"></p>
<p>工作流程</p>
<p>原理图</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/redux%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="redux原理图"></p>
<p>简略的讲一下：</p>
<p>这里的Action Creation是将组件里面的操作封装成对象，对象里的type是操作，data是操作的数据</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240314192748218.png" alt="image-20240314192748218"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240314192903178.png" alt="image-20240314192903178"></p>
<p>安装</p>
<pre><code class="bash">pnpm i redux
pnpm i redux@4.0.5
</code></pre>
<p>现在学习下面这个版本的</p>
<p>处理对应的reducer的文件</p>
<p>目录结构</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240314203905064.png" alt="image-20240314203905064"></p>
<pre><code class="js">//该文件是创建为Count服务的reducer,reducer本质就是一个函数
//会接受到两个参数,之前的数据,还有动作类行
const initState = 0
export default function countReducer(preState=initState,action)&#123;
    // if (preState == undefined) preState = 0 也可以使用形参的默认值进行初始化.当preState为undefined的时候就会为0
    const &#123;type,data&#125; = action
    switch (type) &#123;
        case &#39;increment&#39;:
            return preState += data
        case &#39;decrement&#39;:
            return preState -= data
        default:
            //初始化
             return preState
    &#125;
&#125;
</code></pre>
<p>上面说过，reducer里面进行初始化和修改状态，初始化状态可以使用形参的默认值</p>
<p>在store文件里面</p>
<pre><code class="js">//
import &#123;createStore&#125; from &#39;redux&#39;
// 引入为count服务的reducer
import countReducer from &#39;./count_reducer&#39;
const store =createStore(countReducer)
export default store
</code></pre>
<p>上面初始化以后，我们就可以</p>
<p>在count组件里面读到这个数据</p>
<pre><code class="js">import store  from &quot;../../redux/store&quot;;
 &lt;h1&gt;当前求和为&#123;store.getState()&#125;&lt;/h1&gt;
</code></pre>
<p>这样获取的值就是上面reducer里面返回的值，在初始化的时候，store里面会主动调用count，如果我们开始没有初始化</p>
<pre><code class="js">export default function countReducer(preState,action)&#123;
    console.log(preState,action)
    // if (preState == undefined) preState = 0 也可以使用形参的默认值进行初始化.当preState为undefined的时候就会为0
    const &#123;type,data&#125; = action
    switch (type) &#123;
        case &#39;increment&#39;:
            return preState += data
        case &#39;decrement&#39;:
            return preState -= data
        default:
            //初始化
             return preState
    &#125;
&#125;
</code></pre>
<p>打印出来的是</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240314204703012.png" alt="image-20240314204703012"></p>
<p>注意</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240314205320707.png" alt="image-20240314205320707"></p>
<p>实现代码</p>
<pre><code class="js">import React, &#123;Component&#125; from &#39;react&#39;;
//引入store
import store  from &quot;../../redux/store&quot;;
class Count extends Component &#123;
    state = &#123;
        count:0
    &#125;
    componentDidMount() &#123;
        //检测redux里的状态的变化,主要变化,就会render
        // 只要rendex的状态发生改变就会调用这个回调
        store.subscribe(()=&gt;&#123;
            //store只会保存数据不会在熏染页面,再重新渲染一下页面,这里的setState就重新熏染一下页面,哪怕没有熏染数据
            this.setState(&#123;&#125;)
        &#125;
        )
    &#125;

    increment = ()=&gt;&#123;
        const &#123;value&#125; =  this.selectNumber
        //通知redux加上value
        store.dispatch(&#123;type:&#39;increment&#39;,data: value*1 &#125;,)
    &#125;
    decrement = ()=&gt;&#123;
        const &#123;value&#125; =  this.selectNumber
        const &#123;count &#125; = this.state
        store.dispatch(&#123; type:&#39;decrement&#39;,date:count - value*1&#125;)

    &#125;
    incrementOfOdd = ()=&gt;&#123;
        const &#123;value&#125; =  this.selectNumber
        const &#123;count &#125; = store.getState()
        if (count % 2 !=0 )&#123;
            store.dispatch(&#123;type:&#39;increment&#39;,data: value*1 &#125;,)
        &#125;
    &#125;
    incrementAsync = ()=&gt;&#123;
        const &#123;value&#125; =  this.selectNumber
        const &#123;count &#125; = this.state
        setTimeout(()=&gt;&#123;
            store.dispatch(&#123;type:&#39;increment&#39;,data: value*1 &#125;,)
        &#125;,500)

    &#125;
    render() &#123;
        return (
            &lt;div&gt;
                &lt;h1&gt;当前求和为&#123;store.getState()&#125;&lt;/h1&gt;
                &lt;select ref=&#123;c =&gt; this.selectNumber = c&#125;&gt;
                    &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
                    &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;
                    &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;
                &lt;/select&gt;&amp;nbsp;
                &lt;button onClick=&#123;this.increment&#125;&gt;+&lt;/button&gt;&amp;nbsp;
                &lt;button onClick=&#123;this.decrement&#125;&gt;-&lt;/button&gt;&amp;nbsp;
                &lt;button onClick=&#123;this.incrementOfOdd&#125;&gt;当前求和为奇数再加&lt;/button&gt;&amp;nbsp;
                &lt;button onClick=&#123;this.incrementAsync&#125;&gt;异步加&lt;/button&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;

export default Count;
</code></pre>
<p>reducer里面的</p>
<pre><code class="js">//该文件是创建为Count服务的reducer,reducer本质就是一个函数
//会接受到两个参数,之前的数据,还有动作类行
const initState = 0
export default function countReducer(preState = initState,action)&#123;
        console.log(preState,action)
    // if (preState == undefined) preState = 0 也可以使用形参的默认值进行初始化.当preState为undefined的时候就会为0
    const &#123;type,data&#125; = action
    switch (type) &#123;
        case &#39;increment&#39;:
            return preState += data
        case &#39;decrement&#39;:
            return preState -= data
        default:
            //初始化
             return preState
    &#125;
&#125;
</code></pre>
<p>store里的</p>
<pre><code class="js">//
import &#123;createStore&#125; from &#39;redux&#39;
// 引入为count服务的reducer
import countReducer from &#39;./count_reducer&#39;

const store =createStore(countReducer)

export default store
</code></pre>
<p>说实话真的麻烦</p>
<p>其实重新熏染页面可以直接在index里面写</p>
<pre><code class="js">    componentDidMount() &#123;
        //检测redux里的状态的变化,主要变化,就会render
        // 只要rendex的状态发生改变就会调用这个回调
        store.subscribe(()=&gt;&#123;
            //store只会保存数据不会在熏染页面,再重新渲染一下页面,这里的setState就重新熏染一下页面,哪怕没有熏染数据
            this.setState(&#123;&#125;)
        &#125;
        )
    &#125;
</code></pre>
<p>在index里面写</p>
<pre><code class="js">import React from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;
import App from &#39;./app&#39;
import store from &quot;./redux/store&quot;;


 ReactDOM.render(
        &lt;App/&gt;
        ,document.getElementById(&#39;root&#39;))

store.subscribe(()=&gt;&#123;
    ReactDOM.render(
        &lt;App/&gt;
        ,document.getElementById(&#39;root&#39;))
&#125;)
</code></pre>
<p>这样store里面的数据一更改吗，就会熏染整个页面</p>
<p>上面是redux的精简的版本</p>
<p>这个更是单状态的管理工具</p>
<p>上面的总结一下</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240314212040793.png" alt="image-20240314212040793"></p>
<p>现在写一个完整版</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240314212252828.png" alt="image-20240314212252828"></p>
<p>恢复一下ActionCreation的功能，上面的我们是自己封装成action对象</p>
<p>，这个的功能就是封装成action</p>
<p>这里的复习一下</p>
<pre><code class="js">const fuc = () =&gt; &#123;data:1&#125;
console.log(fuc())//undefined
</code></pre>
<p>因为程序执行机会把返回的对象的{}当作函数的{}，所以可以这样</p>
<pre><code class="js">const fuc = () =&gt; (&#123;data:1&#125;)
console.log(fuc())//&#123; data: 1 &#125;
</code></pre>
<p>下面的actionCreation</p>
<pre><code class="js">//该文件专门为Count组件生成action对象

export function createIncrementAction (data) &#123;
    return  &#123;type:&#39;increment&#39;,data&#125;
&#125;

export function createDecrementAction (data) &#123;
    return  &#123;type:&#39;decrement&#39;,data&#125;
&#125;
</code></pre>
<pre><code class="js">    import &#123;createIncrementAction,createDecrementAction&#125; from &#39;../../redux/count_action&#39;

increment = ()=&gt;&#123;
        const &#123;value&#125; =  this.selectNumber
        //通知redux加上value
        store.dispatch(createIncrementAction(value*1))
    &#125;
</code></pre>
<p>我们有时候会定义常量的文件放着把action写错</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240314214624316.png" alt="image-20240314214624316"></p>
<pre><code class="js">//该模块定义action里面的type的值
export const INCREMENT = &#39;increment&#39;
export const DECREMENT = &#39;decrement&#39;
</code></pre>
<p><strong>异步action</strong></p>
<p>action有两个类型</p>
<p>一个是同步的action，是对象的形式</p>
<p>一个是异步的action，是函数的形式</p>
<p>之前我们做定时器，我们等待的时间是在组件的里面等着</p>
<pre><code class="js">    incrementAsync = ()=&gt;&#123;
        const &#123;value&#125; =  this.selectNumber
        const &#123;count &#125; = this.state
        setTimeout(()=&gt;&#123;
            store.dispatch(&#123;type:&#39;increment&#39;,data: value*1 &#125;,)
        &#125;,500)
    &#125;
</code></pre>
<p>如果我们不想在这里等</p>
<p>在createaction里面等待</p>
<p>实现如下</p>
<p>需要安装中间件</p>
<pre><code class="bash">pnpm i redux-thunk@2.3.0
</code></pre>
<p>原位置的定时器</p>
<pre><code class="js">    incrementAsync = ()=&gt;&#123;
        const &#123;value&#125; =  this.selectNumber
        const &#123;count &#125; = this.state
        store.dispatch(createIncrementAsyncAction(value*1,500))

    &#125;
</code></pre>
<p>createaction的里面</p>
<pre><code class="js">export function createIncrementAction (data) &#123;
    return  &#123;type:&#39;increment&#39;,data&#125;
&#125;
export function createIncrementAsyncAction (data,time) &#123;
    return  ()=&gt;&#123;
        setTimeout(()=&gt;&#123;&#123;
            store.dispatch(createIncrementAction(data))
        &#125;&#125;,time)
    &#125;
&#125;
</code></pre>
<p>但是只是这样写是不行的，我们开始store只会接受state的对象的形式，不会接收一个函数，</p>
<p>开始我们给store</p>
<pre><code class="js">store.dispatch(createIncrementAsyncAction(value*1,500))
</code></pre>
<p>分配给一个函数但是store里面，但是store里买呢只会接受到对象的形式，</p>
<p>所以就要中间件让store帮你调用这个函数</p>
<p>调用完以后</p>
<pre><code class="js">store.dispatch(createIncrementAction(data))
</code></pre>
<p>就会给store里面分配一个对象</p>
<p>这个中间件需要这样引入</p>
<p>在store的里面</p>
<pre><code class="js">//applyMiddleware用于执行中间件，createStore创建store
import &#123;createStore,applyMiddleware&#125; from &#39;redux&#39;
// 引入为count服务的reducer
import countReducer from &#39;./count_reducer&#39;
//用于支持异步的action
import thunk from &#39;redux-thunk&#39;

const store =createStore(countReducer,applyMiddleware(thunk))

export default store
</code></pre>
<p>总结</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240315112150941.png" alt="image-20240315112150941"></p>
<p>之前我们引入的第三方库redux，现在我们引入facebook出的’react-redux</p>
<p>react-redux的原理图</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/react-redux%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" alt="react-redux模型图"></p>
<p>这里面的讲解</p>
<p>ui组件里面调用不了redux的api，只能通过容器总火箭获取，然后通过prop所传递给ui组件，传递的都是redux里面的状态	</p>
<p>先说一下基本的使用</p>
<p>首先创建外壳组件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240315121010850.png" alt="image-20240315121010850"></p>
<pre><code class="js">//容器组件，需要借助实现容器组件

//先引入ui组件库
import CountUi from &quot;../../components/Count&quot;;

//链接ui&#39;组件和容器组件
import &#123;connect&#125; from &#39;react-redux&#39;

//connnec是个函数，返回值也是一个函数
const CountContainer =connect()(CountUi)//最后返回的就会创建一个容器组件

export default CountContainer
</code></pre>
<p>上面是连接容器组件和ui’组件库</p>
<p>但是怎么链接外壳和store呢？</p>
<p>我们注册Count组件这次注册的应该是外壳组件，而不是ui组件</p>
<p>所以在app里面</p>
<pre><code class="js">import React, &#123;Component&#125; from &#39;react&#39;;
//引入容器组件
import Count from &quot;./containers/Count&quot;;
//引入redux的store
import store from &quot;./redux/store&quot;;
class App extends Component &#123;
    render() &#123;
        return (
            &lt;div&gt;
                &lt;Count store=&#123;store&#125;&gt;&lt;/Count&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;

export default App;
</code></pre>
<p>如果连接store就要，需要使用props的方法向容器组件里面传递store</p>
<p>上面实现了连接，那怎么把数据放在ui组件的里面</p>
<p>验证容器组件和ui组件的是父子的关系</p>
<p>在开发者工具可以看出来</p>
<p>搞不懂这个设置为什么这么复杂</p>
<p>下面通过容器组件将状态里的数据传递给ui组，并且绑定对应的事件</p>
<p>容器组件</p>
<pre><code class="js">//容器组件，需要借助实现容器组件

//先引入ui组件库
import CountUi from &quot;../../components/Count&quot;;
//链接ui&#39;组件和容器组件
import &#123;connect&#125; from &#39;react-redux&#39;
//传递state
const a = (state)=&gt;&#123;
    return &#123;count:state&#125;   //这里等价于 &lt;CountUi n=&#123;900&#125;/&gt;返回值的对象啊就相当于props
&#125;
//传递操作状态的方法
const b = (dispatch)=&gt;&#123;
    return &#123;increment : (value)=&gt;&#123;
            dispatch(&#123;type:&#39;increment&#39;,data:value&#125;)
            &#125;&#125;
&#125;
//connnec是个函数，返回值也是一个函数，这里再说一下，第一次connect调用的时候传递两个参数，而且还得是个函数
const CountContainer =connect(a,b)(CountUi)//最后返回的就会创建一个容器组件

export default CountContainer
</code></pre>
<p>讲解一下</p>
<p><strong>connect第一次调用需要两个需要两个参数，两个都是需要函数的形式，并且需要把数据和函数返回出来，第一个参数是传递state，这样就可以在ui组件里读到我需要的数据，使用this.props.count就可以读到，上面a函数的参数就是使用store.getStore获取的数据，这里面的第二个函数的参数就是store.dispacth的方法，通过把第二个函数传递给ui组件，ui组件在调用这个函数，就会通知redux进行操作</strong></p>
<p>这里面的</p>
<pre><code class="js">&#123;type:&#39;increment&#39;,data:value&#125;
</code></pre>
<p>可以替换成我们封装的那个ceateAction的文件</p>
<p>总结下</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240315164133473.png" alt="image-20240315164133473"></p>
<p>容器组件</p>
<pre><code class="js">//容器组件，需要借助实现容器组件
//先引入ui组件库
import CountUi from &quot;../../components/Count&quot;;
//链接ui&#39;组件和容器组件
import &#123;connect&#125; from &#39;react-redux&#39;
import &#123;createIncrementAction,createDecrementAction&#125; from &quot;../../redux/count_action&quot;;

const mapStateToProps = (state)=&gt;&#123;
    return &#123;count:state&#125;   //这里等价于 &lt;CountUi n=&#123;900&#125;/&gt;返回值的对象啊就相当于props
&#125;
//传递操作状态的方法
const mapDispatchToProps = (dispatch)=&gt;&#123;
    return &#123;
        increment : (value)=&gt;&#123;
            dispatch(createIncrementAction(value))
            &#125;,
        decrement : (value)=&gt;&#123;
            dispatch(createDecrementAction(value))
        &#125;,
    &#125;
&#125;
//connnec是个函数，返回值也是一个函数，这里再说一下，第一次connect调用的时候传递两个参数，而且还得是个函数
const CountContainer =connect(mapStateToProps,mapDispatchToProps)(CountUi)//最后返回的就会创建一个容器组件

export default CountContainer
</code></pre>
<p>ui组件</p>
<pre><code class="js">import React, &#123;Component&#125; from &#39;react&#39;;

class Count extends Component &#123;
    state = &#123;
        count:0
    &#125;
    increment = ()=&gt;&#123;
        const &#123;value&#125; =  this.selectNumber
        //通知redux加上value
        this.props.increment(value*1)
    &#125;
    decrement = ()=&gt;&#123;
        const &#123;value&#125; =  this.selectNumber
        const &#123;count &#125; = this.state
        this.props.decrement(value*1 )
    &#125;
    incrementOfOdd = ()=&gt;&#123;
        const &#123;value&#125; =  this.selectNumber
    &#125;
    incrementAsync = ()=&gt;&#123;
        const &#123;value&#125; =  this.selectNumber
        const &#123;count &#125; = this.state

    &#125;
    render() &#123;
        console.log(&#39;ui组件接收到的props&#39;,this.props)
        return (
            &lt;div&gt;
                &lt;h1&gt;当前求和为&#123;this.props.count&#125;&lt;/h1&gt;
                &lt;select ref=&#123;c =&gt; this.selectNumber = c&#125;&gt;
                    &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
                    &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;
                    &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;
                &lt;/select&gt;&amp;nbsp;
                &lt;button onClick=&#123;this.increment&#125;&gt;+&lt;/button&gt;&amp;nbsp;
                &lt;button onClick=&#123;this.decrement&#125;&gt;-&lt;/button&gt;&amp;nbsp;
                &lt;button onClick=&#123;this.incrementOfOdd&#125;&gt;当前求和为奇数再加&lt;/button&gt;&amp;nbsp;
                &lt;button onClick=&#123;this.incrementAsync&#125;&gt;异步加&lt;/button&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;

export default Count;
</code></pre>
<p>我们可以优化一下代码</p>
<pre><code class="js">import CountUi from &quot;../../components/Count&quot;;
import &#123;connect&#125; from &#39;react-redux&#39;
import &#123;createIncrementAction,createDecrementAction&#125; from &quot;../../redux/count_action&quot;;
export default  connect(
    state=&gt; (&#123; count:state &#125;),
    dispatch =&gt;(&#123;       
        increment : value=&gt; dispatch(createIncrementAction(value)),
        decrement : (value)=&gt; dispatch(createDecrementAction(value)&#125;)
)(CountUi)
</code></pre>
<p><strong>上面是代码层面的优化，传递方法的那个优化，代码里面只有一个return，suoy省略{}和return，但是它返回的是一个对象的形式，为了放着把对象的{}当作函数体，需要使用（）包裹</strong></p>
<p>下面是api层面的优化</p>
<pre><code class="js">import CountUi from &quot;../../components/Count&quot;;
import &#123;connect&#125; from &#39;react-redux&#39;
import &#123;createIncrementAction,createDecrementAction&#125; from &quot;../../redux/count_action&quot;;
export default connect(
    state =&gt; (&#123; count:state &#125;),
    &#123;
    increment :  createIncrementAction,
    decrement :  createDecrementAction
&#125;
)(CountUi)
</code></pre>
<p>操作其实是这样的</p>
<p><strong>我们传递给ui组件increment和decrement，这两个东东是什么呢？分别是createIncrementAction和createDecrementAction,这两个是函数，因为我们在createAction里面定义了，然乎我们通过在ui组件使用this.props.decrement(value<em>1 )和this.props.increment(value</em>1)调用以后，就会返回action对象，之前redux就会自动分发自动调用dispatch</strong></p>
<p>之前redux里面数据更新需要从新调用render熏染</p>
<pre><code class="js">store.subscribe(()=&gt;&#123;
    ReactDOM.render(
        &lt;App/&gt;
        ,document.getElementById(&#39;root&#39;))
&#125;)
</code></pre>
<p>但是当我们使用react—redux的以后</p>
<p>我们就不用写这个了 </p>
<p>全是connect的作用，connect就会连接容器组件和redux，检测数据变化，重新熏染</p>
<pre><code class="js">export default connect(
    state =&gt; (&#123; count:state &#125;),
    &#123;
    increment :  createIncrementAction,
    decrement :  createDecrementAction
&#125;
)(CountUi)
</code></pre>
<p>还有当我们在给容器组件传递store的时候</p>
<pre><code class="js">import React, &#123;Component&#125; from &#39;react&#39;;
import Count from &quot;./containers/Count&quot;;
//引入redux的store
import store from &quot;./redux/store&quot;;
class App extends Component &#123;
    render() &#123;
        return (
            &lt;div&gt;
                &lt;Count store=&#123;store&#125;&gt;&lt;/Count&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;

export default App;
</code></pre>
<p>使用</p>
<pre><code class="js">&lt;Count store=&#123;store&#125;&gt;&lt;/Count&gt;
</code></pre>
<p>但是如果有很多的容器组件就要传递很多次</p>
<p>我们可以在index.js里</p>
<p>这样</p>
<pre><code class="js">import React from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;
import App from &#39;./app&#39;
import store from &quot;./redux/store&quot;;
import &#123; Provider &#125; from &#39;react-redux&#39;

ReactDOM.render(
    &lt;Provider store=&#123;store&#125;&gt;
        &lt;App/&gt;
    &lt;/Provider&gt;

    ,document.getElementById(&#39;root&#39;))
</code></pre>
<p>这样容器组件都不用使用 了</p>
<p>下面继续优化</p>
<p>我们可以把ui组件和容器组件整合在一起</p>
<p>我们就可以这么写</p>
<pre><code class="js">import &#123;connect&#125; from &#39;react-redux&#39;
import &#123;createIncrementAction,createDecrementAction&#125; from &quot;../../redux/count_action&quot;;
import React, &#123;Component&#125; from &#39;react&#39;;
//定义ui组件
class Count extends Component &#123;
    state = &#123;
        count:0
    &#125;
    increment = ()=&gt;&#123;
        const &#123;value&#125; =  this.selectNumber
        //通知redux加上value
        this.props.increment(value*1)
    &#125;
    decrement = ()=&gt;&#123;
        const &#123;value&#125; =  this.selectNumber
        const &#123;count &#125; = this.state
        this.props.decrement(value*1 )
    &#125;
    incrementOfOdd = ()=&gt;&#123;
        const &#123;value&#125; =  this.selectNumber
    &#125;
    incrementAsync = ()=&gt;&#123;
        const &#123;value&#125; =  this.selectNumber
        const &#123;count &#125; = this.state

    &#125;
    render() &#123;
        console.log(&#39;ui组件接收到的props&#39;,this.props)
        return (
            &lt;div&gt;
                &lt;h1&gt;当前求和为&#123;this.props.count&#125;&lt;/h1&gt;
                &lt;select ref=&#123;c =&gt; this.selectNumber = c&#125;&gt;
                    &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
                    &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;
                    &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;
                &lt;/select&gt;&amp;nbsp;
                &lt;button onClick=&#123;this.increment&#125;&gt;+&lt;/button&gt;&amp;nbsp;
                &lt;button onClick=&#123;this.decrement&#125;&gt;-&lt;/button&gt;&amp;nbsp;
                &lt;button onClick=&#123;this.incrementOfOdd&#125;&gt;当前求和为奇数再加&lt;/button&gt;&amp;nbsp;
                &lt;button onClick=&#123;this.incrementAsync&#125;&gt;异步加&lt;/button&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;


export default connect(
    state =&gt; (&#123; count:state &#125;),
    &#123;
    increment :  createIncrementAction,
    decrement :  createDecrementAction
&#125;
)(Count)
</code></pre>
<p>总结一下</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240315175734911.png" alt="image-20240315175734911"></p>
<p>如何共享到其他的组件</p>
<h3 id="实现多个组件的共享数据"><a href="#实现多个组件的共享数据" class="headerlink" title="实现多个组件的共享数据"></a>实现多个组件的共享数据</h3><p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240315210414679.png" alt="image-20240315210414679"></p>
<p>多个组件的共享的目录，目录写成这样</p>
<p>而且我们的store的组件里面也需要改变</p>
<pre><code class="js">//applyMiddleware用于执行中间件，createStore创建store,combineReducers合并多个reducer
import &#123;createStore,applyMiddleware,combineReducers&#125; from &#39;redux&#39;
// 引入为count服务的reducer
import countReducer from &#39;./reducer/count&#39;
//使用person的信息
import personReducer from &#39;./reducer/person&#39;
//用于支持异步的action
import thunk from &#39;redux-thunk&#39;

//汇总所有的render作为一个总的
const allReducers = combineReducers(&#123;
    count:countReducer,
    person:personReducer
&#125;)

const store =createStore(allReducers,applyMiddleware(thunk))

export default store
</code></pre>
<p>这里的combineReducers就可以把多个reducer联合到一起，然后写成对象的形式</p>
<p>当我们在外壳组件传递给数据给ui组件，就需要</p>
<pre><code class="js">export default connect(
    allState =&gt; (&#123; count:allState.count,personInfo : allState.person &#125;),
    &#123;
    increment :  createIncrementAction,
    decrement :  createDecrementAction
&#125;
)(Count)
</code></pre>
<p>这里面的allState就是刚才写成对象的</p>
<h4 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h4><p>之前我们在实现person的案例里面</p>
<p>在reducer里使用解构的方法进行向数据添加对象</p>
<pre><code class="js">export default function (perState = initState,action)&#123;
    const &#123;type,data&#125; = action
    switch (type)&#123;
        case ADD_PERSON:
            return [data,...perState]
        default:
            return perState
    &#125;
&#125;
</code></pre>
<p>上面的实现方法是正确的</p>
<p>但是 下面这样写</p>
<pre><code class="js">export default function (perState = initState,action)&#123;
    const &#123;type,data&#125; = action
    switch (type)&#123;
        case ADD_PERSON:
            perState.unshift(data)
            return perState
        default:
            return perState
    &#125;
&#125;
</code></pre>
<p>这样写就当我们添加数据，页面没有显示，但是我们打印一下</p>
<pre><code class="js">export default function (perState = initState,action)&#123;
    const &#123;type,data&#125; = action
    switch (type)&#123;
        case ADD_PERSON:
            perState.unshift(data)
            console.log(perState)
            return perState
        default:
            return perState
    &#125;
&#125;
</code></pre>
<p>上面的输出是正常的，添加是成功的</p>
<p>原因是因为，</p>
<p><strong>当我们执行操作以后 ，redux会对当前返回的值会和之前的值做判断，因为上面的数据类型是数组，当我们使用unshift的方法，是不会更改数组的地址的地址，底层做的是浅比较，一样的就不会更新了，不一样的就会更新了，使用[data,…perState]，就会创建一个新的数据</strong></p>
<p>如果这么写的话,就不是纯函数l了</p>
<pre><code class="js">export default function (perState = initState,action)&#123;
    const &#123;type,data&#125; = action
    switch (type)&#123;
        case ADD_PERSON:
            perState.unshift(data)
            return perState
        default:
            return perState
    &#125;
&#125;
</code></pre>
<p><strong>什么是纯函数</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240315212848794.png" alt="image-20240315212848794"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240315212953523.png" alt="image-20240315212953523"></p>
<p>如果我们传递的相同的值，但是函数返回的值却不一样，这就不是纯函数</p>
<p>比如：随机数</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240315213058730.png" alt="image-20240315213058730"></p>
<p>纯函数的原则</p>
<p>1.不能改变参数数据</p>
<p>上面的</p>
<pre><code class="js">  perState.unshift(data)
</code></pre>
<p>就是修改参数的值，违背了纯函数的原则</p>
<p>2.不能产品副作用</p>
<p>就比如网络请求（因为不确定性太大，有时候就会失败）</p>
<p>3.不可以调用随机数函数和时间戳的函数</p>
<p> <strong>redux里面的reducers必须是一个纯函数</strong></p>
<p><strong>redux的开发者工具</strong></p>
<p>如果想让开发者模式工作</p>
<p>1.下载</p>
<pre><code class="js">pnpm  i redux-devtools-extension
</code></pre>
<p>2.在store里</p>
<pre><code class="js">//引入开发者
import &#123;composeWithDevTools&#125; from &#39;redux-devtools-extension&#39;
</code></pre>
<p>本来，composeWithDevTools应该放在下面的第二个参数的位置，但是我们使用了applyMiddleware(thunk)，如果没有使用thunk的话就可以直接写，但是现在存在</p>
<pre><code class="js">const store =createStore(allReducers,applyMiddleware(thunk))
</code></pre>
<p>就像下面写</p>
<pre><code class="js">const store =createStore(allReducers,composeWithDevTools(applyMiddleware(thunk)))
</code></pre>
<p>这样的我们的图标就亮了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240315214448802.png" alt="image-20240315214448802"></p>
<p>1.state这里面保存着我们全部的state</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240315214718472.png" alt="image-20240315214718472"><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240315214845193.png" alt="image-20240315214845193"></p>
<p>这里的dispatch就可以自己尝试dispatch</p>
<p>redux结束</p>
<h2 id="react的扩展"><a href="#react的扩展" class="headerlink" title="react的扩展"></a>react的扩展</h2><p><strong>setState</strong></p>
<p>setState有两种写法</p>
<pre><code class="js">class Demo extends Component &#123;
    state = &#123;
        sum:0,
    &#125;
    add = ()=&gt;&#123;
        const sum = this.state.sum
        this.setState(&#123;sum:sum+1&#125;,)
        console.log(&#39;@&#39;,sum)
    &#125;
    render() &#123;
        return (
            &lt;div&gt;
                &lt;h1&gt;当前的和为&#123;this.state.sum&#125;&lt;/h1&gt;
                &lt;button onClick=&#123;this.add&#125;&gt;加一 &lt;/button&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;
</code></pre>
<p>之前我们setState是这样写的</p>
<p>在上面的代码我们可以验证setState是一个异步的函数</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316025328727.png" alt="image-20240316025328727"></p>
<p>所以状态的更新是异步的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316025432324.png" alt="image-20240316025432324"></p>
<p>那我们如何拿到最新的值？</p>
<p>在setState后面加上回调</p>
<p>回调执行的时机是在页面更新完毕，这样获取的sum就是更新完毕的，之前的没在回调里面写，setstate是一个异步的任务，所以先去执行后面的语句</p>
<pre><code class="js">import React, &#123;Component&#125; from &#39;react&#39;;

class Demo extends Component &#123;
    state = &#123;
        sum:0,
    &#125;
    add = ()=&gt;&#123;
        const sum = this.state.sum
        this.setState(&#123;sum:sum+1&#125;,()=&gt;&#123;
            console.log(&#39;回调里面的sum&#39;,this.state.sum)
        &#125;)
        console.log(&#39;@&#39;,this.state.sum)
    &#125;
    render() &#123;
        return (
            &lt;div&gt;
                &lt;h1&gt;当前的和为&#123;this.state.sum&#125;&lt;/h1&gt;
                &lt;button onClick=&#123;this.add&#125;&gt;加一 &lt;/button&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;

export default Demo;
</code></pre>
<p>这样就可以</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316092546917.png" alt="image-20240316092546917"></p>
<p>相当于vue里面的nexttick</p>
<p>第二种写法，</p>
<p>函数式的写法</p>
<p>或者写成这样</p>
<pre><code class="js">this.setState(()=&gt;&#123;
    return &#123;sum:9999&#125;
&#125;)
</code></pre>
<p>点击以后直接变成9999</p>
<p>而且还能该函数的参数能够接收到两个参数</p>
<pre><code class="js">    this.setState((state,props)=&gt;&#123;
        console.log(state) //&#123;sum: 0&#125;
        console.log(props) //&#123;a: 1&#125;
        return &#123;sum:9999&#125;
   &#125;)
</code></pre>
<p>state组件里的状态，props是组件传过来的值，我感觉没有用啊，使用this也能获取到啊</p>
<p>这个函数式的形式适用于定时器的修改state参数</p>
<p><strong>layLoad</strong></p>
<p>懒加载</p>
<p>用的时候在加载。不用的时候就不会加载了</p>
<p>一般使用在路由的身上</p>
<p>比如说当我们进入</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316094609168.png" alt="image-20240316094609168"></p>
<p>主页的时候，还没有使用about组建和home组件，但是他们也已经加载出来了</p>
<p>，然后之后使用这些组件走的浏览器的本地存储</p>
<p>基本的使用</p>
<p>1.我们需要使用lazy，使用下面的方法导入组件</p>
<pre><code class="js">import React, &#123;Component,lazy,Suspense&#125; from &#39;react&#39;;
const Home = lazy(()=&gt;import(&#39;./components/LazyLoad/Home&#39;))
const About = lazy(()=&gt;import(&#39;./components/LazyLoad/Home&#39;))
</code></pre>
<p>2.在注册路由的地方包裹Suspense，并且指定没有加载出来，我们显示那哪个组件，为了方便回调里我直接写html 了</p>
<pre><code class="js">                                &lt;Suspense fallback=&#123;&lt;h1&gt;loading....&lt;/h1&gt;&#125;&gt;
                                    &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;
                                    &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;
                                &lt;/Suspense&gt;
</code></pre>
<p>这样就是先懒加载了</p>
<p>尝试一下</p>
<p>当我们直接访问主页的时候，没有使用组件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316095908319.png" alt="image-20240316095908319"></p>
<p>没有发现请求我们的组件的资源</p>
<p>当我们使用组件的时候</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316100002104.png" alt="image-20240316100002104"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316100103871.png" alt="image-20240316100103871">这个时候才会加载出来，这样就是先懒加载了</p>
<p>我们在尝试一下</p>
<pre><code class="js">&lt;Suspense fallback=&#123;&lt;h1&gt;loading....&lt;/h1&gt;&#125;&gt;
    &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;
    &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;
&lt;/Suspense&gt;
</code></pre>
<p>没有加载出来回调试一下</p>
<p>网速慢一点</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316100224686.png" alt="image-20240316100224686"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316100246040.png" alt="image-20240316100246040"></p>
<p>组件没有加载出来就可以显示这个</p>
<p><strong>而且记住,Suspense里的fallback指定的回调的组件一定不要使用懒加载的形式引入，回调的组件应该在和整张页面一起加载出来的</strong></p>
<p><strong>Hooks</strong></p>
<p>让你在函数组件使用state和其他的组件特性</p>
<p>之前说过，函数组件不能使用this和实例对象的，不能使用生命周期和this什么的</p>
<p>但是现在有hooks，就可以实现了</p>
<p>三个常用的Hooks</p>
<p>1.React.useState()</p>
<pre><code class="js">function Count()&#123;
    const a = React.useState()
    console.log(a) //a是一个数组，第一个就是state，第二个更新state的方法
    function add()&#123;
        console.log(&#39;jia&#39;)
    &#125;
    return (
        &lt;div&gt;
            &lt;h1&gt;当前求和为&#123;&#125;&lt;/h1&gt;
            &lt;button onClick=&#123;add&#125;&gt;点我加一&lt;/button&gt;
        &lt;/div&gt;
    )
&#125;
</code></pre>
<p>然后我们可以赋初始值,使用对象 的解构</p>
<pre><code class="js">    const [a,b] = React.useState(0)
    console.log(a,b)//
</code></pre>
<p>结果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316101641354.png" alt="image-20240316101641354"></p>
<p>下面就可以实现了 </p>
<pre><code class="js">function Count()&#123;
    const [count,setCount] = React.useState(0)
    function add()&#123;
        setCount(count+1)
    &#125;
    return (
        &lt;div&gt;
            &lt;h1&gt;当前求和为&#123;count&#125;&lt;/h1&gt;
            &lt;button onClick=&#123;add&#125;&gt;点我加一&lt;/button&gt;
        &lt;/div&gt;
    )
&#125;
</code></pre>
<p>我们观察代码</p>
<p><strong>其实是有个问题的，当我们修改count的时候，就会重新调用Count，然后但是当我们执行到 const [count,setCount] &#x3D; React.useState(0）那不就是再次重新赋值count为0，但是事实不是这样，因为react官方底层做了处理的，不会出现这个问题不会因为再次调用覆盖掉</strong> </p>
<p>第二种写法</p>
<pre><code class="js">    function add()&#123;
        // setCount(count+1)
        setCount((count)=&gt;&#123;
            return count+1
        &#125;)
    &#125;
</code></pre>
<p>如果状态一多，就得写很多次</p>
<pre><code class="js">const [name,setName] = React.useState(&#39;王昌晨&#39;)
const [count,setCount] = React.useState(0)
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316102318260.png" alt="image-20240316102318260"></p>
<p><strong>React.useEffect</strong></p>
<p>有点相当于生命周期钩子，有点复杂，下面的</p>
<p>后面的回调函数的调用实际是，当组件挂载完毕调用，组件更新的时候调用，state里面的数据全部都会监测</p>
<pre><code class="js">    React.useEffect(()=&gt;&#123;
    &#125;)
</code></pre>
<p>后面第二个参数是一个空数组，调用的时机只有在页面挂载完毕以后调用，</p>
<pre><code class="js">    React.useEffect(()=&gt;&#123;
    &#125;,[])
</code></pre>
<p>数据里面有state的属性，调用的实际就是组件挂在完毕，还有更新count的状态的时候调用</p>
<pre><code class="js">    const [count,setCount] = React.useState(0)
        React.useEffect(()=&gt;&#123;
    &#125;,[count])
</code></pre>
<p>总结一下</p>
<p><strong>如果第二个参数没有写，就会监视全部的state，如果第二个参数的是空数组，就会只有在挂载的时候执行</strong></p>
<p>在写的时候出现一些问题</p>
<pre><code class="js">const [count,setCount] = React.useState(0)   
React.useEffect(()=&gt;&#123;
        setInterval(()=&gt;&#123;
            console.log(&#39;@&#39;,count)
            setCount(count+1)
            console.log(count)
        &#125;,1000)
    &#125;,[])
</code></pre>
<p>上面这段代码，有问题</p>
<p>页面只会一直显示1，并不会一直增加</p>
<p>原因是因为：</p>
<p><strong>当我们组件挂载时候，调用定时器，因为state更新数据是异步的，而且在定时器的回调函数中直接访问外部的<code>count</code>变量时，可能会遇到闭包的问题，所以一直获取的是旧的count，所以这个count一直都是0</strong></p>
<p>所以可以使用回调函数</p>
<pre><code class="js">    React.useEffect(()=&gt;&#123;
        setInterval(()=&gt;&#123;
            setCount(count=&gt; count + 1)
        &#125;,1000)
    &#125;,[])
</code></pre>
<p>继续</p>
<pre><code class="js">function Count()&#123;
    const [count,setCount] = React.useState(0)
    function add()&#123;
        setCount((count)=&gt;&#123;
            return count+1
        &#125;)
    &#125;
    React.useEffect(()=&gt;&#123;
        const a= setInterval(()=&gt;&#123;
            setCount(count=&gt; count + 1)
        &#125;,1000)
        return ()=&gt;&#123;//返回的函数相当于componentWillUnmount
            console.log(11)
        &#125;
    &#125;,[])
    function unmount()&#123;
        ReactDOM.unmountComponentAtNode(document.getElementById(&#39;root&#39;))//卸载组件
    &#125;
    return (
        &lt;div &gt;
            &lt;h1&gt;当前求和为&#123;count&#125;&lt;/h1&gt;
            &lt;button onClick=&#123;add&#125;&gt;点我加一&lt;/button&gt;
            &lt;button onClick=&#123;unmount&#125;&gt;卸载组件&lt;/button&gt;
        &lt;/div&gt;
    )
&#125;
</code></pre>
<p>React.useEffect里面的回调的返回的的函数相当于<strong>componentWillUnmount</strong></p>
<p>再卸载之前调用</p>
<p>最后一个hook</p>
<p><strong>Ref Hook</strong></p>
<p>在函数组件里面使用createRef提示信息</p>
<pre><code class="js">function Count()&#123;
    const [count,setCount] = React.useState(0)
    function add()&#123;
        setCount((count)=&gt;&#123;
            return count+1
        &#125;)
    &#125;
    React.useEffect(()=&gt;&#123;
        const a= setInterval(()=&gt;&#123;
            setCount(count=&gt; count + 1)
        &#125;,1000)
        return ()=&gt;&#123;//返回的函数相当于componentWillUnmount
            clearInterval(a)
        &#125;
    &#125;,[])
    function unmount()&#123;
        ReactDOM.unmountComponentAtNode(document.getElementById(&#39;root&#39;))//卸载组件
    &#125;
    const myRef = React.createRef()
    function show()&#123;
        alert(myRef.current.value)
    &#125;
    return (
        &lt;div &gt;
            &lt;input type=&quot;text&quot; ref=&#123;myRef&#125;/&gt;
            &lt;h1&gt;当前求和为&#123;count&#125;&lt;/h1&gt;
            &lt;button onClick=&#123;add&#125;&gt;点我加一&lt;/button&gt;
            &lt;button onClick=&#123;unmount&#125;&gt;卸载组件&lt;/button&gt;
            &lt;button onClick=&#123;show&#125;&gt;点我提示信息&lt;/button&gt;
        &lt;/div&gt;
    )
&#125;
</code></pre>
<p>其实这里的createRef可以使用useRef进行替换</p>
<pre><code class="js">    const myRef = React.useRef()
</code></pre>
<p>也是好用的</p>
<p>总结</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316174744026.png" alt="image-20240316174744026"></p>
<p><strong>Frament</strong></p>
<p>这个就是一个标签</p>
<p>相当于之前的vue需要一个根元素，就可以使用template，而且这样也不会影响层级结构，这个Frament就相当于template</p>
<pre><code class="js">import React, &#123;Component,Fragment&#125; from &#39;react&#39;;

class Demo extends Component &#123;
    render() &#123;
        return (
            &lt;Fragment&gt;
                &lt;h1&gt;演示&lt;/h1&gt;
            &lt;/Fragment&gt;
        );
    &#125;
&#125;
</code></pre>
<p>很简单，其实我们要实现这个原理，直接包裹一个空标签也行</p>
<pre><code class="js">class Demo extends Component &#123;
    render() &#123;
        return (
            &lt;&gt;
                &lt;h1&gt;演示&lt;/h1&gt;
            &lt;/&gt;
        );
    &#125;
&#125;
</code></pre>
<p>这两个标签的区别，就是Fragment有key属性，如果参与遍历就差需要Fragment</p>
<p><strong>context</strong></p>
<p>实现组件之间的通信</p>
<p><strong>适用于组组件和后代组件的的通信</strong></p>
<p>操作</p>
<p>1.创建Context容器对象</p>
<p>注意要开头首字母要大些，因为最后要当作标签</p>
<pre><code class="js">const UserNameContext = React.createContext()
</code></pre>
<p>我们可以在结构一下,下面代码应该全局定义，然后再在后面使用Provider进行包裹将需要传递的值写在value属性里，</p>
<pre><code class="js">const UserNameContext = React.createContext()
const &#123;Provider&#125; = UserNameContext

 render() &#123;
        return (
            &lt;div&gt;
               &lt;h3&gt;A组件，用户名为&#123;this.state.name&#125;&lt;/h3&gt;
                &lt;hr/&gt;
                &lt;Provider value=&#123;this.state.name&#125;&gt;
                    &lt;B/&gt;
                &lt;/Provider&gt;
            &lt;/div&gt;
        );
    &#125;
</code></pre>
<p>2如何接收？经过上面的操作就可以传到后代的组件，但是接收必须声明一下，要不然接收到的是空的，下面就可以接收到了，注意contextType名字是固定的，不能更改，而且前面使用static进行包裹</p>
<pre><code class="js">class B extends Component &#123;
    static contextType = UserNameContext
    render() &#123;
        console.log(this.context)
        return (
            &lt;div&gt;
                &lt;h3&gt;B组件，接收到的用户名为&#123;&#125;&lt;/h3&gt;
                &lt;hr/&gt;
                &lt;C&gt;&lt;/C&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;
</code></pre>
<p>之前我们写过redux页使用Provider，，底层的原理也是这样的</p>
<p>如果要传递多个数据呢？</p>
<p>可以写成对象的形式</p>
<pre><code class="js">                &lt;Provider value=&#123;&#123;name:this.state.name,age:this.state.age&#125;&#125;&gt;
                    &lt;B/&gt;
                &lt;/Provider&gt;
</code></pre>
<p>然后使用接收就可以 了</p>
<p>但是上面的方法局限性很大,如果后代组件是函数式组件没有this我们就可以使用第二种方法</p>
<pre><code class="js">const &#123;Provider,Consumer&#125; = UserNameContext
</code></pre>
<p>然后在函数组件就就可以这样接收,value救赎你传递的值</p>
<pre><code class="js">function C()&#123;
    return (
        &lt;div&gt;
            &lt;h3&gt;C组件，接收到的用户名为:&lt;/h3&gt;
            &lt;Consumer&gt;
                &#123;
                    value =&gt; &#123;
                        return value.name
                    &#125;
                &#125;
            &lt;/Consumer&gt;
        &lt;/div&gt;
    )
&#125;
</code></pre>
<p><strong>组件的优化</strong></p>
<pre><code class="js">class Parent extends Component &#123;
    state = &#123;carName:&#39;奔驰c63&#39;&#125;
    changeCar = ()=&gt;&#123;
        this.setState(&#123;carName:&#39;迈巴赫&#39;&#125;)
&#125;
    render() &#123;
        console.log(&#39;parent-render&#39;)
        return (
            &lt;div&gt;
                &lt;h4&gt;我是Parent组件&lt;/h4&gt;
                &lt;strong&gt;我的车是&#123;this.state.carName&#125;&lt;/strong&gt;&lt;br/&gt;
                &lt;button onClick=&#123;this.changeCar&#125;&gt;点我换车&lt;/button&gt;
                &lt;hr/&gt;
                &lt;Child /&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;
class Child extends Component &#123;
    render() &#123;
        console.log(&#39;child-render&#39;)
        return (
            &lt;div&gt;
                &lt;h3&gt;我是Child组件&lt;/h3&gt;
                &#123;/*&lt;h3&gt;我接到的车为&#123;this.props.carName&#125;&lt;/h3&gt;*/&#125;
            &lt;/div&gt;
        );
    &#125;
&#125;
</code></pre>
<p>这段代码，当父组件数据更新重新调用render，组件的render也会调用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316192247293.png" alt="image-20240316192247293"></p>
<p>这样就不太好，子组件还会更新</p>
<p>component存在两个问题</p>
<p>1.当执行setstate时，即使不改变数据，组件也会render</p>
<p>2.如果当前组件render（），子组件也会跟这render，这样效率低</p>
<p>例</p>
<pre><code class="js">    changeCar = ()=&gt;&#123;
        this.setState(&#123;&#125;)
&#125;
</code></pre>
<p>这样不会影响state里的数据，但是还会重新熏染</p>
<p>效率高的方法</p>
<p><strong>只有当组件的state或者props发生真正的改变才可以重新调用render</strong></p>
<p>原理是因为</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316192917469.png" alt="image-20240316192917469"></p>
<p>解决</p>
<pre><code class="js">    shouldComponentUpdate(nextProps, nextState, nextContext) &#123;
        console.log(nextProps,nextState)//接下要变化的目标的props和state
    &#125;
</code></pre>
<p>所以我们可以做判断</p>
<pre><code class="js">    shouldComponentUpdate(nextProps, nextState, nextContext) &#123;
        if (this.state.carName === nextState.carName)&#123;return false&#125;
        else return true
    &#125;
</code></pre>
<p>下面的代码就可以优化这个问题</p>
<pre><code class="js">import React, &#123;Component&#125; from &#39;react&#39;;

class Parent extends Component &#123;
    state = &#123;carName:&#39;奔驰c63&#39;&#125;
    changeCar = ()=&gt;&#123;
        this.setState(&#123;carName:&#39;迈巴赫&#39;&#125;)
&#125;
    shouldComponentUpdate(nextProps, nextState, nextContext) &#123;
        if (this.state.carName === nextState.carName)
        &#123;
            return false
        &#125;
        else
            return true
    &#125;

    render() &#123;
        console.log(&#39;parent-render&#39;)
        return (
            &lt;div&gt;
                &lt;h4&gt;我是Parent组件&lt;/h4&gt;
                &lt;strong&gt;我的车是&#123;this.state.carName&#125;&lt;/strong&gt;&lt;br/&gt;
                &lt;button onClick=&#123;this.changeCar&#125;&gt;点我换车&lt;/button&gt;
                &lt;hr/&gt;
                &lt;Child carName=&#39;奔驰&#39;/&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;
class Child extends Component &#123;
    //只有当父组件穿过的来的props和上次的不一样才会render
    shouldComponentUpdate(nextProps, nextState, nextContext) &#123;
        // if(this.props.carName === nextProps.carName)&#123;
        //     return false
        // &#125;  else   return true
        return !this.props.carName === nextProps.carName
    &#125;
    render() &#123;
        console.log(&#39;child-render&#39;)
        return (
            &lt;div&gt;
                &lt;h3&gt;我是Child组件&lt;/h3&gt;
                &#123;/*&lt;h3&gt;我接到的车为&#123;this.props.carName&#125;&lt;/h3&gt;*/&#125;
            &lt;/div&gt;
        );
    &#125;
&#125;

export default Parent;
</code></pre>
<p>那如果判断很多个怎么办</p>
<p>开发的话是不需要手动写阀门的</p>
<p>在react提供PureComponent</p>
<p>继承与这个</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316195351776.png" alt="image-20240316195351776"></p>
<p>这样阀门的逻辑就不用写 了</p>
<p>但是还有一个问题 </p>
<p>如果我们使用carName但是却这样写了</p>
<pre><code class="js">    changeCar = ()=&gt;&#123;
        const obj = this.state
        obj.carName= &#39;hahah&#39;
        this.setState(obj)
        // this.setState(&#123;carName:&#39;迈巴赫&#39;&#125;)
&#125;
</code></pre>
<p>触发这个函数但还是没有render，因为这个是地址的引用，地址没有改变，对比是浅对比，这就是之前说过不适用push和unshift的方法在redux的reducer的里面</p>
<p>总结一下</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316200229344.png" alt="image-20240316200229344"></p>
<p><strong>render props</strong></p>
<p><strong>相当于vue*里面的插槽</strong></p>
<p>父组件</p>
<pre><code class="js">&lt;div&gt;
    &lt;h3&gt;Parent组件&lt;/h3&gt;
    &lt;hr/&gt;
    &lt;A id=&#123;1&#125;&gt;Hello&lt;/A&gt;
&lt;/div&gt;
</code></pre>
<p>子组件</p>
<pre><code class="js">console.log(this.props)//&#123;id: 1, children: &#39;Hello&#39;&#125;
</code></pre>
<p>之前说过标签体内容是特别的标签属性</p>
<p>我们在A标签也可以包裹其他组件的内容</p>
<pre><code class="JS">Parent组件
render() &#123;
        return (
            &lt;div&gt;
                &lt;h3&gt;Parent组件&lt;/h3&gt;
                &lt;hr/&gt;
                &lt;A id=&#123;1&#125;&gt;
                    &lt;B/&gt;
                &lt;/A&gt;
            &lt;/div&gt;
        );
A组件
 render() &#123;
        return (
            &lt;div&gt;
                &lt;h3&gt;A组件&lt;/h3&gt;
                &lt;h2&gt;&#123;this.props.children&#125;&lt;/h2&gt;
            &lt;/div&gt;
        );
    &#125;
B组件
 render() &#123;
        return (
            &lt;div&gt;
                &lt;h3&gt;B组件&lt;/h3&gt;
            &lt;/div&gt;
        );
    &#125;
</code></pre>
<p>这样效果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316201752870.png" alt="image-20240316201752870"></p>
<p>所以形成会关系这种方法也是可以的</p>
<p>如果我们想把A组件的state传递给B组件，还是按照这种写法</p>
<p>那应该怎么传</p>
<p>可以向下面这样</p>
<p>我们就可以这么写,非常的巧妙，能看懂，不解释了</p>
<pre><code class="js">import React, &#123;Component&#125; from &#39;react&#39;;

class Parent extends Component &#123;
    render() &#123;
        return (
            &lt;div&gt;
                &lt;h3&gt;Parent组件&lt;/h3&gt;
                &lt;hr/&gt;
                &lt;A render=&#123;(name)=&gt;&lt;B name=&#123;name&#125;/&gt;&#125;&gt;&lt;/A&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;
class A extends Component &#123;
    state = &#123;name:&#39;tom&#39;&#125;
    render() &#123;
        return (
            &lt;div&gt;
                &lt;h3&gt;A组件&lt;/h3&gt;
                &lt;hr/&gt;
                &#123;this.props.render(this.state.name)&#125;
            &lt;/div&gt;
        );
    &#125;
&#125;
class B extends Component &#123;
    render() &#123;
        return (
            &lt;div&gt;
                &lt;h3&gt;B组件&lt;/h3&gt;
                &lt;h3&gt;名字为:&#123;this.props.name&#125;&lt;/h3&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;

export default Parent;
</code></pre>
<p>这样就更接近插槽的技术了</p>
<p>总结这两种方法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316202842295.png" alt="image-20240316202842295"></p>
<p><strong>错误边界</strong></p>
<p>打包以后的文件怎么运行？</p>
<p>1.使用express</p>
<p>2.使用第三方的库：<strong>serve</strong></p>
<p>安装</p>
<pre><code class="js">pnpm i serve
</code></pre>
<p>然后指定哪个文件夹作为根目录</p>
<pre><code class="js">serve build
</code></pre>
<p>这样就可以了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316203808974.png" alt="image-20240316203808974"></p>
<p>错误边界的意思</p>
<p><strong>当我们子组件发生错误，不会影响我们父组件的展示</strong></p>
<p>操作的地方在容易错误组件的父组件</p>
<p>例</p>
<pre><code class="js">class Child extends Component &#123;
    state = &#123;
        users:[
            &#123;id:&#39;001&#39;,name:&#39;tom&#39;,age:18&#125;,
            &#123;id:&#39;002&#39;,name:&#39;jack&#39;,age:18&#125;,
            &#123;id:&#39;003&#39;,name:&#39;peiqi&#39;,age:18&#125;,
            &#123;id:&#39;004&#39;,name:&#39;tom&#39;,age:18&#125;,
        ]
    &#125;
    render() &#123;
        return (
            &lt;div&gt;
                &lt;h2&gt;Child组件&lt;/h2&gt;
                &lt;ul&gt;
                    &#123;
                        this.state.users.map((item)=&gt;&#123;
                            return (
                                &lt;li key=&#123;item.id&#125;&gt;
                                    &#123;item.name&#125;---&#123;item.age&#125;
                                &lt;/li&gt;
                            )
                        &#125;)
                    &#125;
                &lt;/ul&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;
</code></pre>
<p>这是正常的子组件如果我把users改为字符串，这样整个页面就会报错</p>
<p>在父组件就可以这么写</p>
<pre><code class="js">class Parent extends Component &#123;
    state = &#123;
        hasError:null
    &#125;
    //如果parent任意的子组件发生了错误都会调用这个钩子
    static getDerivedStateFromError(error)&#123;
        console.log(error)
        return &#123;hasError:error&#125;
    &#125;
    render() &#123;
        return (
            &lt;div&gt;
                &lt;h2&gt;Parent组件&lt;/h2&gt;
                &lt;hr/&gt;
                &#123;this.state.hasError ? &lt;h2&gt;加载失败&lt;/h2&gt; : &lt;Child/&gt;&#125;
            &lt;/div&gt;
        );
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316205354398.png" alt="image-20240316205354398"></p>
<p><strong>这就是错误边界</strong></p>
<p>其实我们能够做的更好</p>
<pre><code class="js">//组件熏染出错，就会调用   
componentDidCatch(error, errorInfo) &#123;
        console.log(&#39;熏染出错&#39;)
        // 一般这里做记录做错误次数，反馈给服务器
    &#125;
</code></pre>
<p>这个钩子是错误的时候调用，然后就可以在这里记录错误的次数</p>
<p>注意</p>
<p><strong>上面的钩子只能捕获声明周期产生的错误，例如上面的演示就是render（）出的错</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240316205912906.png" alt="image-20240316205912906"></p>
<p>组件通信的总结</p>
<p><strong>React Router6</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240317100540654.png" alt="image-20240317100540654"></p>
<p>发生了一点的改变</p>
<p>安装</p>
<pre><code class="js"> pnpm i react-router-dom@6
</code></pre>
<p>发生的改变，switch被替换成Routes，component的属性被替换成element，这个Routes是必须使用的，如果不使用就会报错，</p>
<pre><code class="js">import &#123;NavLink,Route,Routes&#125; from &#39;react-router-dom&#39;
//在注册路由的时候
                                &lt;Routes&gt;
                                    &lt;Route path=&quot;/about&quot; element=&#123;&lt;About/&gt;&#125;/&gt;
                                    &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home/&gt;&#125;/&gt;
                                &lt;/Routes&gt;
</code></pre>
<p>之前说过一种情况，这个匹配规则还是和switch是一样的，匹配到以后就不会再匹配了</p>
<pre><code class="js">    &lt;Routes&gt;
                                    &lt;Route path=&quot;/about&quot; element=&#123;&lt;About/&gt;&#125;/&gt;
                                    &lt;Route path=&quot;/about&quot; element=&#123;&lt;Home/&gt;&#125;/&gt;
                                    &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home/&gt;&#125;/&gt;
                                &lt;/Routes&gt;
</code></pre>
<p><strong>重定向的写法</strong></p>
<p>之前的重定向最后的使用Redirect进行重定向现在使用</p>
<p>有点麻烦</p>
<pre><code class="js">import &#123;NavLink,Route,Routes,Navigate&#125; from &#39;react-router-dom&#39;
                                &lt;Routes&gt;
                                    &lt;Route path=&quot;/about&quot; element=&#123;&lt;About/&gt;&#125;/&gt;
                                    &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home/&gt;&#125;/&gt;
                                    &lt;Route path=&quot;/&quot; element=&#123;&lt;Navigate to=&#123;&#39;/home&#39;&#125;/&gt;&#125;/&gt;
                                &lt;/Routes&gt;
</code></pre>
<p>只要熏染Navigate就会引起视图的切换</p>
<p>例子</p>
<pre><code class="js">import React, &#123;Component&#125; from &#39;react&#39;;
import &#123;Navigate&#125; from &#39;react-router-dom&#39;

function Home ()&#123;
    const [sum,setSum] = React.useState(0)
    const add = ()=&gt;&#123;
        setSum(2)
    &#125;
    return (
        &lt;div&gt;
            &lt;h3&gt;Home组件&lt;/h3&gt;
            &#123;sum === 2 ? &lt;Navigate to=&#123;&#39;/about&#39;&#125;&gt;&lt;/Navigate&gt; : &lt;h3&gt;当前的sum值为&#123;sum&#125;&lt;/h3&gt;&#125;
            &lt;button onClick=&#123;add&#125;&gt;点我变为2&lt;/button&gt;
        &lt;/div&gt;
    )
&#125;

export default Home;
</code></pre>
<p>当我们sum为2的时候就会跳转到about</p>
<p>而且Navigate还有replace的的属性</p>
<pre><code class="js">   &#123;sum === 2 ? &lt;Navigate replace to=&#123;&#39;/about&#39;&#125;&gt;&lt;/Navigate&gt; : &lt;h3&gt;当前的sum值为&#123;sum&#125;&lt;/h3&gt;&#125;
</code></pre>
<p>总结一下</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240317103844979.png" alt="image-20240317103844979"></p>
<p><strong>之前高亮效果的activeClassname的属性不能使用了</strong></p>
<p>现在规定自定义追加的类名，在类名里面要使用函数的形式</p>
<pre><code class="js"> &lt;NavLink className=&#123;(value)=&gt;&#123;
                                console.log(value)&#125;&#125; to=&#39;/about&#39;&gt;About&lt;/NavLink&gt;
</code></pre>
<p>我们通过上面就可以发现函数的执行时机，当我们刚熏染组件的时候会调用，当跳转到这个路由也会调用，当离开这个路由也会调用</p>
<p>而且里面的isActive也会跟着变化</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240317104700516.png" alt="image-20240317104700516"></p>
<p>这样就可以了</p>
<pre><code class="js">                            &lt;NavLink className=&#123;(&#123;isActive&#125;)=&gt;&#123;
                                return isActive ? &#39;list-group-item active&#39; : &#39;list-group-item&#39;
                                &#125;&#125; to=&#39;/about&#39;&gt;About&lt;/NavLink&gt;
</code></pre>
<p>或者更简单点</p>
<pre><code class="js">function computedClassName(&#123;isActive&#125;)&#123;
    return isActive ? &#39;list-group-item active&#39; : &#39;list-group-item&#39;
&#125;
                  &lt;NavLink className=&#123;computedClassName&#125; to=&#39;/about&#39;&gt;About&lt;/NavLink&gt;
</code></pre>
<p>在学习的时候发现一个注意点</p>
<p>只要NavLink可以写成上面的这样，发现Link标签实现不了上面的效果</p>
<p>所以还是这样写</p>
<pre><code class="js">    function computedClassName(&#123;isActive&#125;)&#123;
        return isActive ? &#39;list-group-item active&#39; : &#39;list-group-item&#39;
    &#125;
                            &lt;div className=&quot;list-group&quot;&gt;
                            &lt;NavLink className=&#123;computedClassName&#125; to=&#39;/about&#39;&gt;About&lt;/NavLink&gt;
                            &lt;NavLink className=&#123;computedClassName&#125; to=&#39;/home&#39;&gt;Home&lt;/NavLink&gt;
                        &lt;/div&gt;
</code></pre>
<p><strong>路由表的使用</strong></p>
<p>我们发现</p>
<pre><code class="js">                                &lt;Routes&gt;
                                    &lt;Route path=&quot;/about&quot; element=&#123;&lt;About/&gt;&#125;/&gt;
                                    &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home/&gt;&#125;/&gt;
                                    &lt;Route path=&quot;/&quot; element=&#123;&lt;Navigate to=&#123;&#39;/home&#39;&#125;/&gt;&#125;/&gt;
                                &lt;/Routes&gt;
</code></pre>
<p>这些内容大致一样，只是路由和组件不一样，我们就可以使用路由表注册路由</p>
<p>使用如下，现在代码都是函数式组件</p>
<pre><code class="js">import &#123;NavLink,Route,Routes,Navigate,Link,useRoutes&#125; from &#39;react-router-dom&#39;
    const element = useRoutes([
        &#123;path:&#39;/about&#39;,element:&lt;About/&gt;&#125;,
        &#123;path:&#39;/home&#39;,element:&lt;Home/&gt;&#125;,
        &#123;path:&#39;/&#39;,element:&lt;Navigate to=&#123;&#39;/home&#39;&#125;/&gt;&#125;,
    ])
    //在之前注册路由的地方
        &#123;element&#125;
</code></pre>
<p>这样就实现了和之前的效果，一般把路由表封装在一个文件里里面</p>
<pre><code class="js">import Home from &#39;../components/Home&#39;
import About from &#39;../components/About&#39;
import &#123;Navigate&#125; from &quot;react-router-dom&quot;;
import React from &quot;react&quot;;
import &#123;useRoutes&#125; from &quot;react-router-dom&quot;;

export default
    [
        &#123;path:&#39;/about&#39;,element:&lt;About/&gt;&#125;,
        &#123;path:&#39;/home&#39;,element:&lt;Home/&gt;&#125;,
        &#123;path:&#39;/&#39;,element:&lt;Navigate to=&#123;&#39;/home&#39;&#125;/&gt;&#125;,
    ]
</code></pre>
<pre><code class="js">import routes from &#39;./Routes/index
const element = useRoutes(routes)
</code></pre>
<p><strong>嵌套路由</strong></p>
<p>基本使用</p>
<p>我们子级路由的注册可以在路由表里面，这可以写成这样</p>
<p>注意这里的路径，注意子路由的path不用跟上父级路由，而且不能加‘&#x2F;’</p>
<pre><code class="js">import Home from &#39;../components/Home&#39;
import About from &#39;../components/About&#39;
import Message from &quot;../components/Message&quot;;
import News from &quot;../components/News&quot;
import &#123;Navigate&#125; from &quot;react-router-dom&quot;;
import React from &quot;react&quot;;
import &#123;useRoutes&#125; from &quot;react-router-dom&quot;;

export default
    [
        &#123;path:&#39;/about&#39;,element:&lt;About/&gt;&#125;,
        &#123;path:&#39;/home&#39;,element:&lt;Home/&gt;,children:[
                &#123;path:&#39;message&#39;,element:&lt;Message/&gt;&#125;,
                &#123;path:&#39;news&#39;,element:&lt;News/&gt;&#125;
            ]&#125;,
        &#123;path:&#39;/&#39;,element:&lt;Navigate to=&#123;&#39;/home&#39;&#125;/&gt;&#125;,
    ]
</code></pre>
<p>在父级路由之前注册路由的地方</p>
<pre><code class="js">import React, &#123;Component&#125; from &#39;react&#39;;
import &#123;NavLink,Outlet &#125; from &quot;react-router-dom&quot;;
function Home ()&#123;
    return (
        &lt;div&gt;
            &lt;h3&gt;Home组件&lt;/h3&gt;
            &lt;div&gt;
                &lt;ul className=&quot;nav nav-tabs&quot;&gt;
                    &lt;li&gt;
                        &lt;NavLink to=&#39;/home/news&#39;&gt;News&lt;/NavLink&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;NavLink to=&#39;/home/message&#39;&gt;message&lt;/NavLink&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
                &#123;/*指定路由组件呈现的路径*/&#125;
                &lt;Outlet&gt;&lt;/Outlet&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    )
&#125;
</code></pre>
<p>引入Outlet相当于vue里面的router-view</p>
<p>还有一个注意点</p>
<pre><code class="js">  &lt;NavLink to=&#39;/home/news&#39;&gt;News&lt;/NavLink&gt;
</code></pre>
<p>这里面的跳转连接可以写成上面这个样子，或者写成下面这个样子，这样的效果是一样的，而且注意不要写’&#x2F;‘</p>
<pre><code class="js">  &lt;NavLink to=&#39;news&#39;&gt;News&lt;/NavLink&gt;
</code></pre>
<p>或者这么写,在当前的路径添加</p>
<pre><code class="js">  &lt;NavLink to=&#39;./news&#39;&gt;News&lt;/NavLink&gt;
</code></pre>
<p>还有一个问题</p>
<p>我们发现</p>
<p>当我们点击子路由的时候，父级路由的也会亮</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240317114934884.png" alt="image-20240317114934884"></p>
<p>如果不想这样的话在父级路由的添加end属性</p>
<pre><code class="js">                            &lt;NavLink className=&#123;computedClassName&#125; to=&#39;/about&#39;&gt;About&lt;/NavLink&gt;
                            &lt;NavLink className=&#123;computedClassName&#125; to=&#39;/home&#39; end&gt;Home&lt;/NavLink&gt;
</code></pre>
<p><strong>路由传参</strong></p>
<p>params传参</p>
<p>传参的地方</p>
<pre><code class="js">&lt;li key=&#123;item.id&#125;&gt;&lt;Link to=&#123;`detail/$&#123;item.username&#125;/$&#123;item.age&#125;`&#125;&gt;&#123;item.username&#125;&lt;/Link&gt;&lt;/li&gt;
</code></pre>
<p>注册路由的地方</p>
<pre><code class="js">//需要占位
&#123;path:&#39;message&#39;,element:&lt;Message/&gt;,children:[
                        &#123;path:&#39;detail/:username/:age&#39;,element:&lt;Detail/&gt;&#125;
                    ]&#125;,
</code></pre>
<p>因为我们现在是函数式的组件，所以我们this，所以就需要使用钩子，</p>
<p>这样获取的a就是就是params参数对象</p>
<pre><code class="js">import &#123;useParams&#125; from &quot;react-router-dom&quot;;

const Detail = () =&gt; &#123;
    const a = useParams()
    console.log(a)
    return (
        &lt;div&gt;
            &lt;ul&gt;&lt;/ul&gt;
        &lt;/div&gt;
    );
&#125;;
</code></pre>
<p>之前我们获取params使用props里面的match获得的</p>
<p>，我们也有match的钩子，不过需要把路径给补上</p>
<pre><code class="js">import &#123;useParams,useMatch&#125; from &quot;react-router-dom&quot;;
    const a = useMatch(&#39;/home/message/detail/:username/:age&#39;)
    console.log(a)
</code></pre>
<p>结果里就有</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240317122141763.png" alt="image-20240317122141763"></p>
<p><strong>search参数</strong></p>
<p>这个参数获取有点麻烦的其他的还好。注册路由的时候不用占位</p>
<pre><code class="js">&lt;li key=&#123;item.id&#125;&gt;&lt;Link to=&#123;`detail?username=$&#123;item.username&#125;&amp;age=$&#123;item.age&#125;`&#125;&gt;&#123;item.username&#125;&lt;/Link&gt;&lt;/li&gt;
</code></pre>
<p>接收的时候,这个useSearchParams有点像useState，返回一个数组，第一个是传过来的数据，第二个是修改数据的方法，获取数据我们还有使用数组返回第一的get方法，这样就可以获取到相对应的值</p>
<pre><code class="js">import &#123;useSearchParams&#125; from &quot;react-router-dom&quot;;
const [user,setUser] = useSearchParams()
console.log(user.get(&#39;username&#39;))
</code></pre>
<p>这样就可以实现了</p>
<pre><code class="js">    const [user,setUser] = useSearchParams()
    const username = user.get(&#39;username&#39;)
    const age = user.get(&#39;age&#39;)
    return (
        &lt;div&gt;
            &lt;ul&gt;&#123;username&#125;--&#123;age&#125;&lt;/ul&gt;
        &lt;/div&gt;
    );
</code></pre>
<p>修改数据的方法</p>
<pre><code class="js">    const [user,setUser] = useSearchParams()
    const username = user.get(&#39;username&#39;)
    const age = user.get(&#39;age&#39;)   
    const refeshUser  = ()=&gt;&#123;
        setUser(&#39;username=哈哈&amp;age=18&#39;)
    &#125;
    return (
        &lt;div&gt;
            &lt;ul&gt;&#123;username&#125;--&#123;age&#125;&lt;/ul&gt;
            &lt;button onClick=&#123;refeshUser&#125;&gt;更新search参数&lt;/button&gt;
        &lt;/div&gt;
    );
&#125;;
</code></pre>
<p>或者使用useLoaction的钩子,注意这个不用向match一样写上路径</p>
<pre><code class="js">    const a = useLocation()
    console.log(a)
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240317123546393.png" alt="image-20240317123546393"></p>
<p>最后还要借助第三方库query—string</p>
<p>s<strong>tate参数</strong></p>
<p>之前我们to里面写的是对象类型 的，这里面可以不用对象</p>
<p>可以写成这样的，添加state参数</p>
<pre><code class="js">    return (&lt;li key=&#123;item.id&#125;&gt;&lt;Link to=&#39;detail&#39; state=&#123;&#123;
                                username:item.username,
                                age:item.age
                            &#125;&#125;&gt;&#123;item.username&#125;&lt;/Link&gt;&lt;/li&gt;)
</code></pre>
<p>获取的话我们可以使用useLocation进行获取</p>
<p>因为location里面有search和state参数，params参数在match里面</p>
<pre><code class="js">    const a = useLocation()
    console.log(a)
</code></pre>
<p>我们就可以获取的到</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240317124340269.png" alt="image-20240317124340269"></p>
<p>state只有这一种这个方法</p>
<p><strong>编程式路由导航</strong></p>
<p>之前使用props.history里的方法</p>
<p>基本的使用</p>
<pre><code class="js">import &#123;useNavigate&#125; from &quot;react-router-dom&quot;;
    const getRoute = ()=&gt;&#123;
        navigate(&#39;/home&#39;)
    &#125;
        return (
        &lt;div&gt;
        &#123;/*//     &lt;ul&gt;&#123;username&#125;--&#123;age&#125;&lt;/ul&gt;*/&#125;
            &lt;button onClick=&#123;getRoute&#125;&gt;点我跳转到首页&lt;/button&gt;
        &lt;/div&gt;
    );
</code></pre>
<p>这样就可以跳转</p>
<p>第二个参数是配置，这里面的第二个参数就是配置对象，注意这个配置对象里面只能传递state参数，其他参数的传递直接拼接在路径里面</p>
<pre><code class="js">    const navigate = useNavigate()
    const getRoute = ()=&gt;&#123;
        navigate(&#39;/home&#39;,&#123;
            replace:false,
            state:&#123;
                
            &#125;
        &#125;)
    &#125;
</code></pre>
<p>之前非路由组件，使用withRouter进行包裹，就可以使用路由的方法</p>
<p>在新版本中，有了useNavigate()，也可以非路由组件使用路由组件的方法</p>
<pre><code class="js">import React from &#39;react&#39;;
import &#123;useNavigate&#125; from &quot;react-router-dom&quot;;

const Title = () =&gt; &#123;
    const navigate = useNavigate()
    function forward()&#123;

        navigate(1)
    &#125;
    function back()&#123;

        navigate(-1)
    &#125;
    return (
        &lt;div&gt;
            &lt;h1&gt;Home组件&lt;/h1&gt;
            &lt;button onClick=&#123;forward&#125;&gt;前进&lt;/button&gt;
            &lt;button onClick=&#123;back&#125;&gt;后退&lt;/button&gt;
        &lt;/div&gt;
    );
&#125;;

export default Title;
</code></pre>
<p>其他的钩子</p>
<p>app被broserRoute包裹，旗下的所有子组件，都是返回的true，当脱离broserRouterj就是false</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240317130246830.png" alt="image-20240317130246830"></p>
<p>返回值是返回值就是你通过什么方式进入这个页面的，pop是刷新进入这个组件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240317130426356.png" alt="image-20240317130426356"></p>
<p>输入</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240317130542276.png" alt="image-20240317130542276"></p>
<p>解析路径的钩子</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240317130645778.png" alt="image-20240317130645778"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240317130705039.png" alt="image-20240317130705039"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240317130719631.png" alt="image-20240317130719631"></p>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 哈哈哈哈哈哈哈重生之我是兵王
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;chenw
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
