
<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8" />
    <title>react | 哈哈哈哈哈哈哈重生之我是兵王</title>
    <meta name="author" content="chenw" />
    <meta name="description" content="description" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
	<canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
	<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
	<script src="/js/fireworks.min.js"></script>
	<canvas id="background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
	<script src="/js/background.min.js"></script>
	<div id="cursor"></div>
	<link rel="stylesheet" href="/css/cursor.min.css">
	<script src="/js/cursor.min.js"></script>
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>哈哈哈哈哈哈哈重生之我是兵王</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;哈哈哈哈哈哈哈重生之我是兵王</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>react</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/7
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <p>摘要</p>
<span id="more"></span>

<p>内容</p>
<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p><strong>尚硅谷react全家桶</strong></p>
<p><strong>开发者</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307183403208.png" alt="image-20240307183403208"></p>
<p>为什么要学习呢？</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307183521107.png" alt="image-20240307183521107"></p>
<p>jquery</p>
<p><strong>react的特点</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307183628824.png" alt="image-20240307183628824"></p>
<p><strong>react native</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307183651762.png" alt="image-20240307183651762"></p>
<p>所以指定客户端的开发也可以开发手机app</p>
<p>和vue的一样</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307183732623.png" alt="image-20240307183732623"></p>
<p>之前的query和原生的js操作的都是真实的DOM</p>
<h2 id="React的入门、"><a href="#React的入门、" class="headerlink" title="React的入门、"></a><strong>React的入门</strong>、</h2><p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307184027693.png" alt="image-20240307184027693"></p>
<p>diffing就是对比的算法和之前的vue的diffin的算法一样</p>
<p><strong>下载react</strong>先学习旧版本</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307184251576.png" alt="image-20240307184251576"></p>
<p>babel有两个功能</p>
<p>1.就是使es6转为es5</p>
<p>2.使jsx转为js</p>
<p>开始学习</p>
<p>引入需要的包</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307184710573.png" alt="image-20240307184710573"></p>
<p>简单的使用方法</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    //因为使用的不是js的语言而是jsx，所有需要Babel进行解析
    //1.创建虚拟dom
    const VDOM = &lt;h1&gt;hello,react&lt;/h1&gt; //这里不可以使用引号，因为这里不是字符串，这里已经不是js的语法了
    //2.熏染虚拟dom到页面
    //调用引入的方法
    ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))//react没有提供选择器
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注意</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
    //因为使用的不是js的语言而是jsx，所有需要Babel进行解析
    //1.创建虚拟dom
    const VDOM = &lt;h1&gt;hello,react&lt;/h1&gt; //这里不可以使用引号，因为这里不是字符串，这里已经不是js的语法了
    const VDOM2 = &lt;h1&gt;hello,react2&lt;/h1&gt; //这里不可以使用引号，因为这里不是字符串，这里已经不是js的语法了
    //2.熏染虚拟dom到页面
    //调用引入的方法
    ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))//react没有提供选择器
    ReactDOM.render(VDOM2,document.getElementById(&#39;test&#39;))//react没有提供选择器
&lt;/script&gt;
</code></pre>
<p>这里提供和两个并没有追加的功能</p>
<p><strong>为什么我们要使用jsx呢？</strong></p>
<p>使用jsx创建id的属性</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    //因为使用的不是js的语言而是jsx，所有需要Babel进行解析
    //1.创建虚拟dom
    const VDOM = &lt;h1 id=&#39;title&#39;&gt;hello,react&lt;/h1&gt; //这里不可以使用引号，因为这里不是字符串，这里已经不是js的语法了
    //2.熏染虚拟dom到页面
    //调用引入的方法
    ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))//react没有提供选择器
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>使用js</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    const VDOM = React.createElement(&#39;h1&#39;,&#123;id:&#39;title&#39;&#125;,&#39;hello world&#39;)
    //2.熏染虚拟dom到页面
    //调用引入的方法
    ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))//react没有提供选择器
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>那如果还有一个要求</p>
<p>在h1下面在创建一个span的标签，这个jsx可以直接写</p>
<p>但是使用js的话</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    const VDOM = React.createElement(&#39;h1&#39;,&#123;id:&#39;title&#39;&#125;,React.createElement(&#39;span&#39;,&#123;&#125;,&#39;hello&#39;))
    //2.熏染虚拟dom到页面
    //调用引入的方法
    ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))//react没有提供选择器
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果有很多个话就会太繁琐了</p>
<p>为更加明显我们一般</p>
<pre><code class="js">v&lt;script type=&quot;text/babel&quot;&gt;
    //因为使用的不是js的语言而是jsx，所有需要Babel进行解析
    //1.创建虚拟dom
    const VDOM = (
        &lt;h1 id=&#39;title&#39;&gt;
            hello,react
        &lt;/h1&gt;
    ) //这里不可以使用引号，因为这里不是字符串，这里已经不是js的语法了
    //2.熏染虚拟dom到页面
    //调用引入的方法
    ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))//react没有提供选择器
&lt;/script&gt;
</code></pre>
<p>这样的书写</p>
<p>那么这个括号里的代码经过babel的翻译变成什么样子呢？</p>
<p>其实就是我们使用js创建dom的写法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307191233743.png" alt="image-20240307191233743"></p>
<p>就相当于语法糖</p>
<p>我们在输出一下</p>
<p>这个VDOM是什么东西</p>
<p><img src="/react.assets/image-20240307191423213.png" alt="image-20240307191423213"></p>
<p>就是一般对象</p>
<p>所以虚拟的dom比较轻</p>
<p>相比较真是的dom里面的有很多的属性和方法</p>
<p>因为虚拟dom是React在使用，无需dom那么多</p>
<h2 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h2><p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307191800226.png" alt="image-20240307191800226"></p>
<p>xml早期用于储存数据和传输数据</p>
<p>之前</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307191858186.png" alt="image-20240307191858186"></p>
<p>但是json以后就使用json</p>
<p><strong>jsx的语法规则</strong></p>
<p>定义虚拟dom的时候不要使用‘’</p>
<p>2.标签混入js表达式要使用{}</p>
<p>3.在jsx中应用样式的类名需要使用classnName 而不是class了</p>
<p>4.使用内敛样式的时候需要两个括号，第一个括号js表达式</p>
<p>第二个括号是使用对象的形式，如果名字是多个单词的需要使用小驼峰</p>
<p>例如fontSize</p>
<p>5.只能有一个根标签</p>
<p>6.标签必须闭合</p>
<p>7.小写字母开头则将其转为html的同名标签</p>
<p>大写的字母开头的标签就当作组件了</p>
<pre><code class="jsx">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;hello&lt;/title&gt;
    &lt;style&gt;
        .title&#123;
            background: orange;
            width: 200px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    const id = &#39;title&#39;
    const name = &#39;haha&#39;
    const VDOM = (
        &lt;div&gt;
            &lt;h1 id=&#123;id&#125; className=&quot;title&quot;&gt;
            &lt;span style=&#123;&#123;color:'white'&#125;&#125;&gt;
                &#123;name&#125;
            &lt;/span&gt;
            &lt;/h1&gt;
            &lt;input type=&quot;text&quot;/&gt;
        &lt;/div&gt;
    )
    ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))//react没有提供选择器
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这样写的话</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;hello&lt;/title&gt;
    &lt;style&gt;
        .title&#123;
            background: orange;
            width: 200px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    const data = [&#39;Angular&#39;,&#39;React&#39;,&#39;Vue&#39;]
const VDOM = (
    &lt;div&gt;
        &lt;h1&gt;前端三大框架&lt;/h1&gt;
        &lt;ul&gt;
            &#123;data&#125;
        &lt;/ul&gt;
    &lt;/div&gt;
)
ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>会帮助你遍历</p>
<p>但不是里li标签的形式</p>
<p>但是如果数据写成</p>
<pre><code class="js">const data = [&lt;li&gt;Angular&lt;/li&gt;,&lt;li&gt;React&lt;/li&gt;,&lt;li&gt;vue&lt;/li&gt;]
</code></pre>
<p>这样是可以的</p>
<p>注意{}这里面只可以使用表达式</p>
<p>不可以放代码</p>
<p>就比如for和if都是不能往里面放的</p>
<p>所以一定区分js表达式和js代码</p>
<p>liru<img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307194939064.png" alt="image-20240307194939064"></p>
<p>这些里面都有返回值</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307195021453.png" alt="image-20240307195021453"></p>
<p>所以可以这么写</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;hello&lt;/title&gt;
    &lt;style&gt;
        .title&#123;
            background: orange;
            width: 200px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    // const data = [&lt;li&gt;Angular&lt;/li&gt;,&lt;li&gt;React&lt;/li&gt;,&lt;li&gt;vue&lt;/li&gt;]
    const data = [&#39;Angular&#39;,&#39;React&#39;,&#39;Vue&#39;]
const VDOM = (
    &lt;div&gt;
        &lt;h1&gt;前端三大框架&lt;/h1&gt;
        &lt;ul&gt;
            &#123;
                data.map((item)=&gt;&#123;
                    return &lt;li&gt;&#123;item&#125;&lt;/li&gt;
                &#125;)
            &#125;
        &lt;/ul&gt;
    &lt;/div&gt;
)
ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>但是注意这里的li需要做好key因为diffing的算法就是通过key进行对比的</p>
<p>就可以这么写</p>
<pre><code class="js">    &lt;div&gt;
        &lt;h1&gt;前端三大框架&lt;/h1&gt;
        &lt;ul&gt;
            &#123;
                data.map((item,index)=&gt;&#123;
                    return &lt;li key=&quot;index&quot;&gt;&#123;item&#125;&lt;/li&gt;
                &#125;)
            &#125;
        &lt;/ul&gt;
    &lt;/div&gt;
</code></pre>
<p>但是这样也会有问题，后面再说</p>
<h2 id="React面对组件编程"><a href="#React面对组件编程" class="headerlink" title="React面对组件编程"></a>React面对组件编程</h2><p>开发者工具的调试工具</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307200440946.png" alt="image-20240307200440946"></p>
<p>这里的components是记录组件的</p>
<p>这里的profiler是分析一些东西 </p>
<p><strong>组件有两种定义的方法</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307200622358.png" alt="image-20240307200622358"></p>
<p>函数式组件的几个要点</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;函数式组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    // 1.创建函数式组件，一般用于简单组件的定义
    const Demo = ()=&gt; &lt;h2&gt;我是使用函数定义的组件&lt;/h2&gt;
    ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>1.函数必须将组件的内容返回出来</p>
<p>2.在上面说过组标签的开头需要大写</p>
<p>3.而且参数里面需要写组件的标签的形式</p>
<p>就像上面一样，而且必须闭合</p>
<p>这样以后开发者工具里面也会有 了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307201813085.png" alt="image-20240307201813085"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307201826264.png" alt="image-20240307201826264"></p>
<p>下面是React的版本</p>
<p>有几个问题</p>
<p>这里的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307201904789.png" alt="image-20240307201904789"></p>
<p>Demo是React帮你调用的</p>
<p>那如果不是箭头函数那这里的this指向谁？</p>
<p>答案是undefine</p>
<p>因为</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307202050218.png" alt="image-20240307202050218"></p>
<p>babel翻译这句话以后开启了严格模式</p>
<p>我们可以去babel的官网去试验一下</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307202152593.png" alt="image-20240307202152593"></p>
<p>同时也验证了jsx通过babel翻译以后成js的形式</p>
<p>执行ReactDom.render以后发生了什么？</p>
<p>1.React解析组件标签，找到了组件</p>
<p>2.发现组件使用函数定义的，随后调用该函数。将返回的虚拟的dom转为真实的dom，然后呈现在页面</p>
<p><strong>类组件</strong></p>
<p>class里面的方法定义不需要使用function</p>
<p>一般方法都在类的原型对象上面,只要不写成赋值函数，那么就会在原型对象上</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307203205647.png" alt="image-20240307203205647"></p>
<p>又复习了一下类的</p>
<p>如果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307203457359.png" alt="image-20240307203457359"></p>
<p>子类在定义构造器</p>
<p>就需要使用super方法调用父亲的构造器</p>
<p>所以这么写</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307203610881.png" alt="image-20240307203610881"></p>
<p>而且super需要放在最前面</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307203731293.png" alt="image-20240307203731293"></p>
<p>这里的stident的实例对象调用speak的方法</p>
<p>但是student的原型对象上面并没没有这样的方法</p>
<p>所有就要顺着原型链往上面找</p>
<p>然后多态</p>
<p>重写父类的方法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307203914984.png" alt="image-20240307203914984"></p>
<p>类似组件的开始</p>
<p>注意点</p>
<p>1.必须继承React里面的类</p>
<p>2.必须使用render函数，使用return返回需要的东西</p>
<p>3.当执行玩render以后发现是类的就是使用new 该类的实例，并且通过该实例调用render的方法，<strong>而且这里面的this就是组件实例对象</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307205032993.png" alt="image-20240307205032993"></p>
<p>这里面props和refs和state特别的重要</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;函数式组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
// 1。创建类是组件
class MyComponent extends React.Component &#123;
    render()&#123;
        console.log(this)
        return  &lt;h2&gt;使用类定义的组件，试用于复杂的组件&lt;/h2&gt;
    &#125;
&#125;
ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>就可以这样的</p>
<p><strong>对state理解</strong></p>
<p>复杂组件和简单组件区别</p>
<p>就是看有没有状态</p>
<p><strong>组件的状态驱动着页面展示</strong></p>
<p>数据就放在状态里面</p>
<p>数据的改变就会驱动着页面的展示</p>
<h3 id="组件第三个核心属性"><a href="#组件第三个核心属性" class="headerlink" title="组件第三个核心属性"></a>组件第三个核心属性</h3><p><strong>state</strong></p>
<p>只有类定义的才有状态</p>
<p>初始化state</p>
<p>借助构造器初始化状态</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;函数式组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
            this.state = &#123;
                isHot:true,
                name:&#39;&#39;
            &#125;
        &#125;
        render()&#123;
            console.log(this)//这里的this就是实例对象
            return  &lt;h1&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;
    &#125;
    ReactDOM.render(&lt;Weather/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>那么react如何做事件绑定呢？</p>
<p>原生js实现</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307210717008.png" alt="image-20240307210717008"></p>
<p>React的事件绑定一般使用第三种</p>
<p><strong>但是有注意点 和原理啊的事件名称不一样</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240307210934602.png" alt="image-20240307210934602"></p>
<p>这里注意一个点</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308095633925.png" alt="image-20240308095633925"></p>
<p>在类里面定义的方法那么在类里面调用不了‘</p>
<p>只能由实例调用所有调用的时候需要加入</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308095731667.png" alt="image-20240308095731667"></p>
<p>这样才可以调用</p>
<p><strong>类中方法this的指向</strong></p>
<p>实例对象</p>
<p>如果直接这样的调用就会出现问题</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;函数式组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
            this.state = &#123;
                isHot:true,
                name:&#39;&#39;
            &#125;
        &#125;
        changeWeather()&#123;
            console.log(this)
        &#125;
        render()&#123;
            console.log(this)//这里的this就是实例对象
            return  &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;

    &#125;
    ReactDOM.render(&lt;Weather/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>因为这里的点击onclick’以后调用函数不是通过实例调用的而是直引用</p>
<p>类中的方法默认开启了局部的严格模式，所有changeweather的this就是为严格模式</p>
<p>这样我们就可以通过bind的方法获取到了组件实例对象的this</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;函数式组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
            this.state = &#123;
                isHot:true,
                name:&#39;&#39;
            &#125;
            this.changeWeather = this.changeWeather.bind(this)
        &#125;
        changeWeather()&#123;
            console.log(this)
        &#125;
        render()&#123;
            console.log(this)//这里的this就是实例对象
            return  &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;

    &#125;
    ReactDOM.render(&lt;Weather/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308101452414.png" alt="image-20240308101452414"></p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;函数式组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
            this.state = &#123;
                isHot:true,
                name:&#39;&#39;
            &#125;
            this.changeWeather = this.changeWeather.bind(this)
        &#125;
        changeWeather()&#123;
            // state不可以直接更改需要借助api
            // this.state.isHot = !this.state.isHot
            // console.log(this.state.isHot)
        &#125;
        render()&#123;
            console.log(this)//这里的this就是实例对象
            return  &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;

    &#125;
    ReactDOM.render(&lt;Weather/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>我们要修改state的状态不可以直接修改</p>
<p>如果直接修改的话不会引state的改变</p>
<p>我们顺着原型链找到类继承react里面的setState这里面的可以帮助你修改</p>
<p>所以修正以后的代码</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;函数式组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
            this.state = &#123;
                isHot:true,
                name:&#39;&#39;
            &#125;
            this.changeWeather = this.changeWeather.bind(this)//这里bind会返回一个函数
        &#125;
        changeWeather()&#123;
            // state不可以直接更改需要借助api
            // this.state.isHot = !this.state.isHot
            // console.log(this.state.isHot)
            this.setState(&#123;isHot:!this.state.isHot&#125;)
        &#125;
        render()&#123;
            console.log(this)//这里的this就是实例对象
            return  &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;

    &#125;
    ReactDOM.render(&lt;Weather/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>然后就有一个疑问setstate就合并的动作还是覆盖的动作</p>
<p>当然就是合并替换</p>
<p>那执行conscructor和render的分别调用几次？</p>
<p>1.conscructor调用1次</p>
<p>2.render调用1+n次，改变几次页面就更新几次</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;函数式组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备容器--&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
            this.state = &#123;
                isHot:true,
                name:&#39;&#39;
            &#125;
            this.changeWeather = this.changeWeather.bind(this)//这里bind会返回一个函数
        &#125;
        changeWeather()&#123;
            // state不可以直接更改需要借助api
            // this.state.isHot = !this.state.isHot
            // console.log(this.state.isHot)
            this.setState(&#123;isHot:!this.state.isHot&#125;)
        &#125;
        render()&#123;
            return  &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;

    &#125;
    ReactDOM.render(&lt;Weather/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这些代码太复杂，其实可以精简点 </p>
<p>对于刚才的总结一下</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308103016788.png" alt="image-20240308103016788"></p>
<hr>
<p><strong>对于上面的代码，constructor里面的this指向是没问题的，这里面的render的this的指向，是因为React自动帮你实例组件实例对象，然后调用这个render方法，所以要这里的this的指向是组件实例对象，但是类里面的定义的函数，因为调用它是出现在类里面的回调的里面，所以这里的this是undfined，所以要改变这样就需要使用bind的方法，</strong></p>
<pre><code class="js">使用
this.demo=this.changeWeather.bind(this)//这里面就会返回一个方法，里面的this就是指向实例对象
onClick=&#123;this.demo&#125;
</code></pre>
<p>现在就有一个问题</p>
<p>如果作为事件的回调调用类里面的方法</p>
<p>如果这么写,岂不是很复杂</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308103747721.png" alt="image-20240308103747721"></p>
<p>所以又精简的写法</p>
<p>这在提一下类，如果我们在实例对象</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308104111622.png" alt="image-20240308104111622"></p>
<p>这里的wheel是定制</p>
<p>其实我们 不用非得在构造器里面写</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308104203094.png" alt="image-20240308104203094"></p>
<p><strong>记住不要声明变量</strong></p>
<pre><code class="js">a=1//在类里面这样写的意思是给car的实例对象追加一个属性名文a，值为1
</code></pre>
<p>所以之前的代码精简成</p>
<p>其实完全可以这样写</p>
<pre><code class="js">    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
            this.changeWeather = this.changeWeather.bind(this)//这里bind会返回一个函数
        &#125;
        state = &#123;
            isHot:true,
            name:&#39;&#39;
        &#125;
</code></pre>
<p>所以这个我们也可以省略掉</p>
<pre><code>this.changeWeather = this.changeWeather.bind(this)
</code></pre>
<p>但是需要这么写</p>
<p>一步一步的来</p>
<p>首先我们</p>
<p><strong>因为我们写成函数赋值的形式，所以这个函数就不会再函数的原型对象上面，其实就是上面的赋值语句一样 changeWeather当做a function (){<br>            this.setState({isHot:!this.state.isHot})<br>        }，当作值，但是有问题这里的this的指向是undefine的因为组件实例不会调用它，他是个回调的函数</strong></p>
<pre><code class="js">    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
        &#125;
        state = &#123;
            isHot:true,
            name:&#39;&#39;
        &#125;
        changeWeather = function ()&#123;
            this.setState(&#123;isHot:!this.state.isHot&#125;)
        &#125;
        render()&#123;
            return  &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;

    &#125;
</code></pre>
<p>但是如果我们写成箭头函数的话，这样我们的箭头函数本身没有this’就回去上一层去找</p>
<pre><code class="js">    class Weather extends React.Component &#123;
        constructor(props) &#123;
            super(props);
        &#125;
        state = &#123;
            isHot:true,
            name:&#39;&#39;
        &#125;
        changeWeather= ()=&gt;&#123;
            this.setState(&#123;isHot:!this.state.isHot&#125;)
        &#125;
        render()&#123;
            return  &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;

    &#125;
</code></pre>
<p>然后再精简一下构造器删掉</p>
<pre><code class="js">    class Weather extends React.Component &#123;
        state = &#123;
            isHot:true,
            name:&#39;&#39;
        &#125;
        changeWeather = ()=&gt;&#123;
            this.setState(&#123;isHot:!this.state.isHot&#125;)
        &#125;
        render()&#123;
            return  &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
        &#125;

    &#125;
</code></pre>
<p><strong>自定义的方法，要用赋值语句+箭头函数</strong></p>
<p><strong>还有一个注意的，类中使用赋值语句定义一个方法的话，不会放在类中的原型对像，还有这个函数会被添加到类的实例上，而不是放在类的原型对象上。这意味着每个类的实例将拥有自己的这个函数副本，而不是共享同一个函数。</strong></p>
<p>*<em>注意</em></p>
<p>1.state只能使用对象的形式定义</p>
<p>2.组件被称为状态机，通过更新state，熏染render刷新页面</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308110156037.png" alt="image-20240308110156037"></p>
<h3 id="props的基本使用"><a href="#props的基本使用" class="headerlink" title="props的基本使用"></a>props的基本使用</h3><p>基本的使用</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
  class Person extends React.Component &#123;
      state = &#123;
          name:&#39;tom&#39;,
          age:18,
          sex:&#39;女&#39;
      &#125;
    render()&#123;
      return(
          &lt;ul&gt;
              &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt;
              &lt;li&gt;&#123;this.props.age&#125;&lt;/li&gt;
              &lt;li&gt;&#123;this.props.sex&#125;&lt;/li&gt;
          &lt;/ul&gt;

      )
    &#125;

  &#125;
  ReactDOM.render(&lt;Person name=&#39;tom&#39; age=&#39;18&#39; sex=&#39;女&#39;/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p>或者使用解构赋值将props里面的内容给结构出来</p>
<p>现在还有问题</p>
<p>如果要传递的数据很多怎么办</p>
<p>如果这些数据是我们请求接口访问到的那怎么动态的传过去</p>
<pre><code class="js"> const p = &#123;name:&#39;tom&#39;,age:&#39;18&#39;,sex: &#39;女&#39;&#125;
  ReactDOM.render(&lt;Person name=&#123;p.name&#125; age=&#123;p.age&#125; sex=&#123;p.sex&#125;/&gt;,document.getElementById(&#39;test&#39;))
</code></pre>
<p>可以这么写</p>
<p>但是React提供更简单的</p>
<p>这样的</p>
<pre><code class="js">  const p = &#123;name:&#39;tom&#39;,age:&#39;18&#39;,sex: &#39;女&#39;&#125;
  ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&#39;test&#39;))
</code></pre>
<p>有点疑问三点运算符不是不能使用在对象身上吗，除非定义一个对象的迭代器，三点运算符的那个底层原理就是使用了迭代器才能遍历</p>
<p>卧槽学到一个新的语法</p>
<pre><code class="js">//其实对象可以使用三点运算符，只不过适用于对象的字面量的赋值
/例如
const person = &#123;
    name:&#39;hahah&#39;,
    age:&quot;11&quot;
&#125;
const person2 = &#123;...person&#125;
</code></pre>
<p>之前学过直接把person付给person1只是地址的引用</p>
<p>还有深拷贝和浅拷贝</p>
<p>浅拷贝或者使用</p>
<pre><code class="js">const originalObject = &#123; a: 1, b: 2 &#125;;
const shallowCopyObject = Object.assign(&#123;&#125;, originalObject);

console.log(shallowCopyObject); // &#123; a: 1, b: 2 &#125;
console.log(originalObject === shallowCopyObject); // false
</code></pre>
<p>那提到之前的简写的方法</p>
<pre><code class="js">  const p = &#123;name:&#39;tom&#39;,age:&#39;18&#39;,sex: &#39;女&#39;&#125;
  ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&#39;test&#39;))
</code></pre>
<p>千万不要我上面的误导了</p>
<p>上面只是复习一下</p>
<p>首先简写的{}这个作用还是js的表达式，原生的js对象不可以使用三点运算符但是这个里面是可以使用的，原因我也不知道</p>
<p>因为babel可以让你使用三点运算符解构对象</p>
<p>但是不可以随便用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308130931802.png" alt="image-20240308130931802"></p>
<p>之前用于传递数据</p>
<p><strong>再增加点语法的知识</strong></p>
<pre><code class="js">const person = &#123;
    name:&#39;hahah&#39;,
    age:&quot;11&quot;
&#125;
const person2 = &#123;...person,name:&#39;王昌晨&#39;&#125;//在复制的同时修改东西
</code></pre>
<p>还有一写问题</p>
<p>如果传递过去数字类型的数据应该怎么办</p>
<p>1.使用简写的形式直接传过去</p>
<pre><code class="js">  const p = &#123;name:&#39;tom&#39;,age:18,sex: &#39;女&#39;&#125;
  ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&#39;test&#39;))//age定义成数字的在传过去
</code></pre>
<p>2.使用{}代码是js的表达式和vue的里面有点像，只不过vue里面是属性的前面加上:,代表是js表达式，而不是字符串</p>
<pre><code class="js">  ReactDOM.render(&lt;Person age:&#123;18&#125;/&gt;,document.getElementById(&#39;test&#39;))
</code></pre>
<p><strong>默认值的设置</strong></p>
<p><strong>必要性的设置</strong></p>
<pre><code class="js">&lt;!--引入proto-types,用于类型标签属性值的限制--&gt;
&lt;script src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
  class Person extends React.Component &#123;
      state = &#123;
          name:&#39;tom&#39;,
          age:18,
          sex:&#39;女&#39;
      &#125;
    render()&#123;
      return(
          &lt;ul&gt;
              &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt;
              &lt;li&gt;&#123;this.props.age&#125;&lt;/li&gt;
              &lt;li&gt;&#123;this.props.sex&#125;&lt;/li&gt;
          &lt;/ul&gt;

      )
    &#125;
  &#125;
  Person.propTypes = &#123;
      name:PropTypes.string.isRequired,
      sex:PropTypes.string
  &#125;
  Person.defaultProps = &#123;
      sex:&#39;不难不女&#39;
  &#125;
  const p = &#123;name:&#39;tom&#39;,age:&#39;18&#39;&#125;
  ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p>解释一下</p>
<pre><code class="js">  Person.propTypes = &#123;
      name:PropTypes.string.isRequired,
      sex:PropTypes.string
  &#125;
</code></pre>
<p>这里的Person是实例对象，里面由propTypes限制属性传递的类型</p>
<p>在调用PropTypes后面限制类型和是否必要的</p>
<pre><code class="js">  Person.defaultProps = &#123;
      sex:&#39;不难不女&#39;
  &#125;
</code></pre>
<p>这个是设置默认值</p>
<p>如果要是传递函数呢？</p>
<p>这里的就要说一下为什么</p>
<pre><code class="js">  Person.propTypes = &#123;
      name:PropTypes.string.isRequired,
      sex:PropTypes.string
  &#125;
</code></pre>
<p>为什么这里的string开头为什么是大写，就是为了避免和内置的冲突</p>
<p>所以函数为了不冲突，使用func</p>
<p>所以这么写</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
  class Person extends React.Component &#123;
      state = &#123;
          name:&#39;tom&#39;,
          age:18,
          sex:&#39;女&#39;
      &#125;
    render()&#123;
      return(
          &lt;ul&gt;
              &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt;
              &lt;li&gt;&#123;this.props.age&#125;&lt;/li&gt;
              &lt;li&gt;&#123;this.props.sex&#125;&lt;/li&gt;
          &lt;/ul&gt;

      )
    &#125;
  &#125;
  Person.propTypes = &#123;
      name:PropTypes.string.isRequired,
      sex:PropTypes.string,
      speak:PropTypes.func
  &#125;
  Person.defaultProps = &#123;
      sex:&#39;不难不女&#39;
  &#125;
  const p = &#123;name:&#39;tom&#39;,age:&#39;18&#39;&#125;
  const speak = ()=&gt;&#123;
      console.log(&#39;hahah&#39;)
  &#125;
  ReactDOM.render(&lt;Person &#123;...p&#125; speak=&#123;speak&#125;/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p><strong>注意事项</strong></p>
<p>这里的props和vue里面一样</p>
<p>只是只读的</p>
<p>props的简写形式</p>
<p>现在我们把限制属性值和默认值都放在类的外边</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308135744587.png" alt="image-20240308135744587"></p>
<p>写在类的里面完全可以</p>
<p>这样我们先举个例子</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308135920715.png" alt="image-20240308135920715"></p>
<p>我们把demo写在外面属实复杂了</p>
<p>我们直接写在里面</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308140005909.png" alt="image-20240308140005909"></p>
<p>但是这样就加在类的实例对象身上了</p>
<p>就比如下面的，只有实例身上才有</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308140313305.png" alt="image-20240308140313305"></p>
<p>如果加在类本身的话，需要使用static修饰，这就是静态属性和静态方法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308140407091.png" alt="image-20240308140407091"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308140050714.png" alt="image-20240308140050714"></p>
<p>所以加在类里面需要</p>
<pre><code class="js">  class Person extends React.Component &#123;
      state = &#123;
          name:&#39;tom&#39;,
          age:18,
          sex:&#39;女&#39;
      &#125;
      static propTypes = &#123;
          name:PropTypes.string.isRequired,
          sex:PropTypes.string,
          speak:PropTypes.func
      &#125;
      static defaultProps = &#123;
          sex:&#39;不难不女&#39;
      &#125;
    render()&#123;
      return(
          &lt;ul&gt;
              &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt;
              &lt;li&gt;&#123;this.props.age&#125;&lt;/li&gt;
              &lt;li&gt;&#123;this.props.sex&#125;&lt;/li&gt;
          &lt;/ul&gt;

      )
    &#125;
  &#125;
</code></pre>
<p>这样写</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>之前我们说构造器里面有个props的</p>
<pre><code class="js">constructor(props) &#123;
    super(props);
    console.log(this.props)
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308141348090.png" alt="image-20240308141348090"></p>
<p>就是我们props传递的</p>
<p>有几个问题</p>
<p>这个构造器有什用？</p>
<p>之前没有简写的作用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308141549600.png" alt="image-20240308141549600"></p>
<p>这是注意点</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308141626702.png" alt="image-20240308141626702"></p>
<p>详细点就是</p>
<p>如果在继承的子类里面，使用构造器，但是没有接收props并且也没有通过super传递，那么this.props的值就是undefined</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308141953032.png" alt="image-20240308141953032"></p>
<p>之前说过的函数式的组件</p>
<p>因为函数所以没有this，所以使用不了state和refs，</p>
<p>但是可以使用props，因为函数是由有参数的</p>
<p>这样也是可以实现的</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
 function Person(props)&#123;
     console.log(props)
     return (
         &lt;ul&gt;
             &lt;li&gt;&#123;props.name&#125;&lt;/li&gt;
             &lt;li&gt;&#123;props.age&#125;&lt;/li&gt;
             &lt;li&gt;&#123;props.sex&#125;&lt;/li&gt;
         &lt;/ul&gt;
     )
 &#125;
  const p = &#123;name:&#39;tom&#39;,age:&#39;18&#39;&#125;
  ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p>这里的props是一个对象</p>
<p>而且还可以做一些限制</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
 function Person(props)&#123;
     console.log(props)
     return (
         &lt;ul&gt;
             &lt;li&gt;&#123;props.name&#125;&lt;/li&gt;
             &lt;li&gt;&#123;props.age&#125;&lt;/li&gt;
             &lt;li&gt;&#123;props.sex&#125;&lt;/li&gt;
         &lt;/ul&gt;
     )
 &#125;
 Person.propTypes = &#123;
     name:PropTypes.string.isRequired,
 &#125;
 Person.defaultProps = &#123;
     sex:&#39;不难不女&#39;
 &#125;
  const p = &#123;name:&#39;tom&#39;,age:&#39;18&#39;&#125;
  ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308143005798.png" alt="image-20240308143005798"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308143024636.png" alt="image-20240308143024636"></p>
<h3 id="refs和事件处理"><a href="#refs和事件处理" class="headerlink" title="refs和事件处理"></a>refs和事件处理</h3><p>简单的使用refs打节点，获取节点的dom元素，下面是字符串类型的ref</p>
<pre><code class="js">    class Demo extends React.Component &#123;
        showData = ()=&gt;&#123;
            alert(this.refs.input1.value)//z这里拿到的就是真实的dom
        &#125;
        render()&#123;
            return  (
                &lt;div&gt;
                    &lt;input ref=&quot;input1&quot; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;&amp;nbsp;
                    &lt;button ref=&quot;button1&quot; style=&#123;&#123;width:'100px'&#125;&#125; onClick=&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;/button&gt;&amp;nbsp;
                    &lt;input ref=&quot;input2&quot; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
</code></pre>
<p>可以使用解构赋值提取解构出来的dom’元素</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
    class Demo extends React.Component &#123;
        showData = ()=&gt;&#123;
            alert(this.refs.input1.value)//z这里拿到的就是真实的dom
        &#125;
        demo2 = ()=&gt;&#123;
            alert(this.refs.input2.value)
        &#125;
        render()&#123;
            return  (
                &lt;div&gt;
                    &lt;input ref=&quot;input1&quot; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;&amp;nbsp;
                    &lt;button ref=&quot;button1&quot; style=&#123;&#123;width:'100px'&#125;&#125; onClick=&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;/button&gt;&amp;nbsp;
                    &lt;input ref=&quot;input2&quot; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p>上面是ref字符串形式的，已经快被淘汰 了</p>
<p>为什么要被淘汰了呢？官网里面有答案</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308145011084.png" alt="image-20240308145011084"></p>
<p>说明白就是效率的问题</p>
<p>如果ref写多了就会出现效率问题</p>
<p>所以不推荐</p>
<p>下面是新的ref</p>
<p><strong>回调函数形式的ref createref</strong></p>
<p>这是回调的形式</p>
<pre><code class="js">    class Demo extends React.Component &#123;
        showData = ()=&gt;&#123;
            alert(this.refs.input1.value)//z这里拿到的就是真实的dom
        &#125;
        demo2 = ()=&gt;&#123;
            alert(this.refs.input2.value)
        &#125;
        render()&#123;
            return  (
                &lt;div&gt;
                    &lt;input ref=&quot;input1&quot; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;&amp;nbsp;
                    &lt;button ref=&quot;button1&quot; style=&#123;&#123;width:'100px'&#125;&#125; onClick=&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;/button&gt;&amp;nbsp;
                    &lt;input ref=&#123;(a)=&gt;&#123;
                        console.log(a)&#125;&#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
</code></pre>
<p>我们打印一下</p>
<p>发现就是我们所处的节点</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308145640245.png" alt="image-20240308145640245"></p>
<p>所以在升级一下</p>
<pre><code class="js">    class Demo extends React.Component &#123;
        showData = ()=&gt;&#123;
            alert(this.refs.input1.value)//z这里拿到的就是真实的dom
        &#125;
        demo2 = ()=&gt;&#123;
            alert(this.input2.value)
        &#125;
        render()&#123;
            return  (
                &lt;div&gt;
                    &lt;input ref=&quot;input1&quot; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;&amp;nbsp;
                    &lt;button ref=&quot;button1&quot; style=&#123;&#123;width:'100px'&#125;&#125; onClick=&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;/button&gt;&amp;nbsp;
                    &lt;input ref=&#123;(currentNode)=&gt;&#123;
                       this.input2 = currentNode&#125;&#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
</code></pre>
<p>这样我们就是实现通过回调函数的方法获取标签额实例</p>
<p><strong>这里讲解一下，这里面，因为回调函数是箭头函数，自身没有this找到了外一层，就是render，所以this就是组建的实例对象</strong></p>
<p>探讨一下ref里面的回调调用次数的问题</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
    class Demo extends React.Component &#123;
        demo2 = ()=&gt;&#123;
            alert(this.input2.value)
        &#125;
        render()&#123;
            return  (
                &lt;div&gt;
                    &lt;input ref=&#123;(currentNode)=&gt;&#123;
                       this.input2 = currentNode&#125;&#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p>这里面的</p>
<pre><code class="js">               &lt;input ref=&#123;(currentNode)=&gt;&#123;
                       this.input2 = currentNode&#125;&#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
</code></pre>
<p>执行几次呢？</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308152628767.png" alt="image-20240308152628767"></p>
<p>我们通过下面的代码可以清楚的看见能使用几次</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
    class Demo extends React.Component &#123;
        state = &#123;
            isHot:false
        &#125;
        demo1 = ()=&gt;&#123;
            this.setState(&#123;isHot:!this.state.isHot&#125;)
        &#125;
        demo2 = ()=&gt;&#123;
            alert(this.input2.value)
        &#125;
        render()&#123;
            return  (
                &lt;div&gt;
                    &lt;h1 onClick=&#123;this.demo1&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
                    &lt;input ref=&#123;(currentNode)=&gt;&#123;
                       this.input2 = currentNode
                        console.log(&#39;@&#39;,currentNode)
                    &#125;&#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p>每当我们使用更新天气的就会刷新页面，</p>
<p>这个时候我们就会发现实际上调用两次</p>
<p>第一次的调用函数的参数为0</p>
<p>第二次调用才获取的标签</p>
<p>原因在这里</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308153630656.png" alt="image-20240308153630656"></p>
<p>为了有一次清空的操作</p>
<p>React熏染到这个回调时候，先设置参数为null，清空的操作，然后网参数传递</p>
<p>然后继续</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308153926882.png" alt="image-20240308153926882"></p>
<p>看起来有点困难其实很简单，其实就是把回调函数写在类的里面</p>
<pre><code class="js">class Demo extends React.Component &#123;
    state = &#123;
        isHot:false
    &#125;
    demo1 = ()=&gt;&#123;
        this.setState(&#123;isHot:!this.state.isHot&#125;)
    &#125;
    demo2 = ()=&gt;&#123;
        alert(this.input2.value)
    &#125;
    render()&#123;
        return  (
            &lt;div&gt;
                &lt;h1 onClick=&#123;this.demo1&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
                &lt;input ref=&#123; this.saveInput &#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                &#123;/*&lt;input ref=&#123;(currentNode)=&gt;&#123;
                   this.input2 = currentNode
                    console.log(&#39;@&#39;,currentNode)
                &#125;&#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;*/&#125;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>
<p>下面写法就可以保证不执行那么多次，因为没有放在render里，而是放在类的里面</p>
<pre><code class="js">    class Demo extends React.Component &#123;
        state = &#123;
            isHot:false
        &#125;
        demo1 = ()=&gt;&#123;
            this.setState(&#123;isHot:!this.state.isHot&#125;)
        &#125;
        demo2 = ()=&gt;&#123;
            alert(this.input2.value)
        &#125;
        saveInput = (currentNode) =&gt; &#123;
            this.input2 = currentNode
            console.log(&#39;@&#39;,currentNode)
        &#125;
        render()&#123;
            return  (
                &lt;div&gt;
                    &lt;h1 onClick=&#123;this.demo1&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
                    &lt;input ref=&#123; this.saveInput &#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                    &#123;/*&lt;input ref=&#123;(currentNode)=&gt;&#123;
                       this.input2 = currentNode
                        console.log(&#39;@&#39;,currentNode)
                    &#125;&#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;*/&#125;
                &lt;/div&gt;
            )
        &#125;
    &#125;
</code></pre>
<p><strong>以后写内敛的回调函数和写内绑定的回调函数其实区别不大，影响也不大，但是内敛的写法还是偏多的</strong></p>
<p>jsx的注释</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308154038486.png" alt="image-20240308154038486"></p>
<p>其实一个快捷键解决了</p>
<p>算了快捷键也是不好用的、</p>
<p>所以还是这样的注释把</p>
<p>下面的ref的定义方法是最新的</p>
<p><strong>使用createRef的api</strong></p>
<p>​	使用createRef实现的基本操作</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
    class Demo extends React.Component &#123;
        state = &#123;
            isHot:false
        &#125;
        demo1 = ()=&gt;&#123;
            this.setState(&#123;isHot:!this.state.isHot&#125;)
        &#125;
        demo2 = ()=&gt;&#123;
            console.log(this.myRef.current)//这个属性里面保存着标签
        &#125;
/React.createRef可调用以后返回一个容器,该容器可以储存被ref标记的节点
        myRef= React.createRef()
        render()&#123;
            return  (
                &lt;div&gt;
                    &lt;h1 onClick=&#123;this.demo1&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
                    &#123;/*当执行到这里,React会把当前ref所在的节点储存在这个容器里面,这既不是回调函数了*/&#125;
                    &lt;input ref=&#123; this.myRef &#125; onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
                &lt;/div&gt;
            )
        &#125;
</code></pre>
<p>有个注意的事项</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308160709778.png" alt="image-20240308160709778"></p>
<p>这里面只能定义一个ref，否则的话后面就会把前面的挤掉</p>
<p>但是可以创建多个容器</p>
<p>像这样的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308160826935.png" alt="image-20240308160826935"></p>
<p>这种形式的ref是react官推荐的</p>
<p>总结一下</p>
<p><strong>字符串类型的ref，回调类型的ref(内联绑定，内绑定)，cretaeRef的ref</strong></p>
<p><strong>事件处理</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308161508099.png" alt="image-20240308161508099"></p>
<p>为什么React为什么要二次封装事件，</p>
<p>是为了更好的兼容性</p>
<p>其实</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308161619064.png" alt="image-20240308161619064"></p>
<p>我们给button和input添加的事件处理最后都绑在了外侧的div上</p>
<p>为什么呢？</p>
<p>因为事件委托的原理是事件冒泡</p>
<p>就比如</p>
<pre><code class="js">&lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p><strong>我们想要实现点击每个li标签就会有事件的触发，</strong></p>
<p><strong>我们可以在最外测ul上绑定事件，</strong></p>
<p><strong>因为点击li最后事件冒泡还是会到ul上触发事件</strong></p>
<p><strong>这就是事件委托，委托到最外层的事件，为了就是高效</strong></p>
<p><strong>通过event.target得到发生事件的dom元素</strong></p>
<p>之前文档说不要使用ref，不管是什么类型的</p>
<p>其实我们刚才上面的案列，都可以不适用ref</p>
<p>那怎么用？</p>
<p><strong>我们通过event.target的方法通过触发的事件获取，如下</strong></p>
<pre><code class="js">class Demo extends React.Component &#123;
    state = &#123;
        isHot:false
    &#125;
    demo1 = ()=&gt;&#123;
        this.setState(&#123;isHot:!this.state.isHot&#125;)
    &#125;
    demo2 = (event)=&gt;&#123;
        console.log(event.target)//这个属性里面保存着标签
    &#125;
    //React.createRef可调用以后返回一个容器,该容器可以储存被ref标记的节点
    myRef= React.createRef()
    render()&#123;
        return  (
            &lt;div&gt;
                &lt;h1 onClick=&#123;this.demo1&#125;&gt;今天的天气很&#123;this.state.isHot?&#39;炎热&#39;:&quot;凉爽&quot;&#125;&lt;/h1&gt;
                &#123;/*当执行到这里,React会把当前ref所在的节点储存在这个容器里面,这既不是回调函数了*/&#125;
                &lt;input  onBlur=&#123;this.demo2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示&quot;/&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>
<p><strong>通过event.target可以获取到触发事件的dom元素</strong></p>
<p><strong>总的来说ref尽量能避免就避免</strong></p>
<h2 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h2><p>这里就有两个概念</p>
<p>1.非受控组件</p>
<p>2.受控组件</p>
<p>先说非受控组件</p>
<p>​	</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;!--引入proto-types,用于类型标签属性值的限制--&gt;
&lt;script src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
  class Demo extends React.Component &#123;
    handleForm = (event)=&gt;&#123;
      event.preventDefault()//阻止页面的默认事件
      alert(&#39;您的用户名为&#39;+this.username.value+&#39;您的密码为&#39;+this.password.value)
    &#125;
    render()&#123;
      return  (
              &lt;div&gt;
                &lt;form action=&quot;https://www.baidu.com&quot; onSubmit=&#123;this.handleForm&#125;&gt;
                  用户名 &lt;input ref=&#123;c=&gt;this.username = c&#125; type=&quot;text&quot; placeholder=&quot;请输入账号&quot; name=&quot;username&quot;/&gt;&amp;nbsp;
                  密码 &lt;input ref=&#123;c=&gt;this.password = c&#125; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; name=&quot;password&quot;/&gt;&amp;nbsp;
                  &lt;button &gt;登录&lt;/button&gt;
                &lt;/form&gt;
              &lt;/div&gt;
      )
    &#125;
  &#125;
  ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>上面的代码</p>
<p>当我们输入用户名和密码，再点击提交的时候，</p>
<p>然后调用回调函数，就会分别去取我们节点的属性值username和password</p>
<p><strong>像这样我们现用先现取的标签的值，我们就称其为非受控组件</strong></p>
<p>这里暂停一下</p>
<p>这里感觉vue里面的v-model真是方便，双向绑定数据</p>
<p><strong>那受控组件该怎么写呢?</strong></p>
<p>下面就是受控组件的实列</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;!--引入proto-types,用于类型标签属性值的限制--&gt;
&lt;script src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
  class Demo extends React.Component &#123;
    state=&#123;
      username:&quot;&quot;,
      password:&quot;&quot;//在这里我们可以初始化值
    &#125;
    demo = (event)=&gt;&#123;
      //只要改变就会调用
      console.log(event.target.value)
      this.setState(&#123;username:event.target.value&#125;)//只要我们该表就会更改state的状态值
    &#125;
    demo2 = (event)=&gt;&#123;
      //只要改变就会调用
      console.log(event.target.value)
      this.setState(&#123;password:event.target.value&#125;)//只要我们该表就会更改state的状态值
    &#125;
    handleForm = (event)=&gt;&#123;
      event.preventDefault()//阻止页面的默认事件
      alert(&#39;您的用户名为&#39;+this.state.username+&#39;您的密码为&#39;+this.state.password)
    &#125;
    render()&#123;
      return  (
              &lt;div&gt;
                &lt;form action=&quot;https://www.baidu.com&quot; onSubmit=&#123;this.handleForm&#125;&gt;
                  用户名 &lt;input onChange=&#123;this.demo&#125; type=&quot;text&quot; placeholder=&quot;请输入账号&quot; name=&quot;username&quot;/&gt;&amp;nbsp;
                  密码 &lt;input onChange=&#123;this.demo2&#125; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; name=&quot;password&quot;/&gt;&amp;nbsp;
                  &lt;button &gt;登录&lt;/button&gt;
                &lt;/form&gt;
              &lt;/div&gt;
      )
    &#125;
  &#125;
  ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>当我们输入框的内容发生了就会调用回调</p>
<p>通过回调我们可以实时的将数据通过setState更新到state里面</p>
<p>就相当于vue里的双向绑定</p>
<p>受控组件还有一个优势就是减少了ref的使用</p>
<p>非受控组件刚才的例子一直在使用ref收取表单的数据</p>
<h3 id="组件的声明周期"><a href="#组件的声明周期" class="headerlink" title="组件的声明周期"></a>组件的声明周期</h3><p><strong>高阶函数和函数的柯里化</strong></p>
<p>如果我们继续上面的例子</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308173823123.png" alt="image-20240308173823123"></p>
<p>如果有很多项怎么办?</p>
<p>那么可以通过参数进行界定</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308174015960.png" alt="image-20240308174015960"></p>
<p>但是上面这样的写写法是不对的因为后面有小括号,这样获取的是返回值</p>
<p>所以我们我们可以把返回值定义成一个函数</p>
<p>补充点对象相关的知识</p>
<pre><code class="js">let a = &#39;name&#39;
let obj = &#123;&#125;
obj[a]=&#39;tom&#39;//&#123;name:&#39;tom&#39;&#125;
</code></pre>
<p>所以我们可以写成这样</p>
<pre><code class="js">  class Demo extends React.Component &#123;
    state=&#123;
      username:&quot;&quot;,
      password:&quot;&quot;//在这里我们可以初始化值
    &#125;
    demo = (data)=&gt;&#123;
      console.log(data)
      return (event)=&gt;&#123;
        console.log([data],event.target.value)

      &#125;
    &#125;
    // handleForm = (event)=&gt;&#123;
    //   event.preventDefault()//阻止页面的默认事件
    //   alert(&#39;您的用户名为&#39;+this.state.username+&#39;您的密码为&#39;+this.state.password)
    // &#125;
    render()&#123;
      return  (
              &lt;div&gt;
                &lt;form action=&quot;https://www.baidu.com&quot; onSubmit=&#123;this.handleForm&#125;&gt;
                  用户名 &lt;input onChange=&#123;this.demo(&#39;username&#39;)&#125; type=&quot;text&quot; placeholder=&quot;请输入账号&quot; name=&quot;username&quot;/&gt;&amp;nbsp;
                  密码 &lt;input onChange=&#123;this.demo(&#39;password&#39;)&#125; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; name=&quot;password&quot;/&gt;&amp;nbsp;
                  &lt;button &gt;登录&lt;/button&gt;
                &lt;/form&gt;
              &lt;/div&gt;
      )
    &#125;
  &#125;
</code></pre>
<p>这时候物品们就可以引入高阶函数的定义了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308180409931.png" alt="image-20240308180409931"></p>
<p>常见的高阶函数有:promise,settimeout,因为这两个的参数 函数</p>
<p><strong>函数的柯里化</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308180807412.png" alt="image-20240308180807412"></p>
<p>简单的例子</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240308180929289.png" alt="image-20240308180929289"></p>
<p>其实不用函数柯比化也能实现上面的代码</p>
<pre><code class="js">  class Demo extends React.Component &#123;
    state=&#123;
      username:&quot;&quot;,
      password:&quot;&quot;//在这里我们可以初始化值
    &#125;
    demo = (data)=&gt;&#123;
      console.log(data)
      return (event)=&gt;&#123;
        console.log([data],event.target.value)

      &#125;
    &#125;
    // handleForm = (event)=&gt;&#123;
    //   event.preventDefault()//阻止页面的默认事件
    //   alert(&#39;您的用户名为&#39;+this.state.username+&#39;您的密码为&#39;+this.state.password)
    // &#125;
    render()&#123;
      return  (
              &lt;div&gt;
                &lt;form action=&quot;https://www.baidu.com&quot; onSubmit=&#123;this.handleForm&#125;&gt;
                  用户名 &lt;input onChange=&#123;this.demo(&#39;username&#39;)&#125; type=&quot;text&quot; placeholder=&quot;请输入账号&quot; name=&quot;username&quot;/&gt;&amp;nbsp;
                  密码 &lt;input onChange=&#123;this.demo(&#39;password&#39;)&#125; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; name=&quot;password&quot;/&gt;&amp;nbsp;
                  &lt;button &gt;登录&lt;/button&gt;
                &lt;/form&gt;
              &lt;/div&gt;
      )
    &#125;
  &#125;
</code></pre>
<p>上面使用函数的科比话</p>
<p>不用函数的柯比化接收到参数</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
  class Demo extends React.Component &#123;
    state=&#123;
      username:&quot;&quot;,
      password:&quot;&quot;//在这里我们可以初始化值
    &#125;
    demo = (data,value)=&gt;&#123;
      this.setState(&#123;[data]:value&#125;)
    &#125;
    handleForm = (event)=&gt;&#123;
      event.preventDefault()//阻止页面的默认事件
      alert(&#39;您的用户名为&#39;+this.state.username+&#39;您的密码为&#39;+this.state.password)
    &#125;
    render()&#123;
      return  (
              &lt;div&gt;
                &lt;form action=&quot;https://www.baidu.com&quot; onSubmit=&#123;this.handleForm&#125;&gt;
                  用户名 &lt;input onChange=&#123;(event)=&gt;&#123;this.demo(&#39;username&#39;,event.target.value)&#125;&#125; type=&quot;text&quot; placeholder=&quot;请输入账号&quot; name=&quot;username&quot;/&gt;&amp;nbsp;
                  密码 &lt;input onChange=&#123;(event)=&gt;&#123;this.demo(&#39;password&#39;,event.target.value)&#125;&#125; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; name=&quot;password&quot;/&gt;&amp;nbsp;
                  &lt;button &gt;登录&lt;/button&gt;
                &lt;/form&gt;
              &lt;/div&gt;
      )
    &#125;
  &#125;
  ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
</code></pre>
<p>这样我们就可以实现</p>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>首先组建的卸载</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;!--引入proto-types,用于类型标签属性值的限制--&gt;
&lt;script src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Life extends React.Component&#123;
        death=()=&gt;&#123;
          ReactDOM.unmountComponentAtNode(document.getElementById(&#39;test&#39;))
        &#125;
        render()&#123;
            return (
                &lt;div&gt;
                    &lt;h2&gt;React学不会怎么办&lt;/h2&gt;
                    &lt;button onClick=&#123;this.death&#125;&gt;不活了&lt;/button&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;Life/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>使用unmountComponentAtNode可以使某个组件卸载</p>
<p>组件挂载的声明周期钩子</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;!--引入proto-types,用于类型标签属性值的限制--&gt;
&lt;script src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Life extends React.Component&#123;
        state=&#123;
            opacity:0.5
        &#125;

        death=()=&gt;&#123;
            ReactDOM.unmountComponentAtNode(document.getElementById(&#39;test&#39;))
        &#125;
        componentDidMount()&#123;// 这里的构造只调用一次,和render函数一样,组件实例化以后,REact会自己帮你调用
            setInterval(()=&gt;&#123;
                let &#123;opacity&#125; = this.state
                opacity -= 0.1
                if (opacity&lt;=0) opacity = 1
                this.setState(&#123;opacity:opacity&#125;)
            &#125;,200)
        &#125;
        render()&#123;
            return (
                &lt;div&gt;
                    &lt;h2 style=&#123;&#123;opacity:this.state.opacity&#125;&#125;&gt;React学不会怎么办&lt;/h2&gt;
                    &lt;button onClick=&#123;this.death&#125;&gt;不活了&lt;/button&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;Life/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>只在组件完成挂载以后开始执行 </p>
<p>componentDidMount:组件挂载完毕调用</p>
<p>render:初始化渲染,数据更新以后</p>
<p>但是在卸载组件的时候上面的代码会出问题,</p>
<p>因为在卸载组件之前没有把定时器卸载掉</p>
<p>所以修改完以后</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;!--引入proto-types,用于类型标签属性值的限制--&gt;
&lt;script src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Life extends React.Component&#123;
        state=&#123;
            opacity:0.5
        &#125;

        death=()=&gt;&#123;
            clearInterval(this.timer)
            ReactDOM.unmountComponentAtNode(document.getElementById(&#39;test&#39;))
        &#125;
        componentDidMount()&#123;// 这里的构造只调用一次,和render函数一样,组件实例化以后,REact会自己帮你调用
            this.timer=setInterval(()=&gt;&#123;
                let &#123;opacity&#125; = this.state
                opacity -= 0.1
                if (opacity&lt;=0) opacity = 1
                this.setState(&#123;opacity:opacity&#125;)
            &#125;,200)
        &#125;
        render()&#123;
            return (
                &lt;div&gt;
                    &lt;h2 style=&#123;&#123;opacity:this.state.opacity&#125;&#125;&gt;React学不会怎么办&lt;/h2&gt;
                    &lt;button onClick=&#123;this.death&#125;&gt;不活了&lt;/button&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;Life/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>其实还可以写在组件将要写在卸载还没有卸载的时候</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

&lt;!--引入react的核心库--&gt;
&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入react-dom--&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;!--引入babel，将jsx转为js
注意顺序不能搞错--&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;!--引入proto-types,用于类型标签属性值的限制--&gt;
&lt;script src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
    class Life extends React.Component&#123;
        state=&#123;
            opacity:0.5
        &#125;

        death=()=&gt;&#123;

            ReactDOM.unmountComponentAtNode(document.getElementById(&#39;test&#39;))
        &#125;
        componentDidMount()&#123;// 这里的构造只调用一次,和render函数一样,组件实例化以后,REact会自己帮你调用
            this.timer=setInterval(()=&gt;&#123;
                let &#123;opacity&#125; = this.state
                opacity -= 0.1
                if (opacity&lt;=0) opacity = 1
                this.setState(&#123;opacity:opacity&#125;)
            &#125;,200)
        &#125;
        componentWillUnmount()&#123;
            clearInterval(this.timer)
        &#125;
        render()&#123;
            return (
                &lt;div&gt;
                    &lt;h2 style=&#123;&#123;opacity:this.state.opacity&#125;&#125;&gt;React学不会怎么办&lt;/h2&gt;
                    &lt;button onClick=&#123;this.death&#125;&gt;不活了&lt;/button&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;Life/&gt;,document.getElementById(&#39;test&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>使用componentWillUnmount这个钩子在快要卸载的时候调用</p>
<p><strong>React的生命周期</strong></p>
<p>&#x2F;<img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F(%E6%97%A7).png" alt="react生命周期(旧)"></p>
<p>其实render也是一个生命周期钩子函数，上面的 生命周期是旧版本的</p>
<p>先测试左边的的钩子</p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
    class Count extends React.Component&#123;
        constructor(props) &#123;
            super(props);
            console.log(&#39;Count-constructor&#39;)
            this.state=&#123;
                count:0,
            &#125;
        &#125;
        //组建的将要挂载,在render的前面
        componentWillMount()&#123;
            console.log(&#39;Count-componentWillMount&#39;)
        &#125;
        render()&#123;
            console.log(&#39;Count-render&#39;)
            const &#123;count&#125; = this.state
            return (
                &lt;div&gt;
                    &lt;h2&gt;当前求和为:&#123;count&#125;&lt;/h2&gt;
                    &lt;button onClick=&#123;this.add&#125;&gt;当前求和为:&lt;/button&gt;
                &lt;/div&gt;
            )
        &#125;
        //组件已经挂载完毕，已经通过render渲染在页面上了
        componentDidMount()&#123;
            console.log(&#39;Count-componentDidMount&#39;)
        &#125;
        add = ()=&gt;&#123;
            const &#123;count&#125; = this.state
            this.setState(&#123;count:count+1&#125;)
        &#125;
    &#125;
    ReactDOM.render(&lt;Count/&gt;,document.getElementById(&#39;test&#39;))
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309093729432.png" alt="image-20240309093729432"></p>
<p>上面的顺序已经验证了</p>
<p>组件的卸载生命周期钩子</p>
<pre><code class="js">            ReactDOM.unmountComponentAtNode(&#39;test&#39;)
</code></pre>
<p>调用这个以后就会卸载组件</p>
<p>然后就会调用</p>
<pre><code class="js">        componentWillUnmount()&#123;
            console.log(&#39;Conut-componentWillUnmount&#39;)
        &#125;
</code></pre>
<p>这个生命周期</p>
<p>然后再讲讲更新的钩子</p>
<p>主要有三个流程</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309094242736.png" alt="ie-20240309094242736"></p>
<p>先说一下2这条线</p>
<p>调用setState以后</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309094628518.png" alt="image-20240309094628518"></p>
<p>讲一下这个钩子</p>
<p><strong>当我们使用setState更改状态以后，就会调用上面的钩子，这个如果没有写就会默认帮你调用。</strong></p>
<p><strong>返回值使boolen类型的，如果钩子返回的是true，那么后面的更新的钩子 都可以走下去，</strong></p>
<p><strong>如果false，更新的操作就会停在这里了，不写默认返回真</strong></p>
<pre><code class="js">        shouldComponentUpdate()&#123;
            console.log(&#39;Count-shouldComponentUpdate&#39;)
            return true
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309095036994.png" alt="image-20240309095036994"></p>
<p>如果是false</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309095108314.png" alt="image-20240309095108314"></p>
<p>render不会调用，</p>
<p><strong>简单地的就是控制组件更新的阀门</strong></p>
<p>然后是</p>
<p>组件将要更新</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309095237631.png" alt="image-20240309095237631"></p>
<pre><code class="js">        //这一步在render的前面，实在更新的之前
        componentWillUpdate()&#123;
            console.log(&#39;Cout-componentWillUpdate&#39;)
        &#125;
</code></pre>
<p>然后是</p>
<p>组件更新完毕的钩子</p>
<pre><code class="js">        //组件更新完成以后，render的后面
        componentDidUpdate()&#123;
            console.log(&#39;Cout-componentDidUpdate&#39;)
        &#125;
</code></pre>
<p>执行的效果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309095603118.png" alt="image-20240309095603118"></p>
<p>然后我们在看这条线</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309100705256.png" alt="image-20240309100705256"></p>
<p>调用forceUpdate的</p>
<p>这个是强制更新，不对 状态里面的数据进行更改，也能更新，这个流程会绕过阀门shouldcomponentupdate</p>
<p>当我们调用</p>
<pre><code class="js">        //轻质更新
        force=()=&gt;&#123;
            this.forceUpdate()
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309101111562.png" alt="image-20240309101111562"></p>
<p>不受阀门的控制</p>
<p>接下来第一条线</p>
<p>这一条线需要父子关系</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309101857230.png" alt="image-20240309101857230"></p>
<p>当我们父组件执行render以后，子组件就会响应componentWillReceiveProps,子组件将要接到props</p>
<p>这个钩子当我们传递数据给子组件，子组件里面就会调用这个钩子</p>
<p>如下</p>
<pre><code class="js">    class A extends React.Component&#123;
        state=&#123;
            carName:&#39;奔驰&#39;
        &#125;
        changeCar=()=&gt;&#123;
            this.setState(&#123;carName:&#39;奥托&#39;&#125;)
        &#125;
        render()&#123;
            return(
                &lt;div&gt;
                    &lt;div&gt;A组件&lt;/div&gt;
                    &lt;button onClick=&#123;this.changeCar&#125;&gt;换车&lt;/button&gt;
                    &lt;B carName=&#123;this.state.carName&#125;&gt;&lt;/B&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    class B extends React.Component&#123;
        componentWillReceiveProps()&#123;
            console.log(&#39;B-componentWillReceiveProps&#39;)
        &#125;
        render()&#123;
            return(
                &lt;div&gt;
                    &lt;p&gt;B组件，接收到&#123;this.props.carName&#125;&lt;/p&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;A/&gt;,document.getElementById(&#39;test&#39;))
</code></pre>
<p>但是这个componentWillReceiveProps有个弊端就是第一次传递props就不会调用。</p>
<p>什么意思呢？</p>
<p><strong>就是上面我们初始的时候就给B组件把state里面的carName传递过去，b组件显示了，数据已经通过props传过去但是却没有调用</strong></p>
<p><strong>componentWillReceiveProps，只有更新state里的state里的carName以后才会调用</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309103003362.png" alt="image-20240309103003362"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309103115494.png" alt="image-20240309103115494"></p>
<p>常用的钩子</p>
<p>**componentDidMount()**常用于做一些初始化的东西，例如开启定时器，发送网络请求，订阅消息</p>
<p>**componentWillUnmount()**一般做收尾的东西，例如关闭定时器</p>
<p>上面是旧版的生命周期</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F(%E6%96%B0).png" alt="react生命周期(新)"></p>
<p>有些生命周期已经改名了但是还可以使用</p>
<p>不过会有报错</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309104918803.png" alt="image-20240309104918803"></p>
<p>但是在18版本必须写改名以后的</p>
<p>我们把名字改下，新版本下面三个需要加上前缀</p>
<pre><code class="js">UNSAFE_componentWillMount()&#123;
    console.log(&#39;Count-componentWillMount&#39;)
&#125;
UNSAFE_componentWillUpdate()&#123;
    console.log(&#39;Cout-componentWillUpdate&#39;)
&#125;
UNSAFE_componentWillReceiveProps()&#123;
    console.log(&#39;B-componentWillReceiveProps&#39;)
&#125;
</code></pre>
<p>这样就可以</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309105212538.png" alt="image-20240309105212538"></p>
<p>所有的带will的除了<strong>componentWillUnmount</strong>都得加上<strong>UNSAFE</strong></p>
<p>为什么要这样呢？</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309105619178.png" alt="image-20240309105619178"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309105627220.png" alt="image-20240309105627220"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309105720027.png" alt="image-20240309105720027"></p>
<p>这几个钩子，经常被人滥用，这几个钩子经常不用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309105902373.png" alt="image-20240309105902373"></p>
<p>除了这个区别还有别的吗？</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309110039854.png" alt="image-20240309110039854"></p>
<p>对吧旧版本没有经过UNSAFE_componentWillUpdate，UNSAFE_componentWillMount，但是还是会掉用</p>
<p>用上图的一个新的钩子替代了他们</p>
<p>更新的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309110319172.png" alt="image-20240309110319172"></p>
<p>注意更新渲染以后有新增一个钩子</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309110405193.png" alt="image-20240309110405193"></p>
<p>getSnapshotBeforeUpdate</p>
<p>相比之下</p>
<p>新版本的钩子</p>
<hr>
<p><strong>将要废弃了三个钩子分别为UNSAFE_componentWillMount，UNSAFE_componentWillUpdate，UNSAFE_componentWillReceiveProps，注意是将要，新增getSnapshotBeforeUpdate，getDerivedStateFormProps</strong></p>
<p><strong>getDerivedStateFromProps</strong></p>
<p>不能定义给是使用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309111212958.png" alt="image-20240309111212958"></p>
<p>需要static</p>
<p>还是不行</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309111307893.png" alt="image-20240309111307893"></p>
<p>需要返回null或者状态的那个对象</p>
<p>返回null对功能没有影响</p>
<p>如果返回状态对象的话</p>
<pre><code class="js">constructor(props) &#123;
    super(props);
    console.log(&#39;Count-constructor&#39;)
    this.state=&#123;
        count:0,
    &#125;
&#125;
//构造器以后
static getDerivedStateFromProps()&#123;
    console.log(&#39;getDerivedStateFromProps&#39;)
    return &#123;count:100,&#125;
&#125;
</code></pre>
<p>这样更新state就会影响了，以后用于改不了，其他的不受影响</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309111535487.png" alt="image-20240309111535487"></p>
<p>而且这里的还能接收到props</p>
<p>这就能解释他的名字了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309111705341.png" alt="image-20240309111705341"></p>
<pre><code class="js">&lt;script type=&quot;text/babel&quot;&gt;
    class Count extends React.Component&#123;
        constructor(props) &#123;
            super(props);
            console.log(&#39;Count-constructor&#39;)
            this.state=&#123;
                count:0,
            &#125;
        &#125;
        //构造器以后
        static getDerivedStateFromProps(props)&#123;
            console.log(&#39;getDerivedStateFromProps=&gt;&#39;+ props)
            return props
        &#125;
        render()&#123;
            console.log(&#39;Count-render&#39;)
            const &#123;count&#125; = this.state
            return (
                &lt;div&gt;
                    &lt;h2&gt;当前求和为:&#123;count&#125;&lt;/h2&gt;
                    &lt;button onClick=&#123;this.add&#125;&gt;当前求和为:&lt;/button&gt;
                    &lt;button onClick=&#123;this.death&#125;&gt;卸载组件&lt;/button&gt;
                    &lt;button onClick=&#123;this.force&#125;&gt;不更改任何状态中的数据，强制更新&lt;/button&gt;
                &lt;/div&gt;
            )
        &#125;
        //组件已经挂载完毕，已经通过render渲染在页面上了
        componentDidMount()&#123;
            console.log(&#39;Count-componentDidMount&#39;)
        &#125;
        //组件卸载前调用这个函数
        componentWillUnmount()&#123;
            console.log(&#39;Conut-componentWillUnmount&#39;)
        &#125;
        shouldComponentUpdate()&#123;
            console.log(&#39;Count-shouldComponentUpdate&#39;)
            return true
        &#125;
        //组件更新完成以后，rnder的后面
        componentDidUpdate()&#123;
            console.log(&#39;Cout-componentDidUpdate&#39;)
        &#125;
        add = ()=&gt;&#123;
            const &#123;count&#125; = this.state
            this.setState(&#123;count:count+1&#125;)
        &#125;
        death = ()=&gt;&#123;
            ReactDOM.unmountComponentAtNode(&#39;test&#39;)
        &#125;
        //轻质更新
        force=()=&gt;&#123;
            this.forceUpdate()
        &#125;
    &#125;
    ReactDOM.render(&lt;Count age=&#39;100&#39;/&gt;,document.getElementById(&#39;test&#39;))
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309111831207.png" alt="image-20240309111831207"></p>
<p><strong>这样就实现了</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309111923036.png" alt="image-20240309111923036"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309111941448.png" alt="image-20240309111941448"></p>
<p>还有一个参数state</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240309112012045.png" alt="image-20240309112012045"></p>
<p><strong>getSnapshotBeforeUpdate</strong></p>
<pre><code class="js">getSnapshotBeforeUpdate()&#123;
    console.log(&#39;getSnapshotBeforeUpdate&#39;)
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310083727159.png" alt="image-20240310083727159"></p>
<p>如果不返回值就会报错</p>
<p>提示说快照值或者 一个null值</p>
<p>这个快照之可以是任意的值 </p>
<p>但是这里的返回值去哪里了？<br>先说一下componentDidupdate</p>
<p>这里的参数</p>
<pre><code class="js">        componentDidUpdate(preProps,preState)&#123;
            console.log(&#39;Cout-componentDidUpdate&#39;,preProps,preState)
        &#125;
</code></pre>
<p>这里的参数分别为，</p>
<p>传过来的props和上一次的的state，注意不是最新的</p>
<p>接着上面的话题</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310084437340.png" alt="image-20240310084437340"></p>
<p>所以它有三个参数</p>
<pre><code class="js">componentDidUpdate(preProps,preState,snapshotValue)&#123;
    console.log(&#39;Cout-componentDidUpdate&#39;,preProps,preState,snapshotValue)
&#125;
</code></pre>
<p>那这个有什么用呢？</p>
<p><strong>为了记录之前的数据，加入之前有10个人，更新以后有11个人，如果逆向获取之前的10个人的数据，我们就可以使用快照记录下之前的数据</strong></p>
<p>作用就是</p>
<p><strong>在更新的时候获取快照</strong></p>
<p>新版生命周期的总结</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310085826926.png" alt="image-20240310085826926"></p>
<h2 id="Dom的diffing算法"><a href="#Dom的diffing算法" class="headerlink" title="Dom的diffing算法"></a>Dom的diffing算法</h2><p>验证React的diffing的算法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310090136662.png" alt="image-20240310090136662"></p>
<p>每个一秒更细state的数据</p>
<p>因为模板里面的h1和input没有发生改变，但是span的发生变化，所以其他的渲染一次，但是span里面一直在熏染</p>
<p>如果里面的span还有input的话，里面的input不会更新熏染</p>
<p>这里重新复习一下vue和react的key的作用原理</p>
<p>这个代码</p>
<pre><code class="js">    class Person extends React.Component &#123;
        state=&#123;
            persons:[
                &#123;id:1,name:&quot;黎明&quot;&#125;,
                &#123;id:2,name:&quot;小白&quot;&#125;,
                &#123;id:3,name:&quot;小黑&quot;&#125;,
                &#123;id:4,name:&#39;小红&#39;&#125;,
            ]
        &#125;
        addPerson = ()=&gt;&#123;
            const &#123;persons&#125; = this.state
            const p = &#123;id:persons.length+1,name:&quot;小王&quot;&#125;
            this.setState(&#123;persons:[p,...persons]&#125;)
        &#125;
        render()&#123;
            return (
                &lt;div&gt;
                    &lt;h2&gt;展示人员信息&lt;/h2&gt;
                    &lt;button onClick=&#123;this.addPerson&#125;&gt;添加一个小王&lt;/button&gt;
                    &lt;ul&gt;
                        &#123;
                            this.state.persons.map((item,index)=&gt;&lt;li key=&quot;index&quot;&gt;&#123;item.name&#125;&lt;/li&gt;)
                        &#125;
                    &lt;/ul&gt;
                &lt;/div&gt;
            )
        &#125;
    &#125;
    ReactDOM.render(&lt;Person&gt;&lt;/Person&gt;,document.getElementById(&#39;test&#39;))
</code></pre>
<p>上面的代码存在严重的效率问题</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310091527249.png" alt="image-20240310091527249"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310091616022.png" alt="image-20240310091616022"></p>
<p><strong>新的虚拟DOM生新的虚拟DOM，然后和旧的虚拟DOM进行比较，然后比较玩以后在生成新的虚拟DOM，记住对比的是虚拟dom</strong></p>
<p>比较过程是这样的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310091847370.png" alt="image-20240310091847370"></p>
<p>我们根据上面的例子看一下</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310093424684.png" alt="image-20240310093424684"></p>
<p><strong>根据diffing算法，先取和旧的虚拟DOM相同的，首先是0 ，但是数据发生改变了，所以需要重新更新dom，接下去的一样，但是我们只是更新了一条数据，所以上面的代码有效率问题，如果上面的小王是往后面的放就不会出现这个问题</strong></p>
<p>如果我们有2000条数据，但是我们只更新一条，还是往前面加，这样我们的2001数据都得更新，</p>
<p>所以我们换个值当最索引值做key，我们就可以拿数据里面的id当作id</p>
<p>上面的问题，当我们的出现大佬输入的节点就会更严重</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310094215984.png" alt="image-20240310094215984"></p>
<p>这样的而原因就是因为</p>
<p><strong>当小王插入以后，key为0，小张的变为1，之前的小张为0 ，里面的输入框因为前后的diffing对比以后没有发生改变，所以input框不会更新还会再原来的位置</strong></p>
<p>如果上面是往后面的加，就不会造成上面的问题</p>
<p>总结</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310094918754.png" alt="image-20240310094918754"></p>
<p>如何避免呢？</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310095020295.png" alt="image-20240310095020295"></p>
<h2 id="初始化React脚手架"><a href="#初始化React脚手架" class="headerlink" title="初始化React脚手架"></a>初始化React<strong>脚手架</strong></h2><p>作用:快速安全的编写基于某种技术</p>
<p>使用webpack搭建的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240310095419651.png" alt="image-20240310095419651"></p>
<p>创建的过程</p>
<p>1.首先安装库，我使用的pnpm</p>
<pre><code class="bash">pnpm i -g create-react-app
</code></pre>
<p>2.然后创建脚手架项目</p>
<pre><code class="bash">create-react-app hello_react
</code></pre>
<p>然后就创建完成了</p>
<pre><code>补充一点知识，做移动端的app
Android 一般使用java
IOS 一般使用oc swift
</code></pre>
<p><strong>加壳技术就是在把pc端的网页加个壳，就会有apk的文件，就可以安在手机上，其实不是一个应用，只是一个壳，当用户点击是就是打开一个壳，壳里面里面内嵌一个网页，这就是应用加壳技术，一般小型软件可以</strong></p>
<p>再说一下noscript的标签</p>
<p>当浏览器不支持js就会显示里面的内容</p>
<p>robots的文件，规定哪些可以爬取，哪些不可以爬取</p>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 哈哈哈哈哈哈哈重生之我是兵王
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;chenw
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
