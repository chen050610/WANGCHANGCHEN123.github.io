
<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8" />
    <title>Java | 哈哈哈哈哈哈哈重生之我是兵王</title>
    <meta name="author" content="chenw" />
    <meta name="description" content="description" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
	<canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
	<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
	<script src="/js/fireworks.min.js"></script>
	<canvas id="background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
	<script src="/js/background.min.js"></script>
	<div id="cursor"></div>
	<link rel="stylesheet" href="/css/cursor.min.css">
	<script src="/js/cursor.min.js"></script>
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>哈哈哈哈哈哈哈重生之我是兵王</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;哈哈哈哈哈哈哈重生之我是兵王</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>Java</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/5
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/Java/" style="color: #00a596">Java</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p>摘要</p>
<span id="more"></span>

<p>内容</p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>跨平台是java语言的趋势</p>
<p>java还是主流的编程语言</p>
<p>Java的各个版本</p>
<p>1.JavaSE：标准版，定位在个人计算机的应用，</p>
<p>2.JavaEE:企业版，定位在服务器</p>
<p>3.JavaME：微型版</p>
<p><strong>Java的运行机制</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322205212089.png" alt="image-20240322205212089"></p>
<p>Java既是编译型语言，又是解释性</p>
<p>例如 python就是解释性语言，直接通过python的解释器直接去运行</p>
<p><strong>什么是JVM？</strong></p>
<p>用于执行字节码虚拟计算机，跨平台的差异就是通过JVM</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322205502948.png" alt="image-20240322205502948"></p>
<p>java提供不同平台的虚拟机</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322205534797.png" alt="image-20240322205534797"></p>
<p><strong>开发人员我们一般使用JDK，因为我们需要编译和运行</strong></p>
<p><strong>一般java的游戏，就直接运行，只下载JRE就可以了</strong></p>
<p>创建的Java项目写在</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322213121539.png" alt="image-20240322213121539"></p>
<p>简单的Java代码</p>
<pre><code class="Java">public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
    &#125;
&#125;
</code></pre>
<p>在运行的时候，会自动帮你进行编译</p>
<p><strong>生成的java的编译的以后的文件在</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322213530098.png" alt="image-20240322213530098"></p>
<p>Java的基础语法</p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li><p>主函数 &amp;  程序的入口</p>
</li>
<li><p>文件名</p>
<pre><code>一个文件中只能有一个public的类，并且文件名必须和public的类名保持一致
如果文件中有多个类，文件名与public的类名保持一致
如果文件中有多个类 且无public类，文件名抗日一是任意的类
</code></pre>
</li>
<li><p>类名 首字母大写，驼峰的命名</p>
</li>
<li><p>类修饰符  public,default</p>
</li>
<li><p>类中的成员修饰符：public,private,protected,default</p>
</li>
<li><p>静态成员：无需实例化就可以直接调用</p>
<pre><code class="java">class Person  &#123;
    public static void  f1()&#123;
        //static静态的方法，无需实例就可以调用，也就只可以类调用
        System.out.println(&quot;111&quot;);
    &#125;
&#125;

public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
        Person.f1();//111
    &#125;
&#125;
</code></pre>
<ul>
<li><p>实例方法：需要实例以后在调用</p>
<pre><code class="java">class Person  &#123;
    public  void  f1()&#123;
        System.out.println(&quot;111&quot;);
    &#125;
&#125;

public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
        Person person = new Person();//实例对象的写法是这样的
        person.f1();//对象调用
    &#125;
&#125; 
</code></pre>
</li>
</ul>
</li>
<li><p>void代表方法没有返回值</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
        Person person = new Person();//实例对象的写法是这样的
        person.f1();//对象调用
    &#125;
</code></pre>
</li>
<li><p>参数,需要限制类型</p>
<pre><code>class Person  &#123;
    public  void  f1(string a , int b)&#123;
        System.out.println(&quot;111&quot;);
    &#125;
&#125;

public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;你好&quot;);
        Person person = new Person();//实例对象的写法是这样的
        person.f1(&#39;aaaa&#39;,123);//对象调用
    &#125;
&#125; 
</code></pre>
<p><strong>注释</strong></p>
<pre><code>//单行注释
/*
多行注释
*/
</code></pre>
</li>
</ul>
<p><strong>变量和常量</strong></p>
<pre><code>final相当于js里的const
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
    System.out.println(&quot;你好&quot;);
    String name = &quot;name&quot;;
    int number = 5;
    int a ;
    a= 18;
    //常量
    final int size = 18;
&#125;
</code></pre>
<p>不像js的动态语言，我们需要对数据的类型做出限制</p>
<p><strong>输入和输出</strong></p>
<p>输入需要外部的包，</p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        //引入的Scanner相当于一个类，System.in感觉时使用系统命令获取输入
        Scanner input  = new Scanner(System.in);
        String text  =  input.nextLine();
        //输出
        System.out.println(text);
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240322220405957.png" alt="image-20240322220405957"></p>
<p>输出语句的不同</p>
<pre><code class="java">        //输出
        System.out.println(text);//输出最后会带换行
        System.out.print(text);//输出最后不带换行
</code></pre>
<p><strong>条件语句</strong></p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        System.out.print(&quot;&quot;);
        int age  = 19 ;
        if (age &lt; 18)&#123;
            System.out.println(&quot;少年&quot;);
        &#125; else if (age&gt;= 18 &amp;&amp; age &lt; 24)&#123;
            System.out.println(&quot;青年&quot;);
        &#125; else &#123;
            System.out.println(&quot;老年&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>switch case语句</strong></p>
<pre><code class="java">        System.out.print(&quot;&quot;);
        int age  = 19 ;
        switch (age)&#123;
            case 19:
                System.out.println(&quot;1111&quot;);
                break;
        &#125;
</code></pre>
<p><strong>循环语句</strong></p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        int count = 0 ;
        while (count &lt; 3)&#123;
            System.out.println(count);
            count++;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>do while循环</strong></p>
<p>至少执行一次</p>
<pre><code class="java">public class Hello &#123;
    public static void main(String[] args) &#123;
        int count = 0 ;
        do &#123;
            System.out.println(count);
            count++;
        &#125; while (count &lt; 3);
    &#125;
&#125;
</code></pre>
<p><strong>For循环</strong></p>
<pre><code class="java">        int count = 0 ;
        for (int i = 0 ; i &lt; 3 ; i++)&#123;
            System.out.println(i);
        &#125;
</code></pre>
<p><strong>数据类型</strong></p>
<p><strong>整数类型</strong></p>
<pre><code>byte 1个字节
short 2个字节
int 4个字节
long 8个字节
</code></pre>
<p>强制类型转化，大的类型往小的范围可能就会出错</p>
<pre><code class="java">byte i = 32 ; 
int a = (int) i;
</code></pre>
<p><strong>字符</strong></p>
<p>字符串的方法</p>
<pre><code class="java">        char  a = &#39;x&#39;;
        char  b = &#39;y&#39;;//字符只能用单引号
        String c = &quot;hahahaha&quot; ;

        String d = new String(&quot;王昌晨&quot;);

        char[] f = &#123;&#39;w&#39;,&#39;c&#39;,&#39;g&#39;&#125;;
        System.out.println(f);
</code></pre>
<pre><code class="java">        String name = &quot;wangchangchen&quot;;
        int count = name.length();//获取字符的长度
        for (int i = 0; i &lt; count; i++) &#123;
            char item = name.charAt(i);//获取当前位置的字符
        &#125;
        String a = name.trim();//去掉空白
        String[] b= name.split(&quot;c&quot;);//分割，返回的是数组
        String c= name.replace(&quot;w&quot;,&quot;d&quot;);//代换
        String d = name.substring(2,5);//切片
        boolean f = name.equals(&quot;wangchangchen&quot;);//进行字符串的比较
        boolean g = name.contains(&quot;ang&quot;);//数组中是否包含
        String k = name.concat(&quot;ahhah&quot;);//在后面进行拼接
</code></pre>
<p><strong>数组</strong></p>
<pre><code class="java">        int[] arr =new int[3];//定义三个数字的数组
        arr[0]=123;
        arr[1]=234;
        arr[2]=456;
        System.out.println(Arrays.toString(arr));


        String[] arr2 =new String[]&#123;&quot;hahah&quot;,&quot;hahah&quot;,&quot;ahah&quot;&#125;;
        System.out.println(Arrays.toString(arr2));

        String[] arr3 = &#123;&quot;haah&quot;,&quot;agaga&quot;,&quot;haha&quot;&#125;;
        System.out.println(Arrays.toString(arr3));

        for (int i = 0; i &lt; arr3.length; i++) &#123;
            System.out.println(arr3[i]);
        &#125;
</code></pre>
<p>注意：<strong>数组里面的个数一旦确定，不可以更改，类似于python里面的元组</strong></p>
<p><strong>对象</strong></p>
<ul>
<li><p>Java中所有的类也是默认继承基类Object这个类的，所以用基类可以反之子类的类型，下面这样写是不会报错的，因为String的类继承了Object的类</p>
<pre><code class="java">        String a = &quot;haha&quot;;
        Object b = &quot;haha&quot;;
        Object c = new String(&quot;haaha&quot;);
</code></pre>
<p>所以我们就可以常见任意类型的数组，所以要以后声明的数组是混合类型的就可以这样写</p>
<pre><code class="java">Object[] arr = new Object[]&#123;&quot;java&quot;,11111,2222,&quot;lkcd&quot;&#125;;
System.out.println(Arrays.toString(arr));//[java, 11111, 2222, lkcd]
</code></pre>
</li>
</ul>
<p>Object类型的字符串</p>
<pre><code class="java">        String v1 = new String(&quot;hahaha&quot;);
        v1.toUpperCase();
        System.out.println(v1);

        Object v2  = &quot;hahaha&quot;;
//只有强制类型转换以后才可以使用字符串的方法
        String data = (String)v2;
        data.toUpperCase()
</code></pre>
<p>传参的参数的类型未知，我们就可以这样写</p>
<pre><code class="java">    public static void func(Object a) &#123;
        System.out.println(a);
        if (a instanceof String) System.out.printf(&quot;String&quot;);
        if (a instanceof Integer) System.out.println(&quot;int&quot;);
    &#125;

    public static void main(String[] args) &#123;
        String v1 = new String(&quot;hahaha&quot;);
        v1.toUpperCase();
        System.out.println(v1);

        Object v2  = &quot;hahaha&quot;;
        String data = (String)v2;
        data.toUpperCase();
        func(&quot;hahahha&quot;);
    &#125;
</code></pre>
<ul>
<li>Java这种所有的类都继承Object，Object代指所有的类型</li>
</ul>
<p><strong>List系列</strong></p>
<ul>
<li>在Java中List不属于一种类型，在Java中List<strong>是一个接口</strong>，接口下面有两个常见的类型 （目的就是存放的动态的数据，可以添加删除）</li>
<li>ArrayList，（连续的内存地址的存储，里面放着的是内存地址而且内部还会自动扩容,可以添加，当超过的容量，创建新的内存地址，然后在保存）。</li>
<li>LinkedLink：（基于链表实现的，链表存储的）</li>
</ul>
<pre><code class="java">        ArrayList arr = new ArrayList();
        arr.add(&quot;hahaha&quot;);
        System.out.println(arr.getClass());//class java.util.ArrayLis
        System.out.println(arr);//[hahaha]
</code></pre>
<pre><code class="java">        LinkedList arr = new LinkedList();
        arr.add(&quot;hahaha&quot;);
        System.out.println(arr.getClass());//class java.util.LinkedList
        System.out.println(arr);//[hahaha]
</code></pre>
<p>用起来都是一样的，就是存储的方式不同,刚才提到list是一个接口，接口下面有如上的数据类型</p>
<ul>
<li><p>接口:使用来约束实现他的类，约束它里面的成员必须有什么，定义有点像TS</p>
<pre><code class="java">interface List&#123;
    public void add(Object)//不写具体的实现
&#125;
//这个类实现接口List，此时这里必须有add的方法
class ArrayList implements  List &#123;
   public void add(Object data)&#123;
       //实现添加数据的代码
   &#125;
&#125;
</code></pre>
<pre><code class="java">**我们用接口名称代指实现接口的类也是可以的**       
        List arr = new LinkedList();
        arr.add(&quot;hahaha&quot;);
        System.out.println(arr.getClass());//class java.util.LinkedList
        System.out.println(arr);//[hahaha]
</code></pre>
<p>创建的时候指定类型</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        List&lt;String&gt; arr = new LinkedList&lt;String&gt;();
        arr.add(&quot;hahaha&quot;);
        arr.add(1111);//这一行报错
        System.out.println(arr.getClass());//class java.util.LinkedList
        System.out.println(arr);//[hahaha]
    &#125;
</code></pre>
<p><strong>默认的是Object，里面的类型可以混着</strong></p>
</li>
<li><p>获取列表的方法和属性</p>
<pre><code class="Java">    public static void main(String[] args) &#123;
        List&lt;String&gt; arr = new LinkedList&lt;String&gt;();
        arr.add(&quot;hahaha&quot;);
        System.out.println(arr.getClass());//class java.util.LinkedList
        System.out.println(arr);//[hahaha]
        System.out.println(arr.get(0));//获取列表里的值

        arr.set(0,&quot;123&quot;);
        System.out.println(arr);//[123]

        arr.add(&quot;456&quot;);
        arr.remove(&quot;123&quot;);
        System.out.println(arr);//[456]
        arr.remove(0);
        System.out.println(arr);//[]

        System.out.println(arr.size());//0

        arr.add(&quot;2112&quot;);
        System.out.println(arr.contains(&quot;2112&quot;));//true

        arr.add(&quot;9999&quot;);
        for (Object item : arr)&#123;
            System.out.println(item);//2112,9999
        &#125;

        for (int i = 0; i &lt; arr.size(); i++) &#123;
            Object item = arr.get(i);
            System.out.println(item);//2112,9999
        &#125;

    &#125;
</code></pre>
</li>
<li><p>通过迭代器进行遍历</p>
<pre><code class="java">        List&lt;Object&gt; arr = new LinkedList&lt;&gt;(Arrays.asList(&quot;123&quot;,&quot;456&quot;,&quot;789&quot;));//快速创建一个，就不用一个一个添加了
        Iterator it = arr.iterator();
        while (it.hasNext())&#123;
            System.out.println(it.hasNext()); //判断指向当前的数据是否为空
            Object item = it.next();
            System.out.println(item); //获取当前指向的数据
        &#125;
</code></pre>
</li>
</ul>
<p><strong>Set系列</strong></p>
<p>主要还是去重</p>
<p>Set还是一个接口，常见的实现这两个接口有两个类，用于实现不重复多元素的集合</p>
<ul>
<li>HashSet ，去重，无序，</li>
<li>TreeSet，去重，内部会默认的排序（ascii,uncode）,不同类型的不能比较</li>
</ul>
<pre><code class="java">        HashSet s  = new HashSet&lt;&gt;();
        s.add(&quot;111&quot;);
        s.add(&quot;111&quot;);
        s.add(&quot;2222&quot;);
        System.out.println(s);//[111, 2222]
</code></pre>
<p>简单的创建，<strong>注意这里的add外层包裹的是双括号</strong></p>
<pre><code class="java">        HashSet a = new HashSet()&#123;
            &#123;
                add(&quot;1111&quot;);
                add(&quot;222&quot;);
            &#125;;
        &#125;;
        System.out.println(a);//[222, 1111]
</code></pre>
<p>通过集合我们就可以实现交并差，使用的方法和列表的实现差不多</p>
<pre><code class="java">        Set a = new HashSet&lt;&gt;()&#123;&#123;
            add("java");
            add("666");
            add("B站");
        &#125;&#125;;
        Set b = new HashSet() &#123;&#123;
             add("B站");
             add("A站");
             add("C站");&#125;&#125;;
        Set c = new HashSet();
        c.addAll(a);//向空的集合添加，或者取并集
        System.out.println(c);//[java, 666, B站]

        //交集
        c.retainAll(b);//交集,这个返回值是布尔
        System.out.println(c);;//[B站]

        //并集
        c.addAll(a);
        System.out.println(a);//[java, 666, B站]

        //差集
        c.removeAll(a); //c-a
        System.out.println(c);//[]

        //差集
        b.removeAll(a); //b-a
        System.out.println(b);//[C站, A站]

        //循环
        for (Object item : a)&#123;
            System.out.println(item);//java     666       B站
        &#125;

        Iterator it = a.iterator();
        while(it.hasNext())&#123;
            System.out.println(it.next());//java  666   B站
        &#125;
</code></pre>
<p><strong>Map系列</strong></p>
<p>Map是一个接口，常见实现这个接口有两个类，用于存储键值对</p>
<ul>
<li>HashMap : 无序；</li>
<li>Treepmap: 有序，根据key进行排序</li>
</ul>
<pre><code class="java">用法和之前的set和list的差不多
        Map a = new HashMap&lt;&gt;();
        a.put(&quot;name&quot; , &quot;demo&quot;);
        a.put(&quot;age&quot; , &quot;18&quot;);
        System.out.println(a);//&#123;name=demo, age=18&#125;


        Map&lt;String,String&gt; b = new HashMap&lt;String,String&gt;();
        b.put(&quot;name&quot; , &quot;demo&quot;);
        b.put(&quot;age&quot; , &quot;18&quot;);
        System.out.println(b);//&#123;name=demo, age=18&#125;


        //可以向setu快速的创建
        HashMap c = new HashMap&lt;&gt;()&#123;
            &#123;
                put(&quot;name&quot;,&quot;wang&quot;);
                put(&quot;age&quot;,&quot;18&quot;);
            &#125;
        &#125;;
        System.out.println(c);
</code></pre>
<pre><code class="java">        Map a = new HashMap&lt;&gt;();
        a.put(&quot;name&quot; , &quot;demo&quot;);
        a.put(&quot;age&quot; , &quot;18&quot;);
        System.out.println(a);//&#123;name=demo, age=18&#125;


        Map&lt;String,String&gt; b = new HashMap&lt;String,String&gt;();
        b.put(&quot;name&quot; , &quot;demo&quot;);
        b.put(&quot;age&quot; , &quot;18&quot;);
        System.out.println(b);//&#123;name=demo, age=18&#125;


        //可以向setu快速的创建
        HashMap c = new HashMap&lt;&gt;()&#123;
            &#123;
                put(&quot;name&quot;,&quot;wang&quot;);
                put(&quot;age&quot;,&quot;18&quot;);
            &#125;
        &#125;;
        System.out.println(c);

        System.out.println(c.size());

        System.out.println(c.get(&quot;name&quot;));

        c.replace(&quot;name&quot;,&quot;chen&quot;);
        System.out.println(c);

        //没有迭代器，但是可以通过下面这个样子实现
        Set&lt;Map.Entry&lt;String,String&gt;&gt; d = c.entrySet();
        System.out.println(d);//[&quot;name=chen&quot;, &quot;age=18&quot;]
        Iterator it = d.iterator();
        while (it.hasNext())&#123;
             Map.Entry&lt;String,String&gt; e = (Map.Entry&lt;String, String&gt;)it.next();//在转为map
            System.out.println(e);//name=chen   age=18
            String k = e.getKey();//获取键名
            String l = e.getValue();//获取值
        &#125;

        //简单的写法
        Set r = b.entrySet();
        Iterator it2 = r.iterator();
        while (it2.hasNext())&#123;
            Map.Entry o = (Map.Entry)it2.next();
            System.out.println(o);
        &#125;
</code></pre>
<p>Map的EntrySet方法会获得实体，转为Set就可以使用迭代器</p>
<p><strong>类和面向对象</strong></p>
<ul>
<li>基本使用</li>
</ul>
<pre><code class="java">class Person &#123;
    public String name;
    public Integer age;
    //构造方法
    public Person()&#123;
        this.name = &quot;chen&quot;;
        this.age = 18 ;
    &#125;
    //一个类中可以有多个构造方法，但是保证参数的不同的才可以
    public Person(String name)&#123;
        this.name = name;
        this.age = 18 ;
    &#125;
    public Person(String name , int age)&#123;
        this.name = name;
        this.age = age ;
    &#125;

    //方法的重载
    public void doSomething ()&#123;
        System.out.println(&quot;做一些事情&quot;);
    &#125;
    public void doSomething(String what)&#123;
        System.out.println(what);
    &#125;
    public void doSomething(String what , int age)&#123;
        System.out.println(age);
        System.out.println(this.name);
    &#125;
&#125;
</code></pre>
<ul>
<li><p>静态成员</p>
<pre><code class="java">class Person &#123;
    //静态变量,只能通过类的方法进行访问
    public static String content = &quot;爱笑&quot;;

    //静态方法
    public static void func()&#123;
        System.out.println(&quot;你好&quot;);
    &#125;
&#125;   
</code></pre>
</li>
</ul>
<p><strong>本质上静态的属于类，非静态的属于实例</strong></p>
<ul>
<li><p>继承， Java只能支持单继承，之前的pyhton和Js都是支持多继承的，Java的一个类只能继承一个父类</p>
<pre><code class="java">import java.lang.reflect.Array;
import java.util.*;

class Person &#123;
    public String name;
    public Integer age;
    public Person(String name , int age)&#123;
        this.name = name;
        this.age = age ;
    &#125;
&#125;
class Cool extends Person &#123;
    public String email;
    public  Cool(String name, int age ,String email)&#123;
        super(name, age);//使用父类的构造方法
        this.email = email;
    &#125;
&#125;
public class Hello &#123;
    public static void main(String[] args) &#123;
        Cool man = new Cool(&quot;wang&quot;,188,&quot;344455&quot;);
        System.out.println(man.email);//34455
        System.out.println(man.name);//wang
        System.out.println(man.age);//188
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>接口</strong></p>
<p>作用</p>
<ul>
<li>约束：实现他的类</li>
<li>泛指实现他的类</li>
</ul>
<pre><code class="Java">//实现其他的类
interface IMessage &#123;
    public void send();
&#125;

class WeChat implements IMessage&#123;
    public void send()&#123;
        System.out.println(&quot;发送&quot;);
    &#125;;
&#125;
</code></pre>
<pre><code class="java">//实现泛指其他的类，调用函数func，参数的类型设置类实现的接口，这样就可以传实现接口的类
interface IMessage &#123;
    public void send();
&#125;

class WeChat implements IMessage&#123;
    public void send()&#123;
        System.out.println(&quot;发送微信&quot;);
    &#125;;
&#125;

class  DingDing implements IMessage&#123;
    public void send()&#123;
        System.out.println(&quot;发送钉钉&quot;);
    &#125;;
&#125;


public class chen1 &#123;
    public static void func(IMessage a)&#123;
        a.send();
    &#125;
    public static void main(String[] args) &#123;
        WeChat a = new WeChat();
        func(a);
    &#125;
&#125;
</code></pre>
<p><strong>注意</strong></p>
<p><strong>Java中不支持多继承，但是可以支持多接口</strong></p>
<p><strong>抽象</strong></p>
<p><strong>抽象类，既能实现接口又能实现继承</strong></p>
<pre><code class="Java">abstract class Person1 &#123;
    //继承的子类必须有实现这个函数
    public abstract void func(String name);
    //子类也能继承这个方法
    public void func2()&#123;
        System.out.println(22222);
    &#125;
&#125;
class Hututu extends Person1 &#123;
    public void func(String name)&#123;
        System.out.println(name);
    &#125;
&#125;


public class chen1 &#123;
    public static void main(String[] args) &#123;
        Hututu hututu  = new Hututu();
        hututu.func(&quot;hututu&quot;);//hututu
        hututu.func2();//22222
    &#125;
&#125;
</code></pre>
<p><strong>包的概念</strong></p>
<p>新建包的文件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323165138897.png" alt="image-20240323165138897"></p>
<p>代码</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323165157520.png" alt="image-20240323165157520"></p>
<p>再在其他的地方导入</p>
<pre><code class="java">import java.lang.reflect.Array;
import java.util.*;
import utils.Helper;//导入包
public class Hello &#123;
    public static void main(String[] args) &#123;
        //调用包的里面的类的静态方法
        System.out.println(Helper.func());//hahahaha
    &#125;
&#125;
</code></pre>
<p><strong>包中类的修饰符</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323165801124.png" alt="image-20240323165801124"></p>
<ul>
<li><p>public，公共（任意人能调用包中的）</p>
</li>
<li><p>default，只能在当前包中调用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323170034173.png" alt="image-20240323170034173"></p>
</li>
</ul>
<p>这个只能在同一个包中调用，</p>
<p><strong>类修饰符</strong></p>
<p>之前学过</p>
<ul>
<li>public，所有都可以访问</li>
<li>private，只能在当前的类中访问</li>
<li>protected，只有在当前的类和当前的类的子类可以调用</li>
</ul>
<h2 id="基础的补充"><a href="#基础的补充" class="headerlink" title="基础的补充"></a>基础的补充</h2><p><strong>递归</strong></p>
<p>例子计算阶乘</p>
<ul>
<li><p>定义递归头 什么时候不调用自身的方法</p>
</li>
<li><p>递归体：什么时候调用自身的方法</p>
<pre><code class="Java">public class Helper &#123;
    public static long func(int n)&#123;
        if (n == 1)&#123;
            return 1;
        &#125; else &#123;
            return n * func(n - 1);
        &#125;
    &#125;;
    public static void main(String[] args) &#123;
        System.out.println(func(3));
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>内存分析</strong></p>
<p>栈主要放的是main方法的代码，堆里面放着的是类，里面有类的属性，方法保存在方法区</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323203251941.png" alt="image-20240323203251941"></p>
<p><strong>注意一点，实例对象的时候没有构造函数。默认的赋值是0和null，属性值的显性初始化‘，就是在类里面不通过构造器，而是通过 a &#x3D; 11,这样初始化</strong></p>
<p><strong>构造器</strong></p>
<ul>
<li>构造器通过new关键字调用</li>
<li>构造器虽然有返回值，但是在定义的构造器的时候不能定义构造器的返回类型，不能return在构造里面使用</li>
<li>构造器的名称和类名保持一致</li>
<li>如果没有构造器，会默认的定义一个无参的构造方法</li>
</ul>
<p>Java<strong>虚拟机内存分析</strong></p>
<p>虚拟机栈的特点</p>
<p><strong>每一个方法调用都会创建一个栈帧，虚拟机为每一个线程创建一个栈，栈属于线程的私有，不能实现线程的共享，栈的特点是先进后出，后进先出</strong></p>
<p><strong>堆的特点</strong></p>
<ul>
<li><p>用于存储创好的对象和数组</p>
</li>
<li><p>只有一个堆，被所有的线程共享</p>
</li>
<li><p>栈是一个不连续的内存共享</p>
</li>
<li><p>堆被所有的线程所共享 ，堆会被分为年生带和老年代，用于垃圾的回收</p>
</li>
</ul>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323203251941.png" alt="image-20240323203251941"></p>
<p><strong>垃圾回收的算法</strong></p>
<ul>
<li>引用计数法：堆中的每个对象都对应一个引用计数器，当引用指向这个对象，引用加一，当为0 的时候java进行回收，缺点就是循环引用就会导致清空不了</li>
</ul>
<p>例子，这样的引入的值一直不为0这样就不会清楚<img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323210136655.png" alt="image-20240323210136655"></p>
<ul>
<li>引用可达法：程序把所有的引用关系看做一张图，从一个节点的Gc Root开始，寻找引用的节点以后，继续寻找这个节点的引用节点吗，当所有的节点寻找完毕以后，剩余的节点则被认为是没有被引用的节点</li>
</ul>
<p><strong>通用的分代垃圾回收机制</strong></p>
<p>永久代就是我刚在的方法区，存放一些常量什么的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323211008599.png" alt="image-20240323211008599"></p>
<p>this<strong>的关键字</strong></p>
<ul>
<li>普通方法，this总是指向调用该方法的对象</li>
<li>构造方法，this指向正要初始化的对象</li>
<li>this（）调用重载的构造方法，避免相同的初始化代码，但只能在构造方法里面使用，并且必须位于构造方法的第一位</li>
<li>this不能用于静态方法（其实向上面的图，static放在方法去里面，只能方法区里面去引入堆里面的东西，显然是不行的）</li>
</ul>
<pre><code class="java">package utils;
class Person1 &#123;
    Person1()&#123;
        //this这里是对象的地址
        System.out.println(&quot;正在初始化对象&quot;+this);//正在初始化对象utils.Person1@682a0b20
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person1 xiaoming = new Person1();

    &#125;
&#125;
</code></pre>
<p>通过this构造</p>
<pre><code class="Java">package utils;
class Person1 &#123;
    public String name;
    public int age;
    Person1(String name , int age)&#123;
//        name = name  //这样因为作用域的问题
        this.name = name ;
        this.age = age ;
        //this这里是对象的地址
        System.out.println(&quot;正在初始化对象&quot;+this);//正在初始化对象utils.Person1@682a0b20
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person1 xiaoming = new Person1(&quot;wang&quot;,18);
        System.out.println(xiaoming.name); //wang
        System.out.println(xiaoming.age);  //18
    &#125;
&#125;
</code></pre>
<p>this（），还可以带参数</p>
<pre><code class="Java">package utils;
class Person1 &#123;
    public String name;
    public int age;
    Person1()&#123;
        System.out.println(&quot;wwww&quot;);//wwww
    &#125;;
    Person1(String name , int age)&#123;
        //this()调用无参构造器，而且必须位于第一行
        this();
        this.name = name ;
        this.age = age ;
        System.out.println(&quot;正在初始化对象&quot;+this);//正在初始化对象utils.Person1@682a0b20
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person1 xiaoming = new Person1(&quot;wang&quot;,18);
        System.out.println(xiaoming.name); //wang
        System.out.println(xiaoming.age);  //18
    &#125;
&#125;
</code></pre>
<p><strong>static关键字</strong></p>
<p>这里面的代码</p>
<p>代码的开始定义一个静态的name，但是在构造器里面，有使用了name，就导致实例对象里面也有name的属性 了</p>
<pre><code class="java">package utils;
class Person1 &#123;
    static String name;
    Person1(String a)&#123;
    name = a ;
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person1 shuai = new Person1(&quot;nini&quot;);
        
        System.out.println(shuai.name);//nini
        System.out.println(Person1.name);//nini
    &#125;
&#125;
</code></pre>
<p>正确给静态的属性赋值的方法，调用的时机在类被加载的时候。</p>
<pre><code class="java">package utils;
public class Helper &#123;
    static String name;
    static &#123;
        System.out.println(&quot;执行初始化的工作&quot;);//执行初始化的工作
        name = &quot;王昌晨&quot;;
        printName();

    &#125;
    public static void printName()&#123;
        System.out.println(name);//王昌晨
    &#125;
    public static void main(String[] args) &#123;
    &#125;
&#125;
</code></pre>
<p>敲的时候出现一些问题，问了一下ai</p>
<pre><code class="java">package utils;
public class Helper &#123;
    static String name;
    static &#123;
        System.out.println(&quot;执行初始化的工作&quot;);//执行初始化的工作
        name = &quot;王昌晨&quot;;
        printName();
    &#125;
    public static void printName()&#123;
        System.out.println(name);//王昌晨
    &#125;
    public static void main(String[] args) &#123;
        Helper p = new Helper();
        System.out.println(p.name);/**
        虽然 name 属性被声明为 static，但是在 main 方法中通过实例对象访问静态属性 name 是合法的，这是因为静态成员虽然属于类而不属于实例对象，但在 Java 中仍然可以通过实例对象访问静态成员。

当你使用实例对象访问静态成员时，实际上是通过该实例对象来引用静态成员，编译器会在后台进行转换，将实例对象替换为对应的类名。因此，尽管最佳实践是通过类名直接访问静态成员，但是通过实例对象访问静态成员在语法上是合法的。

所以，在你的代码中，虽然在 main 方法中通过实例对象 p 访问静态属性 name，实际上会被转换为 Helper.name，因此可以正常访问并输出静态属性 name 的值。**/
    &#125;
&#125;
</code></pre>
<p>静态初始化 的执行顺序</p>
<pre><code>因为所有的类都继承Object
*上溯到Object类，先执行Object的静态初始化模块，在向下执行子类的静态初始化块，直至类的静态初始化
*构造方法的执行顺序也是一样的，这就是为什么在子类的构造器里面的super的方法
</code></pre>
<p><strong>包机制</strong></p>
<ul>
<li><p>用于管理类和类重名的问题</p>
</li>
<li><p>Java中常见的包	</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323220021699.png" alt="image-20240323220021699"></p>
</li>
</ul>
<p>导入的报名重名</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323220302005.png" alt="image-20240323220302005"></p>
<p>最好写齐路径</p>
<p>下面不会全部导入，会先检查用到这个文件的哪些类，然后再导入</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323220335026.png" alt="image-20240323220335026"></p>
<p><strong>静态导入</strong></p>
<p>导入包下面的所有的静态的属性</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240323220509419.png" alt="image-20240323220509419"></p>
<p><strong>方法的重写</strong></p>
<p><strong>三个要点</strong></p>
<ul>
<li><p>1.方法名，形参，形参列表相同</p>
</li>
<li><p>2.返回值类型和声明异常类型，子类小于父类</p>
<pre><code class="Java">package utils;
class Person &#123;
    public Person func()&#123;
        System.out.println(&quot;1111&quot;);
        return new Person();
    &#125;
&#125;

class Li extends Person&#123;
    public Li func()&#123;
        System.out.println(&quot;222&quot;);
        return new Li();
    &#125;
&#125;

public class Helper &#123;

    public static void main(String[] args) &#123;
        
    &#125;
&#125;
</code></pre>
</li>
<li><p>3.访问权限，子类大于等于父类</p>
</li>
</ul>
<p><strong>final关键字</strong></p>
<ul>
<li><p>修饰变量</p>
</li>
<li><p>修饰方法：该方法不可以被子类重写，但是可以重载</p>
<pre><code class="java">public final void study()&#123;&#125;
</code></pre>
</li>
<li><p>修饰类：修饰类不能被继承，比如：Math,String</p>
<pre><code class="java">public final class A &#123;&#125;
</code></pre>
</li>
</ul>
<p><strong>组合</strong></p>
<p><strong>除了继承，组合也能实现代码的复用，组合的核心是将父类对象作为子类的属性</strong></p>
<pre><code class="Java">package utils;
class Person &#123;
    public String name;
    public int age;
    Person()&#123;
        name = &quot;hahaha&quot;;
        age = 18;
    &#125;
    public Person func()&#123;
        System.out.println(&quot;1111&quot;);
        return new Person();
    &#125;
&#125;

class Li &#123;
    Person chen = new Person();
    Li()&#123;
        System.out.println(chen.age);
        System.out.println(chen.name);
    &#125;
&#125;

public class Helper &#123;

    public static void main(String[] args) &#123;
        Li li = new Li();
    &#125;
&#125;
</code></pre>
<p><strong>Object类的详解</strong></p>
<ul>
<li>Object是所有类的父类</li>
<li>IDEA的快捷键<ul>
<li>类结构试图 alt+7</li>
<li>查看类的源码 ctrl+左键</li>
<li>自动生成构造器，get，set，equai方法 alt+insert</li>
<li>查看错误 alt+enter</li>
<li>快捷键常见代码片段<ul>
<li>main public static void main</li>
<li>sout System.out.printf()</li>
<li>soutm  System.out.printf（描述所在类中的，所在的方法）</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="java">        System.out.println(&quot;Person.func&quot;);//Person类里的func函数
</code></pre>
<p><strong>Object的equals方法</strong></p>
<pre><code>== 比较双方是否相同，普通的数据类型判断值，引用类型的判断的是地址
equals默认的比较两个对象地址是否相同
</code></pre>
<p>我们可以重写equal方法实现判断其他的</p>
<p><strong>super关键字</strong></p>
<ul>
<li><p>可以看作父类对象的引用，可以通过super来访问父类中被子类覆盖的方法和属性</p>
</li>
<li><p>使用super调用普通方法，语句没有位置限制，可以在子类中随意的调用</p>
</li>
<li><p>在一个类中，若是构造方法的第一行没有调用super或者是this；Java默认调用super含义是调用父类无参数的构造方法</p>
<pre><code class="java">package utils;
class Person &#123;
    public String name;
    public int age;
    public  void func()&#123;
        name = &quot;wang&quot;;
        age = 18;
        System.out.println(&quot;Person_age&quot;+age);
    &#125;
&#125;

class xiao extends Person&#123;
    public String name;
    public int age;
    public void func()&#123;
        super.func();
        age = 19;
        System.out.println(&quot;xiao_age&quot;+age);
        System.out.println(age);
        System.out.println(super.age);
    &#125;
&#125;

public class Helper &#123;

    public static void main(String[] args) &#123;
        xiao he = new xiao();
        he.func();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>程序的执行顺序</strong></p>
<p>构造方法的第一句总是super来调用父类的构造方法，，所以一直相声追溯，知道object</p>
<p><strong>封装</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324094833900.png" alt="image-20240324094833900"></p>
<ul>
<li><p>属性一般使用private访问权限，一般在开发中，我们把类中的属性都设为私有属性，然后通过相应的get和set的方法进行修改和读取。这些方法是public修饰（注意boolen类型的get方法是is开头）</p>
</li>
<li><p>方法：一些只用本类的辅助性方法可以用private修饰，希望其他类调用方法用public</p>
<pre><code class="java">//快速生成的get阿set的方法用 alt+insert
package utils;
class Person &#123;
    private String name;
    private int  age;
    private Boolean man;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public Boolean getMan() &#123;
        return man;
    &#125;

    public void setMan(Boolean man) &#123;
        this.man = man;
    &#125;
&#125;

public class Helper &#123;

    public static void main(String[] args) &#123;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>多态的要点</strong></p>
<ul>
<li>多态方法 的多态，不是属性</li>
<li>多态的存在三个条件，继承，方法重写，父类指向子类对象</li>
<li>父类引用子类的对象。用父类引用调用子类重写的方法</li>
</ul>
<pre><code class="Java">package utils;
class Animal&#123;

    public void shout ()&#123;
        System.out.println(&quot;叫一声&quot;);
    &#125;
&#125;
class Dog extends Animal&#123;
    public void shout()&#123;
        System.out.println(&quot;汪汪&quot;);
    &#125;
&#125;

class Cat extends Animal&#123;
    public void shout()&#123;
        System.out.println(&quot;喵喵&quot;);
    &#125;
&#125;

public class Helper &#123;
     public static void diao(Animal animal)&#123;//这里实现父类引用子类对象Animal animal
        animal.shout();
    &#125;

    public static void main(String[] args) &#123;
        Dog dog = new Dog();
        diao(dog);
    &#125;
&#125;
</code></pre>
<p><strong>再补充点</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324101703654.png" alt="image-20240324101703654"></p>
<ul>
<li><code>animal</code> 是 <code>Animal</code> 类型的引用，但是在运行时却指向了 <code>Dog</code> 类的实例，因此调用 <code>shout()</code> 方法时会调用 <code>Dog</code> 类中的 <code>shout()</code> 方法。</li>
<li><code>Animal</code> 类型的引用 <code>dog</code> 指向了 <code>Dog</code> 类的实例，然后尝试调用 <code>shout1()</code> 方法，但是 <code>Animal</code> 类并没有定义 <code>shout1()</code> 方法，因此编译器会报错</li>
</ul>
<p><strong>对象的转型</strong></p>
<ul>
<li><p>向上转型：就是刚下上面说过的父类引用子类对象</p>
<pre><code>Animal是父类
Dog是子类
Animal dog = new Dog();//父类引用子类对象
</code></pre>
</li>
<li><p>向下转型</p>
<pre><code class="Java">package utils;
class Animal&#123;

    public void shout ()&#123;
        System.out.println(&quot;叫一声&quot;);
    &#125;
&#125;
class Dog extends Animal&#123;
    public void shout()&#123;
        System.out.println(&quot;汪汪&quot;);
    &#125;
    public void shout1()&#123;
        System.out.println(&quot;汪汪&quot;);
    &#125;
&#125;

public class Helper &#123;
     public static void diao(Animal animal)&#123;//这里实现父类引用子类对象Animal animal
        animal.shout();
    &#125;

    public static void main(String[] args) &#123;
         Animal animal = new Dog();//自动向上转型为Animal
        animal.shout();//汪汪
        animal.shout1();//代码错误，因为animal没有shout
        ((Dog) animal).shout1();//向下转型

    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>转型前后都是一个对象</strong></p>
<p><strong>接口定义静态方法和默认方法</strong></p>
<p>默认方法用default修饰</p>
<pre><code class="Java">public interface Test &#123;
    void printInfo();
    default void moren()&#123;
        System.out.println(&quot;默认方法&quot;);
    &#125;
&#125;
class Testclass implements Test&#123;
    @Override
    public void printInfo() &#123;

    &#125;
&#125;
</code></pre>
<p>静态的方法，<strong>注意接口的静态方法和子类一点关系也没有，不会有父子类的那样的关系，接口的静态方法只能通过接口进行调用和实现接口的类没有一点关系</strong></p>
<pre><code class="java">public interface Test &#123;
    void printInfo();
    default void moren()&#123;
        System.out.println(&quot;默认方法&quot;);
    &#125;
    public static void func()&#123;
        System.out.println(&quot;hahaha&quot;);
    &#125;
&#125;
class Testclass implements Test&#123;
    @Override
    public void printInfo() &#123;
        Test.func();//hahaha
        Testclass.func();//报错	
    &#125;
    
&#125;
</code></pre>
<p>字符串的一些api</p>
<pre><code class="java">String s1=&quot;core Java&quot;;
String s2=&quot;core Java&quot;;
s1.charAt()//查看下标为几 的字符
s1.length();
s1.equals(s2)//检查相等
s1.equalIgnoreCase(s2);//忽略大小写
s1.indexOf(&quot;Java&quot;);//字符串是否包含Java，位置，如果没有返回-1
s1.replace(&#39;&#39;,&#39;&amp;&#39;);//将空格替换成&amp;
s1.substring(4,7);
s1.substring(4)//提取字符串从4到字符串结尾
</code></pre>
<p><strong>内部类</strong></p>
<ul>
<li>内部类提供更好的封装，只能外部类直接访问，不允许同一个包其他类直接访问</li>
<li>内部类可以直接访问外部类的私有属性，内部类被当作其他外部类成员，但外部类不能访问内部类的属性</li>
</ul>
<p>		</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324104900955.png" alt="image-20240324104900955"></p>
<p><strong>非静态内部类</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324105114585.png" alt="image-20240324105114585"></p>
<pre><code class="java">package utils;
class Outer &#123;
    private String name = &quot;王昌晨&quot;;
    public void show()&#123;
        System.out.println(&quot;Outer_name&quot;+name);
        //在外部类实例内部类
        Inner a = new Inner();
    &#125;
    public class Inner&#123;
        private String name = &quot;兵王&quot;;
        public void show()&#123;
            System.out.println(&quot;Inner_name&quot;+name);
            System.out.println(Outer.this.name);//访问外部类
            Outer.this.show();
        &#125;
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        //外部类实例
        Outer out = new Outer();
        //内部类的实例
        Outer.Inner inner  = new Outer().new Inner();
    &#125;
&#125;
</code></pre>
<p><strong>静态内部类</strong></p>
<ul>
<li>静态内部类可以访问外部类的静态成员，不能直接访问外部类的普通成员</li>
<li>静态内部类可以看作外部类的一个静态成员</li>
</ul>
<pre><code class="Java">package utils;
class Outer &#123;
    private String name = &quot;王昌晨&quot;;
    private static int a = 1;
    private static int b = 3;
    public void show()&#123;
        System.out.println(&quot;Outer_name&quot;+name);
        //在外部类实例内部类
        Inner a = new Inner();
    &#125;
    public static class Inner&#123;
        private String name = &quot;兵王&quot;;
        public void show()&#123;
            System.out.println(&quot;Inner_name&quot;+name);
//            可以直接访问外部的成员的静态属性和方法
            System.out.println(a);//1
            System.out.println(b);//3

        &#125;
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        //外部类实例
        Outer out = new Outer();
        //静态类这么实例
        Outer.Inner a = new Outer.Inner();
        a.show();

    &#125;
&#125;
</code></pre>
<p><strong>匿名的匿名类</strong></p>
<ul>
<li>适用于那种只需要使用一次的类，b比如：键盘监听操作等，</li>
</ul>
<p>如下面的这段代码，我们如果想要调用Person里的B方法，必须需要传入实现接口A的对象，需要在写一个实现A接口的类，有点麻烦，可以写匿名类</p>
<pre><code class="Java">package utils;
class Person &#123;
    public void B(A f)&#123;
        f.func();
    &#125;
&#125;
interface A &#123;
    void func();
&#125;
class B implements A&#123;
    @Override
    public void func() &#123;
        System.out.println(&quot;hahaha&quot;);
    &#125;
&#125;

public class Helper &#123;
    public static void main(String[] args) &#123;
        Person h = new Person();
        h.B(new B());
    &#125;
&#125;
</code></pre>
<pre><code class="Java">package utils;
class Person &#123;
    public void B(A f)&#123;
        f.func();
    &#125;
&#125;
interface A &#123;
    void func();
&#125;
public class Helper &#123;
    public static void main(String[] args) &#123;
        Person h = new Person();
        //直接new A就会有代码提示，下面的就是实力一个实现接口A的类
        h.B(new A() &#123;
            @Override
            public void func() &#123;
                System.out.println(&quot;hehehe&quot;);
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre>
<p><strong>方法的内部类</strong></p>
<ul>
<li>只能在方法里面使用</li>
<li><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324111801398.png" alt="image-20240324111801398"></li>
</ul>
<p><strong>数组</strong></p>
<ul>
<li>数组是相同数据类型的有序集合</li>
<li>长度是确定的</li>
<li>元素类型是相同 的</li>
<li>数组对象是引用类型</li>
</ul>
<p>内存分析</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240324113002955.png" alt="image-20240324113002955"></p>
<p><strong>静态初始化</strong></p>
<ul>
<li>除了通过new的关键字，还可以通过定义数组的同时就为数组分配空间并且赋值</li>
</ul>
<pre><code class="Java">package utils;
class Person &#123;
&#125;
public class Helper &#123;
    public static void main(String[] args) &#123;
        int[] a = &#123;1,2,3&#125;;
        Person[] b = &#123;new Person(),new Person()&#125;;
    &#125;
&#125;
</code></pre>
<p><strong>动态初始化</strong></p>
<pre><code class="Java">package utils;
class Person &#123;
&#125;
public class Helper &#123;
        int[] c = new int[3];
        c[0] = 1;
        c[1] = 2;
        c[2] = 3;
    &#125;
&#125;
</code></pre>
<p><strong>默认初始化</strong></p>
<pre><code class="Java">package utils;
class Person &#123;
&#125;
public class Helper &#123;
    public static void main(String[] args) &#123;
    int d[] = new int[2];//默认[0,0]
    boolean[] b = new boolean[2];//默认[false,false]

&#125;
</code></pre>
<p><strong>数组的两个遍历</strong></p>
<ul>
<li><p>使用For循环</p>
</li>
<li><p>for-each专门用于数组和集合所有的元素,在循环的过程中只能读取不能修改数组的值，for-each 仅用于简单的遍历，操作不了索引</p>
<pre><code class="Java">String[] ss = &#123;&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;&#125;;
for(String item : ss)&#123;
    System.out.println(item);
&#125;
</code></pre>
</li>
</ul>
<p><strong>异常</strong></p>
<ul>
<li><p>代码出现不正常的状态，异常是一个一个的类</p>
<p><strong>Throwable下面的两个子类</strong></p>
<ul>
<li>Error:错误，代码出现重大的错误</li>
<li>Exception：异常：代码出现小问题，异常分为两类<ul>
<li>编译时期异常，代码一些写一编译就暴红了（语法错误除外），Exception以及子类（除了RuntimeException之外）</li>
<li>运行时期异常：RuntimeException和他的子类，写代码不暴红，运行的时期爆红了<img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325143129953.png" alt="image-20240325143129953"></li>
</ul>
</li>
</ul>
<p>实例</p>
<p><strong>错误</strong></p>
</li>
<li><pre><code class="Java">package execption;

public class Demo &#123;
    public static void main(String[] args) &#123;
        method();
    &#125;

    public static void method() &#123;
        method();
    &#125;
&#125;
</code></pre>
<p>控制台报错</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325143434765.png" alt="image-20240325143434765"></p>
</li>
</ul>
<p><strong>运行时期异常</strong></p>
<pre><code class="Java">    public static void main(String[] args) &#123;
        int[] a= &#123;1,2,3&#125;;
        System.out.println(a[4]);
    &#125;
</code></pre>
<p>编译器没有飘红</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325143605424.png" alt="image-20240325143605424"></p>
<p>运行的时候</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325143635501.png" alt="image-20240325143635501"></p>
<p>发现是他的子类，所以是运行时期异常</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325143710714.png" alt="image-20240325143710714"></p>
<p><strong>编译时期异常</strong></p>
<p>下面的例子</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325144118255.png" alt="image-20240325144118255"></p>
<p>代码没有错，但是编译时期飘红 了，</p>
<p><strong>注意</strong></p>
<ul>
<li>编译时期飘红不是因为我们的代码写错 了</li>
<li>是因为该方法的底层给我们抛了一个错误，所以我们一调用这个方法一编译就飘红了</li>
</ul>
<p>异常出现的过程</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325145239439.png" alt="image-20240325145239439"></p>
<p><strong>创建异常对象</strong></p>
<p>创建异常对象只是为了后面学习如何处理异常</p>
<ul>
<li>1.关键字：throw：把异常对象显示出来</li>
<li>2.格式throw new 异常</li>
</ul>
<p>例</p>
<pre><code class="Java">package execption;

public class Demo1 &#123;
    public static void main(String[] args) &#123;
        String s = &quot;a.txt1&quot;;
        method(s);

    &#125;
    public static void method(String s)&#123;
        if (! s.endsWith(&quot;.txt&quot;))&#123;
            //故意创建异常对象，用throw说明这出有异常
            throw new NullPointerException();//这里出现异常没有人处理就会往上面抛，最后都没有人处理交给虚拟机，虚拟机终止程序，打印异常信息
            /**
             Exception in thread &quot;main&quot; java.lang.NullPointerException
             at execption.Demo1.method(Demo1.java:12)
             at execption.Demo1.main(Demo1.java:6)**/
        &#125;
        System.out.println(&quot;执行&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>异常处理的两种方法</strong></p>
<ul>
<li>throws：在方法参数和方法体之间的位置写<ul>
<li>格式：throws 异常</li>
<li>将异常往上面</li>
</ul>
</li>
</ul>
<p>例子</p>
<pre><code class="Java">package execption;

import java.io.FileNotFoundException;

public class Democracy
&#123;
    public static void main(String[] args)  &#123;
        String s = &quot;1.txt&quot;;
        add(s);
        delete(s);
        
    &#125;

    private static void delete(String s) &#123;
        System.out.println(&quot;删除&quot;);
    &#125;

    private static void add(String s)  &#123;
        if (! s.endsWith(&quot;.txt&quot;))&#123;
            //故意创建异常
            throw new FileNotFoundException(&quot;文件找不到&quot;);
        &#125;
        System.out.println(&quot;增加&quot;);
    &#125;
&#125;
</code></pre>
<p>直接new异常会报错，因为他是编译时期异常</p>
<p>所以使用throws向上抛，这样就可以了，这个异常处理的过程还是和默认的一样，最终还是往上面抛，最后给虚拟机，<strong>这样也会有问题，当一个出现我问题的时候，例如当add出现问题，程序就不会往下面走去到delete</strong></p>
<pre><code class="Java">package execption;

import java.io.FileNotFoundException;

public class Democracy
&#123;
    public static void main(String[] args) throws FileNotFoundException &#123;
        String s = &quot;1.txt&quot;;
        add(s);
        delete(s);
        
    &#125;

    private static void delete(String s) &#123;
        System.out.println(&quot;删除&quot;);
    &#125;

    private static void add(String s) throws FileNotFoundException  &#123;
        if (! s.endsWith(&quot;.txt&quot;))&#123;
            //故意创建异常
            throw new FileNotFoundException(&quot;文件找不到&quot;);
        &#125;
        System.out.println(&quot;增加&quot;);
    &#125;
&#125;
</code></pre>
<p>多个异常可以这样写</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325151526466.png" alt="image-20240325151526466"></p>
<ul>
<li><p>如果throws的多个异常之间有一个子父类的继承关系，我们直接可以throws 父类的异常</p>
</li>
<li><p>所以根据上面，有多个异常我们可以直接抛出他们最终的父类Exception</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325151726630.png" alt="image-20240325151726630"></p>
</li>
</ul>
<p><strong>第二种方法</strong></p>
<p><strong>try catch</strong></p>
<ul>
<li><p>格式</p>
<pre><code class="java">try &#123;
//可能出现的异常的代码
    
&#125; catch(异常 对象名)&#123;
    //处理异常的代码（把异常打印在控制台）--》将来将开发会把异常信息保存在日志文件中（用于查询）
&#125;
</code></pre>
<p>实例</p>
<p><strong>当我们程序出现异常，会被catch捕获到，然后在输出异常，然后继续往下面走</strong></p>
<pre><code class="Java">package execption;

import java.io.FileNotFoundException;

public class Democracy
&#123;
    public static void main(String[] args)&#123;
        String s = &quot;1.txt1&quot;;
        try &#123;
            add(s);
        &#125; catch (FileNotFoundException e)&#123;
            System.out.println(e);//java.io.FileNotFoundException: 文件找不到
        &#125;
        delete(s);//删除
    &#125;

    private static void delete(String s) &#123;
        System.out.println(&quot;删除&quot;);
    &#125;

    private static void add(String s) throws FileNotFoundException  &#123;
        if (! s.endsWith(&quot;.txt&quot;))&#123;
            //故意创建异常
            throw new FileNotFoundException(&quot;文件找不到&quot;);
        &#125;
        System.out.println(&quot;增加&quot;);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p>控制台的输出结果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325152527183.png" alt="image-20240325152527183"></p>
<p><strong>注意</strong>这段代码只捕获了FileNotFoundException的错误，但是没有捕获数组的那个错误，此时这个try catch是失效了</p>
<pre><code class="java">        try &#123;
            add(s);
            int[] a = null;
            System.out.println(a.length);
        &#125; catch (FileNotFoundException e)&#123;
            System.out.println(e);//java.io.FileNotFoundException: 文件找不到
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325152924929.png" alt="image-20240325152924929"></p>
<p><strong>有一个发现，当我们的add方法错误以后，直接就去走catch，这样       System.out.println(1111);这段代码就不会执行</strong></p>
<pre><code class="java">    public static void main(String[] args)&#123;
        String s = &quot;1.txt1&quot;;
        try &#123;
            add(s);
            System.out.println(1111);
        &#125; catch (FileNotFoundException e)&#123;
            System.out.println(e);//java.io.FileNotFoundException: 文件找不到
        &#125;
        delete(s);//删除
    &#125;
</code></pre>
<p>catch多个异常的格式，使用多个catch</p>
<pre><code class="Java">package execption;

import java.io.FileNotFoundException;
import java.io.IOException;

public class Democracy
&#123;
    public static void main(String[] args)&#123;
        String s = &quot;1.txt1&quot;;
        try &#123;
            add(s);
            System.out.println(1111);
        &#125; catch (FileNotFoundException e)&#123;
            System.out.println(e);//java.io.FileNotFoundException: 文件找不到
        &#125; catch (IOException e)&#123;
            System.out.println(e);
        &#125;
        delete(s);//删除
    &#125;

    private static void delete(String s) &#123;
        System.out.println(&quot;删除&quot;);
    &#125;

    private static void add(String s) throws IOException ,FileNotFoundException &#123;
        if (! s.endsWith(&quot;.txt&quot;))&#123;
            //故意创建异常
            throw new FileNotFoundException(&quot;文件找不到&quot;);
        &#125;
        if (s==null)&#123;
            throw new IOException(&quot;Io异常&quot;);
        &#125;
        System.out.println(&quot;增加&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>如果异常的有父子关系，直接用父类也是可以的</strong></p>
<p><strong>不知道的话，我们直接catch Exception</strong></p>
<p>我们还可以打印详细的</p>
<p>cu错误的信息打印在控制台，使用printStackTrace的方法</p>
<pre><code class="Java">        try &#123;
            add(s);
            System.out.println(1111);
        &#125; catch (FileNotFoundException e)&#123;
            e.printStackTrace();
        &#125; catch (IOException e)&#123;
            System.out.println(e);
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325181330429.png" alt="image-20240325181330429"></p>
<p><strong>finally关键字</strong></p>
<pre><code>注意和final区别开
1.代表的是不管是否触发了异常，都会执行的代码块
特殊情况：如果前面有代码System.exit(0)这个作用是终止Java虚拟机
2.使用配合try catch放在trycatch后面
</code></pre>
<p>例子</p>
<pre><code class="Java">try &#123;
    add(s);
    System.out.println(2222);
&#125; catch (FileNotFoundException e)&#123;
    e.printStackTrace();
&#125; catch (IOException e)&#123;
    System.out.println(e);
&#125; finally &#123;
    System.out.println(1111);
&#125;
</code></pre>
<p>之前说过try里面发生错误以后直接进入catch，然后就不会输出22222，</p>
<p>但是finally不管你有没有异常都会执行 的</p>
<p>下面将一些问题</p>
<ul>
<li>正常我们程序发生异常走进catch里面，里面有一个return,但是我们程序的执行顺序是先走的是finally，然后是catch里的内容</li>
</ul>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325182306317.png" alt="image-20240325182306317"></p>
<ul>
<li><p>所以我们在finally里面加上return，那么就会直接离开这个函数也不会执行catch里面的内容了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325182506837.png" alt="image-20240325182506837"></p>
</li>
</ul>
<p>注意执行的顺序</p>
<p><strong>try代码块，发现错误然后到finally，然后到catch里面的代码</strong></p>
<p><strong>finally的使用场景</strong></p>
<ul>
<li>关闭资源<ul>
<li>原因：如果没有使用 了，GC回收机制，用来回收堆内存的垃圾，释放内存，但是有一些对象GC回收不了，例如：连接对象（mysql）,io流对象，socket对象，这些GC回收不了，就需要我们手动进行回收，将来不能回收的对象new完以后，后续的操作不管异常还是好的，都要关闭</li>
</ul>
</li>
</ul>
<p><strong>抛异常的注意的事项</strong></p>
<ul>
<li><p>如果父类中的方法抛出了异常，那么子类的重写以后要不要抛？</p>
<pre><code>子类重写的方法可以抛也可以不抛
</code></pre>
</li>
<li><p>如果父类中的方法没有抛异常，那么子类重写方法的可不可以抛异常？</p>
</li>
</ul>
<pre><code>子类重写的方法不可以抛异常
</code></pre>
<p><strong>try catch和throws的使用时机</strong></p>
<ul>
<li><p>1.如果处理异常之后还要继续执行代码，那么就要使用try catch</p>
</li>
<li><p>2.如果方法之间是递进的调用，可以先throws，但是到最后用try catch做一个统一的错误处理</p>
</li>
</ul>
<p>比如说页面的架构，到后面一定使用这三个架构</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325184146232.png" alt="image-20240325184146232"></p>
<p>编译时期的异常是必须要处理</p>
<p>运行时期的异常没有必要处理，需要更改代码了</p>
<p><strong>自定义异常</strong></p>
<p>简单的创建方法</p>
<pre><code class="Java">public class Demo2 &#123;
    public static void main(String[] args) throws LoginUserException &#123;
        String username = &quot;root&quot;;

        Scanner input  = new Scanner(System.in);
        System.out.println(&quot;请输入您要登录的用户名:&quot;);
        String name = input.next();

        if (name.equals(username))&#123;
            System.out.println(&quot;登录失败&quot;);
        &#125; else &#123;
            throw new LoginUserException();
        &#125;


    &#125;
&#125;
</code></pre>
<p>然后我们需要去定义一个LoginUserException类，而且还要继承Exception</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325185420455.png" alt="image-20240325185420455"></p>
<p>这样就可以了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325185441928.png" alt="image-20240325185441928"></p>
<p>我们就还可以自定义异常的原因</p>
<pre><code class="Java">throw new LoginUserException(&quot;账号或密码错误&quot;);
            -------------------------------
使用构造方法
public class LoginUserException extends Exception &#123;
    public LoginUserException() &#123;
    &#125;
    public LoginUserException(String message) &#123;
        super(message);
    &#125;
&#125;
            
            
            
</code></pre>
<p>这样就可以了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325190118158.png" alt="image-20240325190118158"></p>
<p>设置异常的原因</p>
<p><strong>打印异常信息的三个方法</strong></p>
<pre><code>Throwable的方法
          try &#123;
                throw new LoginUserException(&quot;账号或密码错误&quot;);
            &#125; catch (Exception e)&#123;
                //异常加错误的原因，之前说过打印你一个对象默认调用了tostring的方法
                System.out.println(e);//execption.LoginUserException: 账号或密码错误
                System.out.println(e.toString());//execption.LoginUserException: 账号或密码错误
                System.out.println(e.getMessage());//账号或密码错误          只获取异常的信息
                e.printStackTrace();//飘红，信息完整
            &#125;
</code></pre>
<p><strong>说一下scanner的</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325185812928.png" alt="image-20240325185812928"></p>
<p><strong>Object类</strong></p>
<p><strong>toString方法</strong></p>
<p>类的源码</p>
<pre><code class="Java">    public String toString() &#123;
        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
    &#125;
</code></pre>
<p>示例</p>
<pre><code class="Java">package _object;

public class Person &#123;
    private String name;
    private int age;

    public Person() &#123;
    &#125;

    public Person(String name) &#123;
        this.name = name;
    &#125;

    public Person(int age) &#123;
        this.age = age;
    &#125;

    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;
&#125;
</code></pre>
<pre><code class="Java">package _object;

public class Test &#123;
    public static void main(String[] args) &#123;
        Person p1= new Person(&quot;王昌晨&quot;,18);
        System.out.println(p1);//_object.Person@3b07d329
        System.out.println(p1.toString());//_object.Person@3b07d329
    &#125;

&#125;
</code></pre>
<p><strong>总结</strong></p>
<pre><code>注意：
*如果没有重写object里的tostrig的方法，直接输出对象名会默认的调用tostring方法，tostring的方法会返回对象的地址值
</code></pre>
<p>有些问题</p>
<pre><code class="Java">        List a = new ArrayList();
        a.add(&quot;张三&quot;);
        a.add(&quot;王五&quot;);
        a.add(&quot;李四&quot;);
        System.out.println(a.toString());//[张三, 王五, 李四]
</code></pre>
<ul>
<li>输出的不是地址值,是因为重写了tostring的方法</li>
</ul>
<p>所以我们还可以重写tostring的方法在我们自己的类里面</p>
<pre><code class="java">    public String toString ()&#123;
        return name + age;
    &#125;
</code></pre>
<p>快速生成toString的方法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325104744357.png" alt="image-20240325104744357"></p>
<p><strong>Object的equals方法</strong></p>
<p>源代码</p>
<pre><code class="java">    public boolean equals(Object obj) &#123;
        return (this == obj);
    &#125;
</code></pre>
<p>返回的是boolean类型，比较的是两个地址值是否相等</p>
<pre><code class="java">        System.out.println(p1.equals(p2));//false
        System.out.println(p1.equals(p1));//true
</code></pre>
<p>底层的原理</p>
<pre><code>    public boolean equals(Object obj) &#123;
        return (this == obj);
    &#125;
    -----------------------------------------
    System.out.println(p1.equals(p2));//false
    *当p1调用obj的时候,这个this就是指向的p1，==在引用类型的比较的是地址值，在基础数据类型是比较数据的值
</code></pre>
<p>注意还是重写的问题</p>
<pre><code class="java">//我们使用实例的方法创建字符串
String name = new String(&quot;name&quot;);
String name1 = new String(&quot;name&quot;);
System.out.println(name.equals(name1));//true
因为String的equals的重写了，比较的是值
</code></pre>
<p>下面是重写的代码</p>
<pre><code class="Java">    public boolean equals(Object anObject) &#123;
        if (this == anObject) &#123;
            return true;
        &#125;
        return (anObject instanceof String aString)
                &amp;&amp; (!COMPACT_STRINGS || this.coder == aString.coder)
                &amp;&amp; StringLatin1.equals(value, aString.value);
    &#125;
</code></pre>
<p>我们也可以在重写一下</p>
<p>这是快捷键重写以后的</p>
<pre><code class="java">    @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &amp;&amp; Objects.equals(name, person.name);
    &#125;

    @Override
    public int hashCode() &#123;
        return Objects.hash(name, age);
    &#125;
</code></pre>
<pre><code class="Java">System.out.println(p1.equals(p2))
//当我们传入p2的时候，重写的类用父类引用子类 object 0 = p2;
//如果想要获取p2的里面的属性和方法需要向下转型
//        if (o == null || getClass() != o.getClass()) return false;这一步在判断传入的对象类型是否是当当前的类，如果传入一个字符串对象的话，强转就会出现问题
 //      if (this == o) return true;如果传入的是自己那么肯定是相等的，返回true
</code></pre>
<p><strong>Object的clone的方法</strong></p>
<pre><code>1.作用:复制一个属性值一样的新对象
2.使用:需要被克隆的对象实现cloneable的接口
        重写clone
</code></pre>
<p>过程</p>
<pre><code class="Java">Person的类实现public class Person implements Cloneable
重写clone方法    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;
    在主函数里面调用
            public static void main(String[] args) throws CloneNotSupportedException &#123;
        Person p = new Person(&quot;wang&quot;,18);
        Object o = p.clone();//克隆一个新对象,地址不一样，属性值是一样的
        Person p1 = (Person) o;
        System.out.println(p1.equals(p));//true

    &#125;
</code></pre>
<p><strong>在复习一下多态</strong></p>
<ul>
<li><p>不要从字面形式上理解多态的这两个子，要从形式上掌握</p>
</li>
<li><p>要知道多态的好处，多态的前提</p>
<pre><code>前提
    a.必须有字符类的继承或者接口实现关系
    b.必须有方法的重写（没有重写，多态没有意义）
    c.父类引用指向子类对象
Fu fu = new zi();--&gt;理解成大数据类型接受一个小数据类型的数据，比如 double b = 10;
注意：
    多态下不能直接调用子类的特有功能
</code></pre>
</li>
</ul>
<p><strong>多态的好处</strong></p>
<pre><code>1.问题描述
    如果不使用多态，使用原始的方法new对象，既能调用子类重写的父类的方法，还能调用自己特有的成员，但是多态的new的对象只能调用子类重写的，不能调用子类的特有的成员那为什么还要用多态？
2.多态方式和原始方式new对象的优缺点
    原始方式:
        优点:既能调用重写的，还能调用父类非私有的，还能调用自己特有的
        缺点:扩展性差，就像之前的讲的，传递的参数可以写成父类
    多态方法:
        优点:扩展性强
        缺点:不能调用子类特有的功能
</code></pre>
<p><strong>多态的转型</strong></p>
<p>向上转型以后调用子类的特有的功能就要使用向下转型</p>
<pre><code>转型是出现的问题
左右两边类型不一样，就会出现类型转换异常
可以使用instanceOf进行判断然后再类型转换
</code></pre>
<p><strong>String补充</strong></p>
<pre><code class="Java">String s1 = &quot;10&quot;;
String s2 = &quot;10&quot;;
String s3 = new String(&quot;10&quot;);
System.out.println(s1 == s2);//true
System.out.println(s1 == s3);//false
System.out.println(s2 == s3);//false
</code></pre>
<p>内存的分析</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325194042492.png" alt="image-20240325194042492"></p>
<pre><code class="Java">String a = new String(&quot;abc&quot;);//共有几个对象？ 一个new本身，一个abc
String b = new String(&quot;abc&quot;)//共创建今儿个对象？  如果之前没有创建abc，那么就会创建两个，有的话就只会创建new的对象，把abc之恶共享过来即可
</code></pre>
<p>内存分析</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325194436987.png" alt="image-20240325194436987"></p>
<pre><code class="Java">        String s = &quot;HelloWorld&quot;;
        String s1 = &quot;Hello&quot;;
        String s2 = &quot;World&quot;;
        String s4 = &quot;Hello&quot;+&quot;World&quot;;
        String s5 = s1 + &quot;World&quot;;
        String s6 = &quot;Hello&quot;+s2;
        String s7 = s1+s2;
        System.out.println(s == s4);//true
        System.out.println(s == s5);//false
        System.out.println(s == s6);//false
        System.out.println(s == s7);//false
</code></pre>
<p>为什么会出现上面的问题，直接反编译以后就能知道结果了</p>
<p><strong>String的常用的方法</strong></p>
<p><strong>注意在Java中String不是基本数据类型，而是一个类，</strong></p>
<p><strong>如果我们使用&#x3D;&#x3D;比较，之前说过当&#x3D;&#x3D; 比较引用的数据类型，比较的是地址，所以我们使用equals比较内容，</strong></p>
<pre><code>equals();//比较字符串的内容
equalsIgnorecase();//忽略大小写的
</code></pre>
<p>或者使用</p>
<pre><code class="Java">    String s2 = &quot;10&quot;;
    String s3 = new String(&quot;10&quot;);
    System.out.println(Objects.equals(s2,s3));//true
</code></pre>
<p>底层的源码，这个可以有效的防止防止空指针</p>
<pre><code class="Java">public static boolean equals(Object a, Object b) &#123;
    return (a == b) || (a != null &amp;&amp; a.equals(b));
&#125;
</code></pre>
<p>比如说</p>
<pre><code class="Java">String s2 = null;
String s3 = new String(&quot;10&quot;);
s2.equals(s3);//这一行就会报错
System.out.println(Objects.equals(s2,s3));
</code></pre>
<p>这样就会报错空指针异常</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325200556819.png" alt="image-20240325200556819"></p>
<pre><code>*length()//
*concat()//拼接返回一个新的字符串
*charAt()//根据索引获取响应的字符
*indexOf(String s);//返回字符串在大字符串第一次出现的位置
*subString(int begin);//从开始索引截到最后
*sunString(int begin, int end);//记住左闭右开
</code></pre>
<pre><code>toCharArray();//转为char数组
getBytes();//将字符串转为字节数组
replace(String s1, String s2);//替换
getBytes(String charsetName);//按照编码格式将字符串转为Bytes数组
</code></pre>
<pre><code>split(String regex);//分割
</code></pre>
<pre><code>contains()//
endwiths()
startsWith()
toLowerCase()
toUpperCase()
trim()
</code></pre>
<p><strong>StringBuilder</strong></p>
<ul>
<li>介绍<ul>
<li>一个可变的字符序列，此类提供一个和StringBuffer兼容的APi，但是线程不同步，但是效率高</li>
</ul>
</li>
<li>作用<ul>
<li>拼接字符串</li>
</ul>
</li>
<li>之前的拼接为什不行，为什么用StringBuilder拼接？<ul>
<li>因为之前string的拼接，每拼接一次就会产生一个新的字符串对象，就是上面举的例子,如果拼接过多占用堆的内存</li>
<li>StringBuilder底层自带一个缓冲区（没有被final修饰的bytes数组）拼接字符串以后都会在这个缓冲区保存，在拼接的过程中不会随意产生新对象</li>
</ul>
</li>
</ul>
<pre><code class="java">    String s = &quot;HelloWorld&quot;;
    String s1 = &quot;Hello&quot;;
    String s2 = &quot;World&quot;;
    String s4 = &quot;Hello&quot;+&quot;World&quot;;
    String s5 = s1 + &quot;World&quot;;
    String s6 = &quot;Hello&quot;+s2;
    String s7 = s1+s2;
    System.out.println(s == s4);//true
    System.out.println(s == s5);//false
    System.out.println(s == s6);//false
    System.out.println(s == s7);//false
</code></pre>
<ul>
<li>特点<ul>
<li>自带缓冲区，默认的长度为16，没有final修饰所以是可变的，如果超过16了，数组会自动的扩容，<ul>
<li>创建一个新长度的数组，将老数组的元素复制到新数组的里面，在将新数组的地址值重新赋给老数组</li>
<li>默认每次扩容老数组的2倍+2</li>
<li>如果超过2倍+2的，那么直接创建等大的内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>两种创建方法</p>
<pre><code class="Java">StringBuilder sb  = new StringBuilder();
sb.append(&quot;wei3588559&quot;);

StringBuilder sb2 = new StringBuilder(&quot;wei3588559&quot;);
</code></pre>
<p>append用来拼接字符串，返回一个StringBuilder</p>
<pre><code class="Java">StringBuilder sb2 = new StringBuilder(&quot;wei3588559&quot;);
StringBuilder sb3=sb2.append(&quot;haha&quot;);
System.out.println(sb2);//wei3588559haha
System.out.println(sb3);//wei3588559haha
System.out.println(sb3 == sb2);//true
</code></pre>
<p>我们还可以链式调用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240325204030828.png" alt="image-20240325204030828"></p>
<p>reserve(),反转用法和append一样</p>
<p>toString（）：将StringBuilder对象转为String对象，为了可以使用String的方法</p>
<p>判断回文内容</p>
<pre><code class="Java">    public static void main(String[] args)  &#123;
        Scanner input  = new Scanner(System.in);
        String data = input.nextLine();
        StringBuilder str = new StringBuilder(data);
        str.reverse();
        String str2 = str.toString();//将StringBuilder转为String对象
        if (data.equals(str2))&#123;//注意这里的比较一定是字符串的对象，不能呢和是string和stringbuilder的比较，这样内容一样也是false
            System.out.println(&quot;是回文数&quot;);
        &#125; else &#123;
            System.out.println(&quot;不是回文数&quot;);
        &#125;
    &#125;
</code></pre>
<p>补充字符的equals方法</p>
<p>比较的时候一定比较的是字符串</p>
<pre><code class="Java">    public boolean equals(Object anObject) &#123;
        if (this == anObject) &#123;
            return true;
        &#125;
        return (anObject instanceof String aString)
                &amp;&amp; (!COMPACT_STRINGS || this.coder == aString.coder)
                &amp;&amp; StringLatin1.equals(value, aString.value);
    &#125;
</code></pre>
<pre><code>定义一个数组，以[元素1，元素2...],用StringBuilder拼接
</code></pre>
<p>String 拼接的效率满，而且拼接一次就会产生一个新的字符串对象</p>
<p>StringBuilder和StringBuffer:</p>
<p>​	1.相同点：拼接的效率比StringBuffer高</p>
<p>​						但是线程不安全</p>
<p>​	2.Stringbuffer：效率比较低，线程安全</p>
<p><strong>Math类</strong></p>
<ul>
<li><p>特点：他的构造方法私有了</p>
<ul>
<li>方法都是静态的直接类名调用就可以</li>
</ul>
</li>
<li><p>数学工具类</p>
<pre><code>Math.abs(-10)//10
static int abs(int a) --&gt;求参数的绝对值
static double ceil(double a) --&gt;向上取整
static double floor(double a) --&gt;向下取整
static long round(double a) --&gt;四舍五入
static int max(int a , int b) --&gt;最大值
static int min(int a , int b) --&gt;最小值
</code></pre>
</li>
</ul>
<p><strong>BigInteger</strong></p>
<pre><code>操作数据的时候，将来的数据很大，大到比long还大，这种称为对象
作用:操作大的数字
BigInteger(String value)
方法
    add(BigInteger value);//加
    subtract(BigInteger value)//减
    multiply(BigInteger value) //×
    divide(BigInteger value)//  除
</code></pre>
<p><strong>BigDecimal</strong></p>
<p>floor的数据直接参加运算会出现精度损失的问题</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326124121160.png" alt="image-20240326124121160"></p>
<pre><code>**BigDecimal**解决精度损失的问题
构造方法
BigDEcimal(Stirng value) --&gt;value一定是数字的字符串
常用的方法
static BigDecimal valueOf(doubt value) --&gt;此方法 初始化小数可以传doule的数据
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326124552341.png" alt="image-20240326124552341"></p>
<p><strong>Date类</strong></p>
<pre><code class="Java">表示时间
        Date time = new Date();
        System.out.println(time);//Tue Mar 26 14:28:03 CST 2024
//有参的，从时间原点开始放
        Date time2 = new Date(10000l);
        System.out.println(time2);//Thu Jan 01 08:00:10 CST 1970
//方法，设置时间
        Date time = new Date();
        time.setTime(10000l);
        System.out.println(time);//Thu Jan 01 08:00:10 CST 1970
</code></pre>
<p><strong>Calendar类</strong></p>
<pre><code class="Java">1.概述:日历类，抽象类
2.获取的calendar里面的方法：
    static Calendar getInstance();
    ---------------------------------------
     Calendar calendar = Calendar.getInstance();
     System.out.println( calendar );
</code></pre>
<pre><code class="java">
        Calendar calendar = Calendar.getInstance();
        int year = calendar.get(Calendar.YEAR);
        System.out.println(year);//2004

        calendar.set(Calendar.YEAR,2008);
        System.out.println(calendar.get(Calendar.YEAR));//2008

     //的
        System.out.println(time1);//Thu Mar 26 14:44:44 CST 2009
</code></pre>
<p><strong>日期格式化类SimpleDateFormat</strong></p>
<pre><code>格式化日期
2.构造
simpleDateFormat(String pattern);//pattern代表模式，注意字母的大小写不要改变，但是中间的连接符是可以改变的
例如
    yyyy--MM--dd HH:mm:ss
</code></pre>
<p>格式的字母表示</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326144906530.png" alt="image-20240326144906530"></p>
<p>使用</p>
<pre><code class="java">        Date time = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        System.out.println(sdf.format(time) );
//sdf.format(time)将Date对象按照符合日期对格式的字符串
        System.out.println(sdf.parse(time2));//Tue Mar 26 14:56:55 CST 2024     parse的作用将格式化以后的转为date对象
注意因为parse方法底层抛了一个异常,所以我们还要往上面抛
</code></pre>
<p><strong>JDK8新日期类</strong></p>
<p><strong>LocalDate本地时间</strong></p>
<pre><code class="Java">        //通过LocalDate.now();创建对象
        LocalDate ld = LocalDate.now();
        System.out.println(ld);//2024-03-26

//自己设置时间
        LocalDate time = LocalDate.of(2000,3,30);
        System.out.println(time);
</code></pre>
<p><strong>LocalDateTime类</strong></p>
<pre><code>和上面的用法一样只不过更加精确
</code></pre>
<pre><code class="java">获取各个字段
        LocalDateTime time = LocalDateTime.now();
        System.out.println(time.getYear());//2024
        System.out.println(time.getMonth());//MARCH
        System.out.println(time.getMonthValue());//3
        System.out.println(time.getDayOfMonth());//

//设置
        LocalDate time2 =LocalDate.EPOCH.withYear(2000);
        System.out.println(time2);//2000-01-01
---------------------------------------------
    设置月份
        LocalDate time2 =LocalDate.EPOCH.withYear(2000);
        LocalDate time3=time2.withMonth(5);
        System.out.println(time3);//2000-05-01
--------------------------------------------------
    //我们可以将上面设置成链式调用
       LocalDate time2 =LocalDate.EPOCH.withYear(2000).withMonth(5);
        System.out.println(time2);//2000-05-01
</code></pre>
<p>每次使用都会返回一个新的LocalDate对象</p>
<pre><code class="Java">偏移量
    //Plus是向日期大的偏移
        LocalDate time2 =LocalDate.EPOCH.withYear(2000).withMonth(5).plusYears(1);
        System.out.println(time2);//2000-05-01
//minus是像日期小的偏移
        LocalDate time2 =LocalDate.EPOCH.withYear(2000).withMonth(5).minusYears(1);
        System.out.println(time2);//1999-05-01
</code></pre>
<p><strong>Period计算日期之间的偏差</strong></p>
<pre><code class="Java">static Period between(LocalDate d1, LocalDate d2)
----------------------------------------------------
        LocalDate d1 = LocalDate.of(2022,12,12);
        LocalDate d2 = LocalDate.of(2022,12,13);
        Period p =Period.between(d1,d2);
        System.out.println(p.getDays());//1
        System.out.println(p.getYears());//0
        System.out.println(p.getMonths());//0
</code></pre>
<p><strong>Duration计算偏差</strong></p>
<p>计算LocalDateTime的偏差</p>
<pre><code>static Duration between(Temporal startInclusive,Temporal endInclusive)//--&gt;计算时间差
Temporal是接口，实现类有LocalDate和LocalDateTime,所以参数可以是
实现对象，注意需要传递LocalDateTime,因为Duration是计算精确时间的

利用duration计算相差
toDays();
toHours();
toMinutes();
toMillis();//毫秒
</code></pre>
<pre><code class="java">        LocalDateTime d1 = LocalDateTime.of(2022,12,12,10,10,10,10);
        LocalDateTime d2 = LocalDateTime.of(2022,12,13,10,10,10,10);
        Duration duration  = Duration.between(d1,d2);
        System.out.println(duration.toDays());//1
        System.out.println(duration.toHours());//24
        System.out.println(duration.toMillis());//86400000
        System.out.println(duration.toMinutes());//1440
</code></pre>
<p><strong>注意这个计算不是直接减，而是根据时间</strong></p>
<p><strong>DateTimeFormatter日期格式化类</strong></p>
<pre><code>static DateTimeFormatter ofPattern (String pattern)--&gt;获取对象
方法：
String format(TemporalAccessor temporal)-&gt;将日期规则按照指定规则转为字符产
TemporalAccessor parse(CharSequence text) --&gt;和上面的相反


TemporalAccessor是一个接口子接口有Temporal，之前说过他的实现类有LocalDate和LocalDateTime,，所以可以传他们
CharSequence是string接口
</code></pre>
<p>使用</p>
<pre><code class="Java">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
LocalDateTime time = LocalDateTime.now();
System.out.println(time);
System.out.println(dtf.format(time));//2024-03-26 15:59:11

如果想将TemporalAccessor转为我们常见的LocalDateTime日期对象，就需要用到LocalDateTime里面的静态方法
    static LocalDateTime from (TemporalAccessor temporal)
    
    //所以把日期的字符串转为localdatetime
        TemporalAccessor temporalAccessor = dtf.parse(dtf.format(time));
        LocalDateTime localDateTime = LocalDateTime.from(temporalAccessor);
        System.out.println(localDateTime);
    
    
</code></pre>
<p><strong>System工具类</strong></p>
<pre><code>系统相关类
特点
    构造私有，不能使用构造方法new对象
    方法都是静态的
使用
    static long currentTimeMillis()//返回毫秒为单位的当前时间
        long i= System.currentTimeMillis();
        System.out.println(i);//1711452549818
    static void exit(int status)//终止当前的虚拟机
        System.exit(0);
    static void arraycopy(object src ,int srcPos , Object dest ,int desPos,int length) //数组的复制 
    src:原数组
    srcPos:从原数组的哪个索引开始复制
    dest:目标数组
    destPos:从目标数组的哪个位置开始粘贴
    length:复制的长度
    
</code></pre>
<pre><code class="java">       int[] arr = &#123;1,2,3,4,5,6&#125;;
        int[] arr2 = new int[10];
        System.arraycopy(arr,0,arr2,0,5);
        for (int i = 0; i &lt; arr2.length; i++) &#123;
            System.out.println(arr2[i]);
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326193738250.png" alt="image-20240326193738250"></p>
<p>有一个快捷键，这样快速生成遍历数组的方法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326193809404.png" alt="image-20240326193809404"></p>
<p><strong>Arrays数组工具类</strong></p>
<p><strong>记住，没有重写的数组的toString，打印数组是数组的地址值，所以需要toString的方法，和对象一样，使用对象 的toString的方法，只会打印对象的地址值，只有在对象的里面重写toString才可以</strong></p>
<pre><code>构造私有，方法静态
使用：类名直接调用
    static String toString(int[] a)//按照格式打印数组元素
    static int binarySearch(int[] a, int key) //二分查找
    static void sort(int[] a)//升序排列
    static int[] copyOf(int[] orginal ,int newLength)//数组的扩容
</code></pre>
<pre><code class="Java">        int[] a = &#123;1,2,3,4,5&#125;;
        System.out.println(Arrays.toString(a));//[1, 2, 3, 4, 5]
        int[] b = &#123;1,2,5,3,21,1&#125;;
        Arrays.sort(b);
        System.out.println(Arrays.toString(b));//[1, 1, 2, 3, 5, 21]
//二分查找前提是升序，传过去的一定是升序玩的数组
        int[] b = &#123;1,2,5,3,21,1&#125;;
        Arrays.sort(b);
        System.out.println(Arrays.binarySearch(b,2));//2
//数组的扩容
        int[] b = &#123;1,2,5,3,21,1&#125;;
        int[] c = Arrays.copyOf(b,10);
        System.out.println(Arrays.toString(c));//[1, 2, 5, 3, 21, 1, 0, 0, 0, 0]
</code></pre>
<p>**包装类	**</p>
<pre><code>就是基本数据类型对应的类（包装类），我们需要将基本数据类型转为包装类，从而让基本的数据类型拥有类的特性
为什么要学包装类？
    特点的场景。比如要调用方法传递包装类
    包装类转为基本数据类型，因为包装类不能使用+ - 等
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326195728471.png" alt="image-20240326195728471"></p>
<p>比如</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326200154630.png" alt="image-20240326200154630"></p>
<p>这里面需要Integer的类，就需要包装</p>
<p>但是我们传递一个基本数据类型，没有报错为什么？</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326200255602.png" alt="image-20240326200255602"></p>
<p><strong>因为这部操作虚拟机会帮你自动类型转换，转为Integer类</strong></p>
<p><strong>Interger包装类</strong></p>
<pre><code>概述：Interger是int的包装类
使用:构造方法：
Interger(int value);
Interger(String value)
例如
        Integer i = new Integer(1);
        Integer j = new Integer(&quot;10&quot;);
        System.out.println(i);//1
        System.out.println(j);//10
</code></pre>
<p>上面过时了</p>
<pre><code>1.装箱：将基本数据类型转为包装类
2.方法:Integer里的方法
static Integer valueOf(int i)
static Integer valueOf(String s)
这些操作叫做装箱
拆箱：将包装类转为基本的数据类型
 方法
 int intValue()
         Integer i = new Integer(1);
         int k = i.intValue();
</code></pre>
<ul>
<li>拆箱和装箱很多时候都是自动完成的</li>
<li><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326202631150.png" alt="image-20240326202631150"></li>
</ul>
<p>这一步就是在自动装箱</p>
<p>反编译就可以看出来</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326202824007.png" alt="image-20240326202824007"></p>
<p>提问</p>
<pre><code class="Java">        Integer i = 100;//自动装箱
        Integer j = 100;
        System.out.println(i == j);//比较的是地址 //true

        Integer k  =128;
        Integer l = 128;
        System.out.println(k == l);//false
</code></pre>
<p>这是为什么？	</p>
<p>底层的源码</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326203411680.png" alt="image-20240326203411680"></p>
<pre><code>100在这个范围以内，所以直接返回这个数组里面的数据，所以i和j同时指向数组里面的同一个元素
但是128不在这个范围以内，所以直接新建一个新的对象，所以两个k和l不是同一个对象，这个范围是在-128到127数组里面装着-128到127Integer对象
</code></pre>
<p><strong>基本数据类型往String转</strong></p>
<pre><code>1.拼接
    int a  = 1;
    String b = a + &#39;&#39;;	 
2.String的静态方法
static String valueOf(int i)
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326204541033.png" alt="image-20240326204541033"></p>
<ul>
<li>在实际开发中如何定义一个标准的Javabean</li>
</ul>
<pre><code>定义javabean的时候一般会将基本的数据类型变成包装类的类型
</code></pre>
<p>​	比如</p>
<pre><code class="java">public class User &#123;
    private Integer uid;
    private String name;
    private String password;
    public User(Integer uid, String name, String password) &#123;
        this.uid = uid;
        this.name = name;
        this.password = password;
    &#125;

    public User(String password) &#123;
        this.password = password;
    &#125;

    public User(Integer uid) &#123;
        this.uid = uid;
    &#125;
&#125;
</code></pre>
<pre><code>1.如果uid为Integer型(因为是对象没有值是null)，默认值为null
2.将来javabean中的数据和数据库联系起来，我们可以将javabean中数据添加到表中，如果uid为主键自增此时的sql语句不用我们单独维护赋值，添加sql语句就可以这样写；
insert into user(uid,username,password) values (null,&#39;1&#39;,&#39;1&#39;)
3.到时候，我们需要将javabean中封装的数据放在sql语句里面，uid能够自增，而且javabean为包装类型，默认值为null，这样不用单独维护uid的值，也不用给javabean中赋值，然后保存在数据库里面，咱们就可以使用uid的默认值
</code></pre>
<p><strong>多线程</strong></p>
<p>基础知识</p>
<pre><code>进程:在内存中执行的应用程序
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326212838603.png" alt="image-20240326212838603"></p>
<p>这里一个一个都是进程</p>
<pre><code>线程:进程中最小的执行单元
线程的作用:负责进程程序的运行
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240326213347771.png" alt="image-20240326213347771"></p>
<p>使用场景，耗时操作就需要多线程</p>
<p>  我们同时同时就可以多件事，这样的话提高了cpu的利用率 </p>
<p><strong>并发和并行</strong></p>
<pre><code>并行:在同一时刻，有多个执行在多个Cpu上同时运行
比如:多个厨师在同时炒多个菜
</code></pre>
<pre><code>并发:在同一时刻，有多个指令在单个Cpu上交替找执行
比如：一个厨师在同时超多个菜
</code></pre>
<p>就是之前说过的同步和异步的概念</p>
<pre><code>细节：
1.之前的cpu是单核，但是在执行多个程序好像是在同时执行，原因是CPU在多个线程之间做高速切换，比如2和4线程，那么CPU可以同时运行4个线程，此时不用切换，但是如果超过了，cPU就要切换了，cpu执行程序的时候，既有并发既有并行
</code></pre>
<p>CPU<strong>的调度</strong></p>
<pre><code>分时调度:是让所有的线程轮流CPU使用权，并且平均分配每个线程占用CPU的时间片
抢占调度:多个线程轮流抢占CPU的使用权，哪个线程抢到了，哪个线程先执行，优先级高的纪律比较大，
</code></pre>
<p>我们JAVA就是抢占式调度</p>
<p><strong>主线程</strong></p>
<p>就是main方法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327205244012.png" alt="image-20240327205244012"></p>
<p><strong>创建线程</strong></p>
<p><strong>第一种方法：继承Threads的类</strong></p>
<pre><code>1.定义一个类，继承Thread
2.重写run方法，在run方法中设置线程任务（所谓的线程任务指的就是此线程要执行 的具体代码）
3.创建自定义线程类的对象
4.调用Thread里的start的方法，开启线程，虚拟机自动调用run方法
</code></pre>
<p>例如</p>
<pre><code class="java">package lianxi_Thread;

public class MyThread extends Thread&#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 5; i++) &#123;
            System.out.println(&quot;Thread执行&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="Java">package lianxi_Thread;

public class Test &#123;
    public static void main(String[] args) &#123;
        //创建线程对象
        MyThread myThread = new MyThread();
//        调用start方法，开启线程，虚拟机自动调用run方法
        myThread.start();
        //主线程的任务
        for (int i = 0; i &lt; 5; i++) &#123;
            System.out.println(&quot;main&quot;+i);
        &#125;

    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327210425055.png" alt="image-20240327210425055"></p>
<p>输出和cpu的调度有关，哪个抢到执行权</p>
<p><strong>如果不开启线程，就是按照顺序执行的</strong></p>
<p><strong>多线程的运行原理</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327210754267.png" alt="image-20240327210754267"></p>
<p>当我们调用start的方法以后，就会在栈空间执行写在run方法里面的代码</p>
<p>注意</p>
<p><strong>start方法调用一次就可以</strong></p>
<p><strong>Thread的方法</strong></p>
<pre><code>void start() -&gt;开启线程自动调用run方法
void run() -&gt;设置线程任务，线程任务写在这里
String getName() -&gt;获取线程名字
void setName() -&gt;设置名字
static Thread currentThread() -&gt;获取正在执行的线程对象（此方法在哪个线程使用，获取的就是哪个线程对象）
static void sleep(long mills) -&gt;线程睡眠，设置时间，这个时间段里面，这个线程不会执行
</code></pre>
<p>例如</p>
<pre><code class="Java">package lianxi_Thread;

public class MyThread extends Thread&#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 100; i++) &#123;
            System.out.println(getName()+&quot;Thread&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package lianxi_Thread;

public class Test &#123;
    public static void main(String[] args) &#123;
        //创建线程对象
        MyThread myThread = new MyThread();
//        调用start方法，开启线程，虚拟机自动调用run方法
        myThread.setName(&quot;haha&quot;);
        myThread.start();
        for (int i = 0; i &lt; 100; i++) &#123;
            System.out.println(Thread.currentThread().getName()+&quot;main&quot;+i);
        &#125;

    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327212139128.png" alt="image-20240327212139128"></p>
<p><strong>前面就是我们的线程的名字</strong></p>
<p><strong>Thread.sleep</strong></p>
<pre><code class="Java">        MyThread myThread = new MyThread();
//        调用start方法，开启线程，虚拟机自动调用run方法
        myThread.setName(&quot;haha&quot;);
        myThread.start();
        try &#123;
            Thread.sleep(1000);
        &#125; catch (Exception e)&#123;
            System.out.println(e);
        &#125;
        for (int i = 0; i &lt; 100; i++) &#123;
            System.out.println(Thread.currentThread().getName()+&quot;main&quot;+i);
        &#125;
</code></pre>
<p>这里面还有一个问题</p>
<p>在其他的线程里面，不能使用throws向上抛出异常</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327212844355.png" alt="image-20240327212844355"></p>
<p>但是在主线程，可以抛出异常</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327212921665.png" alt="image-20240327212921665"></p>
<p>原因之前说过</p>
<pre><code class="java">public class MyThread extends Thread&#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 100; i++) &#123;
            Thread.sleep(1000);
            System.out.println(getName()+&quot;Thread&quot;+i);
        &#125;
    &#125;
&#125;
//因为上面run方法是重写父类的，但是父类没有抛这个异常，子类就不可以，所以只能使用try catch
</code></pre>
<p><strong>Thread的其他的方法</strong></p>
<pre><code class="Java">void setPriority(int newPriority) -&gt;线程的优先级，优先级越高的线程，抢到cpu使用率几率越大，
int getPriority()	-&gt;获取线程的优先级
void setDaemon(boolean on) -&gt;设置守护线程,当非守护线程执行完毕，守护线程就要结束
static void yield() -&gt;礼让线程让当前的线程让出cpu的使用权
void join() -&gt; 插入线程或者插队线程
</code></pre>
<pre><code>默认的优先级是5；
最小的优先级是1；
最大的优先级是10;
</code></pre>
<pre><code class="Java">MyThread myThread = new MyThread();
myThread.setName(&quot;线程1&quot;);
MyThread myThread1 = new MyThread();
myThread1.setName(&quot;线程2&quot;);


System.out.println(myThread1.getPriority());//5
System.out.println(myThread.getPriority());//5
myThread1.setPriority(1);
myThread.setPriority(10);

myThread1.start();
myThread.start();
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327221022276.png" alt="image-20240327221022276"></p>
<p>守护线程的使用</p>
<pre><code class="Java">package lianxi_Thread;

public class Test &#123;
    public static void main(String[] args)&#123;
        MyThread1 myThread1 = new MyThread1();
        myThread1.setName(&quot;线程1&quot;);
        MyThread2 myThread2 = new MyThread2();
        myThread2.setName(&quot;线程2&quot;);
        myThread1.setDaemon(true);
        myThread1.start();
        myThread2.start();
    &#125;
&#125;
</code></pre>
<pre><code class="Java">package lianxi_Thread;

public class MyThread1 extends Thread&#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 100; i++) &#123;
            System.out.println(getName()+&quot;:Thread&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package lianxi_Thread;

public class MyThread2 extends Thread&#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(getName()+&quot;:Thread&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code>守护线程设置100次循环，非守护线程设置10次，当我们的非守护线程执行完以后，守护线程就会停止
注意
守护线程不是立马结束的，当非守护线程执行完，会通知守护线程，这需要一点时间
</code></pre>
<p>使用场景</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327222327738.png" alt="image-20240327222327738"></p>
<p><strong>礼让线程</strong></p>
<pre><code>如果两个线程一起执行，可能执行一会a,在执行一会b，或者可能线程a执行完线程b在执行，那么如果我们想要均衡点，尽量让两个线程交替执行
</code></pre>
<pre><code class="Java">package lianxi_Thread;

public class MyThread1 extends Thread&#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(getName()+&quot;:Thread&quot;+i);
            Thread.yield();
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>注意只是尽可能的平衡，不是绝对的你来我往</strong></p>
<p><strong>插入线程</strong></p>
<p>就是插队</p>
<pre><code class="java">package lianxi_Thread;

public class Test &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        MyThread1 myThread1 = new MyThread1();
        myThread1.setName(&quot;线程1&quot;);

        myThread1.start();
        //表示把myThread1插入到当前的线程的前面。myThread1插在main线程之前
        myThread1.join();
        for (int i = 0; i &lt; 5; i++) &#123;
            System.out.println(&quot;main&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240327223353863.png" alt="image-20240327223353863"></p>
<p><strong>第二种方法实现Runnable接口</strong></p>
<pre><code>1.因为Thread里面的run方法是实现Runnable接口，所以我们直接实现Runnable的接口就可以了
</code></pre>
<pre><code>创建类，实现Runnable接口
重写Run方法，设置线程任务
利用Thread的构造方法，Thread有一个这样得到构造函数Thread(Runnable target),将自定义的类作为参数传递到Thread构造中
调用Thread的start的方法，虚拟机自动调用run
</code></pre>
<p>例子</p>
<pre><code class="Java">package wei_Runnable;

public class MyRunnable implements Runnable &#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
         System.out.println(Thread.currentThread().getName()+i);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package wei_Runnable;

public class Test &#123;
    public static void main(String[] args) &#123;
        MyRunnable r = new MyRunnable();
        Thread t =  new Thread(r);
        
        t.start();
        
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(Thread.currentThread().getName()+i);
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328083338637.png" alt="image-20240328083338637"></p>
<p><strong>两种方式的区别</strong></p>
<pre><code>继承的Thread的只能支持单继承，有继承的局限性，
实现接口，既可以继承父类还可以实现接口
</code></pre>
<p><strong>第三种方式匿名内部类创建多线程</strong></p>
<pre><code>严格的来说不是第三种方法，而是匿名内部类是建立在实现Runnable的接口的基础上
</code></pre>
<pre><code class="java">        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                for (int i = 0; i &lt; 10; i++) &#123;
                    System.out.println(Thread.currentThread().getName()+i);
                &#125;
            &#125;
        &#125;).start();
</code></pre>
<pre><code class="java">        Thread t1 = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                for (int i = 0; i &lt; 10; i++) &#123;
                    System.out.println(Thread.currentThread().getName()+i);
                &#125;
            &#125;
        &#125;);
        t1.start()
</code></pre>
<p>如果想取名</p>
<pre><code class="java">Thread(Runnable a, String name);使用这个构造函数
</code></pre>
<p><strong>线程安全问题</strong></p>
<pre><code>当多个线程访问一个资源的时候，就是之前解释为什么Js是单线程，就是因为害怕，多个线程操作同一个dom元素，就会出现问题
</code></pre>
<p>例如</p>
<pre><code class="java">package wei_Runnable;

public class  MyRunnable implements Runnable &#123;
    int ticket = 100;

    @Override
    public void run() &#123;
        while (true)&#123;
            if (ticket &gt; 0)&#123;
                System.out.println(Thread.currentThread().getName()+&quot;买了&quot;+ticket+&quot;票&quot;);
                ticket--;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package wei_Runnable;

public class Test &#123;
    public static void main(String[] args) &#123;
        MyRunnable r = new MyRunnable();
        Thread t1 =  new Thread(r,&quot;张三&quot;);
        Thread t2 =  new Thread(r,&quot;李四&quot;);
        Thread t3 =  new Thread(r,&quot;王五&quot;);

        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;
</code></pre>
<p>执行，我们就发现，三个线程访问同一个资源发生了问题</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328085213139.png" alt="image-20240328085213139"></p>
<pre><code>原因：CPU在多个线程做告诉切换导致的
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328085439813.png" alt="image-20240328085439813"></p>
<ul>
<li>我们把这个三个线程当作小红，小蓝和小绿，当我们小红抢到执行权，输出以后，还没有执行ticket–，就因为cpu的高速切换，导致小红停在那里，然后小兰执行，此时的票还是100；</li>
</ul>
<p>解决这个问题。<strong>抽象一点，我们可以上锁</strong></p>
<p><strong>使用同步代码块</strong></p>
<pre><code class="java">格式
synchronized(任意对象)&#123;
    线程出现不安全的地方
&#125;
2.任意对象就是我们的锁对象
3.执行特点，一个线程拿到锁以后，会进入到同步代码块，再次期间，其他的线程拿不到锁，就进不去同步代码块，需要等待执行的线程，执行完毕以后，出了同步代码块执行，相当于释放锁，等待的线程才能抢到锁
</code></pre>
<p>例如</p>
<pre><code class="java">public class  MyRunnable implements Runnable &#123;
    int ticket = 100;
    Object o = new Object();

    @Override
    public void run() &#123;
        while (true)&#123;
            synchronized (o)&#123;
                if (ticket &gt; 0)&#123;
                    System.out.println(Thread.currentThread().getName()+&quot;买了&quot;+ticket+&quot;票&quot;);
                    ticket--;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code>随便创建一个对象，然后把有线程问题的代码放在里面
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328091016832.png" alt="image-20240328091016832"></p>
<p>这样就不会出现买同一张的票的情况</p>
<p>注意</p>
<pre><code class="java">            synchronized (new Object())&#123;
                if (ticket &gt; 0)&#123;
                    System.out.println(Thread.currentThread().getName()+&quot;买了&quot;+ticket+&quot;票&quot;);
                    ticket--;
                &#125;
</code></pre>
<pre><code>不能直接在这里面创建锁对象，只能有一个锁对象，每当我们，创建线程，调用run方法，就会出来一个新的锁对象，记住只能有一个锁
</code></pre>
<p><strong>解决方法二 	普通同步方法</strong></p>
<p>1.非静态的</p>
<pre><code>格式
    修饰符 synchronize 返回值类型 方法名(参数)&#123;
    方法体
    return 结果
    &#125;
    默认的锁对象是this
</code></pre>
<p>例子</p>
<pre><code class="java">package wei_Runnable;

public class  MyRunnable implements Runnable &#123;
    int ticket = 100;

    @Override
    public void run() &#123;
        while (true)&#123;
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                throw new RuntimeException(e);
            &#125;
            func();
        &#125;
    &#125;
    public synchronized void func()&#123;
        if (ticket &gt; 0)&#123;
            System.out.println(Thread.currentThread().getName()+&quot;买了&quot;+ticket+&quot;票&quot;);
            ticket--;
        &#125;
    &#125;
&#125;
</code></pre>
<p>2.静态的同步方法</p>
<pre><code>格式
修饰符 static sychronized 返回值类型 方法(参数)&#123;
    方法体
    return 结果
&#125;
默认锁:class对象
</code></pre>
<pre><code class="java">package wei_Runnable;

public class  MyRunnable implements Runnable &#123;
    static int ticket = 100;

    @Override
    public void run() &#123;
        while (true)&#123;
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                throw new RuntimeException(e);
            &#125;
            func();
        &#125;
    &#125;
    public static synchronized void func()&#123;
        if (ticket &gt; 0)&#123;
            System.out.println(Thread.currentThread().getName()+&quot;买了&quot;+ticket+&quot;票&quot;);
            ticket--;
        &#125;
    &#125;
&#125;
</code></pre>
<p>之前说过StringBuilder是线程不安全的，StringBuffer是线程安全的</p>
<p>因为StringBuffer的底层源码</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328092416232.png" alt="image-20240328092416232"></p>
<p>都是同步方法</p>
<p><strong>死锁</strong></p>
<pre><code>指两个或者两个以上的线程在执行的过程中由于竞争同步锁，而产生的一种堵塞的情况；如果没有外力的作用，他们将无法继续执行下去，这种情况叫做死锁
</code></pre>
<p>就是如下图的情况</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328135449157.png" alt="image-20240328135449157"></p>
<p>例子</p>
<p>创建两个锁对象</p>
<pre><code class="java">package sisuo;

public class Lock1 &#123;
    public static Lock1 lock1 = new Lock1();
&#125;
</code></pre>
<pre><code class="java">package sisuo;

public class Lock2 &#123;
    public static Lock2 lock2 = new Lock2();
&#125;
</code></pre>
<pre><code class="java">package sisuo;

public class DieLock implements Runnable &#123;
    private Boolean flag;

    public DieLock(Boolean flag) &#123;
        this.flag = flag;
    &#125;

    @Override
    public void run() &#123;
        if (flag)&#123;
            synchronized (Lock1.lock1)&#123;
                System.out.println(&quot;if...Lock1&quot;);
                synchronized (Lock2.lock2)&#123;
                    System.out.println(&quot;else...Lock2&quot;);
                &#125;
            &#125;
        &#125; else &#123;
            synchronized (Lock2.lock2)&#123;
                System.out.println(&quot;if...Lock2&quot;);
                synchronized (Lock1.lock1)&#123;
                    System.out.println(&quot;else...Lock1&quot;);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package sisuo;

public class Test &#123;
    public static void main(String[] args) &#123;
        DieLock dieLock1 = new DieLock(true);
        DieLock dieLock2 = new DieLock(false);

        new Thread(dieLock1).start();
        new Thread(dieLock2).start();
    &#125;
&#125;
</code></pre>
<p>这是我们发现死锁了 </p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328141112921.png" alt="image-20240328141112921"></p>
<pre><code class="java">解释一下
当开启我们的两个线程，第一个线程进入
                synchronized (Lock1.lock1)&#123;
                System.out.println(&quot;if...Lock1&quot;);
                synchronized (Lock2.lock2)&#123;
                    System.out.println(&quot;else...Lock2&quot;);
                &#125;
            
   第二个线程进入
                   synchronized (Lock2.lock2)&#123;
                System.out.println(&quot;if...Lock2&quot;);
                synchronized (Lock1.lock1)&#123;
                    System.out.println(&quot;else...Lock1&quot;);
                &#125;
            &#125;
    但是第一个线程要进入我们的锁二的时候，锁二的执行权还在第二个线程，第二个线程必须得进入锁一才可以继续运行，这是就出现这个问题
</code></pre>
<ul>
<li>其实如果线程一执行的抢到执行权快的话，有可能把两个锁都给拿到</li>
</ul>
<pre><code>锁嵌套尽量要避免
</code></pre>
<p><strong>线程的生命周期</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328142105507.png" alt="image-20240328142105507"></p>
<p>sleep和wait的区别</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328142544754.png" alt="image-20240328142544754"></p>
<p>wait和notify</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328142857290.png" alt="image-20240328142857290"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328142905586.png" alt="image-20240328142905586"></p>
<p>而且注意</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240328143038677.png" alt="image-20240328143038677"></p>
<p><strong>等待唤醒</strong></p>
<pre><code>void wait()//线程等待过程中会释放锁，需要其他的其他的线程使用notify方法将其唤醒
void notify()//线程等待唤醒；如果有多条，随机唤醒一条
void notifyAll( )//唤醒所有的等待的线程
而且这些方法需要使用锁对象调用，所以需要用到同步代码块，而且必须是同一个锁对象
</code></pre>
<p>案例</p>
<pre><code>要求一个线程生产包子，一个线程吃包子，但是不能连续生产和消费，只能造一个吃一个
</code></pre>
<pre><code class="java">package baozipu;

public class Baozipu &#123;
    private int count;
    private boolean flag;

    public Baozipu(int count, Boolean flag) &#123;
        this.count = count;
        this.flag = flag;
    &#125;

    public Baozipu(Boolean flag) &#123;
        this.flag = flag;
    &#125;

    public Baozipu(int count) &#123;
        this.count = count;
    &#125;

    public Baozipu() &#123;
    &#125;

    public void getCount() &#123;
        System.out.println(&quot;消费了&quot;+count+&quot;包子&quot;);
    &#125;

    public void setCount() &#123;
        count++;
        System.out.println(&quot;生产了&quot;+count+&quot;包子&quot;);
    &#125;

    public Boolean getFlag() &#123;
        return flag;
    &#125;

    public void setFlag(Boolean flag) &#123;
        this.flag = flag;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package baozipu;

public class Consumer implements Runnable &#123;
    private Baozipu baozipu;

    public Consumer(Baozipu baozipu) &#123;
        this.baozipu = baozipu;
    &#125;

    @Override
    public void run() &#123;
        while(true)&#123;
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                throw new RuntimeException(e);
            &#125;
            //如果没有包子等待，让出线程给生产者
            synchronized (baozipu)&#123;
                if (baozipu.getFlag() == false)&#123;
                    try &#123;
                        baozipu.wait();
                    &#125; catch (InterruptedException e) &#123;
                        throw new RuntimeException(e);
                    &#125;
                &#125;
                //flag为false证明没有包子
                baozipu.getCount();
                //设置包子噗没有包子了
                baozipu.setFlag(false);
                //唤醒生产线程
                baozipu.notify();

            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package baozipu;

public class Product implements Runnable&#123;
    private Baozipu baozipu;

    public Product(Baozipu baozipu) &#123;
        this.baozipu = baozipu;
    &#125;

    @Override
    public void run() &#123;
        while(true)&#123;
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                throw new RuntimeException(e);
            &#125;
            //如果有包子让出线程给消费者
            synchronized (baozipu)&#123;
                if (baozipu.getFlag() == true)&#123;
                    try &#123;
                        baozipu.wait();
                    &#125; catch (InterruptedException e) &#123;
                        throw new RuntimeException(e);
                    &#125;
                &#125;
                //flag为false证明没有包子，生产包子
                baozipu.setCount();
                //生产完证明有包子
                baozipu.setFlag(true);
                //唤醒生产线程
                baozipu.notify();

            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package baozipu;

public class Test &#123;
    public static void main(String[] args) &#123;
        Baozipu baozipu = new Baozipu();

        Product product = new Product(baozipu);
        Consumer consumer = new Consumer(baozipu);


        new Thread(product).start();
        new Thread(consumer).start();
    &#125;
&#125;
</code></pre>
<p><strong>第二中解决线程不安全Lock锁</strong></p>
<pre><code>1.Lock是一个接口
2.实现类:ReaentrantLock
3.方法:
lock() //获得锁
unlock()//释放锁
</code></pre>
<p>使用</p>
<pre><code class="java">package wei_Runnable;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class  MyRunnable implements Runnable &#123;
    static int ticket = 100;
    Lock lock = new ReentrantLock();
    @Override
    public void run() &#123;
        while (true)&#123;
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                throw new RuntimeException(e);
            &#125;
            //获得锁
            lock.lock();
            if (ticket &gt; 0) &#123;
                System.out.println(Thread.currentThread().getName() + &quot;买了&quot; + ticket + &quot;票&quot;);
                ticket--;
            &#125;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<p>不管我们if里面是否发生了错误，我们都应该执行释放锁，所以我们可以包裹try catch然后用finally放释放锁的</p>
<p>有什么区别呢和synchronize</p>
<pre><code>synchronize:不管是同步代码还是同步方法，都需要在结束一对&#123;&#125;之后，释放锁对象
Lock,通过两个方法控制
</code></pre>
<p><strong>Callable接口</strong></p>
<pre><code>之前实现多线程继承Thread或者实现Runnable
第三种就是实现Callable接口
方法
 v call()-&gt;设置线程任务，类似于Run方法
 call和run方法的区别
 相同点：都是设置线程任务的
 不同点：call方法有返回值，而且有异常可以throws
         run方法没有返回值，而且有异常不可以throws
&lt;V&gt;
 叫做泛型，用于指定我们操作什么类型的数据 ，而且尖括号里面只能写引用数据类型，如果泛型不写默认是Object的数据
 实习Callable方法接口的时候，指定泛型是什么类型，重写的call方法的返回值就是什么类型的
 
 
 获取call方法的会返回值：FutureTask
 a.FutureTask&lt;V&gt;//实现一个接口FutureTask&lt;T&gt;
 b.FutureTask&lt;V&gt;有一个方法
     V get()//获取call的返回值 
</code></pre>
<p>使用</p>
<pre><code class="java">package chenw_callable;

import java.util.concurrent.Callable;

public class MyCallable implements Callable&lt;Integer&gt; &#123;
    @Override
    public Integer call() throws Exception &#123;
        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package chenw_callable;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class Test &#123;
    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        MyCallable myCallable = new MyCallable();
        FutureTask&lt;Integer&gt; integerFutureTask = new FutureTask&lt;&gt;(myCallable);
        //创建Thread对象-》
        Thread thread = new Thread(integerFutureTask);
        thread.start();
        //调用get方法获取call方法的返回值
        System.out.println(integerFutureTask.get());
    &#125;
&#125;
</code></pre>
<p><strong>线程池</strong></p>
<p><strong>实现多线程的方式之一</strong></p>
<pre><code>之前来一个线程任务，就需要创建一个线程对象去执行,用完还要销毁线程对象,如果线程任务多了，就要需要频繁创建线程对象和销毁对象，这样耗费内存资源，所以我们线程对象能不能循环利用，用的时候直接拿线程对象，用完还回去 
</code></pre>
<pre><code>创建线程池对象，指定池子最多有多少条线程对象
来了第一个线程任务，看池子中有没有线程对象，如果没有，创建线程对象，给现场任务用，用完还回去
</code></pre>
<p>使用</p>
<pre><code>创建线程池:用具类-&gt;Excutors
2.获取线程池对象Excutors中的静态方法
static ExcutorService newFindedThreadPool(int nThreads)
参数指定：指定线程池中最多的线程对象条数
返回值ExecutorService是线程池，用来管理线程对象
执行线程任务:ExecutorService 中的方法
Future&lt;?&gt; submit(Runnable task)//提交一个runnable的任务
Future&lt;?&gt; submit(callable&lt;T&gt; task)//提交一盒callable执行
4.submit的返回值：future接口
    用于接收run方法或者call方法的返回值，但是run方法没有返回值，所以可以不用Future接收，执行call方法需要Future进行接收
     Future里面有一个
     V get()，用于接受call方法的返回值
     
5.ExcutorService里面的方法：
    void shutdown()  关闭线程池，不会接受新的线程任务
</code></pre>
<p>例子</p>
<pre><code class="java">package wei_ThreadPool;

public class MyRunnable implements Runnable&#123;
    @Override
    public void run() &#123;
        System.out.println(Thread.currentThread().getName()+&quot;执行了&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package wei_ThreadPool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Test &#123;
    public static void main(String[] args) &#123;
        ExecutorService es= Executors.newFixedThreadPool(2);
        es.submit(new MyRunnable());
        es.submit(new MyRunnable());
        es.submit(new MyRunnable());
        es.shutdown();//关闭线程池
    &#125;
&#125;
</code></pre>
<p>执行结果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240329170346929.png" alt="image-20240329170346929"></p>
<pre><code>因为我们创建两个线程，所以当我们提交的第三个任务以后，首先线程池里面的线程1，2分别就会执行任务1和任务2，当我们其中的一个任务执行完以后，那么执行完以后的线程就会执行任务三
</code></pre>
<p>使用callable的方法实现</p>
<pre><code class="java">package wei_ThreadPool;

import java.util.concurrent.Callable;

public class MyCallable implements Callable &#123;
    @Override
    public Integer call() throws Exception &#123;
        return 1;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package wei_ThreadPool;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Test1 &#123;
    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        Future&lt;Object&gt; future=executorService.submit(new MyCallable());//call方法就会有返回值，我们可以看使用Future进行接受
        System.out.println(future.get());
        System.out.println();

    &#125;
&#125;
</code></pre>
<pre><code>因为call方法有返回值，所以我们可以使用future进行接受	
</code></pre>
<pre><code>练习设置线程池为2，一个线程输出字符串，一个线程求总和
</code></pre>
<pre><code class="Java">package ThreadPool_pratice;

import java.util.concurrent.Callable;

public class PrintString implements Callable&lt;String&gt; &#123;
    @Override
    public String call() throws Exception &#123;
        return &quot;那一夜你伤害了我&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="Java">package ThreadPool_pratice;

import java.util.concurrent.Callable;

public class PrintSum implements Callable&lt;Integer&gt; &#123;
    @Override
    public Integer call() throws Exception &#123;
        int sum = 0;
        for (int i = 0; i &lt; 100; i++) &#123;
            sum +=i;
        &#125;
        return sum;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package ThreadPool_pratice;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Test &#123;
    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        Future&lt;String&gt; future1=executorService.submit(new PrintString());
        Future&lt;Integer&gt; future2 = executorService.submit(new PrintSum());
        System.out.println(future1.get());
        System.out.println(future2.get());
        executorService.shutdown();
    &#125;
&#125;
</code></pre>
<p><strong>定时器Timer</strong></p>
<pre><code>构造
 Timer();//空参构造
方法
void schedule(TimeTask task,Data firstTime,long period)
    task:抽线类，是Runable的实现类
    firstTime:从什么时间开始执行
    period:每个多长时间执行一次，设置的是毫秒值
</code></pre>
<p>例子，使用匿名内部类</p>
<pre><code class="java">public class Demo &#123;
    public static void main(String[] args) &#123;
        Timer timer = new Timer();
        timer.schedule(new TimerTask() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;金莲对我说&quot;);
            &#125;
        &#125;,new Date(),2000);
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240329173026063.png" alt="image-20240329173026063"></p>
<p>这样每隔2秒就会执行</p>
<ul>
<li>这里面的timer就相当于js里面的setTimenter</li>
</ul>
<p><strong>复习</strong></p>
<p><strong>集合</strong></p>
<p><strong>collection集合</strong></p>
<p><strong>单列集合框架</strong></p>
<pre><code>1.之前学过保存数据的有：变量，数组，但是数组定长，所以如果添加一个数据或者删除一个数据就要创建一个新的数组，所以学一个长度可变，就是集合
集合的特点
 只能保存引入数据类型的数据（如果传入的是基本的数据类型，就会对应的包装成相应的包装类）
 长度是可变的
 集合有大量的方法
分类
    单列集合:一个元素就一个组成部分list.add(value)
    双列集合：一个集合有两个部分构成:key和value，例如map.put(key,value)
</code></pre>
<ul>
<li>单列集合的顶级接口是Collection接口</li>
</ul>
<p>  <img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240329181611468.png" alt="image-20240329181611468"></p>
<ul>
<li><p>list有三个实现类</p>
<ul>
<li>ArrayList:<ul>
<li>元素是有序的，按照什么顺序存的输出也是什么顺序</li>
<li>元素是可以重复的</li>
<li>每一个元素都有对应的索引</li>
<li>线程不安全</li>
<li>底层数据结构是数组，但是长度是可变的</li>
</ul>
</li>
<li>LikedList<ul>
<li>元素有序</li>
<li>元素可重复</li>
<li>有索引</li>
<li>线程不安全</li>
<li>底层数据结构：双向链表</li>
</ul>
</li>
<li>Vector<ul>
<li>元素有序</li>
<li>元素可以重复</li>
<li>有索引</li>
<li>线程安全 效率比较低</li>
<li>底层数据结构：数组</li>
</ul>
</li>
</ul>
</li>
<li><p>set接口有三个实现类</p>
<ul>
<li>HashSet<ul>
<li>元素无序</li>
<li>元素唯一</li>
<li>没有索引</li>
<li>线程不安全</li>
<li>底层数据结构哈希表</li>
</ul>
</li>
<li>LikedSet(<strong>继承于HashSet</strong>)<ul>
<li>继承与HashSet，其他的特点一致，但是他的元素是有序的</li>
<li>有序的原因是：他的底层结构是哈希表加上双向链表</li>
</ul>
</li>
<li>treeSet<ul>
<li>可以对元素进行排序</li>
<li>元素唯一</li>
<li>没有索引</li>
<li>线程不安全</li>
<li>底层数据结构<ul>
<li>红黑树</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>集合的框架</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240330161805160.png" alt="image-20240330161805160"></p>
<ul>
<li>LinkList本质上没有索引，但是java为其提供很多根据索引操作元素的方法</li>
</ul>
<p><strong>Collection接口</strong></p>
<pre><code>1.单列集合的顶级接口
2.使用:
    Collection&lt;E&gt; 对象名 = new 实现类对象&lt;E&gt;()
    E是泛型，决定集合中能够存储什么类型的数据，可以统一元素类型
    泛型中只能写引用数据类型，如果不写默认Object，这样所有的数据类型都可以存储
    注意之前说过，集合里面的数据类型是引用数据类型，就是因为泛型的原因
    &lt;Integer&gt;这样存储的就数字
这里的泛型的细节：
    我们等号前面的泛型必须写，等号后面的泛型可以不写，jvm里面有一段话，可推导的代码，就可以省略
常用代码
    boolean add(E e):将给定的元素添加到当前集合中（我们一般调用add的时候，不用boolean，因为add一定成功）
    boolean addAll(Colleaction&lt;? extend E&gt; c):将另一个集合元素添加到当前的集合中
    void clear():清除集合中的所有元素
    boolean contains(object o)//判断当前的集合是否有该元素
    boolean isEmpty()判断当前集合是否有元素
    boolean remove(object o)将指定的元素从集合中删去
    int size()返回集合的元素个数
    Object[] toArray()  将集合的元素储存在数组中
</code></pre>
<p>例子</p>
<pre><code class="Java">package wei_Collection;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Objects;

public class Test &#123;
    public static void main(String[] args) &#123;
        Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();
        collection.add(&quot;消炎&quot;);
        collection.add(&quot;小云儿&quot;);
        System.out.println(collection);//[消炎, 小云儿]

        Collection&lt;String&gt; collection1 = new ArrayList&lt;&gt;();
        collection1.add(&quot;zhang&quot;);
        collection1.add(&quot;wu&quot;);
        collection1.add(&quot;ji&quot;);
        collection.addAll(collection1);
        System.out.println(collection);//[消炎, 小云儿, zhang, wu, ji]

        collection1.clear();
        System.out.println(collection1);//[]

        System.out.println(collection.contains(&quot;zhang&quot;));//true

        System.out.println(collection1.isEmpty());//true

        collection.remove(&quot;zhang&quot;);
        System.out.println(collection);//[消炎, 小云儿, wu, ji]

        System.out.println(collection.size());//4

        Object[] arr = collection.toArray();
        System.out.println(Arrays.toString(arr));//[消炎, 小云儿, wu, ji]
    &#125;
&#125;
</code></pre>
<p><strong>迭代器</strong></p>
<pre><code>概述Interator
主要作用：Collection中的方法获取
Interator&lt;E&gt; interator()
方法
boolean hasNext() -&gt;判断集合有没有下一个元素
E next() -&gt;获取下一个元素
</code></pre>
<pre><code class="java">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;haha&quot;);
        list.add(&quot;nihao&quot;);
        Iterator&lt;String&gt; iterator = list.iterator();
        while(iterator.hasNext())&#123;
            System.out.println(iterator.next());//haha//nihao
        &#125;
</code></pre>
<p><strong>迭代器迭代过程</strong></p>
<p><strong>迭代器原理分析</strong></p>
<pre><code class="Java">Iterator是一个接口，等号右边一定是他的实现类对象
问题 Interator接受的到底是哪个实现类对象呢？-》ArrayList的是Itr对象
    public Iterator&lt;E&gt; iterator() &#123;
        return new Itr();
    &#125;
    private class Itr implements Iterator&lt;E&gt;
</code></pre>
<p><strong>并发修改异常</strong></p>
<p><strong>ConcurrentModificationException</strong></p>
<p>出现异常的原因</p>
<pre><code class="java">ArrayList&lt;String&gt; xiyou = new ArrayList&lt;&gt;();
xiyou.add(&quot;猪八戒&quot;);
xiyou.add(&quot;孙悟空&quot;);
xiyou.add(&quot;沙僧&quot;);
xiyou.add(&quot;白龙马&quot;);
Iterator&lt;String&gt; iterator1 = xiyou.iterator();
while (iterator1.hasNext())&#123;
    String item = iterator1.next();
    if (Objects.equals(item,&quot;猪八戒&quot;))&#123;
        xiyou.add(&quot;haha&quot;);
    &#125;
&#125;
</code></pre>
<p>这个出现的原因</p>
<p>发现问题出现在这里</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240330192316090.png" alt="image-20240330192316090"></p>
<p>我们查看一下底层的源码</p>
<pre><code class="java">在我们执行
        Iterator&lt;String&gt; iterator1 = xiyou.iterator();
这句话的时候，下面的关键的代码
    当我们创建迭代器对象的的时候初始化，实际操作次数和预期操作次数相等
    modCount是实际操作次数
    expectedModCount 是预期的操作次数
    private class Itr implements Iterator&lt;E&gt; &#123;
        int expectedModCount = modCount;
        public E next() &#123;
            checkForComodification();
        &#125;
        我们再看checkForComodification函数，这里在判断预期次数和实际次数是否相等，不相等抛出异常
     final void checkForComodification() &#123;
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        &#125;
        再看add方法，这里面使得我们的实际的操作次数++，而且这个不会赋给预期操作次数，因为初始化的时候才会赋值，这样就就会使得我们的预期操作次数和实际操作次数不相等，
     public boolean add(E e) &#123;
        modCount++;
        add(e, elementData, size);
        return true;
    &#125;
</code></pre>
<ul>
<li>结论我们调用add方法，而add方法底层只给modcount++ 但是在调用next并没有给修改的后的modcount赋给expectmodcout导致这个问题</li>
</ul>
<p>解决的方法</p>
<p>listInterator</p>
<pre><code class="Java">ArrayList&lt;String&gt; xiyou = new ArrayList&lt;&gt;();
xiyou.add(&quot;猪八戒&quot;);
xiyou.add(&quot;孙悟空&quot;);
xiyou.add(&quot;沙僧&quot;);
xiyou.add(&quot;白龙马&quot;);
ListIterator&lt;String&gt; iterator1 = xiyou.listIterator();
while (iterator1.hasNext())&#123;
    String item = iterator1.next();
    if (Objects.equals(item,&quot;猪八戒&quot;))&#123;
        iterator1.add(&quot;haha&quot;);
    &#125;
&#125;
System.out.println(xiyou);//[猪八戒, haha, 孙悟空, 沙僧, 白龙马]
</code></pre>
<ul>
<li>使用迭代器的时候不要修改数据的长度</li>
</ul>
<p><strong>数据结构</strong></p>
<pre><code>数据结构是一种具有一定逻辑关系	，在计算机中应用某种储存结构，并且封装了相应操作的数据元素集合，他还包含三方面内容，逻辑关系，存储关系和操作
</code></pre>
<p><strong>为什么需要数据结构</strong></p>
<pre><code>随着程序的变得更复杂还丰富，几百万的数据就会出现，面对这么打的数据进行搜素，插入，或者排序操作越来越慢，数据结构就是解决这种问题
</code></pre>
<p><strong>栈结构</strong></p>
<pre><code>特点:
    先进后出：例如手枪压子弹
好处:
</code></pre>
<p><strong>队列</strong></p>
<pre><code>特点：先进先出
例如:过安检
</code></pre>
<p><strong>数组</strong></p>
<pre><code>特点：有索引，所以查询快，增删慢
查询快因为有索引，我们可以通过索引操作元素
增删慢的原因
    添加删除元素：创建新数组，将老数组复制到新数组
</code></pre>
<p><strong>链表</strong></p>
<pre><code>在集合中涉及两种链表
单项链表
    节点：一个节点分为两部分
    第一部分：数据域（存数据）
    第二部分：指针域（保存下一个节点地址）
    特点：前面的节点记录后面节点的地址，后面的节点地址不记录前面节点的地址
双向链表
    分为三部分
    第一部分：指针域（保存上一个节点的地址）
    第二个部分：数据域（保存的数据）
    第三部分：指针域（保存下一个节点地址）
    特点 查询慢增删快
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240330201444471.png" alt="image-20240330201444471"></p>
<p><strong>List接口</strong></p>
<pre><code>Collection的子接口
常见的实现类
    ArrayLink,LinkedList Vector
方法
 前面的Colection的方法都试用
 void add(int index,)
 E remove(int index)//根据索引移除
 E set(int index ,E element)//将指定的索引位置上的元素，修改为后面的元素,返回值是替换的元素
 E Get(int index,E element) //根据索引获取元素
</code></pre>
<p>遍历的快捷键</p>
<pre><code>集合名+fori
</code></pre>
<p>但是还有一个问题</p>
<p>remove可以根据索引进行删除,如果这样就会出现歧义，remove可以根据索引删除</p>
<pre><code class="java">        ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();
        list1.add(1);
        list1.remove(1);
</code></pre>
<p>就会出现越界异常</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240330211721790.png" alt="image-20240330211721790"></p>
<ul>
<li><p>注意如果传递整数2在remove，remove就会默认根据索引值进行删除，我们解决这个可以把他包装成包装类</p>
<p>例如</p>
<pre><code class="Java">ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();
list1.add(1);
Integer a = 1;
list1.remove(a);
System.out.println(list1);//[]
</code></pre>
</li>
</ul>
<p>或者</p>
<pre><code class="java">ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();
list1.add(1);
list1.remove(Integer.valueOf(1));
System.out.println(list1);//[]
</code></pre>
<pre><code>ArrayList的构造方法
    a.arrayList() 构造初始容量为10的空列表。不是在构造的时候，而是在add的时候
    b.ArrayList(int initialCapacity) //指定初始容量
</code></pre>
<p><strong>LnkedList的使用</strong>	</p>
<pre><code>LinkedList是实现List的接口
底层的数据结构:双向链表：
方法：有大量操作首尾元素的方法
    public void addFirst(E e)将指定的元素插入此列表的开头
    public void addLast(E e)将指定的元素插入此列表的末尾
    public E getFirst()//返回此列表的第一个元素
    public E getLast()//返回此列表的最后一个元素
    public E removeFirst() 移除并且返回数组的第一个元素
    public E removeLast() 移除并且返回数组的最后一个元素
    public E pop()从此列表所表示的堆栈中弹出第一个元素
    public void push(E e)将元素推入此列表所表示的堆栈中
    public boolean isEmpty();如果此列表没有元素，那么返回true
</code></pre>
<p>使用</p>
<pre><code class="java">        LinkedList&lt;String&gt; strings = new LinkedList&lt;&gt;();
        strings.add(&quot;吕布&quot;);
        strings.add(&quot;关羽&quot;);
        strings.add(&quot;曹操&quot;);
        System.out.println(strings);//[吕布, 关羽, 曹操]
        strings.addFirst(&quot;刘备&quot;);
        System.out.println(strings);//[刘备, 吕布, 关羽, 曹操]
        Iterator&lt;String&gt; iterator2 = strings.iterator();
        while (iterator2.hasNext())&#123;
            System.out.println(iterator2.next());
        &#125;
        for (int i = 0; i &lt; strings.size(); i++) &#123;
            System.out.println(strings.get(i));
        &#125;
</code></pre>
<pre><code class="java">        LinkedList&lt;String&gt; strings1 = new LinkedList&lt;&gt;();
        strings1.add(&quot;吕布&quot;);
        strings1.add(&quot;关羽&quot;);
        strings1.add(&quot;曹操&quot;);
        System.out.println(strings1);//[吕布, 关羽, 曹操]
        strings1.pop();
        System.out.println(strings1);//[关羽, 曹操]删除第一个元素
        strings1.push(&quot;haha&quot;);
        System.out.println(strings1);//添加第一个元素[haha, 关羽, 曹操]
</code></pre>
<p><strong>增强for</strong></p>
<p><strong>基本使用</strong></p>
<p>格式for(元素类型 变量名:要遍历的集合名或者数组名){}</p>
<p>快捷键</p>
<pre><code>列表.for
</code></pre>
<pre><code class="java">        for (String s : strings1) &#123;
            System.out.println(s);
        &#125;
</code></pre>
<pre><code>增强for遍历集合的时候，底层实现原理为迭代器
增强for遍历数组时候，底层实现原理为普通for
</code></pre>
<p><strong>集合工具类</strong></p>
<pre><code>概述：集合工具类
特点：
    构造私有
    方法都是静态的
使用：类名直接调用
</code></pre>
<pre><code>static &lt;T&gt; void sort(list&lt;T&gt; list,Comparator&lt;? super T&gt; C)--》将集合中的数组按照指定的规则进行排序
这里面的参数 Comparator比较器
    方法:
        int compare(T 01,T 02)
        o1-o2 -&gt;升序
        02-o1 -&gt;降序
</code></pre>
<pre><code class="java">ArrayList&lt;String&gt; list3 = new ArrayList&lt;&gt;();
Collections.addAll(list3,&quot;zangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;);//第一个为需要添加的列表
System.out.println(list3);//[zangsan, lisi, wangwu]
Collections.shuffle(list3);
System.out.println(list3);//[lisi, zangsan, wangwu]

ArrayList&lt;String&gt; list4 = new ArrayList&lt;&gt;();
Collections.addAll(list4,&quot;b.wang&quot;,&quot;a.wang&quot;,&quot;c.wang&quot;);
System.out.println(list4);//[b.wang, a.wang, c.wang]
Collections.sort(list4);
System.out.println(list4);//[a.wang, b.wang, c.wang],按照第一个字符的acill
</code></pre>
<p>如果我们对对象进行排序</p>
<pre><code class="Java">新建一个Person的类
        ArrayList&lt;Person&gt; peoples = new ArrayList&lt;&gt;();
    Collections.addAll(peoples,new Person(&quot;wang&quot;,18),new Person(&quot;王昌晨&quot;,18));
    Collections.sort(peoples);
</code></pre>
<p>这样就会报错</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240331153747135.png" alt="image-20240331153747135"></p>
<p>我们对象的比较就可以这样写</p>
<p>创建匿名类，然后重写compare方法，然后再根据类中的年龄进行升序排列</p>
<pre><code class="java">ArrayList&lt;Person&gt; peoples = new ArrayList&lt;&gt;();
Collections.addAll(peoples,new Person(&quot;wang&quot;,18),new Person(&quot;王昌晨&quot;,18));
Collections.sort(peoples, new Comparator&lt;Person&gt;() &#123;
    @Override
    public int compare(Person o1, Person o2) &#123;
        return o1.getAge()-o2.getAge();
    &#125;
&#125;);
</code></pre>
<pre><code class="Java">ArrayList&lt;Person&gt; peoples = new ArrayList&lt;&gt;();
Collections.addAll(peoples,new Person(&quot;wang&quot;,18),new Person(&quot;王昌晨&quot;,13));
Collections.sort(peoples, new Comparator&lt;Person&gt;() &#123;
    @Override
    public int compare(Person o1, Person o2) &#123;
        return o1.getAge()-o2.getAge();
    &#125;
&#125;);
System.out.println(peoples);//[wei__s.Person&#123;name=&#39;王昌晨&#39;, age=13&#125;, wei__s.Person&#123;name=&#39;wang&#39;, age=18&#125;]
</code></pre>
<p>或者我们在列表中的类实现compare接口</p>
<pre><code class="java">package wei__s;

public class Student implements Comparable&lt;Student&gt; &#123;
    private String name;
    private int age;

    public Student(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    public Student(int age) &#123;
        this.age = age;
    &#125;

    public Student(String name) &#123;
        this.name = name;
    &#125;
    public Student() &#123;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;wei__s.Stdent&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;

    @Override
    public int compareTo(Student o) &#123;
        return this.age - o.age; //this-o升序，o - this是降序
    &#125;
&#125;
</code></pre>
<pre><code class="Java">ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;();
Collections.addAll(students,new Student(&quot;许兴航&quot;,18),new Student(&quot;王昌晨&quot;,16));
Collections.sort(students);
System.out.println(students);//[wei__s.Stdent&#123;name=&#39;王昌晨&#39;, age=16&#125;, wei__s.Stdent&#123;name=&#39;许兴航&#39;, age=18&#125;]
</code></pre>
<p><strong>这样就不需要sort的第二个参数</strong></p>
<pre><code>总结Collections的工具类
addAll()//向列表添加多个元素
shuff()//进行打乱排序
sort()//进行排序，第二个参数可以是Comparable类的实现，进行排序规则
</code></pre>
<p>这里在复习一下js的排序</p>
<pre><code class="java">基本用法：
javascript
let fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];
fruits.sort();
// fruits 现在是 [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Mango&quot;, &quot;Orange&quot;]
比较函数：
如果要按照特定的顺序进行排序，或者对数字进行排序，可以提供一个比较函数。

如果比较函数返回负值，则 a 在 b 前面。
如果比较函数返回正值，则 b 在 a 前面。
如果比较函数返回 0，则 a 和 b 保持不变。
对数字进行排序：
javascript
let numbers = [4, 2, 5, 1, 3];
numbers.sort(function(a, b) &#123;
    return a - b;
&#125;);
// numbers 现在是 [1, 2, 3, 4, 5]
对对象数组进行排序：
javascript
let students = [
    &#123; name: &quot;Alice&quot;, age: 20 &#125;,
    &#123; name: &quot;Bob&quot;, age: 25 &#125;,
    &#123; name: &quot;Charlie&quot;, age: 18 &#125;
];
students.sort(function(a, b) &#123;
    return a.age - b.age;
&#125;);
// students 现在是按照年龄升序排序的数组
</code></pre>
<p><strong>泛型</strong></p>
<pre><code>泛型:&lt;&gt;
作用；
    统一数据类型，防止将来的数据转换异常
注意
    泛型中的数据类型必须是引用数据类型
    如果泛型的数据类型不写的话。默认的数据类类型是object类型的
</code></pre>
<ul>
<li>为什么使用<ul>
<li>统一数据类型，防止数据转换异常</li>
<li>定义带泛型的类，方法，将来使用的时候给泛型确定什么类型，泛型就会变成什么类型，凡是涉及泛型的都会变成的确定的代码，代码更加灵活</li>
</ul>
</li>
</ul>
<p><strong>定义含有泛型的类</strong></p>
<pre><code>定义：
public class 类名&lt;E&gt;&#123;

&#125;

在new对象的时候确定类型
</code></pre>
<p><strong>含有泛型的方法</strong></p>
<pre><code>格式
    修饰符 &lt;E&gt; 返回值类型 方法名(E e)
什么时候确定类型
    调用的时候确定类型
</code></pre>
<hr>
<p><strong>现在说一下Java里的可变参</strong></p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        printNumbers(1, 2, 3);
        printNumbers(4, 5, 6, 7, 8);
        printNumbers(); // 无参数调用
    &#125;
    
    public static void printNumbers(int... numbers) &#123;
        System.out.println(&quot;Printing numbers:&quot;);
        for (int number : numbers) &#123;
            System.out.println(number);
        &#125;
    &#125;
&#125;
</code></pre>
<hr></hr>

<p>现在可以使用泛型的函数，例如实现addAll函数</p>
<pre><code class="java">package wei_genericity;

import java.util.ArrayList;

public class Wei_addAll &#123;
    public static &lt;E&gt; void AddAll(ArrayList&lt;E&gt; list,E...e)&#123;
        for (E element : e) &#123;
            list.add(element);
        &#125;
    &#125;
&#125;
</code></pre>
<hr></hr>

<pre><code class="java">package wei_genericity;

import java.util.ArrayList;

public class Test &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();
        Wei_addAll.AddAll(strings,&quot;wang&quot;,&quot;wwer&quot;,&quot;haha&quot;);
        System.out.println(strings);//[wang, wwer, haha]
    &#125;
&#125;
</code></pre>
<hr></hr>

<p><strong>含有泛型的接口</strong></p>
<pre><code>格式:
    public interface 接口名&lt;E&gt;&#123;
    
    &#125;
什么时候确定类型
    在实现类的时候还没有确定类型，只能在new实现类的时候确定类型 --》ArrayList
</code></pre>
<p><strong>在创建对象的确定类型</strong></p>
<p>接口</p>
<pre><code class="java">package wei_genericity;

public interface MyList&lt;E&gt;  &#123;
    public boolean add(E e);
&#125;
</code></pre>
<p>实现类，注意类名的后面也要加泛型</p>
<pre><code class="java">package wei_genericity;
import java.util.Arrays;

public class Wei_Interface&lt;E&gt; implements MyList&lt;E&gt; &#123;
    Object[] obj = new Object[10];
    int size;
    @Override
    public boolean add(E e)&#123;
        obj[size] = e;
        size ++;
        return true;
    &#125;
    public E get(int index)&#123;return (E) obj[index];&#125;

    @Override
    public String toString() &#123;
        return &quot;Wei_Interface&#123;&quot; +
                &quot;obj=&quot; + Arrays.toString(obj) +
                &quot;, size=&quot; + size +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>测试的主程序</p>
<pre><code class="java">package wei_genericity;

public class MyTest &#123;
    public static void main(String[] args) &#123;
        Wei_Interface&lt;String&gt; list = new Wei_Interface&lt;&gt;();
        list.add(&quot;李家乐真帅&quot;);
        list.add(&quot;李四真帅&quot;);
        System.out.println(list.get(0));//李家乐真帅
        System.out.println(list.get(1));//李四真帅
    &#125;
&#125;
</code></pre>
<p><strong>实现类的时候确定类型</strong></p>
<p>接口</p>
<pre><code class="java">package wei_genericity;

public interface Myinter&lt;E&gt; &#123;
    E next();
&#125;
</code></pre>
<p>实现接口的类，在实现接口的时候确定类型</p>
<pre><code class="java">package wei_genericity;

public class Myscanner implements Myinter&lt;String&gt;  &#123;
    @Override
    public String next() &#123;
        return &quot;王昌晨&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">        Myscanner myscanner = new Myscanner();
        System.out.println(myscanner.next());//王昌晨
</code></pre>
<p><strong>泛型的通配符</strong></p>
<p>当我们实现这样</p>
<pre><code class="java">package wei_genericity;

import java.util.ArrayList;
import java.util.Collections;

public class Test &#123;
    public static &lt;E&gt; void method(ArrayList&lt;E&gt; list)&#123;
        for (E e : list) &#123;
            System.out.println(e);
        &#125;
    &#125;
    public static void main(String[] args) &#123;
 ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;();
        Collections.addAll(list1,&quot;wang&quot;,&quot;wangchang&quot;,&quot;wangchangchen&quot;);

        ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();
        Collections.addAll(list2,1,2,3,4);

        method(list1);
        method(list2);

    &#125;
&#125;
</code></pre>
<p>或者直接使用泛型的通配符</p>
<pre><code class="java">package wei_genericity;

import java.util.ArrayList;
import java.util.Collections;

public class Test &#123;
    public static  void method(ArrayList&lt;?&gt; list)&#123;
        for (Object o : list) &#123;
            System.out.println(list);
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;();
        Collections.addAll(list1,&quot;wang&quot;,&quot;wangchang&quot;,&quot;wangchangchen&quot;);

        ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();
        Collections.addAll(list2,1,2,3,4);

        method(list1);
        method(list2);

    &#125;
&#125;
</code></pre>
<p><strong>泛型的上限和下限</strong></p>
<pre><code>作用:规定泛型的范围
上线:
    格式:&lt;? extends 类型&gt;
    含义：？只能接受extends后面的本类类型及子类类型
下线
    格式:&lt;? super 类型&gt;
    含义:?只能接受super后面的本类类型以及父类类型
</code></pre>
<p>例如</p>
<pre><code class="java">    public static void get1(Collection&lt;? extends Number&gt; collection)&#123;

    &#125;
    public static void get2(Collection&lt;? super Number&gt; collection)&#123;

    &#125;
————————————————————————————————————————————————-------------
        ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;();
        ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();
        ArrayList&lt;Object&gt; list3 = new ArrayList&lt;&gt;();
        ArrayList&lt;Number&gt; list4 = new ArrayList&lt;&gt;();
        /*
        Integer -&gt; Number -&gt;Object
        String -&gt;Object
         */
        get1(list2);
        get1(list4);
        get2(list3);
</code></pre>
<p>斗地主的案列</p>
<pre><code class="java">package d_Poker;

import java.util.ArrayList;
import java.util.Collections;

public class Poker &#123;
    public static void main(String[] args) &#123;
        //创建ArrayList集合 -》color-》专门存花色
        ArrayList&lt;String&gt; colors = new ArrayList&lt;&gt;();
        //专门存牌号
        ArrayList&lt;String&gt; numbers = new ArrayList&lt;&gt;();
        //专门存花色和牌号的组合
        ArrayList&lt;String&gt; poker = new ArrayList&lt;&gt;();

        Collections.addAll(colors,&quot;♣&quot;,&quot;♠&quot;,&quot;♦&quot;,&quot;♥&quot;);
        for (int i = 2; i &lt;= 10; i++) &#123;
            numbers.add(i+&quot;&quot;);
        &#125;

        Collections.addAll(numbers,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&quot;A&quot;);

        for (String number : numbers) &#123;
            for (String color : colors) &#123;
                String pokerNumber  = color + number;
                poker.add(pokerNumber);
            &#125;
            
        &#125;
        poker.add(&quot;大王&quot;);
        poker.add(&quot;小王&quot;);

        //打乱
        Collections.shuffle(poker);

        //发牌，创建四个集合分别代表三个玩家，以及一个存储一个底牌
        ArrayList&lt;String&gt; p1 = new ArrayList&lt;&gt;();
        ArrayList&lt;String&gt; p2 = new ArrayList&lt;&gt;();
        ArrayList&lt;String&gt; p3 = new ArrayList&lt;&gt;();
        ArrayList&lt;String&gt; dipai = new ArrayList&lt;&gt;();

        //如果index为最后的三张,网dipai里面存
        for (int i = 0; i &lt; poker.size(); i++) &#123;
            String s=poker.get(i);
            if (i&gt;=51)
            &#123;
                dipai.add(s);
            &#125; else if (i%3 == 0)&#123;
                p1.add(s);
            &#125; else if (i%3==1)&#123;
                p2.add(s);
            &#125; else if(i%3 == 2)&#123;
                p3.add(s);
            &#125;
        &#125;
        System.out.println(p1);
        System.out.println(p2);
        System.out.println(p3);
        System.out.println(dipai);
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240331182743193.png" alt="image-20240331182743193"></p>
<p><strong>红黑树</strong></p>
<ul>
<li><p>二叉树</p>
<ul>
<li>分支节点不能超过两个</li>
<li><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240331194150090.png" alt="image-20240331194150090"></li>
</ul>
</li>
<li><p>​	平衡树:</p>
<ul>
<li>左边的和右边的是相等的</li>
<li><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240331194202420.png" alt="image-20240331194202420"></li>
</ul>
</li>
<li><p>不平衡树</p>
<ul>
<li>左孩子和有孩子不相等</li>
<li><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240331194257475.png" alt="image-20240331194257475"></li>
</ul>
</li>
<li><p>排序树，查找树</p>
<ul>
<li>和根节点相比较，左边的数据比较小，右边的数据比较大</li>
<li><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240331194412677.png" alt="image-20240331194412677"></li>
</ul>
</li>
<li><p>红黑树</p>
<ul>
<li>数据的储存规则是和排序树一样的</li>
<li><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240331194534758.png" alt="image-20240331194534758"></li>
</ul>
</li>
</ul>
<p>操作</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240331194736725.png" alt="image-20240331194736725"></p>
<p>当我们这样储存的时候，因为要保持平衡，所以就需要旋转，这样查找我们的数据更加方</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240331194808072.png" alt="image-20240331194808072"></p>
<p>集合加入chc红黑树的目的，<strong>就是提高查询效率</strong></p>
<pre><code>HashSet集合
    数据结构是hash表
        在jdk8：哈希表 = 数组 + 链表
        之后   哈希表 = 数组 + 链表 +红黑树
        为了就是增快查询的效率
</code></pre>
<p><strong>Set集合</strong></p>
<pre><code>Set接口并没有Colleaction接口进行功能型的扩充，没有进行扩充的方法
所有的Set集合的底层这都是依靠Map实现
</code></pre>
<ul>
<li>set和map是密切相关的</li>
<li>Map的遍历需要先变成单列集合，只能变成set集合</li>
</ul>
<p><strong>HashSet集合的使用</strong></p>
<pre><code>Hashset是set接口的实现类
    特点
        元素唯一
        快速去重
        无序
        没有索引
        也没有根据索引操作数据的方法，之前的list有get一些方法可以根据索引操作列表，但是在set里面没有这些方法
        线程不安全
    数据表结构
        哈希表
    
方法：和collection一样
    遍历
        增强for
        迭代器
        普通for是不行的，因为根据不了索引来操作
</code></pre>
<pre><code class="java">        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();
        set.add(&quot;zhangsan&quot;);
        set.add(&quot;zhangsan1&quot;);
        set.add(&quot;zhangsan2&quot;);
        set.add(&quot;zhangsan2&quot;);
        set.add(&quot;zhangsan2&quot;);
        set.add(&quot;zhangsan2&quot;);
        System.out.println(set);//[zhangsan1, zhangsan2, zhangsan]
</code></pre>
<p>遍历的方法</p>
<pre><code class="Java">Iterator&lt;String&gt; iterator = set.iterator();
while(iterator.hasNext())&#123;
    System.out.println(iterator.next());
&#125;
for (String s : set) &#123;
    System.out.println(s);
&#125;
</code></pre>
<p><strong>LinkedHashSet</strong></p>
<pre><code>继承与HashSet，使用和HashSet差不多
唯一的不同
    元素是有序的
数据的结构
    哈希表+双向链表（这样就是有序的）
使用:和HashSet一样
</code></pre>
<p><strong>哈希值</strong></p>
<pre><code>概述:是由计算机算出一个十进制数,可以看作对象的地址值
获取对象的哈希值，使用的是Object中的方法
public native int hashCode()
</code></pre>
<pre><code class="java">        Person p1 = new Person(&quot;涛哥&quot;, 18);//Wei_Set.Person@3b07d329
        Person p2 = new Person(&quot;王昌晨&quot;,17);//Wei_Set.Person@41629346
        System.out.println(p1.toString());//Wei_Set.Person@3b07d329
        System.out.println(p1.hashCode());//990368553
        System.out.println(p2.toString());//Wei_Set.Person@41629346
        System.out.println(p2.hashCode());//1096979270
</code></pre>
<p>我们看toString的底层源码，hashCode()获取对象的十进制的地址，toHexString再转为16进制</p>
<pre><code class="java">    public String toString() &#123;
        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
    &#125;
</code></pre>
<p>所以就可以把hash值为作为地址</p>
<p>有一个问题，本来这两个地址是不一样的，但是在String里面重写这个hashCode这个方法，比较的是内容的地址的hash值</p>
<pre><code class="Java">        String name = &quot;abc&quot;;
        String s = new String(&quot;abc&quot;);
        System.out.println(name.hashCode());//96354
        System.out.println(s.hashCode());//96354
</code></pre>
<p>我们也可以在自己类里面重写</p>
<pre><code class="java">    public int hashCode() &#123;
        return Objects.hash(name, age);
    &#125;
</code></pre>
<hr></hr>

<pre><code class="java">Person p1 = new Person(&quot;涛哥&quot;, 18);
Person p2 = new Person(&quot;涛哥&quot;,18);
System.out.println(p1.hashCode());//27639401
System.out.println(p2.hashCode());//27639401
</code></pre>
<ul>
<li><p>获取的地址值是对象属性的地址值，这样比较的就是</p>
<pre><code>注意:重写的hashCode方法，那计算就是对象内容的hash值
</code></pre>
</li>
<li><p>通常内容不同的字符串他的hash值不同，但是也还是会有相同的</p>
<pre><code class="java">        String s3 = &quot;通话&quot;;
        String s4 = &quot;重地&quot;;
        System.out.println(s3.hashCode());//1179395
        System.out.println(s4.hashCode());//1179395
</code></pre>
</li>
</ul>
<pre><code>总结
    哈希值不一样，内容一定不一样
    哈希值一样的，内容不一定一样
</code></pre>
<pre><code>如果不重写hasCode，默认计算对象的哈希值
如果重写hashCode，计算的是对象内容的hash值
</code></pre>
<p>HashSet<strong>的存储去重的过程</strong></p>
<pre><code class="java">        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();
        set.add(&quot;通话&quot;);
        set.add(&quot;重地&quot;);
        set.add(&quot;abc&quot;);
        set.add(&quot;abc&quot;);
        System.out.println(set);//[通话, 重地, abc]
</code></pre>
<ul>
<li>计算元素的Hash值（重写hashCode方法）,再比较内容（重写equals方法）</li>
<li>先比较hash值，如果hash不一样，存</li>
<li>如果hash值一样，在比较内容，如果一样不存去重复，不一样就存</li>
</ul>
<p>如果存储的自定义的内容呢？</p>
<p>例如</p>
<pre><code class="java">        HashSet&lt;Person&gt; people = new HashSet&lt;&gt;();
        people.add(new Person(&quot;wang&quot;,18));
        people.add(new Person(&quot;wang&quot;,18));
        people.add(new Person(&quot;wang2&quot;,18));
        System.out.println(people);
--------------------------------------------
    输出
    [Person&#123;name=&#39;wang&#39;, age=18&#125;, Person&#123;name=&#39;wang2&#39;, age=18&#125;]
</code></pre>
<p><strong>上面的原因是因为Persom重写了hashCode和equals的方法，这样在比较的时候比较就是对象的内容和地址</strong></p>
<p>如果不重写的时候，就会默认调用Object里的hashCode和equals</p>
<p><strong>Map集合</strong></p>
<ul>
<li><p>双列集合</p>
<pre><code>Map:双列集合的顶级接口
hashmap
    特点a.key唯一，value可以重复
    无序
    没有索引
    线程不安全
    可以存null键，null值
    数据结构;哈希表
LinkedHashMap
    是继承于hashmap
    是有序的，因为数据结构是哈希表+双向列表
Hashtable
    特点线程安全
    数据结构哈希表
    不可以存null值
Properties
    继承于HashSet配合于Io读取配置文件
    线程安全
    不能null键null值
    数据结构hash表
TreeMap
    特点
        key唯一，value可以重复
        可以根据key进行排序
        线程不安全
        不可以存null键和null值
        数据结构是红黑树
</code></pre>
</li>
</ul>
<p>总结一下是这个</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401100731144.png" alt="image-20240401100731144"></p>
<p><strong>Map的介绍</strong></p>
<pre><code>概述是双列集合的顶级接口
特点：都是由键值对构成
</code></pre>
<p><strong>实现类</strong></p>
<p><strong>HashMap</strong></p>
<pre><code>特点
    无序
    可以存null和null值
    哈希表
方法
    V put(K key,V value)//添加元素，返返回的是被覆盖的value
    V remove(K key)//根据索引删除元素，最后返回的是删除元素的value
    V get(k key)//根据索引获取元素
    boolean containKeys(K key)//是否包含某一个键
    V[] values()//获取map里的所有键值
</code></pre>
<p>使用</p>
<pre><code class="java">        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
        String wang = map.put(&quot;1&quot;, &quot;wang&quot;);
        System.out.println(wang);//null
        String wang1 = map.put(&quot;1&quot;, &quot;wang1&quot;);//返回的覆盖的元素
        System.out.println(wang1);//wang
</code></pre>
<pre><code class="java">HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
String wang = map.put(&quot;1&quot;, &quot;wang&quot;);
System.out.println(wang);//null
String wang1 = map.put(&quot;1&quot;, &quot;wang1&quot;);
System.out.println(wang1);//wang
map.put(&quot;2&quot;,&quot;haha&quot;);
map.put(&quot;3&quot;,&quot;haha1&quot;);
map.put(&quot;4&quot;,&quot;haha2&quot;);
map.put(&quot;5&quot;,&quot;haha3&quot;);
System.out.println(map);//&#123;1=wang1, 2=haha, 3=haha1, 4=haha2, 5=haha3&#125;
String remove = map.remove(&quot;2&quot;);
System.out.println(remove);//haha返回的值是删除的元素
System.out.println(map);//&#123;1=wang1, 3=haha1, 4=haha2, 5=haha3&#125;

System.out.println(map.get(&quot;1&quot;));//wang1
System.out.println(map.containsKey(&quot;1&quot;));//true
Collection&lt;String&gt; values = map.values();
System.out.println(values);//[wang1, haha1, haha2, haha3]
</code></pre>
<p><strong>LinkedHashmap</strong></p>
<pre><code>继承于Hashmap，使用和hashmap一样，但是是有序的，结构是hash表加双向列表
</code></pre>
<p><strong>Map的遍历方法</strong></p>
<pre><code>KeySet()//获取map所有键值的集合
</code></pre>
<pre><code class="java">Set&lt;String&gt; set = map.keySet();//
for (String s : set) &#123;
    System.out.println(s+&quot;...&quot;+map.get(s));
&#125;
</code></pre>
<p><strong>同时获取key和value</strong></p>
<p>使用entrySet的方法</p>
<pre><code class="java">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();//这里得到的是set集合
        System.out.println(entries);//[1=wang1, 3=haha1, 4=haha2, 5=haha3]
        for (Map.Entry&lt;String, String&gt; entry : entries) &#123;
            System.out.println(entry.getKey());
            System.out.println(entry.getValue());
        &#125;
</code></pre>
<p><strong>Map存储自定义对象怎么去重</strong></p>
<pre><code>其实原理是Set的原理是一样的，适应hashCode方法先比较地址，在使用equal
</code></pre>
<p>如果类里面没有重写equals和hashCode的方法</p>
<pre><code class="java">        HashMap&lt;Person, String&gt; map = new HashMap&lt;&gt;();
        //怎么保证key唯一
        map.put(new Person(&quot;wang&quot;,16),&quot;haha&quot;);
        map.put(new Person(&quot;wang&quot;,16),&quot;haha1&quot;);
        map.put(new Person(&quot;wang&quot;,16),&quot;haha2&quot;);
        System.out.println(map);
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401104049222.png" alt="image-20240401104049222"></p>
<p><strong>这样直接调用Object里面的hashCode，这样不同对象的地址肯定不一样，这样属性值相同的对象就去不了重</strong></p>
<p><strong>当我们重写hashCode和equals以后，比较的就是对象属性的地值</strong></p>
<p><strong>案例</strong></p>
<p>统计字符串中各字符出现的次数</p>
<pre><code class="java">package Wei_map;

import java.util.HashMap;
import java.util.Scanner;

public class Wei_string &#123;
    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);
        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        String s = scanner.next();
        //获取字符串的每一个字符
        char[] chars = s.toCharArray();
        for (char aChar : chars) &#123;
            String key = aChar+&quot;&quot;;
            if (!map.containsKey(key))&#123;
                map.put(key,1);
            &#125; else &#123;
                Integer value = map.get(key);
                value++;
                map.put(key,value);
            &#125;
        &#125;
        System.out.println(map);
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401105016971.png" alt="image-20240401105016971"></p>
<p>使用</p>
<pre><code class="java">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();
        for (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;
            System.out.println(entry.getKey()+&quot;...&quot;+entry.getValue());
        &#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401105149785.png" alt="image-20240401105149785"></p>
<p>还是斗地主案例</p>
<ul>
<li>注意map一般是无序的，但是如果是1，2，3，4，这样就会是有序的</li>
</ul>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401105542267.png" alt="image-20240401105542267"></p>
<p>然后向下面这样的操作，这样分的poker就是有序的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401105852869.png" alt="image-20240401105852869"></p>
<pre><code class="java">package Wei_map;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;

public class Wei_poker &#123;
    public static void main(String[] args) &#123;
        String[] colors = &quot;♣-♠-♦-♥&quot;.split(&quot;-&quot;);
        String[] numbers = &quot;2-3-4-5-6-7-8-9-10-J-Q-K-A&quot;.split(&quot;-&quot;);
        HashMap&lt;Integer, String&gt; poker = new HashMap&lt;&gt;();
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        list.add(0);
        list.add(1);

        int key = 2;
        for (String number : numbers) &#123;
            for (String color : colors) &#123;
                String PokerNumber = color + number;
                poker.put(key,PokerNumber);
                list.add(key);
                key++;
            &#125;
        &#125;

        poker.put(0,&quot;大王&quot;);
        poker.put(1,&quot;小王&quot;);
        System.out.println(list);
        Collections.shuffle(list);

        ArrayList&lt;Integer&gt; p1 = new ArrayList&lt;&gt;();
        ArrayList&lt;Integer&gt; p2 = new ArrayList&lt;&gt;();
        ArrayList&lt;Integer&gt; p3 = new ArrayList&lt;&gt;();
        ArrayList&lt;Integer&gt; dipai = new ArrayList&lt;&gt;();

        for (int i = 0; i &lt; list.size(); i++) &#123;
            Integer key1 = list.get(i);
            if ( i &gt;= 51 )&#123;
                dipai.add(key1);
            &#125; else if (i%3==0)&#123;
                p1.add(key1);
            &#125; else if (i%3==1)&#123;
                p2.add(key1);
            &#125; else if (i%3==2)&#123;
                p3.add(key1);
            &#125;
        &#125;
        Collections.sort(p1);
        Collections.sort(p2);
        Collections.sort(p3);


        LookPoker(&quot;王昌晨&quot;,p1,poker);
        LookPoker(&quot;程国源&quot;,p2,poker);
        LookPoker(&quot;李家乐&quot;,p3,poker);
        LookPoker(&quot;底牌&quot;,dipai,poker);
    &#125;

    private static void LookPoker(String name, ArrayList&lt;Integer&gt; list, HashMap&lt;Integer, String&gt; poker) &#123;
        System.out.print(name+&quot;:&quot;);
        for (Integer integer : list) &#123;
            String value = poker.get(integer);
            System.out.print(value+&quot;&quot;);
        &#125;
        System.out.println();
    &#125;
&#125;
</code></pre>
<p><strong>哈希表的存储过程</strong></p>
<p>哈希表有三部分组成</p>
<p><strong>链表+数组+红黑树</strong></p>
<p>存储的过程</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401120307807.png" alt="image-20240401120307807"></p>
<p>因为做完运算以后通话和重地的位置一样，然后在使用链表</p>
<p>如果位置很多一样的，这样链表的长度很长，这样我们就需要用到红黑树</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401120538692.png" alt="image-20240401120538692"></p>
<ul>
<li>细节，哈希表初始在长度16，但是是在第一次put 的时候初始化的</li>
<li>哈希表中有一个加载因子，0.75F，含义是数组长度到达容量的75%就会扩容，扩容两倍</li>
<li>如果链表长度到达8，并且数组的容量大于等于64的时候链表会自动转为红黑树</li>
<li>如果删除元素，元素个数小于等于6了，红黑树会转为链表</li>
</ul>
<p>这样就会提高我们的性能</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401121306279.png" alt="image-20240401121306279"></p>
<p>哈希表的</p>
<p><strong>TreeSet</strong></p>
<pre><code>是set的实现类
特点
    对元素进行排序
    没有索引
    不能存null
    线程不安全
    元素唯一
    数据结构红黑树
</code></pre>
<pre><code>构造
 TreeSet()//无参构造器
 TreeSet(Comparation)//如果集合里放的是自定义类型，就需要这个 了
</code></pre>
<p><strong>TreeMap</strong></p>
<pre><code>对key进行排序
数据结构：红黑树，
构造方法
    和TreeSet的一样
</code></pre>
<p><strong>HashTable</strong></p>
<pre><code>概述
    是map的实现类
特点
    key唯一，value可以重复
    线程安全
    不能存储null
    哈希表
基本使用和HashMap差不多
区别是
    HashMap线程不安全，还可以存储null
</code></pre>
<p><strong>Vetor集合</strong></p>
<pre><code>概述
    是LIst接口的实现类
特点
    有序，有索引
    线程安全
    数据结构，数组
    
</code></pre>
<p>构造</p>
<pre><code>vector()//构造一个为10的，标准的容量增量为0，
Vector(int i,int j)//构造一个容量为i的列表，而且容量增量为j的
这个空间的创建是在new对象的时候
之前的ArrayList的都是再add的时候构造
</code></pre>
<p><strong>Properties属性集</strong></p>
<pre><code>1.集合于io使用
特点	
    继承于hashTable
    特点和hashTable差不多
    Properties的key和value的类型，默认是String
数据结构hash表
特有的方法
    Object setProperty(String key ,String value) --&gt;存键值对
    String getProperty(String key) --&gt;根据key获取value
    Set&lt;String&gt; stringPropertyNames()--&gt;获取所有的key保存起来再set里面，和之前的keySet一样
    void load(InputStream inStream) --&gt;将流中的数据加载到propperties集合中（IO流部分）
</code></pre>
<p><strong>IO流</strong></p>
<p><strong>File类</strong></p>
<pre><code>计算机尝试
1，以jog结尾的不一定是图片，还有可能是文件夹
2.什么是文本文档？
    用记事本打开，人能看懂的文件
3.分隔符
    路径名称分隔符
    widows：\
    Liunx:/
    路径分隔符:一个路径和其他路径的分隔符
    :
</code></pre>
<pre><code>File类
概述
    文件和目录(文件夹)的抽象表示、
简介理解
    我们再创建File对象的时候，需要传递一个路径，这个路径定在哪个文件上，我们的File就代表哪个对象
        File file = new File(&quot;E:\etc\haha&quot;)
</code></pre>
<pre><code>File里的静态成员
static String pathSeparator:与系统有关的分割符，为了方便，他被表示为一个字符串
static String separator :和系统有关的默认名称分隔符，为了方便，他被表示为一个字符串
</code></pre>
<pre><code class="java">       几个路径之间的分隔符
        String pathSeparator = File.pathSeparator;
        System.out.println(pathSeparator);//;
路径名称分隔符
        String separator = File.separator;//\
        System.out.println(separator);
</code></pre>
<p>注意，\是转义字符，需要写两个</p>
<pre><code class="java">        String path = &quot;E:\\etc\\haha&quot;;
</code></pre>
<p>但是这样写，我们的程序只能在widows上面执行，因为这个路径只有再widos是反斜杠，但是再linux里面是正斜杠</p>
<p>所以我们通常写路径通常这样写</p>
<pre><code class="java">     String path = &quot;E:&quot;+File.separator+&quot;etc&quot;+File.separator+&quot;haha&quot;;
</code></pre>
<p>这样自动获取路径的分隔符</p>
<p><strong>File的构造方法</strong></p>
<pre><code>File(String parent ,String child)
    parent:父路径
    child:子路径
最后拼接成完整的路径
File(File parent,String child)
    还是上面的一样，只不过父路径是file对象
File(String Pathname)
    直接传递路径
</code></pre>
<p>我们创建file对象的时候可以传递路径不存在的文件</p>
<pre><code>File里面的方法
String getAbsolutePath() --&gt;获取File的绝对路径--&gt;带盘符的路径
String getPath() --&gt;获取的是封装路径-&gt;new对象的是什么路径这个就是什么
String getName() --&gt;获取的是文件夹或者文件的名称
long length() --&gt;获取文件的长度-》文件的字节数
</code></pre>
<p>使用</p>
<pre><code class="java">File file = new File(&quot;E:\\a&quot;, &quot;1.png&quot;);
File file1 = new File(&quot;1.txt&quot;);
System.out.println(file);//E:\a\1.jpg
System.out.println(file.getAbsoluteFile());//E:\a\1.jpg
System.out.println(file.getPath());//E:\a\1.jpg
System.out.println(file1.getPath());//1.txt
System.out.println(file.getName());//1.jpg
System.out.println(file.length());//147761
</code></pre>
<pre><code>File的创建方法
    boolean createNewFile() -&gt;创建文件
        如果要创建的文件之前有，创建失败，返沪false
        如果要创建的文件之前没有，创建成功，返回true
    boolean mkdirs() -&gt;创建文件夹，既可以创建多级还可以创建单级
            如果要创建的文件之前有，创建失败，返沪false
            如果要创建的文件之前没有，创建成功，返回true
</code></pre>
<pre><code class="java">       File file2 = new File(&quot;E:\\a\\1.txt&quot;);
        boolean b = file2.createNewFile();
        System.out.println(b);//true
</code></pre>
<pre><code class="java">        File file2 = new File(&quot;E:\\a\\haha\\hehehe&quot;);
        boolean b = file2.mkdirs();
        System.out.println(b);//true
</code></pre>
<p>这样以后就创建多级的文件夹</p>
<p><strong>删除的方法</strong></p>
<pre><code>boolean delete() -&gt;删除文件或者文件夹
</code></pre>
<pre><code class="java">File file2 = new File(&quot;E:\\a\\haha\\hehehe&quot;);
boolean b = file2.mkdirs();
System.out.println(b);//true
System.out.println(file2.delete());//true
</code></pre>
<p>这样我们刚创建的hehehe就被删除了，</p>
<ul>
<li>注意delete慎用，如果删除文件是不走的回收站的</li>
<li>而且删除文件夹，只能删除空文件夹，里面有文件的文件夹是删除不了的，而且也不走回收站</li>
</ul>
<p><strong>File类的判断方法</strong></p>
<pre><code class="java">boolean isDirectory();//判断是否为文件夹
boolean isFile(); //判断是否为文件
boolean exists() //判断文件或者文件夹是否存在
</code></pre>
<p>非常的简单，所以跳过</p>
<p><strong>File的遍历方法</strong></p>
<pre><code class="java">String[] list();//遍历指定的文件夹，返回的是String数组
File[] listFiles();//遍历文件夹，返回的是File类型的数组--》这个推荐使用
</code></pre>
<pre><code class="java">        File file3 = new File(&quot;E:\\a&quot;);
        String[] list = file3.list();
        System.out.println(Arrays.toString(list));//[1.png, 111, c++.md, haha, qqq]
        File[] files = file3.listFiles();
        System.out.println(Arrays.toString(files));//[E:\a\1.png, E:\a\111, E:\a\c++.md, E:\a\haha, E:\a\qqq]
</code></pre>
<ul>
<li>下面的方法返回的是绝对路径</li>
<li>上面的方法返回的是相对路径的</li>
</ul>
<p><strong>字节流</strong></p>
<p><strong>IO流介绍以及输入输出以及流向的介绍</strong></p>
<pre><code>单词
    Output:输出
    Input：输入
    write：写数
    read:读数据
Io流
    将一个设备上的数据传输到另外一个设备上,称为IO流技术
为啥要学IO流?
    之前学过集合和数组能够保存数据，但是只是临时的，达不到永久保存数据，需要永久保存，所以我们可以把数据保存在硬盘上
    而且我们传入数据，必须要输入，输出动作
</code></pre>
<p><strong>IO流流向_针对se阶段的Io</strong></p>
<pre><code>输入流:将数据从硬盘中读到内存中
输出流:从内存写在硬盘上

如果电脑通信的
发数据:输出
收数据:输入
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401173727404.png" alt="image-20240401173727404"></p>
<p><strong>IO流的分类</strong></p>
<pre><code>字节流:万能流，一切都是由字节为基础的，复制一个文件和文件夹都是字节流

    字节输出流:OutputStream 抽象类
    字节输入流:InputStream 抽象类
    
字符流:专门操作文本文档

    字符输出流:Writer 抽象类
    字符输入流:Reader 抽象类
</code></pre>
<p><strong>OutputStream中的子类FileOutputStream 的介绍以及方法的简单介绍</strong></p>
<pre><code>概述
    字节输出流
FileOutputStream：往硬盘上写数据
构造
    FileOutputStream(File file)
    FileOutputStream(String name)
</code></pre>
<pre><code class="java">        FileOutputStream fos = new FileOutputStream(new File(&quot;E:\\a&quot;, &quot;1.txt&quot;));
//特点	指定的文件如果没有自动创建
            每执行一次，就会覆盖之前的文件
</code></pre>
<pre><code>方法
    void write(int b)//一次写一个字节
    void write(byte[] b)//一次写一个字节数组
    void write(byte[] b,int off,int len)//一次写一个字节数组,写指定长度的
    void close() //手动关闭，虚拟机不能关闭，需要手动关闭
</code></pre>
<pre><code class="java">        FileOutputStream fos = new FileOutputStream(new File(&quot;E:\\a&quot;, &quot;1.txt&quot;));
        fos.write(97);
        fos.close();
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401175647305.png" alt="image-20240401175647305"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401175740318.png" alt="image-20240401175740318"></p>
<pre><code class="java">        FileOutputStream fos = new FileOutputStream(new File(&quot;E:\\a&quot;, &quot;1.txt&quot;));
        byte[] bytes = &#123;97,98,99,100&#125;;
        fos.write(bytes);
        fos.close();
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401175859686.png" alt="image-20240401175859686"></p>
<p>下面的更加方便</p>
<pre><code class="java">        FileOutputStream fos = new FileOutputStream(new File(&quot;E:\\a&quot;, &quot;1.txt&quot;));
        byte[] bytes = &#123;97,98,99,100&#125;;
        fos.write(&quot;wangchangchenzhenshuai&quot;.getBytes());
        fos.close();
</code></pre>
<p><strong>如果不要覆盖怎么办？</strong></p>
<p>追击内容</p>
<pre><code>    FileOutputStream(String name,boolean append)//在构造的时候这样写
    append为true的时候，就会追加
</code></pre>
<pre><code>注意
    换行符
        windows :\r\n -&gt;占两个字节
        Liunx:\n
        mac os:\r
</code></pre>
<pre><code class="java">        FileOutputStream fos1 = new FileOutputStream(new File(&quot;E:\\a&quot;, &quot;2.txt&quot;),true);
        fos1.write(&quot;窗前明月光\r\n&quot;.getBytes());
        fos1.write(&quot;疑似地上霜\r\n&quot;.getBytes());
        fos.close();
        fos1.close();
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401180656238.png" alt="image-20240401180656238"></p>
<p><strong>InputStream字节输入流[FileInputStream]的介绍和方法的使用</strong></p>
<pre><code>概述
    字节输入流InputStream,是一个抽象类
    子类
        FileInputStream
作用
    读数据，将数据从硬盘上读到内存上
构造
    FileInputStream(File file)
    FileInputStream(String name)
方法
    int read()一次读取一个字节，返回的是读取的字节
    int read(byte[] b) 一次读取一个字节数组，返回的是读取的读取的个数
    int read(byte[] b,int off,int length)
    void close()
</code></pre>
<p>一次读一个字节</p>
<pre><code class="java">        FileInputStream fis = new FileInputStream(&quot;E:\\a\\2.txt&quot;);
        int read = fis.read();
        System.out.println(read);//231

        int read2 = fis.read();
        System.out.println(read2);//170
</code></pre>
<p>当我们读玩这个文件以后，读取的就是-1</p>
<p>这样就可以连续读取</p>
<pre><code class="java">        int len;
        while ((len=fis.read())!=-1)&#123;
            System.out.println(len);
        &#125;
        fis.close();
</code></pre>
<p>一个流对象，读完以后就不要再读了</p>
<p>流对象关闭以后，就不要再读了</p>
<p>读取的-1的问题</p>
<pre><code>每一个文件的末尾，有一个看不见的结束标记
而read()到达文件的末尾读到结束标记就会是-1
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401184205502.png" alt="image-20240401184205502"></p>
<pre><code class="java">FileInputStream fis = new FileInputStream(&quot;E:\\a\\2.txt&quot;);
//创建的一个数组相当于临时储存区域，我们读取的内容就会保存在临时数组里面
//长度定为多少就会读取到多少个，一般的长度为1024或者1024的整数倍
byte[] bytes = new byte[2];
int i = fis.read(bytes);
System.out.println(i);//2
System.out.println(new String(bytes,0,i));//ab

int j = fis.read(bytes);
System.out.println(j);//2
System.out.println(new String(bytes,0,j));//cd

int k = fis.read(bytes);
System.out.println(k);//2
System.out.println(new String(bytes,0,k));//e
</code></pre>
<p>当返回-1的时候，这时候已经读完 了</p>
<pre><code class="java">        FileInputStream fis = new FileInputStream(&quot;E:\\a\\2.txt&quot;);
        //创建的一个数组相当于临时储存区域，我们读取的内容就会保存在临时数组里面
        //长度定为多少就会读取到多少个，一般的长度为1024或者1024的整数倍
        byte[] bytes = new byte[2];
        int length;
        while ((length = fis.read(bytes))!=-1)&#123;
            System.out.println(new String(bytes,0,length));
        &#125;
</code></pre>
<p>注意再输出字符串的时候一定要指定长度</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401185122597.png" alt="image-20240401185122597"></p>
<p>因为读取的过程是这样的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401185228130.png" alt="image-20240401185228130"></p>
<pre><code>当我们读取前两个
    a，再第一个b再第二个
    以此类推
    当我们读完cd以后，
    c被e替换，但是d还在哪个位置，所以就会读到d
</code></pre>
<p><strong>文件的复制</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401193916292.png" alt="image-20240401193916292"></p>
<p>案例</p>
<pre><code class="java">        //创建FileInputStream
        FileInputStream fis = new FileInputStream(&quot;E:\\a\\1.png&quot;);
//        2.创建fileOutputStream将读取的文件写在指定的位置上
        FileOutputStream fos = new FileOutputStream(&quot;E:\\a\\2.png&quot;,true);
        //可以一个字节的复制还可以一个数组的复制
        byte[] bytes = new byte[1024];
        int length;
        while(( length = fis.read(bytes))!=-1)&#123;
            fos.write(bytes,0,length);//读多少个写多少个防止到最后写进去多余的
        &#125;
        //先开的后关
        fos.close();
        fis.close();
</code></pre>
<p><strong>字符流</strong></p>
<pre><code>之前我们使用字节流读取的文件的时候，我们没有写中文，读字母，一个字母1个字节，但是汉字再不同的版本字节不同
</code></pre>
<p>例如</p>
<p>当我们读取</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401195641859.png" alt="image-20240401195641859"></p>
<p>utf—8一个汉字战3个字节</p>
<p>如果我们这样读</p>
<pre><code class="java">FileInputStream fis = new FileInputStream(&quot;E:\\a\\1.txt&quot;);
byte[] bytes = new byte[2];
int length;
while((length = fis.read(bytes))!=-1)&#123;
    System.out.println(new String(bytes,0,length));
&#125;
</code></pre>
<p>这样的输出</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401195739061.png" alt="image-20240401195739061"></p>
<p>只有我们等于3的时候</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401195814080.png" alt="image-20240401195814080"></p>
<p>才能正常的打印</p>
<p>所以就需要字符流读取</p>
<p><strong>字符流</strong></p>
<pre><code>utf-8，一个汉字占3个字节
GBK,一个汉字占2个字节
将文本文档按照字符操作
注意
    按照字符也需要编码一致，
</code></pre>
<p><strong>FileReader介绍以及使用</strong></p>
<pre><code class="java">字符流专门操作文本文档，复制我们还是用字节流


概述
    字符流输入 -》Reader --》是一个抽象类
    子类：FileReader
作用
    将文本文档的阿内容，读取到内存中
构造
    FileReader(File file)
    FileReader(String path)
方法
    int read(); --&gt;一次读取一个字符，返回的是读取字符的int值，比如a就是97
    int read(char[] cbuf) --》读取数组，返回的是读取的个数
    int read(char[] cbuf,int off,int length)
    void close()
</code></pre>
<pre><code class="java">        FileReader fis = new FileReader(&quot;E:\\a\\1.txt&quot;);
        System.out.println(fis.read());//20320你
        System.out.println(fis.read());//22909好
        System.out.println(fis.read());//-1
</code></pre>
<pre><code class="java">        System.out.println((char) fis.read());//你
        System.out.println((char) fis.read());//好
        System.out.println(fis.read());//-1
</code></pre>
<pre><code class="java">        FileReader fis = new FileReader(&quot;E:\\a\\1.txt&quot;);
        char[] chars = new char[1];
        System.out.println(fis.read(chars));//1
        System.out.println(chars);//你
        System.out.println(fis.read(chars));//1
        System.out.println(chars);//好
</code></pre>
<pre><code class="java">        FileReader fis = new FileReader(&quot;E:\\a\\1.txt&quot;);
        char[] chars = new char[1];
        int len;
        while((len = fis.read())!=-1)&#123;
            System.out.println((char) len);
        &#125;
        fis.close();
</code></pre>
<p><strong>FileWriter</strong></p>
<pre><code>字符输出流--》Writer--》抽象类
子类
    void write(int b)//一次写一个字节
    void write(char[] b)//一次写一个字符数组
    void write(char[] b,int off,int len)//一次写一个字符数组,写指定长度的
    
    相比之前的字节型输出流新型方法
    void wrtie(String str),直接写字符串
</code></pre>
<ul>
<li><strong>注意fileWriter底层自带一个缓冲区，我们写的数据会先保存再缓冲区，所以我们需要将缓冲区的数据刷到文件中，所以需要flush这个方法</strong></li>
</ul>
<pre><code class="java">        FileWriter fw = new FileWriter(&quot;E:\\a\\3.txt&quot;,true);
//        fw.write(97);
//        char[] a = &#123;&#39;你&#39;,&#39;好&#39;&#125;;
//        fw.write(a);
//        char[] b = &#123;&#39;王&#39;,&#39;昌&#39;,&#39;晨&#39;&#125;;
//        fw.write(b,0,2);
        fw.write(&quot;Hello&quot;);
        fw.flush();
</code></pre>
<pre><code>flush():将缓冲区数据刷在文件中，流并没有关
close():先刷新后关闭,后续流不能用了
</code></pre>
<p><strong>IO处理异常</strong></p>
<pre><code>之前再练习的时候，我们处理io流异常的时候直接向上抛，这样并不好
</code></pre>
<p>我们之前说过再finnally进行流对象的关闭</p>
<pre><code class="java">        try &#123;
            FileWriter  fw = new FileWriter(&quot;E:\\a\\7.txt&quot;);
            fw.write(&quot;你好\r\n&quot;);
            fw.write(&quot;王昌晨\r\n&quot;);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            fw.close();
        &#125;
</code></pre>
<p>但是很明显</p>
<p>是飘红的，原因是因为作用域的问题</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401204833553.png" alt="image-20240401204833553"></p>
<p>我们可以往外面定义</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401204954512.png" alt="image-20240401204954512"></p>
<p>但是close也会出现异常了，我们还需要try catch整一下</p>
<pre><code class="java">FileWriter fw = null;
try &#123;
    fw = new FileWriter(&quot;E:\\a\\7.txt&quot;);
    fw.write(&quot;你好\r\n&quot;);
    fw.write(&quot;王昌晨\r\n&quot;);
&#125; catch (IOException e) &#123;
    throw new RuntimeException(e);
&#125; finally &#123;
    try &#123;
        fw.close();
    &#125; catch (IOException e) &#123;
        throw new RuntimeException(e);
    &#125;
&#125;
</code></pre>
<p>这样就可以了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240401205111058.png" alt="image-20240401205111058"></p>
<p>但是还有一些问题，当我们的只有fwnew出来以后才能close，如果new的时候发生错误，我们的fw还是null再去close就会有问题</p>
<p>所以需要判断一下</p>
<pre><code class="java">try &#123;
    fw = new FileWriter(&quot;E:\\a\\7.txt&quot;);
    fw.write(&quot;你好\r\n&quot;);
    fw.write(&quot;王昌晨\r\n&quot;);
&#125; catch (IOException e) &#123;
    throw new RuntimeException(e);
&#125; finally &#123;
    if (fw!=null)&#123;
        try &#123;
            fw.close();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>JDk7以后Io流处理异常的新写法</strong></p>
<pre><code>格式
 try(io对象)&#123;
 可能出现的异常
 &#125; catch()&#123;
 
 &#125;
 这样格式的处理异常的代码，会自动关流，不用再使用finally再关流
</code></pre>
<pre><code class="java">try(FileWriter fileWriter = new FileWriter(&quot;E:\\a\\7.txt&quot;);)&#123;
    fileWriter.write(&quot;hahaha&quot;);
&#125; catch (Exception e)&#123;
    e.printStackTrace();
&#125;
</code></pre>
<ul>
<li>再字符流里面必须要关流，如果不关就不会写进去，所以需要close或者flush</li>
</ul>
<p><strong>字节缓冲区</strong></p>
<pre><code>为什么要学字节缓冲区
    之前缩写FileOutputStream,FileInputStream，FillReader，FileWriter叫做基本类，其中FileInputStream和FileOutputStream的读写方法都是本地方法（方法声明上native）,本地方法是和系统和硬盘打交道的，也就是说这两个对象的读和写都是再硬盘上之间进行读写的，效率不高
    缓冲流中底层带一个长度为8192的数组(缓冲区)，此时读和写都是在内存而不是再硬盘中完成的（在缓冲区直接完成），内存中的读写效率非常高
    注意使用的时候将基础流包装成缓冲流，其实就是new对象的时候，传递基本流
    
    
字节缓冲流	
    a.BufferedOutputStream:字节缓冲输出流
    构造BufferOutputStream(OutputStream out)
    //OutputStream是抽象类，传递的应该是子类对象
    使用和FileOutputStream 的使用是一样的
    b.BufferedInputStream:字节缓冲输入流
    构造BufferedInputStream(InputStream in)
    使用:FileInputStream使用一样
</code></pre>
<p>正常的复制</p>
<pre><code class="java">        long start  = System.currentTimeMillis();
        FileInputStream fis = new FileInputStream(&quot;E:\\a\\1.png&quot;);
        FileOutputStream fos = new FileOutputStream(&quot;E:\\a\\3.png&quot;);
        int len;
        byte[] bytes = new byte[1024];
        while((len = fis.read(bytes)) !=-1)&#123;
            fos.write(bytes,0,len);
        &#125;
        long end = System.currentTimeMillis();
        System.out.println(end-start);//1
        fos.close();
        fis.close();
</code></pre>
<pre><code class="java">long start  = System.currentTimeMillis();
FileInputStream fis = new FileInputStream(&quot;E:\\a\\1.png&quot;);
FileOutputStream fos = new FileOutputStream(&quot;E:\\a\\3.png&quot;);
BufferedInputStream bis = new BufferedInputStream(fis);
BufferedOutputStream bos = new BufferedOutputStream(fos);
int len;
byte[] bytes = new byte[1024];
while((len = bis.read(bytes)) !=-1)&#123;
    bos.write(bytes,0,len);
&#125;
long end = System.currentTimeMillis();
System.out.println(end-start);//1
bos.close();
bis.close();
</code></pre>
<p>效果有点不明显,大一点的文件是可以看见的</p>
<pre><code>细节
    使用缓冲流的时候，为啥只需要关闭缓冲流，不用单独关闭基本流
        原因是缓冲流的的close的方法会自动关闭基本流的close方法
    缓冲流底层有数组(缓冲区),都是在内存之间进行读写，那么缓冲流的读写过程是什么样的？
        
</code></pre>
<p>​		</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402145027870.png" alt="image-20240402145027870"></p>
<ul>
<li>在使用缓冲流的时候复制也是基于基本流的.先依靠基本流将数据放在缓冲流里面，每次都是读取8192个字节</li>
</ul>
<p><strong>字符缓冲流</strong></p>
<pre><code>字符流的基本流是有缓冲区的，所以效率这一块是不太明显，但是有一些特有的方法
</code></pre>
<p><strong>字符缓冲流输出BufferWriter</strong></p>
<pre><code>构造
    BufferedWriter(Writer w)
方法
    和FileWriter一样，但是有一个特有的方法
    newLine()  //换行
</code></pre>
<pre><code class="java">        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;E:\\a\\3.txt&quot;,true));
        bw.write(&quot;窗前明月光&quot;);
        bw.newLine();
        bw.write(&quot;疑似地上霜&quot;);
        bw.close();
</code></pre>
<p>这样写进去的内容就会有换行，不用使用\r\n</p>
<p><strong>字符输入流</strong></p>
<pre><code>构造
 BufferReader(Reader r)
方法
 和FileReader的使用一样
特有的方法
    String readLine() --&gt;一次读一行，如果读到结束的标志，返回的是null
</code></pre>
<pre><code class="java">        BufferedReader br = new BufferedReader(new FileReader(&quot;E:\\a\\3.txt&quot;));
        String s;
        while ((s=br.readLine())!=null)&#123;
            System.out.println(s);//窗前明月光          疑似地上霜
        &#125;
</code></pre>
<p><strong>字符编码</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402151009458.png" alt="image-20240402151009458"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402151352058.png" alt="image-20240402151352058"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402151432187.png" alt="image-20240402151432187"></p>
<pre><code>总结
    想要不乱码，编码和解码遵循的规则(字符编码)要一致
    UTF-8中一个汉字站3个字节
    GbK一个汉字占2个字节
编码是将文字转为字节
解码是将字节转为文字
</code></pre>
<p><strong>转换流InputStreamReader</strong></p>
<pre><code>字节流在读取中文再编码一致的情况下，也不要边读边看，因为字节都不准都不全，输出的内容也会可能出现乱码
所以我们学习字符流，就不会出现乱码，但是如果编码不一致，字符流读取文本的内容，也会可能出现乱码
</code></pre>
<p>例如</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402152104197.png" alt="image-20240402152104197"></p>
<p>按照GBk进行保存</p>
<p>然后我们在进行读取</p>
<pre><code class="java">FileReader fr = new FileReader(&quot;E:\\1.txt&quot;);
int data = fr.read();
System.out.println((char) data);
fr.close();
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402152312588.png" alt="image-20240402152312588"></p>
<p>这样我们使用字符流，也会出现乱码</p>
<p>如果我们再读取的过程中指定编码这样就可以了</p>
<pre><code>所以我们就需要转换流
概述
    是字节流通向字符流的桥梁-&gt;读数据
构造
     InputStreamReader(InputStream in,String  charsetName)
     charsetName指定编码，不区分大小写
作用
    指定读取内容使用的编码
用法
    基本的用法和FileReader一致，
</code></pre>
<p>使用，这样我们就可以读取一样的,注意指定编码，不指定的话默认使用UTF</p>
<pre><code class="java">InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;E:\\1.txt&quot;),&quot;GBK&quot;);
int data = isr.read();
System.out.println((char) data);
</code></pre>
<p><strong>转换流OutputStreamWriter</strong></p>
<pre><code>概述
    是字符流通向字节流的桥梁
构造
    OutputStreamWriter(OutputStream out,String charsetName)
作用
    按照指定编码规则存数据
用法
    和FileWriter的一致
</code></pre>
<p>使用，如果不指定还是默认的是utf-8</p>
<pre><code class="java">OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;E:\\2.txt&quot;), &quot;GBK&quot;);
osw.write(&quot;王昌晨真帅&quot;);
osw.close();
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402154058564.png" alt="image-20240402154058564"></p>
<p><strong>序列化流</strong></p>
<pre><code>比如说将来我们new一个对象，里面有属性值，属性的值也是算数据的，如果我们想把保存数据的对象保存再硬盘上，这时候就需要序列化流
作用
    读写对象
两个对象
    ObjectOutputStream() -&gt; 序列化流，-&gt;写对象的
    ObjectInputStream()-&gt;反序列化流 -&gt;读对象的
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402155056718.png" alt="image-20240402155056718"></p>
<p>我们写进去的也是看不懂的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402155139220.png" alt="image-20240402155139220"></p>
<pre><code>注意
    我们将对象序列化到文件中，我们打开文件是看不懂的，我们只需读回来的时候
例如
    当我们玩游戏的时候，英雄就可以有很多的属性，我们存档的时候，就可以存在文件中
</code></pre>
<p><strong>序列化流ObjectOutputStream</strong></p>
<pre><code>作用:写对象
构造:ObjectOutputStream(OutputStream out)
方法
    writeObject(Object obj)-&gt;写对象
注意
    想要将对象序列化到文件中 ,想要将对象写在文件里面，需要被写的对象实现serializable接口
</code></pre>
<p>例如</p>
<pre><code class="java">package Wei_ObjectStream;

import java.io.Serializable;
import java.util.Objects;

public class Person implements Serializable &#123;
    private String name;
    private Integer age;

    public Person(String name) &#123;
        this.name = name;
    &#125;

    public Person(int age) &#123;
        this.age = age;
    &#125;

    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Person&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;

    @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &amp;&amp; Objects.equals(name, person.name);
    &#125;

    @Override
    public int hashCode() &#123;
        return Objects.hash(name, age);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package Wei_ObjectStream;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

public class Demo &#123;
    public static void main(String[] args) throws IOException &#123;
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;E://a.txt&quot;));
        Person person = new Person(&quot;王昌晨&quot;, 28);
        oos.writeObject(person);
        oos.close();

    &#125;
&#125;
</code></pre>
<p>效果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402160843180.png" alt="image-20240402160843180"></p>
<p><strong>反序列化流ObjectInputStream</strong></p>
<pre><code>作用:读对象
构造
    ObjectInputStream(InputStream in)
方法
readObject()	
</code></pre>
<p>使用</p>
<pre><code class="java">ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;E:\\a.txt&quot;));
Object o = ois.readObject();
System.out.println(o);
</code></pre>
<p><strong>如果不想被序列化到文件里面</strong></p>
<pre><code>使用transient 修饰成员变量
</code></pre>
<p><strong>问题</strong></p>
<pre><code>反序列化的时候出现的问题
问题描述
    序列化以后，我们修改源码，然后我们没有序列化，直接反序列化，这样就会报错
    就会出现序列号冲突的问题
    原因是
        
</code></pre>
<p><strong>原因的复现</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402162302729.png" alt="image-20240402162302729"></p>
<pre><code>当我们编译这个类文件就会生成一个class的文件，而且还会生成一个序列号，
当我们序列化的时候就会将对象和类对应的序列号保存在文件里面，当我们反序列化的时候，文件的序列号号就会和class的文件中的序列号进行对比，如果一样反序列化成功，当我们修改的时候就会重新编译，这样导致序列号发生改变，我们没有将的新的序列号，这样反序列的时候就会失败出现异常
</code></pre>
<pre><code>解决
    我们将序列号固定，不管更改都不会变
    在被序列化的对象上加一个public static final long  的变量，然后赋值
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402162930649.png" alt="image-20240402162930649"></p>
<p>这样我们更改就不会出现问题</p>
<ul>
<li><p>将一个对象实现序列化接口，我们将来才能让这个对象变成二进制，在网络上传输，网络传输都是二进制的</p>
<p>当我们序列化多个对象的时候</p>
<pre><code class="java">Person person = new Person(&quot;王昌晨&quot;, 28);
Person person1 = new Person(&quot;王昌晨&quot;, 22);
Person person2 = new Person(&quot;王昌晨&quot;, 23);
oos.writeObject(person);
oos.writeObject(person1);
oos.writeObject(person2);
oos.close();
</code></pre>
</li>
</ul>
<pre><code class="java">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;E:\\b.txt&quot;));
        Person o =(Person) ois.readObject();
        Person o1 =(Person) ois.readObject();
        Person o2 =(Person) ois.readObject();
        System.out.println(o);
        System.out.println(o1);
        System.out.println(o2);
        ois.close();
</code></pre>
<p>也可以连续的读出来</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402163955406.png" alt="image-20240402163955406"></p>
<p>我们也可以使用循环	那怎么控制循环的次数</p>
<pre><code>解决
    我们可以在序列化的时候，整一个列表，存储的要序列化的对象，然后就可以在序列化的时候传入列表
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402164308622.png" alt="image-20240402164308622"></p>
<pre><code>然后再反序列化的时候将集合反序列化即可
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402164354826.png" alt="image-20240402164354826"></p>
<p><strong>打印流PrintStream</strong></p>
<pre><code>我们之前的
System.out.println(&quot;Hello World&quot;)
查看源码//System.out返回一个输出流对象，对象里面有一个println方法
public static final PrintStream out = null;
</code></pre>
<pre><code>构造
    PrintStream(String fileName);//参数是保存在哪里
方法
    println(); 原样输出自带换行的效果
    print();不带换行
</code></pre>
<p>使用</p>
<pre><code class="java">PrintStream ps = new PrintStream(&quot;3.txt&quot;);
ps.print(&quot;wang&quot;);
ps.print(&quot;changchen&quot;);
ps.println(&quot;zhen&quot;);
ps.println(&quot;shuai&quot;)
</code></pre>
<pre><code>改变流向


    System.out.println() -&gt;本身是输出在控制台上
    改变流向可以让输出语句从控制台输出变为往指定的流向的输出
方法 System里面的方法
    static void setOut(printStream out)--&gt;改变流向--&gt;让输出语句从控制台上输出到指定的文件里面
    
</code></pre>
<p>例如</p>
<p>通过 <code>System.setOut(ps)</code> 方法将标准输出流 <code>System.out</code> 重定向到了一个文件输出流 <code>ps</code>，该文件输出流将输出内容写入到文件 “3.txt” 中。这意味着，之后所有通过 <code>System.out.println()</code> 输出的内容都会被写入到文件 “3.txt” 中，而不会显示在控制台上</p>
<pre><code class="java">PrintStream ps = new PrintStream(&quot;3.txt&quot;);

//改变流向
System.setOut(ps);



System.out.println(&quot;haha&quot;);
System.out.println(&quot;haha&quot;);
System.out.println(&quot;nihao&quot;);
ps.close();
</code></pre>
<p>这样以后</p>
<p>控制台就不会输出内容，二四保存在我们指定的文件里面去</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402172533397.png" alt="image-20240402172533397"></p>
<p><strong>打印流的续写</strong></p>
<pre><code>构造
    PrintStream(OutputStream out) -&gt;可以依靠output实现续写的功能
</code></pre>
<pre><code class="java">    PrintStream ps = new PrintStream(new FileOutputStream(&quot;3,txt&quot;,true));
    System.setOut(ps);
    System.out.println(&quot;haha&quot;);
    System.out.println(&quot;haha&quot;);
    System.out.println(&quot;nihao&quot;);
    ps.close();
&#125;
</code></pre>
<p>这样我们每一次执行都会</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402172928805.png" alt="image-20240402172928805"></p>
<p>像我们的文件后面续写</p>
<p><strong>ProPerties集合</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402173350695.png" alt="image-20240402173350695"></p>
<p>在io的使用场景</p>
<pre><code>配合配置文件进行使用
注意：不能将很多的硬数据放在源码里面，比如用户名和密码这些数据，因为将来更换，这样就会到源码修改，我们类和类之间都有练习，有可能会影响，我们可以将这些数据提取出来，直接去文件里改
</code></pre>
<pre><code>创建配置文件
在模块下右键-》file-》取名为xxx.properties-》
在xxx.properties写配置数据
    key和value都是key=value的形式
    key和value都是String,但是 不要加&quot;&quot;
    每一个键值对写完需要换行
    键值对之前不要写空格
    键值对的不要写中文（这样会乱码，但是可以使用转换流转码）
    
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402174136370.png" alt="image-20240402174136370"></p>
<p>然后解析</p>
<pre><code class="java">        Properties properties = new Properties();
        FileInputStream fis = new FileInputStream(&quot;jdbc.properties&quot;);
        properties.load(fis);
        System.out.println(properties);//&#123;jdbc.password=root, jdbc.username=root&#125;
</code></pre>
<p>可以在遍历一下</p>
<pre><code class="java">Set&lt;String&gt; set = properties.stringPropertyNames();
for (String s : set) &#123;
    System.out.println(s+&#39;=&#39;+properties.getProperty(s));
&#125;
</code></pre>
<p>再说一下之前的hashmap获取键值集合的方法</p>
<pre><code>values的方法
</code></pre>
<p><strong>IO流工具包</strong></p>
<pre><code>IO技术开发，代码量大，而且代码的重复率高，如果我们想要遍历目录，拷贝目录，就需要使用方法的递归调用，增加了程序的复杂度
Apache基金会，开发Io技术工具类commonsIO，大大简化io开发
</code></pre>
<ul>
<li><p>注意这个commonsIO是第三方的工具类</p>
</li>
<li><p>Oracle属于第一方，我们自己是第二方，其他的都是第三方</p>
</li>
<li><p>我们使用第三方的工具类，都需要添加第三方提供的jar包</p>
</li>
<li><p>jar就是压缩包可以解压，里面转的都是class文件，肯定看不见源码，我们想使用jar包的工具类，就需要将相应的jar包解压到我们的当前目录下\</p>
</li>
<li><p>怎么引入</p>
<ul>
<li><p>在当前的文件夹创建文件夹，取名为lib或者libs</p>
</li>
<li><p>将准备好的jar包放在此文件夹</p>
</li>
<li><p>对着jar包右键-》</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402175851153.png" alt="image-20240402175851153"></p>
</li>
</ul>
</li>
</ul>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402180235500.png" alt="image-20240402180235500"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402180248575.png" alt="image-20240402180248575"></p>
<p>这样这个库就可以在当前的模块下是好用 的</p>
<pre><code>使用
    IoUtils类
        静态方法 copy(InputStream in,OutputStream out)//传递字节流实现文件的复制
        closeQuietly(任意流对象)//悄悄的是释放资源，自动处理close()方法抛出的异常
</code></pre>
<pre><code class="java">        //不用关闭会自动的关闭
        IOUtils.copy(new FileReader(&quot;E:\\1.txt&quot;),new FileOutputStream(&quot;E:\\d.txt&quot;));
</code></pre>
<p>之前的close异常需要捕获</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402181045568.png" alt="image-20240402181045568"></p>
<p>现在，这样就处理掉了</p>
<pre><code class="java">        FileWriter fw = null;
        try&#123;
            fw = new FileWriter(&quot;a.txt&quot;);
            fw.write(&quot;hahah&quot;);
        &#125; catch(Exception e)&#123;
            e.printStackTrace();
        &#125; finally &#123;
            IOUtils.closeQuietly(fw);
        &#125;
</code></pre>
<p><strong>FileUtils类</strong></p>
<pre><code>静态方法
    FileUtils.copyDirectoryToDirectoty(File src,file dest)
    传递整个目录，进行整个目录的复制
    src要复制的路径
    writeStringToFile(File file,String str)//将字符串写在指定的文件里面去
    String readFileToString(File file)读取文本文件，返回字符串
</code></pre>
<pre><code class="java">FileUtils.copyDirectoryToDirectory(new File(&quot;E:\\a&quot;),new File(&quot;E:\\b&quot;));
        FileUtils.writeStringToFile(new File(&quot;E:\\a\\121.txt&quot;),&quot;hahaha&quot;);
        System.out.println(FileUtils.readFileToString(new File(&quot;E:\\a\\121.txt&quot;)));//hahah
</code></pre>
<p><strong>网络编程</strong></p>
<p><strong>基础概念</strong></p>
<pre><code>概述
    在网络通信协议下，不同的计算机运行的程序，进行数据传输
    比如:通信，视频，邮件什么的
    
只要计算机进行数据的传输，就有网络编程的存在
</code></pre>
<p><strong>软件架构</strong></p>
<p>C&#x2F;S架构</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402184842434.png" alt="image-20240402184842434"></p>
<p>好处</p>
<pre><code>我们在安装的时候安装包的内存有时候很大，索引不用把所有的数据放在服务端，减轻了服务端的压力
</code></pre>
<p>坏处</p>
<pre><code>这样维护的难度比较大
</code></pre>
<p>B&#x2F;S架构</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402185137143.png" alt="image-20240402185137143"></p>
<pre><code>访问的时候就不用了下载，直接通过浏览器访问服务器
</code></pre>
<p>好处</p>
<pre><code>更新维护比较方便
</code></pre>
<p>坏处</p>
<pre><code>所有的数据都在服务端，压力比较大
</code></pre>
<ul>
<li>我们java主要针对的就是bs架构的</li>
</ul>
<p><strong>服务器概念</strong></p>
<pre><code>安装服务器软件的计算机
后面要见到的服务器软件tomcat
</code></pre>
<ul>
<li>计算机进行数据的传输需要遵守规则，协议会对数据的格式，速率进行规定，只有都遵守这个协议才能完成数据的交互</li>
</ul>
<p><strong>通信的三要素</strong></p>
<pre><code>IP地址
协议
端口号
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402185834871.png" alt="image-20240402185834871"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402190153906.png" alt="image-20240402190153906"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402190250750.png" alt="image-20240402190250750"></p>
<p><strong>UDP协议编程</strong></p>
<pre><code>1.DatagramSocket -&gt;好比寄快递找的快递公司
2.DatagramPacket -&gt;好比快递公司打包
</code></pre>
<p><strong>发送端</strong></p>
<pre><code>创建DatagramSoket对象
    空参：端口号从可用的的端口号随机选一个使用
    有参:自己指定	
创建DatagramPacket对象，进行数据打包
    打包要发送的数据 -》bytes
    指定接收端的ip
    指定接收端的端口号
发送数据
释放资源
</code></pre>
<pre><code class="java">        DatagramSocket socket = new DatagramSocket();
        //指定传输的数据
        byte[] bytes = &quot;你好呀&quot;.getBytes();
//        指定ip
        InetAddress ip = InetAddress.getByName(&quot;127.0.0.1&quot;);
        int port = 6666;
        DatagramPacket dp = new DatagramPacket(bytes, bytes.length, ip, port);
        //发送数据
        socket.send(dp);
        //关闭资源
        socket.close();
</code></pre>
<pre><code class="java">        DatagramSocket socket = new DatagramSocket();
        //指定传输的数据
        byte[] bytes = &quot;你好呀&quot;.getBytes();
//        指定ip
        InetAddress ip= InetAddress.getByName(&quot;127.0.0.1&quot;);
        int port = 6666;
        DatagramPacket dp = new DatagramPacket(bytes, bytes.length, ip, port);
        //发送数据
        socket.send(dp);
        //关闭资源
        socket.close();
</code></pre>
<p>因为是无连接协议，所以只是直接把信息发过去了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240402193321248.png" alt="image-20240402193321248"></p>
<ul>
<li>​	直接执行发送端，没有接收端也不会报错，因为是无连接的协议</li>
</ul>
<p>接收端的代码</p>
<pre><code>1.创建DatagramSocket对象，指定服务的端口号
2.接受数据包
3.解析数据包
4.释放资源
</code></pre>
<p>例如</p>
<pre><code class="java">DatagramSocket socket = new DatagramSocket(6666);
byte[] bytes= new byte[1024];//用于保存接受过来的数据
//获取数据包
DatagramPacket dp = new DatagramPacket(bytes,bytes.length);//这个byes的作用作为数据的缓冲区
socket.receive(dp);
//解析
byte[] data = dp.getData();//接受数据
int length = dp.getLength();//获取数的长度
InetAddress address = dp.getAddress();//获取发送端的主机
int port = dp.getPort();
System.out.println(new String(data,0,data.length));
System.out.println(&quot;length:&quot;+length+&quot;address:&quot;+address+&quot;port:&quot;+port);
socket.close();
</code></pre>
<p><strong>TCP协议编程</strong></p>
<pre><code>Soket:客户端对象
ServerSocket:服务器对象
</code></pre>
<pre><code>
Socket的客户端对象

创建Socket对象，指明发送的服务器ip和端口号
调用Socket对象里的getOutputStream获取输出流发送请求
调用Socket中的getInputStream获取输入流获取响应的结果
</code></pre>
<pre><code>

Socket的服务端对象
 
 创建ServerSocke对象，设置端口号，
 等待服务端连接使用ServerSocket里的accept方法，等待客户端连接(该方法返回的是连接服务端的Socket对象)
 调用Socket里的getInputStream,，用于读取请求 
 调用socket里的getOutputstream，用于给客户端写响应
</code></pre>
<p>因为TCP是面向连接的协议，当我们启动客户端，但是没有启动服务端，这样就会报错 了</p>
<p>例子</p>
<pre><code class="java">package Wei_Tcp;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class Wei_receive &#123;
    public static void main(String[] args) throws IOException &#123;
        ServerSocket serverSocket = new ServerSocket(6666);
        //等待响应
        Socket accept = serverSocket.accept();
        //响应以后
        InputStream is = accept.getInputStream();
        byte[] bytes = new byte[1024];
        int len  = is.read(bytes);
        System.out.println(&quot;接受的数据为&quot;+new String(bytes,0,len));

        //响应

        OutputStream os = accept.getOutputStream();
        os.write(&quot;服务端接收到了数据&quot;.getBytes());
        os.close();
        is.close();
        serverSocket.close();

    &#125;
&#125;
</code></pre>
<pre><code class="java">package Wei_Tcp;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

public class Wei_send &#123;
    public static void main(String[] args) throws IOException &#123;
        //指定发送的主机和端口号
        Socket socket = new Socket(&quot;127.0.0.1&quot;,6666);
        //传输数
        OutputStream os = socket.getOutputStream();
        os.write(&quot;我喜欢你&quot;.getBytes());
        //读取响应
        InputStream is = socket.getInputStream();
        byte[] bytes = is.readAllBytes();
        System.out.println(new String(bytes,0,bytes.length));

//        byte[] bytes1 = new byte[1024];
//        is.read(bytes1);
//        System.out.println(&quot;接受的响应&quot;+new String(bytes1,0,bytes.length));
        //关闭
        is.close();
        os.close();
        socket.close();
    &#125;
&#125;
</code></pre>
<p>这样就是先TCP协议 了</p>
<p><strong>TCP练习</strong></p>
<p><strong>文件上传</strong></p>
<p>操作的过程</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403202103110.png" alt="image-20240403202103110"></p>
<ul>
<li><p>首先将数据从本机的硬盘上读取到客户端，再有客户端发送给服务端，在由服务端写在硬盘上</p>
</li>
<li><p>FileInputStream-&gt;socket.getOutputStream-&gt;Socket.getInputStream-&gt;FileOutputStream</p>
</li>
</ul>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403202453741.png" alt="image-20240403202453741"></p>
<p>代码</p>
<pre><code class="java">package Wei_imgUpload;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class Wei_receive &#123;
    public static void main(String[] args) throws IOException &#123;
        ServerSocket serverSocket = new ServerSocket(6666);
        Socket accept = serverSocket.accept();
        InputStream inputStream = accept.getInputStream();

        FileOutputStream fos = new FileOutputStream(&quot;E:\\12.png&quot;);
        byte[] bytes = new byte[1024];
        int len;
        while ((len = inputStream.read(bytes)) != -1) &#123;
            fos.write(bytes, 0, len);
        &#125;


        System.out.println(&quot;文件接收成功&quot;);

        OutputStream outputStream = accept.getOutputStream();
        outputStream.write(&quot;上传成功&quot;.getBytes());

        outputStream.close(); // 关闭输出流，告知客户端响应已发送完成
        fos.close(); // 关闭文件输出流，释放资源
        accept.close();
        serverSocket.close();
    &#125;
&#125;
</code></pre>
<pre><code class="java">package Wei_imgUpload;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

public class Wei_Upload &#123;
    public static void main(String[] args) throws IOException &#123;
        Socket socket = new Socket(&quot;127.0.0.1&quot;, 6666);
        FileInputStream fis = new FileInputStream(&quot;E:\\a\\1.png&quot;);
        OutputStream os = socket.getOutputStream();

        byte[] bytes = new byte[1024];
        int len;
        while ((len = fis.read(bytes)) != -1) &#123;
            os.write(bytes, 0, len);
        &#125;

        fis.close(); // 关闭文件输入流，释放资源
        os.close(); // 关闭输出流，告知服务端数据已发送完成
        System.out.println(&quot;___--响应结果--_____&quot;);

        InputStream inputStream = socket.getInputStream();
        byte[] bytes1 = new byte[1024];
        int length = inputStream.read(bytes1);
        System.out.println(&quot;服务端接受的到的响应结果\r\n&quot; + new String(bytes1, 0, length));

        inputStream.close();
        socket.close();
    &#125;
&#125;
</code></pre>
<p>在操作的时候出现的问题</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403210139076.png" alt="image-20240403210139076"></p>
<ul>
<li><p>注意当我们的客户端向服务端发送数据的时候，当我们读完以后传给服务端，然后客户端的代码向下走，单词此时的服务端的while里接受数据还没有停，因为没有传递接受标志，这样服务端的代码就卡在那里</p>
<p>解决，关闭输出流写在这里</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403210440420.png" alt="image-20240403210440420"></p>
</li>
</ul>
<p>或者写一个结束的标记</p>
<pre><code class="java">socket.shutDownOutput();
</code></pre>
<p><strong>随机数生成UUID</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403210912215.png" alt="image-20240403210912215"></p>
<p><strong>文件上传改造成多线程的形式（多线程）</strong></p>
<pre><code>放过我太难了
</code></pre>
<p><strong>正则表达式</strong></p>
<pre><code>概述
    具有特殊规则的字符串，比如身份证，邮箱，手机号
String里有一个校验正则的方法
    boolean matches(String regex) //校验字符串是否符合regex的规则
</code></pre>
<p>使用</p>
<pre><code class="java">        Scanner scanner = new Scanner(System.in);
        String data = scanner.next();
        boolean matches = data.matches(&quot;[1-9][0-9]&#123;4,9&#125;&quot;);
        System.out.println(matches);
</code></pre>
<ul>
<li>意思是第一位是1-9的然后后面的0-9出现4到9次</li>
</ul>
<p><strong>基本的使用</strong></p>
<pre><code>模式
    字符类:[]表示一个区间，范围可以自己定义
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403213606986.png" alt="image-20240403213606986"></p>
<p><strong>设计模式</strong></p>
<ul>
<li><strong>模板方法设计模式</strong></li>
</ul>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403213909276.png" alt="image-20240403213909276"></p>
<ul>
<li><p>单例模式</p>
</li>
<li><p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403214311346.png" alt="image-20240403214311346"></p>
<ul>
<li><p>饿汉式</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403214429039.png" alt="image-20240403214429039"></p>
</li>
<li><p>懒汉式</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403214700789.png" alt="image-20240403214700789"></p>
<pre><code>总结
    单列，构造私有，对象私有，静态的
</code></pre>
<p><strong>Lombok</strong></p>
<pre><code>作用:简化javabean开发
    
</code></pre>
<p>之前我们都是这样的写的</p>
<pre><code class="java">package Wei_mathes;

public class Person &#123;
    private String name;
    private Integer age;

    public Person(String name, Integer age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    public Person(String name) &#123;
        this.name = name;
    &#125;

    public Person(Integer age) &#123;
        this.age = age;
    &#125;

    public Person() &#123;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public Integer getAge() &#123;
        return age;
    &#125;

    public void setAge(Integer age) &#123;
        this.age = age;
    &#125;
&#125;
</code></pre>
<p>但是有了Lombok</p>
<p>需要这个插件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403215058069.png" alt="image-20240403215058069"></p>
<p>导入lombok的jar包</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403215347970.png" alt="image-20240403215347970"></p>
<p>源码里没有getter什么的但是在编译的时候会自动给你生成</p>
<p>在设置中需要</p>
<ul>
<li>让注解可以使用</li>
</ul>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403215552256.png" alt="image-20240403215552256"></p>
<ul>
<li>自动编译注解</li>
</ul>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403215637125.png" alt="image-20240403215637125"></p>
<p>使用</p>
<p>将jar包放在lib下</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403215915183.png" alt="image-20240403215915183"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403220155878.png" alt="image-20240403220155878"></p>
<p>我们没有写get和set的方法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403220248601.png" alt="image-20240403220248601"></p>
<p>但是这里提供</p>
<pre><code>@Getter和@Setter
    写在类上对所有的成员有效
    注意:静态成员变量无效
@ToString
    注解只能写在类上面
@NoArgsConstructor和@AllArgsConstructor
    NoArgsConstructor:无参的构造方法
    AllArgsConstructor:满参数的构造方法
    注解只能写在类上
@EqualsAndHashCode
    作用:生成hashCode()和equals()方法
    注解只能写在类上
@Data	
    作用:生成get/set，toString，hashCode，equals，无参构造函数
    注解只能写在类上
</code></pre>
<h2 id="JDK新特性"><a href="#JDK新特性" class="headerlink" title="JDK新特性"></a>JDK新特性</h2><p><strong>Lambda表达式</strong></p>
<p><strong>函数式编程思想和lambda表达式</strong></p>
<pre><code>面对对象的思想
    Java的核心的面对思想
    强调的是找对象帮我们做事
    
    比如:去北京 -&gt; 怎么去，火车，高铁，飞机，汽车，自行车，腿
    其实重要的是去没去成
JDK8开始了一个新的思想:函数式编程思想
    不在强调找对象，而是结果
在这个思想的推出一个表达式
    Lambda表达式:
        定义格式:()-&gt;&#123;&#125;
        各部分的理解
        ():重写方法的参数的位置
        -&gt;:将参数传递到方法体中
        &#123;&#125;:重写方法的方法体
</code></pre>
<p>比如</p>
<pre><code class="java">        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;开始执行了&quot;);
            &#125;
        &#125;).start();

        //    但是使用lamdba的表达式
        //这里面new Runnable的就是为了实现重写run方法
        //    所以
        new Thread(() -&gt; &#123;
            System.out.println(&quot;我执行了&quot;);
        &#125;).start();
</code></pre>
<p>这样的可读性变差了</p>
<pre><code>为什么可以这么写
 因为虚拟机会给你反推推理出来，记住可推理的就是可以省略的
 就像之前的
         ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();//后面的泛型就不用写了
</code></pre>
<p>因为只有一个还可以在进行省略</p>
<pre><code class="java">new Thread(() -&gt; System.out.println(&quot;我执行了&quot;)).start();
</code></pre>
<p><strong>Lamdba表达式的使用前提</strong></p>
<pre><code>必须是函数式接口做方法参数传递
什么是函数式接口？
    有且只有一个抽象方法的接口，可以用@FunctionalInterface去检测
</code></pre>
<p>例如，这里面的@FunctionalInterface，而且只有一个抽象方法，所以这个Rnnable就可以改造成lamdba接口</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403223342620.png" alt="image-20240403223342620"></p>
<p>这个是有口诀的</p>
<pre><code>a.观察是否函数式接口做方法参数传递
b.如果是，考虑lamdba表达式
c.调用方法，以匿名内部类的形式传递形参
d.从new接口开始到重写的方法的方法名结束。删除，删除括号
e.在重写方法的参数后面写上-&gt;
</code></pre>
<p>省略规则</p>
<pre><code>a.重写的方法的参数类型可以干掉
b.如果重写方法只有一个参数,所在的小括号可以省略
c.如果方法体只有一句，那么所在的大括号和分号去掉
d.如果只有一句话还是return的，那么return和都能干掉
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240403224711801.png" alt="image-20240403224711801"></p>
<p><strong>函数式接口</strong></p>
<pre><code>函数式接口
    有且只有一个抽象方法的接口
检查
    @FunctionalInterface用在函数式接口上
</code></pre>
<p>例如</p>
<pre><code class="java">package Wei_lomdba;

@FunctionalInterface
public interface USB &#123;
    void open(String s);
&#125;
</code></pre>
<pre><code class="java">package Wei_lomdba;

public class Test &#123;
    public static void main(String[] args) &#123;
        method(new USB() &#123;
            @Override
            public void open(String s) &#123;
                System.out.println(s+&quot;开启&quot;);
            &#125;
        &#125;);

        method((s)-&gt;&#123;
            System.out.println(s+&quot;开启了&quot;);
        &#125;);

        method(s-&gt; System.out.println(s+&quot;开启了&quot;));&#125;
    public static void method(USB usb)&#123;
        usb.open(&quot;鼠标&quot;);
    &#125;
&#125;
</code></pre>
<p>这是我们自定义的函数式接口，还有jdk给我们提供的函数式接口</p>
<pre><code>Supperlier
    他意味着供给，我们想要什么就给什么
方法
    T get() -&gt;我们想要什么，get方法就会返回什么
需求
    使用Supperlier接口作为方法的参数
    用Lamdba表达式求出int数组的最大值
</code></pre>
<p>例如</p>
<pre><code class="java">package Wei_lomdba;

import java.util.Arrays;
import java.util.function.Supplier;

public class Wei_Supperlier &#123;
    public static void main(String[] args) &#123;
        method(new Supplier&lt;Integer&gt;() &#123;
            @Override
            public Integer get() &#123;
                int[] arr = &#123;4,5,6,7&#125;;
                Arrays.sort(arr);
                return arr[arr.length-1];
            &#125;
        &#125;);

    &#125;
    public static void  method(Supplier&lt;Integer&gt; supplier)&#123;
        Integer max =  supplier.get();//让get方法返回一个数组的最大值
        System.out.println(&quot;最大值为&quot;+max);
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404100217349.png" alt="image-20240404100217349"></p>
<pre><code>supperlier里面有一个get的方法，我们可以把具体的实现写在这里面
</code></pre>
<p>然后我们写成lomdba表达式可以写成这样</p>
<pre><code class="java">package Wei_lomdba;

import java.util.Arrays;
import java.util.function.Supplier;

public class Wei_Supperlier &#123;
    public static void main(String[] args) &#123;
        method(() -&gt;&#123;
                int[] arr = &#123;4,5,6,7&#125;;
                Arrays.sort(arr);
                return arr[arr.length-1];
        &#125;);

    &#125;
    public static void  method(Supplier&lt;Integer&gt; supplier)&#123;
        Integer max =  supplier.get();//让get方法返回一个数组的最大值
        System.out.println(&quot;最大值为&quot;+max);
    &#125;
&#125;
</code></pre>
<p>操作的过程</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404100701078.png" alt="image-20240404100701078"></p>
<p><strong>Comsumer</strong></p>
<pre><code>消费性接口
方法
    void accept(T t),意思是消费一个指定的泛型的数据
消费就是操作，至于怎么操作，就看重写的accept方法之后，方法体怎么写了
</code></pre>
<p>使用</p>
<pre><code class="java">package Wei_lomdba;


import java.util.function.Consumer;

public class Wei_Consumer &#123;
    public static void main(String[] args) &#123;
        method(new Consumer&lt;String&gt;() &#123;
            @Override
            public void accept(String s) &#123;
                System.out.println(s.length());
            &#125;
        &#125;,&quot;haha&quot;);
    &#125;
    public static void method(Consumer&lt;String&gt; consumer, String s)&#123;
        consumer.accept(s);
    &#125;
&#125;
</code></pre>
<p>改为lamdba表达式</p>
<pre><code class="java">package Wei_lomdba;


import java.util.function.Consumer;

public class Wei_Consumer &#123;
    public static void main(String[] args) &#123;
        method(s-&gt;&#123;System.out.println(s.length());&#125;,&quot;haha&quot;);&#125;
    public static void method(Consumer&lt;String&gt; consumer, String s)&#123;
        consumer.accept(s);
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404102358966.png" alt="image-20240404102358966"></p>
<pre><code>supplier提供返回数据的泛型，consumer提供参数的泛型
</code></pre>
<p><strong>Function</strong></p>
<pre><code>Function&lt;T,R&gt;泛型有两个，接口用来根据一个数据得到另外一个数据的类型
方法	
    R apply(T t)根据类型T参数获取类型R的结果
</code></pre>
<p>示例</p>
<pre><code class="java">package Wei_lomdba;

import java.util.function.Function;

public class Wei_Function &#123;
    public static void main(String[] args) &#123;
        method(s -&gt; Integer.valueOf(s), &quot;haha&quot;);

        method(new Function&lt;String, Integer&gt;() &#123;
            @Override
            public Integer apply(String s) &#123;
                return Integer.valueOf(s);
            &#125;
        &#125;,&quot;haha&quot;);
    &#125;
    
    public static void method(Function&lt;String,Integer&gt; function,String s)&#123;
        Integer integer = function.apply(s);
        System.out.println(&quot;转为整数为&quot;+integer);
    &#125;
&#125;
</code></pre>
<pre><code>supperlier式设置返回值的类型，consumer是获取参数的泛型，Function既可以指定返回值的类型而参数的类型
</code></pre>
<p><strong>Predicate</strong></p>
<pre><code>Function&lt;T&gt;判断型接口
boolean test(T t)-&gt;用于判断的方法，返回的值是boolean
</code></pre>
<p>实现</p>
<pre><code class="java">package Wei_lomdba;

import java.util.function.Predicate;

public class Wei_Predicate &#123;
    public static void main(String[] args) &#123;
        method(i-&gt;&#123;return i&gt;5;&#125;,20);
        method(new Predicate&lt;Integer&gt;() &#123;
            @Override
            public boolean test(Integer integer) &#123;
                return integer&gt;5;
            &#125;
        &#125;,2);
    &#125;
    public static void method(Predicate&lt;Integer&gt; predicate,Integer integer)&#123;
        boolean test = predicate.test(integer);
        System.out.println(test? &quot;大于5&quot; :&quot;小于等于5&quot;);
    &#125;
&#125;
</code></pre>
<pre><code>感觉这个可以使用Function替代
</code></pre>
<p>使用Function的方法</p>
<pre><code class="java">package Wei_lomdba;

import java.util.function.Function;
import java.util.function.Predicate;

public class Wei_Predicate &#123;
    public static void main(String[] args) &#123;
        method(i-&gt; i&gt;5,20);
        method(new Predicate&lt;Integer&gt;() &#123;
            @Override
            public boolean test(Integer integer) &#123;
                return integer&gt;5;
            &#125;
        &#125;,2);

        method1(new Function&lt;Integer, Boolean&gt;() &#123;
            @Override
            public Boolean apply(Integer integer) &#123;
                return integer&gt;5;
            &#125;
        &#125;,10);

        method1(i-&gt; i&gt;5 ,10);
    &#125;
    public static void method(Predicate&lt;Integer&gt; predicate,Integer integer)&#123;
        boolean test = predicate.test(integer);
        System.out.println(test? &quot;大于5&quot; :&quot;小于等于5&quot;);
    &#125;
    public static void method1(Function&lt;Integer,Boolean&gt; function,Integer integer)&#123;
        Boolean apply = function.apply(integer);
        System.out.println(apply? &quot;大于5&quot; :&quot;小于等于5&quot;);
    &#125;
&#125;
</code></pre>
<pre><code>这四个单独可能不会拿出来用，但是可以配合stream流使用
</code></pre>
<p><strong>Stream流</strong></p>
<pre><code>Stream流中的不是特指IO流，他指的是一种编程方式，可以看做流水线，
</code></pre>
<p>例如</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404105930448.png" alt="image-20240404105930448"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404110119293.png" alt="image-20240404110119293"></p>
<p>我们可以用Stream写</p>
<p>例如</p>
<pre><code class="java">package Wei_stream;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.stream.Stream;

public class demo &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();
        Collections.addAll(strings,&quot;王昌晨&quot;,&quot;王少杰&quot;,&quot;王绍英&quot;,&quot;胡英俊&quot;,&quot;胡图图&quot;,&quot;王晓&quot;);
        Stream&lt;String&gt; stream = strings.stream();
        stream.filter(new Predicate&lt;String&gt;() &#123;
            @Override
            public boolean test(String s) &#123;
                return s.startsWith(&quot;王&quot;);
            &#125;
        &#125;).filter(new Predicate&lt;String&gt;() &#123;
            @Override
            public boolean test(String s) &#123;
                return s.length() == 3;
            &#125;
        &#125;).forEach(new Consumer&lt;String&gt;() &#123;
            @Override
            public void accept(String s) &#123;
                System.out.println(s);
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre>
<p>而且还可以改成lamdba表达式</p>
<p>使用以后</p>
<pre><code class="java">ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();
Collections.addAll(strings,&quot;王昌晨&quot;,&quot;王少杰&quot;,&quot;王绍英&quot;,&quot;胡英俊&quot;,&quot;胡图图&quot;,&quot;王晓&quot;);
Stream&lt;String&gt; stream = strings.stream();
stream.filter( s -&gt; s.startsWith(&quot;王&quot;)).filter(s-&gt;s.length() == 3).forEach(s-&gt; System.out.println(s));
</code></pre>
<p>其实就是一个链式调用</p>
<p><strong>Stream的获取</strong></p>
<pre><code>针对集合 : Collection中的方法
    Stream&lt;E&gt; stream()
针对数组:Stream接口中的静态方法
    static &lt;T&gt; Stream&lt;T&gt; of(T...values)
</code></pre>
<pre><code class="java">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
Collections .addAll(list,&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;);
Stream&lt;String&gt; stream = list.stream();
System.out.println(stream);

使用静态方法of获取stream对象
Stream&lt;String&gt; stream1 = Stream.of(&quot;金莲&quot;, &quot;三少&quot;, &quot;王五&quot;, &quot;礼物&quot;);
System.out.println(stream1)
</code></pre>
<p><strong>Stream对象的方法</strong></p>
<p><strong>forEach</strong></p>
<pre><code>void forEach(Cunsomer&lt;? super T&gt; action);
注意forEach方法是一个终结方法，使用完以后stream流就使用不了了
逐一处理
</code></pre>
<p>例如</p>
<pre><code class="java">Stream&lt;String&gt; stream = Stream.of(&quot;王昌晨&quot;, &quot;哈哈哈&quot;, &quot;真帅&quot;, &quot;真的哈哈哈&quot;);
stream.forEach(s-&gt;System.out.println(s));
</code></pre>
<p><strong>count方法</strong></p>
<pre><code>作用:统计元素个数
注意:count也是一个终结方法
long count()
</code></pre>
<pre><code class="java">        Stream&lt;String&gt; stream = Stream.of(&quot;王昌晨&quot;, &quot;哈哈哈&quot;, &quot;真帅&quot;, &quot;真的哈哈哈&quot;);
//        stream.forEach(s-&gt;System.out.println(s));
        long count = stream.count();
        System.out.println(count);//4
</code></pre>
<p><strong>filter方法</strong></p>
<pre><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)方法，返回一个新的stream流对象
作用:根据某条件进行筛选
</code></pre>
<pre><code class="java">Stream&lt;String&gt; stream = Stream.of(&quot;王昌晨&quot;, &quot;哈哈哈&quot;, &quot;真帅&quot;, &quot;真的哈哈哈&quot;);

stream.filter(new Predicate&lt;String&gt;() &#123;
    @Override
    public boolean test(String s) &#123;
        return s.startsWith(&quot;王&quot;);
    &#125;
&#125;).forEach(new Consumer&lt;String&gt;() &#123;
    @Override
    public void accept(String s) &#123;
        System.out.println(s);
    &#125;
&#125;);
</code></pre>
<pre><code class="java">Stream&lt;String&gt; stream = Stream.of(&quot;王昌晨&quot;, &quot;哈哈哈&quot;, &quot;真帅&quot;, &quot;真的哈哈哈&quot;);

stream.filter(s -&gt; s.startsWith(&quot;王&quot;)).forEach(s-&gt;System.out.println(s));
</code></pre>
<p><strong>limit方法</strong></p>
<pre><code>Stream&lt;T&gt; limit(long maxsize):获取Stream流对象的前n个元素，返回一个新的Stream对象
</code></pre>
<pre><code class="java">Stream&lt;String&gt; stream = Stream.of(&quot;王昌晨&quot;, &quot;哈哈哈&quot;, &quot;真帅&quot;, &quot;真的哈哈哈&quot;);
Stream&lt;String&gt; limit = stream.limit(2);
limit.forEach(s-&gt; System.out.println(s));//王昌晨，哈哈哈
</code></pre>
<p><strong>skip方法</strong></p>
<pre><code>Stream &lt;T&gt; skip(long n) :跳过Stream流对象的前n个元素，返回一个新的Stream的对象
</code></pre>
<pre><code class="java">        Stream&lt;String&gt; stream = Stream.of(&quot;王昌晨&quot;, &quot;哈哈哈&quot;, &quot;真帅&quot;, &quot;真的哈哈哈&quot;);

        Stream&lt;String&gt; skip = stream.skip(1);
        skip.forEach(s-&gt; System.out.println(s) );

        //哈哈哈
        //真帅
        //真的哈哈哈
</code></pre>
<p><strong>concat方法</strong></p>
<pre><code>static &lt;T&gt; Stream &lt;T&gt; concat(Stream&lt;? extends T&gt; a,Stream&lt;? extends T&gt; b):俩个流合成一起 
</code></pre>
<p>例如，这个concat是一个静态的方法</p>
<pre><code class="java">Stream&lt;String&gt; stream = Stream.of(&quot;王昌晨&quot;, &quot;哈哈哈&quot;, &quot;真帅&quot;, &quot;真的哈哈哈&quot;);
Stream&lt;String&gt; stream1 = Stream.of(&quot;haha&quot;);
Stream.concat(stream1,stream).forEach(s-&gt; System.out.println(s));
//haha
//王昌晨
//哈哈哈
//真帅
//真的哈哈
</code></pre>
<p><strong>将Stream转为列表</strong></p>
<p>​	</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404124630549.png" alt="image-20240404124630549"></p>
<p>这里面可以变成很多种</p>
<pre><code class="java">Stream&lt;String&gt; stream = Stream.of(&quot;王昌晨&quot;, &quot;哈哈哈&quot;, &quot;真帅&quot;, &quot;真的哈哈哈&quot;);
List&lt;String&gt; collect = stream.collect(Collectors.toList());
System.out.println(collect);//[王昌晨, 哈哈哈, 真帅, 真的哈哈哈]
</code></pre>
<p><strong>dinstinct方法</strong></p>
<pre><code>Stream&lt;T&gt; distinct()
元素去重复，依赖hashCode和equals，所以 去重的元素的底层需要重写hashCode和euqals方法
</code></pre>
<pre><code class="java">        Stream&lt;String&gt; stream = Stream.of(&quot;王昌晨&quot;, &quot;哈哈哈&quot;, &quot;真帅&quot;, &quot;真的哈哈哈&quot;,&quot;王昌晨&quot;);
        stream.distinct().forEach(s -&gt; System.out.println(s));
    //王昌晨
    //哈哈哈
    //真帅
</code></pre>
<p>如果每一个是对象的话</p>
<pre><code class="java">package Wei_stream;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class Person &#123;
    private String name;
    private Integer age;
&#125;
</code></pre>
<pre><code class="java">Stream&lt;Person&gt; stream = Stream.of(new Person(&quot;王昌晨&quot;, 18), new Person(&quot;王昌晨&quot;, 18), new Person(&quot;黎明&quot;, 19));
stream.distinct().forEach(s-&gt; System.out.println(s));
</code></pre>
<pre><code class="java">输出结果
    Person(name=王昌晨, age=18)
    Person(name=黎明, age=19)
</code></pre>
<p><strong>转换流中的类型</strong></p>
<pre><code>Stream&lt;R&gt; map(Function &lt;T,R&gt; mapper)-&gt;转换流中的数据类型
</code></pre>
<p>例如</p>
<pre><code class="java">Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6);
stream.map(new Function&lt;Integer, String&gt;() &#123;
    @Override
    public String apply(Integer integer) &#123;
        return integer+&quot;&quot;;
    &#125;
&#125;).forEach(i-&gt; System.out.println(i));
</code></pre>
<p>使用lamdba表达式</p>
<pre><code class="java">Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6);
stream.map(integer-&gt;integer+&quot;&quot;).forEach(i-&gt; System.out.println(i));
</code></pre>
<p><strong>方法引用</strong></p>
<pre><code>概述
    引用方法
使用
    被引用的方法要写在重写方法里
    被引用的方法从参数，返回值上要和所在重写方法一致，而且引用的方法最好是操作重写方法的参数值的
    在lamdba表达式的基础上，去掉重写的参数，去掉-&gt;，去掉引用方法的参数，将被引方法的.改成::
</code></pre>
<pre><code class="java">        Stream&lt;String&gt; stream = Stream.of(&quot;王昌晨&quot;, &quot;王俊凯&quot;, &quot;王直义&quot;, &quot;马超&quot;, &quot;黄忠&quot;);
//         stream.forEach(
//             /*
//             accept是重写方法:参数类型String
//                            没有返回值
//               在accept里面println是方法，println参数类型是String,被引用的方法操作重写方法的参数值，println没有返回值
//               就可以引用println方法
//
//              */
//            (String s)-&gt;System.out.println(s));
         stream.forEach(System.out::println);
         //王昌晨
        //王俊凯
        //王直义
        //马超
        //黄忠
</code></pre>
<pre><code>println方法写在重写方法的里面，而且返回值类型和参数类型和重写的一致，这样我们就可以使用方法的使用
</code></pre>
<p><strong>引用对象成员方法</strong></p>
<pre><code>格式
    ::成员方法名
需求
    函数式接口:supperlier
    java.until.function.Suppelier&lt;T&gt;接口
    抽象方法
        T get() :用来获取一个泛型参数指定类型的数据
        Supperlier接口使用什么泛型，就可以使用get方法获取一个什么样的数据
</code></pre>
<p>例如</p>
<pre><code class="java">    method(new Supplier&lt;String&gt;() &#123;
        /*
        get为重写方法，无参的返回值为String
        trim方法在get中，无参的而且返回值也是String
        所以get可以引用trim
         */
        @Override
        public String get() &#123;
            return &quot; abc &quot;.trim();
        &#125;
    &#125;);
&#125;
public static void  method(Supplier&lt;String&gt; supplier)&#123;
    String s = supplier.get();
    System.out.println(&quot;s=&quot;+s);
&#125;
</code></pre>
<p>先变成lamdba</p>
<pre><code class="java">        method( ()-&gt; &quot; abc &quot;.trim());
</code></pre>
<p>在使用方法的引用</p>
<pre><code class="java">       method(&quot; abc &quot;::trim);
</code></pre>
<p><strong>引用静态方法</strong></p>
<pre><code>类名--引用静态成员方法
    格式
        类名::静态成员方法
</code></pre>
<p>例如下面的代码</p>
<pre><code class="java">package Wei_method;

import java.util.function.Supplier;

public class Demo2 &#123;
    public static void main(String[] args) &#123;
        method(new Supplier&lt;Double&gt;() &#123;
            @Override
            public Double get() &#123;
                return Math.random();
            &#125;
        &#125;);
    &#125;
    public static void  method(Supplier&lt;Double&gt; supplier)&#123;
        Double aDouble = supplier.get();
        System.out.println(&quot;adoule=&quot;+aDouble);
    &#125;
&#125;
</code></pre>
<p>可以先变成lamdba表达式</p>
<pre><code class="java"> method(()-&gt;Math.random());
</code></pre>
<ul>
<li>都是无参返回值类型为double</li>
</ul>
<pre><code class="java">    public static void main(String[] args) &#123;
        method(()-&gt;Math.random());
        method(Math::random);
    &#125;
    public static void  method(Supplier&lt;Double&gt; supplier)&#123;
        Double aDouble = supplier.get();
        System.out.println(&quot;adoule=&quot;+aDouble);
    &#125;
</code></pre>
<p><strong>构造引用</strong></p>
<p>例如</p>
<pre><code class="java">package Wei_method;

import java.util.function.Function;

public class Demo3 &#123;
    public static void main(String[] args) &#123;
        method(new Function&lt;String, Person&gt;() &#123;
            /*

             */
            @Override
            public Person apply(String s) &#123;
                return new Person(s);
            &#125;
        &#125;,&quot;王昌晨&quot;);
        method( s -&gt; new Person(s),&quot;王昌晨&quot;);
    &#125;
    public static  void method(Function&lt;String,Person&gt; function,String name)&#123;
        Person person = function.apply(name);
        System.out.println(person);
    &#125;
&#125;
</code></pre>
<p>改为方法的引用</p>
<pre><code class="java">method( Person::new,&quot;王昌晨&quot;);
</code></pre>
<p>构造方法名：：new</p>
<p><strong>数组引用</strong></p>
<pre><code>格式
    数组的数据类型[]::new
    int[]::new//创建一个为int的数组
    double[]::new //创建一个为double的数组
</code></pre>
<p>例如</p>
<pre><code class="java">package Wei_method;

import java.util.Arrays;
import java.util.function.Function;

public class Demo4 &#123;
    public static void main(String[] args) &#123;
        method(new Function&lt;Integer, int[]&gt;() &#123;
            @Override
            public int[] apply(Integer integer) &#123;
                return new int[integer];
            &#125;
        &#125;,6);

        //变成lamdba表达式
        method( integer-&gt; new int[integer],6);

        //在变成引用的形式
        method(  int[]::new,6);
    &#125;






    public static  void method(Function&lt;Integer,int[]&gt; function,Integer integer)&#123;
        int[] apply = function.apply(integer);
        System.out.println(Arrays.toString(apply));
    &#125;
&#125;
</code></pre>
<ul>
<li>就可以把这个[integer]看作参数的那个位置</li>
</ul>
<p><strong>JDK8以后的新特性</strong></p>
<p>jdk8中接口新型两种方法</p>
<ul>
<li>公共的默认方法</li>
<li>公共的静态方法</li>
</ul>
<p><strong>接口中的私有方法</strong></p>
<p>例如</p>
<pre><code class="java">package Wei_src;

public interface USB &#123;
    private void open()&#123;
        System.out.println(&quot;私有静态方法&quot;);
    &#125;
    private static void close()&#123;
        System.out.println(&quot;私有静态方法&quot;);
    &#125;

    //定义的=一个默认方法·调用私有方法
    public default void methodOpen()&#123;
        open();
    &#125;
    public default void methodClose()&#123;
        close();
    &#125;
&#125;
</code></pre>
<p>在</p>
<pre><code class="java">package Wei_src;

public class Demo &#123;
    public static void main(String[] args) &#123;

        new usb().methodOpen();
        new usb().methodClose();
    &#125;
&#125;
class usb implements USB&#123;
&#125;
</code></pre>
<ul>
<li>这个说一下接口的默认方法，这个实现的接口可以不用实现这个方法，这样实例以后直接调用接口里这个方法</li>
</ul>
<p><strong>钻石操作符和匿名内部类</strong></p>
<pre><code>钻石操作符就是泛型&lt;&gt;
</code></pre>
<p>匿名内部类里的泛型可以省略</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404202555829.png" alt="image-20240404202555829"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404202612474.png" alt="image-20240404202612474"></p>
<p><strong>try catch的升级</strong><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404204851302.png" alt="image-20240404204851302"></p>
<p>io流new写在外面</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404204950256.png" alt="image-20240404204950256"></p>
<p><strong>局部变量的类型的自动推断</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404205029701.png" alt="image-20240404205029701"></p>
<p>定义局部变量的时候可以不用指定类型</p>
<p>使用var声明，然后虚拟机会进行推断</p>
<p><strong>switch表达式</strong></p>
<p>之前的写法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404205209697.png" alt="image-20240404205209697"></p>
<p>现在的写法</p>
<p>我们的case可以写很多个</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404205237960.png" alt="image-20240404205237960"></p>
<p>如果不想写break的话</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404205323414.png" alt="image-20240404205323414"></p>
<p>使用箭头</p>
<p><strong>yield语句</strong></p>
<p>switch的返回值</p>
<p>之前想要拿到switch的结果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404205459937.png" alt="image-20240404205459937"></p>
<p>提前先定义一个变量然后再赋值</p>
<p>现在的就可以这样写</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404205552874.png" alt="image-20240404205552874"></p>
<p><strong>文本块</strong></p>
<p>如果我们想要代码写出这段文字</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404205636402.png" alt="image-20240404205636402"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404205643933.png" alt="image-20240404205643933"></p>
<p>就要不断的加换行符这样体验不太好</p>
<p>所以出现</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404205725585.png" alt="image-20240404205725585"></p>
<p>这样写也会正常的输出，而且注意，正文的那一行必须和第一个”””换行</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404205817645.png" alt="image-20240404205817645"></p>
<p><strong>instanceof模式匹配</strong></p>
<p>之前判断以后在强转<img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404205918391.png" alt="image-20240404205918391"></p>
<p>现在的需要直接在instanceof直接强转</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404210011634.png" alt="image-20240404210011634"></p>
<p><strong>Record类</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404210029480.png" alt="image-20240404210029480"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404210151602.png" alt="image-20240404210151602"></p>
<p>而且自动给你提供了equals和hashCode，用的不多</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404210224813.png" alt="image-20240404210224813"></p>
<p><strong>密封类</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404210300579.png" alt="image-20240404210300579"></p>
<pre><code>密封类的概念就是我让谁可以继承我，谁才可以继承我
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404210343527.png" alt="image-20240404210343527"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240404210416148.png" alt="image-20240404210416148"></p>
<p>前面的sealed就是指定为密封类，permits限定哪个类可以继承</p>
<p>而且在指定子类中必须指定他为非密封</p>
<p><strong>junit单元测试</strong></p>
<p>Junit介绍</p>
<pre><code>概述
    Junit是一个单元测试的框架，可以代替main方法去执行
    之前我们如果想要一个能够执行起来，那么需要提供一个main方法，这压根才能够执行起来
作用
    可以单独执行一个方法，测试该方法是否能够跑通
    Junit是第三方的工具，所以使用之前需要导入jar包
</code></pre>
<p>操作</p>
<ul>
<li>导入Junit的jar包</li>
<li>定义一个方法在方法上面写注解:@Test</li>
</ul>
<p>例如</p>
<pre><code class="java">public class Demo &#123;
    @Test
    public void func()&#123;
        System.out.println(&quot;我是Test执行的func方法&quot;);
    &#125;
&#125;
</code></pre>
<p>点击这里</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405104042901.png" alt="image-20240405104042901"></p>
<p>就可以执行了</p>
<ul>
<li>如果想要执行所有的Test方法直接点击类名左边的按钮，点击run进行执行-&gt;执行当前类中所有的Test方法</li>
</ul>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405104244896.png" alt="image-20240405104244896"></p>
<p>这样全部都能够执行了</p>
<pre><code>使用时候的注意事项
    @Test不能够修饰static方法
    @Test不能修饰带参数的方法
    @Test不能修饰带返回值的方法
</code></pre>
<p><strong>Junit的相关注解</strong></p>
<pre><code>@Before
@After
</code></pre>
<p>执行的顺序</p>
<pre><code class="java">public class Demo2 &#123;
    @Test
    public void func()&#123;
        System.out.println(&quot;i am func&quot;);
    &#125;
    @Before
    public void methodBefore()&#123;
        System.out.println(&quot;i am before&quot;);
    &#125;
    @After
    public void methodAfter()&#123;
        System.out.println(&quot;i am After&quot;);
    &#125;
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405104924434.png" alt="image-20240405104924434"></p>
<p>这里的</p>
<pre><code class="java">注解使用@Before修饰的在@Test之前执行

注解使用@After修饰的在@Test之后在进行执行
</code></pre>
<p>注意</p>
<pre><code class="java">package Wei_junit;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class Demo2 &#123;
    @Test
    public void func()&#123;
        System.out.println(&quot;i am func&quot;);
    &#125;
    @Test 
    public void func1()&#123;
        System.out.println(&quot;i am func1&quot;);
    &#125;
    @Before
    public void methodBefore()&#123;
        System.out.println(&quot;i am before&quot;);
    &#125;
    @After
    public void methodAfter()&#123;
        System.out.println(&quot;i am After&quot;);
    &#125;
&#125;
</code></pre>
<pre><code>如果两个Test一起执行
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405105217776.png" alt="image-20240405105217776"></p>
<pre><code>@Before,有多少个@Test执行，@Before就之前执行多少次 -&gt;用在初始化数据
@After，有多少个@Test执行，@After就之后执行多少次-&gt;用在释放资源
</code></pre>
<p>其他的注解</p>
<pre><code>@BeforeClass: 在@Test之前执行，但是只执行一次，必须是修饰静态方法
@AfterClass: 在@Test之后执行，执行一次，也可以修饰静态方法
</code></pre>
<p>使用</p>
<pre><code class="java">package Wei_junit;

import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

public class Demo3 &#123;
    @Test
    public void func()&#123;
        System.out.println(&quot;i am func&quot;);
    &#125;
    @Test
    public void func2()&#123;
        System.out.println(&quot;i am func2&quot;);
    &#125;
    @BeforeClass
    public static void  methodBefore()&#123;
        System.out.println(&quot;i am beforeClass&quot;);
    &#125;
    @AfterClass
    public static void methodAfter()&#123;
        System.out.println(&quot;i am methodAfter&quot;);
    &#125;
&#125;
</code></pre>
<p>执行的结果</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405110456036.png" alt="image-20240405110456036"></p>
<p><strong>类的加载机制</strong></p>
<pre><code>下面都会将类加载到内存
new 对象
new 子类对象(new子类对象先初始化父类)
执行main方法
调用静态方法
反射，创建Class对象
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405122941438.png" alt="image-20240405122941438"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405123135183.png" alt="image-20240405123135183"></p>
<p><strong>类加载器ClassLoader</strong></p>
<pre><code>基于JDK8
概述
    在jvm，负责将本地上的class文件加载到内存对象_ClassLoader
分类
    BootStrapClassLoader:根类加载器-&gt;C语言写的，我们是获取不到的
                        也称为引导类加载器，负责java的核心类加载的
                        比如:System,string等
                        jre/lib/rt.jar下面的都是核心类
    ExtClassLOader:扩展类加载器
                    负责jre扩展目录中的jar包的加载
                    在jdk中的jre的lib目录下的ext目录
    AppClassLoader:系统类加载器
                    负责在jvm启动时加载来自java命令class文件（自定义类），以及classPath环境变量所指定的jar包(第三jar包)
                    
                    不同的类加载器负责加载不同的类
    三者之间的关系
        AppClassLoader的父类加载器ExtClassLOader
        ExtClassLOader的父类加载器BootStrapClassLoader
        
        但是他们从代码层级上面看，没有子类继承关系-&gt;他们只有一个共同的父类-&gt;ClassLoader
        
获取类加载器对象对象 getClassLoader是class对象中的方法
类名.class.getClassLoader()拿到对应的加载对象
</code></pre>
<p><strong>双亲委派</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405125458111.png" alt="image-20240405125458111"></p>
<p>缓存机制</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405125544823.png" alt="image-20240405125544823"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405125606417.png" alt="image-20240405125606417"></p>
<pre><code>当加载某一个类的时候，首先先去appclassloader然后先判断缓存的里是否有，如果有的话直接返回，没有的话，app还是先不加载，再去上面询问EXt如果他的缓存里面有那就从他的缓存里面返回，如果还是没有继续向上面找，Bootacrap里面找，如果缓存里面还是没有，说明这个类之前没有加载过，然后boot就会去自己规定的jar包里面查找，如果没有话，就会去下面找ext也是，然后回到app目录找，这个app里肯定是有的
</code></pre>
<p><strong>反射</strong></p>
<p><strong>class对象和反射的介绍</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405130340825.png" alt="image-20240405130340825"></p>
<pre><code>当我们的类加载到方法去以后，就会在堆中创建对应类的对应的对象-&gt;class对象
</code></pre>
<pre><code>万物都是对象
class文件-&gt;也是一个对象-&gt;class对象-&gt;描述class对象的类叫做class类


成员变量-&gt;有对象-&gt;Filed对象-&gt;描述Field对象类叫做Field类

成员方法 -&gt;有对象-&gt;Method对象-&gt;描述Method的类叫做methd类

构造方法 -&gt;有对象 -&gt; Constructor对象 -&gt;描述Constructor对象类叫做Constructor类
</code></pre>
<p><strong>什么叫做反射</strong></p>
<pre><code>概述:解刨class对象的技术
问题:能解抛class对象的什么东西?
    参数，修饰符，成员等等
    a.解抛成员变量:赋值
    b.解抛出成员方法:调用
    c.解抛构造方法:创建对象
为什么要用反射呢，直接实例然后去调用获取不好吗？
    用反射的好处是所有的代码都没有写死，让代码变得更灵活
怎么体现呢?

怎么学习？
    将反射看作一套api来学
</code></pre>
<ul>
<li><p>获取class对象:class文件对应的对象</p>
</li>
<li><p>class类:描述class对象的类</p>
<p><strong>反射之获取class对象</strong></p>
<pre><code>方法1:调用Object里面的getclass方法
Class &lt;?&gt;getClass()
方式2:不管是基本类型还是引用类型，jvm都为其提供一个静态的成员:class
方式3:Class类中的静态方法
static Class&lt;?&gt; forName(String className)
                    className:是类的全限定名(包名.类名)
</code></pre>
</li>
</ul>
<p>例如</p>
<pre><code class="java">        Person person = new Person();
        Class&lt;? extends Person&gt; aClass = person.getClass();
        System.out.println(aClass);//class Wei_Reflect.Person
</code></pre>
<pre><code class="java">Person person = new Person();
Class&lt;? extends Person&gt; aClass = person.getClass();
System.out.println(aClass);


Class&lt;Double&gt; doubleClass = Double.class;
Class&lt;Integer&gt; integerClass = Integer.class;
Class&lt;Person&gt; personClass = Person.class;
System.out.println(personClass);//class Wei_Reflect.Person


Class&lt;?&gt; aClass1 = Class.forName(&quot;Wei_Reflect.Person&quot;);
System.out.println(aClass1);//class Wei_Reflect.Person
</code></pre>
<hr></hr>

<p>注意写类的全限定名的时候小技巧</p>
<pre><code>1.快速写
    a.直接复制粘贴
    B.直接写类名这样也可以自动补全
</code></pre>
<p>例如</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405150923456.png" alt="image-20240405150923456"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405150941012.png" alt="image-20240405150941012"></p>
<p>这样就可以快速复制到全限制名</p>
<p>而且在比较，class对象只有一个</p>
<pre><code class="java">System.out.println(aClass1 == aClass);//true
</code></pre>
<pre><code>三种获取class对象的最通用的是forName(String className)
原因是参数是String形式，这样就可以和properties文件饥饿和使用
</code></pre>
<p>例如</p>
<p>新建一个properties文件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405154307790.png" alt="image-20240405154307790"></p>
<p>然后</p>
<pre><code class="java">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;
        Properties properties = new Properties();
        FileInputStream fileInputStream = new FileInputStream(&quot;E:\\java\\Java\\src\\Wei_Reflect\\wei.properties&quot;);
        properties.load(fileInputStream);
        String className = properties.getProperty(&quot;className&quot;);
        Class.forName(className);
    &#125;
</code></pre>
<pre><code>我们可以通过读取配置文件的形式，获取响应的class对象
</code></pre>
<p>最常用的是</p>
<pre><code>直接类名.class
</code></pre>
<p><strong>反射构造方法</strong></p>
<pre><code>获取所有public的构造方法
1.Constructor &lt;?&gt;[] getConstructors()-&gt;获取所有public的构造
</code></pre>
<p>获取共有的构造方法</p>
<pre><code class="java">public void func()&#123;
    //获取class对象
    Class&lt;Person&gt; personClass = Person.class;
    //获取所有的public的构造
    Constructor&lt;?&gt;[] constructors = personClass.getConstructors();
    for (Constructor&lt;?&gt; constructor : constructors) &#123;
        System.out.println(constructor);
        //public Wei_Reflect.Person(java.lang.String,java.lang.Integer)
        //public Wei_Reflect.Person()
    &#125;
&#125;
</code></pre>
<pre><code>这样就获取我们写的两个构造
//public Wei_Reflect.Person(java.lang.String,java.lang.Integer)
//public Wei_Reflect.Person()
</code></pre>
<p>但是没有获取到我们写的私有的构造方法</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405155208412.png" alt="image-20240405155208412"></p>
<p><strong>获取空参的的构造方法—public</strong></p>
<pre><code>Class类中的方法
Constructor&lt;T&gt; getConstructor(Class&lt;?&gt; ...parameterTypes)-&gt;获取指定的public的构造
            parameterTypes可变惨，可以传递0个或者多个参数
如果获取的是空参构造:参数不用写
如果获取的是有参构造:参数写参数类型的class对象
</code></pre>
<p>例如</p>
<pre><code class="java">        Constructor&lt;Person&gt; constructor = personClass.getConstructor();
        System.out.println(constructor);//public Wei_Reflect.Person()
        Constructor&lt;Person&gt; constructor1 = personClass.getConstructor(String.class, Integer.class);
        System.out.println(constructor1);//public Wei_Reflect.Person(java.lang.String,java.lang.Integer)
</code></pre>
<p><strong>怎么使用反射new对象</strong></p>
<pre><code>Constructor类中的方法
    T newIntance(Object...initargs)-&gt;创建对象
                            initargs:传递的是构造方法的实参
    如果根据无参构造创建对象,initargs不用写
    如果是有参创建对象，initargs传递实参
</code></pre>
<p>比如下面是无参的</p>
<pre><code class="java">Constructor&lt;Person&gt; constructor = personClass.getConstructor();
Person person = constructor.newInstance();
System.out.println(person);//Person(name=null, age=null)
</code></pre>
<p>有参的</p>
<pre><code class="java">Constructor&lt;Person&gt; constructor1 = personClass.getConstructor(String.class, Integer.class);
Person person1 = constructor1.newInstance(&quot;王昌晨&quot;, 17);
System.out.println(person1);//Person(name=王昌晨, age=17)
</code></pre>
<p><strong>利用空参构造创建对象的快捷方式</strong></p>
<pre><code>Class类中的方法，
    T newInstance() -&gt; 根据空参构造创建对象，之前的是constructor里的方法
</code></pre>
<pre><code class="java">Class&lt;Person&gt; personClass = Person.class;
Person person2 = personClass.newInstance();
System.out.println(person2);//Person(name=null, age=null)
</code></pre>
<ul>
<li>少一部获取构造方法，被反射的类中必须有public的空参构造</li>
</ul>
<p><strong>私有的构造方法</strong></p>
<pre><code>使用反射获取私有构造方法
Constructor&lt;?&gt;[] getDeclaredConstructors() //获取所有的构造方法，包括private
Constructor&lt;?&gt; getDeclaredConstructor(class&lt;?&gt;...paramterTypes)//获取指定构造
    paramterTypes参数类型的class对象
</code></pre>
<p>使用</p>
<pre><code class="java">Class&lt;Person&gt; personClass = Person.class;
Constructor&lt;?&gt;[] declaredConstructors = personClass.getDeclaredConstructors();
for (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;
    System.out.println(declaredConstructor);
    /*
    public Wei_Reflect.Person()
    public Wei_Reflect.Person(java.lang.String,java.lang.Integer)
    private Wei_Reflect.Person(java.lang.Integer)
    private Wei_Reflect.Person(java.lang.String)
     */
&#125;
</code></pre>
<p>这样把我们的私有的构造方法获取出来所有的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405163252388.png" alt="image-20240405163252388"></p>
<p>但是我们还是按照之前newInstance使用私有构造方法创建对象，发现</p>
<pre><code class="java">Constructor&lt;Person&gt; declaredConstructor = personClass.getDeclaredConstructor(String.class);
Person haha = declaredConstructor.newInstance(&quot;haha&quot;);
System.out.println(haha);
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405163630980.png" alt="image-20240405163630980"></p>
<p>那应该怎么操作？</p>
<ul>
<li><pre><code>Constructor有一个父类叫做AccessibleObject里面有一个方法
    void setAccessilble(boolean flag) -&gt; 修改访问权限
        如果flag为true，解决私有权限，
</code></pre>
</li>
</ul>
<p>例如</p>
<pre><code class="java">Constructor&lt;Person&gt; declaredConstructor = personClass.getDeclaredConstructor(String.class);
declaredConstructor.setAccessible(true);//解除私有权限-&gt;暴力反射
Person haha = declaredConstructor.newInstance(&quot;haha&quot;);
System.out.println(haha);//Person(name=haha, age=null)
</code></pre>
<ul>
<li><pre><code>declaredConstructor.setAccessible(true);//解除私有权限-&gt;暴力反射，这个就可以解除私有权限
</code></pre>
</li>
</ul>
<p><strong>反射成员方法_public</strong></p>
<pre><code>1.class类中方法:
    Method[] getMethods()-&gt;获取所有的public方法，包括他的父类
</code></pre>
<p>例如</p>
<pre><code class="java">Class&lt;Person&gt; personClass = Person.class;
Method[] methods = personClass.getMethods();
for (Method method : methods) &#123;
    System.out.println(method);
&#125;
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405164408308.png" alt="image-20240405164408308"></p>
<p>因为所有的类都继承与Object类，所以Object的方法也会打印</p>
<p><strong>反射指定的方法</strong></p>
<pre><code>Method&lt;?&gt; getMethod(String name,class&lt;?&gt;...paranterTypes)//读取指定的成员方法public
                name:传递方法名
                paranterTypes:方法的参数，为了放着重载的。方法名字相同，但是参数是不同的
</code></pre>
<pre><code class="java">Method setAge = personClass.getMethod(&quot;setAge&quot;, Integer.class);
System.out.println(setAge);//public void Wei_Reflect.Person.setAge(java.lang.Integer)
</code></pre>
<p><strong>怎么调用?</strong></p>
<pre><code class="java">调用方法:Method对象中的方法:
     Object  invoke(Object obj, Object...args) -&gt;执行方法
         obj:根据构造new出来的对象;
         args:方法的实参 -&gt; 如果有参数，直接传递实参:否则不用传
         返回值:Object -&gt; 接受被执行方法的返回值，如果方法没有返回值，不用接受了
</code></pre>
<p>例如</p>
<pre><code class="java">Method setAge = personClass.getMethod(&quot;setAge&quot;, Integer.class);
Person person = personClass.newInstance();
Object invoke = setAge.invoke(person,19 );
System.out.println(person);//Person(name=null, age=19)
</code></pre>
<p>在通过返回获取</p>
<pre><code class="java">Method getAge = personClass.getMethod(&quot;getAge&quot;);
Object invoke1 = getAge.invoke(person);
System.out.println(invoke1);//19
</code></pre>
<p><strong>反射之操作私有方法</strong></p>
<pre><code>1.
    Method[] getDeclaredMethods()  -&gt;获取所有的成员的方法，包括private
    Method getDeclaredMethod(String name , class&lt;?&gt;...parameterTypes) -&gt;获取指定的
        name:方法名
        parameterTypes:方法参数的class对象
    解除私有权限
        void setAccessible(boolean flag)
</code></pre>
<pre><code class="java">Method func = personClass.getDeclaredMethod(&quot;func&quot;);
func.setAccessible(true);
func.invoke(person);//我是func我执行了

//有返回值有参数的私有方法
Method func1 = personClass.getDeclaredMethod(&quot;func1&quot;, String.class);
func1.setAccessible(true);
Object haha = func1.invoke(person, &quot;haha&quot;);
System.out.println(haha);//haha
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405172415167.png" alt="image-20240405172415167"></p>
<p><strong>反射成员变量</strong></p>
<pre><code>class中的方法
获取所有的属性
    Field[] getFields() -&gt;获取所有的public的属性
    Field[] getDeclaredFields() -&gt;获取所有的属性，包括私有的
</code></pre>
<pre><code class="java">package Wei_Reflect;

import java.lang.reflect.Field;

public class Demo4 &#123;
    public static void main(String[] args) &#123;
        Class&lt;Person&gt; personClass = Person.class;
        Field[] field = personClass.getFields();
        for (Field field1 : field) &#123;
            System.out.println(field1);
            /*
            public java.lang.String Wei_Reflect.Person.number
             */
        &#125;
        System.out.println(&quot;________________________&quot;);
        Field[] declaredFields = personClass.getDeclaredFields();
        for (Field declaredField : declaredFields) &#123;
            System.out.println(declaredField);
            /*
            public java.lang.String Wei_Reflect.Person.number
            private java.lang.String Wei_Reflect.Person.name
            private java.lang.Integer Wei_Reflect.Person.age
             */
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>获取指定 属性</strong></p>
<pre><code class="java">class类中的方法
    Field getField(String name);  -&gt;获取属性名为name的属性值
    Filed getDeclaredField(String name); --&gt;获取私有属名字为name的
    
    
 赋值和取值
    Field类中的方法
    void  set(Object obj, Object value) -&gt;为属性赋值
        obj是要赋值的对象
           value是要赋值的值
   Object get(Object obj) --&gt;Obj是new出来的对象
</code></pre>
<p>例如</p>
<pre><code class="java">Class&lt;Person&gt; personClass1 = Person.class;
Field number = personClass1.getField(&quot;number&quot;);
Person person = personClass1.newInstance();
number.set(person,&quot;23&quot;);
Object o = number.get(person);
System.out.println(o);//23
</code></pre>
<p>如果是私有的属性</p>
<pre><code class="java">Field declaredField = personClass1.getDeclaredField(&quot;name&quot;);
declaredField.setAccessible(true);
declaredField.set(person,&quot;王昌晨&quot;);
Object o1 = declaredField.get(person);
System.out.println(o1);//王昌晨
</code></pre>
<p><strong>反射的练习</strong></p>
<p><strong>注意下面的问题</strong></p>
<pre><code>需求在配置中，配置类的全限定名,以及方法名，通过解析配置文件，让配置好的方法执行起来
 className=Baoming.Person
 methodName=eat
 
 步骤
 1.创建properties配置文件,配置信息
 问题Propertires放在哪里？
     现在放在模块下，将来项目的开发以后给用户的是out路径下的class的文件，将class文件打包，如果将配置文件直接放在模块下，out目录不会直接生成配置文的，如果没有配置文件，那么程序也运行不起来
         解决:将配置文件放在src下，
     问题
         将配置文件放在src下，out路径会自动生成配置文件，但是如果我们将来所有的配置文件都放在src下就会特别乱
         解决:在模块下单独创建一个文件夹，将所有的配置文件放在这里，将此文件夹更改为资源目录,取名为resources
     
 2.读取配置信息，解析配置信息
     问题：怎么读取配置文件?
     new FileInputStream(&quot;模块名//resources//配置文件&quot;)-&gt;这样是不对的，因为我们out目录下只有配置文件，相当于写死了，
     解决
         用类加载器
         ClassLoader classLoader = 当前类.class.getClassLoader()
         inputstream in = classLoader.getResourceAsStream(&quot;文件名&quot;)//自动扫描resources下面的文件，可以理解扫描out路径下的配置文件，
         
         
 3.根据解析出来的className，创建Class对象
 4.根据解析出来的methodName,创建对应的方法
 5.执行方法
</code></pre>
<ul>
<li><p>创建resources目录</p>
</li>
<li><p>将其改为资源目录</p>
</li>
<li><p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405181738942.png" alt="image-20240405181738942"></p>
</li>
<li><p>然后再随便运行一个文件</p>
</li>
<li><p>发现<img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405181910602.png" alt="image-20240405181910602"></p>
</li>
</ul>
<p>我们在资源目录下创建的文件出现在out下面</p>
<p>代码</p>
<p>配置文件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405190847807.png" alt="image-20240405190847807"></p>
<p>Person类</p>
<pre><code class="java">package E_Reflect;

public class Person &#123;
    public void eat()
    &#123;
        System.out.println(&quot;人要吃饭&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package E_Reflect;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Properties;

public class Demo &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException &#123;
        //创建properties集合
        Properties properties = new Properties();
        //读取配置文件,解析配置文件
        InputStream in = Demo.class.getClassLoader().getResourceAsStream(&quot;pro.properties&quot;);
        properties.load(in);
        String className = properties.getProperty(&quot;className&quot;);
        String methodName = properties.getProperty(&quot;methodName&quot;);
        //根据解析的className,创建class对象
        Class&lt;?&gt; aClass = Class.forName(className);
        Method method = aClass.getMethod(methodName);//因为没有参数，所以第二个参数参数类型class对象不用写
        Object o = aClass.newInstance();
        method.invoke(o);//没有参数
        //

    &#125;
&#125;
</code></pre>
<pre><code class="java">Demo.class：Demo 类的 class 对象，表示 Demo 类在内存中的类对象。

getClassLoader()：获取类加载器。在 Java 中，每个类都有一个与之对应的类加载器对象，类加载器负责加载类文件到内存中。通过调用 getClassLoader() 方法，可以获取到加载 Demo 类的类加载器对象。

getResourceAsStream(&quot;pro.properties&quot;)：通过类加载器获取资源文件的输入流。getResourceAsStream() 方法用于从类路径中获取指定名称的资源文件，并返回一个对应的输入流。这里指定的资源文件名是 &quot;pro.properties&quot;，表示要获取名为 &quot;pro.properties&quot; 的配置文件。

综合起来，这行代码的作用是利用 Demo 类的类加载器从类路径中获取名为 &quot;pro.properties&quot; 的配置文件，并将其转换为输入流，以便后续读取其中的属性信息。在后续代码中，通过 properties.load(in) 方法将配置文件中的属性加载到 Properties 对象中进行解析和使用。
</code></pre>
<p>这是解释我也有点不太懂</p>
<p>这里面也体现框架的思想</p>
<p>当我们像不执行eat方法，直接在配置文件里面更改，不用再其他的位置进行更改</p>
<pre><code class="java">这里突然醒悟了，这就是为什么之前说写使用反射可以让代码变得更加灵活
当我们执行想要执行Person里的eat方法，就需要先实例再实例.eat()调用，当我们想要执行其他的方法的话，只能修改源码，我们上面配合properties就解决这个问题，我们需要修改配置文件，这里就体现我们的框架的思想
</code></pre>
<p><strong>注解</strong></p>
<pre><code>引用数据类型有5种
    类，数组，接口，枚举，注解
jdk1.5版本的新特性-&gt;一个引用数据类型
    和类，接口，枚举是一个层次的
    
    引用数据类型:类，数组，接口，枚举，注解
作用
    说明:对代码进行说明，生成doc文档(API文档)
    检查:检查代码是否符合条件 @Override(@会用)@FunctionalInterface
    分析:对代码进行分析，起到代码配置文件的作用
JDK中的注解
    @override -&gt;检测该方法是否为重写的方法
    jdk1.5版本，支持父类方法重写
    1.6版本，支持接口的方法的重写
</code></pre>
<p><strong>就比如@Deprecated</strong></p>
<pre><code class="java">package E_Reflect;

public class Person &#123;
    @Deprecated
    public void eat()
    &#123;
        System.out.println(&quot;人要吃饭&quot;);
    &#125;
&#125;
</code></pre>
<p>在当我我们调用eat的时候 ，就会有过时的标志</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405193315757.png" alt="image-20240405193315757"></p>
<p>@SuppressWarnings–&gt;消除警告</p>
<hr>
<p>之前我们</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405193525845.png" alt="image-20240405193525845"></p>
<p>如果不传泛型的话警告</p>
<p>如果不想要提醒的话，这样就会消除这个类的所有的警告</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405193650892.png" alt="image-20240405193650892"></p>
<p><strong>注解的定义以及属性的定义格式</strong></p>
<pre><code>这里的注解属性本质上是抽象方法，但是按照属性好理解
</code></pre>
<pre><code class="java">1.定义
    public @interface 注解名&#123;
    
    &#125;
2.定义属性(本质上是抽象方法):增强注解的作用
    数据类型 属性名() -&gt;  此属性没有默认值，需要再使用注解的时候为其赋值
    数据类型 属性名() default值 -&gt;此属性证明有默认值，如果还有需要，还可以二次赋值
3.注解中可以定义什么类型的属性呢？
    a.八种基本类型
    b.String类型,class类型，枚举类型，注解类型
    c.以上类型的一位数组
</code></pre>
<pre><code class="java">package E_Reflect;

public @interface Book &#123;
    String bookName();
    String[] author();
    int price();
    int count()default 10;
&#125;
</code></pre>
<p>例如上面的这样</p>
<p><strong>注解的的使用</strong></p>
<pre><code>注解使用
    为注解里面的属性赋值
使用位置上
    再类中，方法中，成员变量，局部变量，参数的位置使用
使用格式
    a.@注解名(属性名 = 值，属性名= 值)
    b.如果属性中有数组
        @注解名(属性名=&#123;元素1，元素2&#125;)
</code></pre>
<pre><code>空注解可以直接使用
不同的位置可以使用一样的注解，但是同样的位置还可以使用一样的注解
如果注解只有一个属性，并让属性名为value，那么使用注解的时候，属性名不用写，直接写值(包括数组)
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405195824849.png" alt="image-20240405195824849"></p>
<p>这样就会报错下面的可以</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405195853901.png" alt="image-20240405195853901"></p>
<p><strong>注解的解析-&gt;AnnotatedElement接口</strong></p>
<pre><code class="java">赋值以后有什么用?
    注解的解析，获取注解里的属性值
1.注解的解析涉及一个接口:AnnotatedElement接口
    实现类:AccessibleObject,Class,Constructor,Executable,Field,Method,Package,Parameter
    
2.解析思路:先判断指定位置上有没有使用指定的注解，如果有获取指定的注解，然后获取注解的属性值
boolean isAnnotationPresent(class&lt;? extend Annotation&gt; annotationClass) -&gt;判断指定位置上有没有指定的注解

Class&lt;Bookshelf&gt; bookshelfClass = Bookshelf.class;
boolean annotationPresent = bookshelfClass.isAnnotationPresent(Book.class);
3.获取指定的注解
getAnnotation(calss&lt;T&gt; annationClass),比如获取BookShelf上的Book注解

----------------------------
Class&lt;Bookshelf&gt; bookshelfClass = Bookshelf.class;
boolean annotationPresent = bookshelfClass.isAnnotationPresent(Book.class);
if(annotationPresent)&#123;
    Book book = bookshelfClass.getAnnotation(Book.class)//返回值是注解类型
&#125;	
</code></pre>
<p>例如判断bokkshelf是否有book注解</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405200950670.png" alt="image-20240405200950670"></p>
<p>实例</p>
<pre><code class="java">package E_Reflect;

import java.util.ArrayList;
import java.util.Arrays;

@SuppressWarnings(&quot;all&quot;)
public class Demo1 &#123;
    public static void main(String[] args) &#123;
        Class&lt;Bookshelf&gt; bookshelfClass = Bookshelf.class;
        boolean annotationPresent = bookshelfClass.isAnnotationPresent(Book.class);

        if (annotationPresent)&#123;
            Book annotation = bookshelfClass.getAnnotation(Book.class);
            System.out.println(annotation.bookName());
            System.out.println(annotation.price());
            System.out.println(annotation.count());
            System.out.println(Arrays.toString(annotation.author()));
        &#125;
    &#125;
&#125;
</code></pre>
<p>但是这里面的</p>
<pre><code>annotationPresent 是false
原因是因为
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405202926707.png" alt="image-20240405202926707"></p>
<p><strong>元注解</strong></p>
<pre><code>上面说Book注解没有加载到内存，导致判断为false
</code></pre>
<pre><code>概述
    元注解就是管理注解的注解
a.控制注解的使用位置，
b.控制注解的声明周期

怎么使用
a.@target:控制注解使用的位置
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405203211205.png" alt="image-20240405203211205"></p>
<pre><code class="java">
Target的源码

    
 @Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target &#123;
    /**
     * Returns an array of the kinds of elements an annotation interface
     * can be applied to.
     * @return an array of the kinds of elements an annotation interface
     * can be applied to
     */
    ElementType[] value();
&#125;


ElementType是一个枚举,里的成员可以直接类名调用
    TYPE：控制注解能够使用在类上
    FIELD 控制注解能够使用在属性上
    METHOD 控制注解能够使用在方法上
    PARAMETER 控制注解能够使用在参数上
    CONSTRUCTOR 控制注解能够使用在构造上
     LOCAL_VARIABLE 控制注解能够使用在局部变量上
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
 ————————————————————————————————————————————--------------------------------------
@Retention:控制注解的声明周期(加载位置)
    
    源码
    @Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Retention &#123;
    /**
     * Returns the retention policy.
     * @return the retention policy
     */
    RetentionPolicy value();
&#125;

    属性RetentionPolicy value()
        RetentionPolic也是枚举，里的成员可以类名直接调用
        SOURCE:控制注解能够在源码出现，这个是默认的，因为现在注解就在源码出现
        CLASS：控制注解在class文件出先
        RUNTIME:控制注解在内存出现，添加这个我们上面的问题就可以解决了
</code></pre>
<p>比如这样</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405203826015.png" alt="image-20240405203826015"></p>
<p>这样注解就可以在类上在成员上，在方法上使用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405204451937.png" alt="image-20240405204451937"></p>
<p>这样以后，我们的Book就可以在内存出现，这样我们就判断成功，然后获取属性值</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405204535890.png" alt="image-20240405204535890"></p>
<p><strong>枚举</strong></p>
<pre><code>五大引用数据类型之一
定义
public enum 枚举类名&#123;


&#125;
所有枚举类的父类都是Enum

定义枚举值
a.枚举值的特点:都是static final修饰,但是定义的时候不要写出来，这个是默认的，
写完所有枚举值之后 ，最后加;
枚举值要大写
使用类名直接调用
注意
    每一个枚举值都是当前枚举类的对象
</code></pre>
<p>每一个枚举值都是当前枚举类的对象，就是下面这个，<strong>所以每一个枚举都是当前枚举的对象</strong></p>
<pre><code class="java">package Wei_enum;

import javax.swing.*;

public enum State &#123;
    //State WEIFUKUAN = new State()
    WEIFUKUAN,
    //State YIFUKUAN = new State()
    YIFUKUAN,
    //State WEIFAHUO = new State()
    WEIFAHUO,
    //State YIFAHUO = new State()
    YIFAHUO;
&#125;
</code></pre>
<pre><code>枚举类的枚举都是本类类型


------------------------------
除了定义枚举还可以定义其他的成员，不过成员都是private的
</code></pre>
<pre><code class="java">package Wei_enum;

import javax.swing.*;

public enum State &#123;
    //State WEIFUKUAN = new State()
    WEIFUKUAN,

    //State YIFUKUAN = new State()
    YIFUKUAN,
    //State WEIFAHUO = new State()
    WEIFAHUO,
    //State YIFAHUO = new State()
    YIFAHUO;
    private String name;
&#125;
</code></pre>
<ul>
<li>枚举使用场景:表示对象 的状态<ul>
<li>表示对象状态</li>
</ul>
</li>
</ul>
<p>赋值这样</p>
<pre><code class="java">package Wei_enum;

import javax.swing.*;

public enum State &#123;
    //State WEIFUKUAN = new State()
    WEIFUKUAN(&quot;未付款&quot;),

    //State YIFUKUAN = new State()
    YIFUKUAN(&quot;已付款&quot;),
    //State WEIFAHUO = new State()
    WEIFAHUO(&quot;未发货&quot;),
    //State YIFAHUO = new State()
    YIFAHUO(&quot;已发货&quot;);
    private String name;
    State(String name) &#123;
        this.name = name;
    &#125;

&#125;
</code></pre>
<p>注意需要有构造方法</p>
<p>这样就可以看见状态</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240405214055295.png" alt="image-20240405214055295"></p>
<p>我们还可以提供getter方法</p>
<pre><code class="java">package Wei_enum;

import javax.swing.*;

public enum State &#123;
    //State WEIFUKUAN = new State()
    WEIFUKUAN(&quot;未付款&quot;),

    //State YIFUKUAN = new State()
    YIFUKUAN(&quot;已付款&quot;),
    //State WEIFAHUO = new State()
    WEIFAHUO(&quot;未发货&quot;),
    //State YIFAHUO = new State()
    YIFAHUO(&quot;已发货&quot;);
    private String name;
    State(String name) &#123;
        this.name = name;
    &#125;

    public String getName() &#123;
        return name;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package Wei_enum;

public class Test &#123;
    public static void main(String[] args) &#123;
        State weifahuo = State.WEIFAHUO;
        System.out.println(weifahuo);//WEIFAHUO
        System.out.println(weifahuo.getName());//未发货
    &#125;
&#125;
</code></pre>
<ul>
<li>记住每一个枚举都是一个枚举类的对象</li>
</ul>
<p>那</p>
<pre><code class="java">    WEIFUKUAN(&quot;未付款&quot;),
这一段代表什么
    State WEIFUKUAN = new State(&quot;未付款&quot;)
</code></pre>
<p><strong>枚举方法</strong></p>
<pre><code class="java">String toString() //返回枚举值的名字
            State weifahuo = State.WEIFAHUO;
            System.out.println(weifahuo);//WEIFAHUO
            System.out.println(weifahuo.toString());//WEIFAHUO
values()//返回所有的枚举值
            State[] values = State.values();
            for (State value : values) &#123;
                System.out.println(value);
                /*
                WEIFUKUAN
                YIFUKUAN
                WEIFAHUO
                YIFAHUO
                 */
            &#125;
valueOf(String str)//将一个字符串转为枚举类型，注意枚举类里面必须有这个字符串的枚举
        State yifahuo = State.valueOf(&quot;YIFAHUO&quot;);
        System.out.println(yifahuo);//YIFAHUO
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 哈哈哈哈哈哈哈重生之我是兵王
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;chenw
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
