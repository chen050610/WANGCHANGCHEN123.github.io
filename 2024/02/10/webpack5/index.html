
<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8" />
    <title>webpack5 | 哈哈哈哈哈哈哈重生之我是兵王</title>
    <meta name="author" content="chenw" />
    <meta name="description" content="description" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
	<canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
	<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
	<script src="/js/fireworks.min.js"></script>
	<canvas id="background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
	<script src="/js/background.min.js"></script>
	<div id="cursor"></div>
	<link rel="stylesheet" href="/css/cursor.min.css">
	<script src="/js/cursor.min.js"></script>
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>哈哈哈哈哈哈哈重生之我是兵王</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;哈哈哈哈哈哈哈重生之我是兵王</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>webpack5</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/10
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/webpack/" style="color: #00a596">webpack</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p>摘要</p>
<span id="more"></span>
<p>正文</p>
<h1 id="webpack5"><a href="#webpack5" class="headerlink" title="webpack5"></a>webpack5</h1><p>为什么使用webpack5</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211153307297.png" alt="image-20240211153307297"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211153637618.png" alt="image-20240211153637618"></p>
<p>编译的工作</p>
<p>编译成浏览器能够识别的语言</p>
<h2 id="下载过程"><a href="#下载过程" class="headerlink" title="下载过程"></a>下载过程</h2><p>首先执行</p>
<pre><code class="bash">npm init -y
</code></pre>
<p>此时生成基础的package.json的文件</p>
<p>这里的name一定要是webpack</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211154132905.png" alt="image-20240211154132905"></p>
<p>然后下载相关的依赖</p>
<pre><code class="bash">npm i webpack webpack-cli -D
</code></pre>
<p>使用npx的指令可以把node_modules下的bin目录当作环境变量</p>
<p>这样就可以使用webpack的指令</p>
<p>然后在在后面加上入口的文件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211162037585.png" alt="image-20240211162037585"></p>
<p>然后在指定模式</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211162122788.png" alt="image-20240211162122788"></p>
<p>这样</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211162145636.png" alt="image-20240211162145636"></p>
<p>就代表打包成功</p>
<p>生成的打包文件在disk目录下</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211162417297.png" alt="image-20240211162417297"></p>
<p>在运行就能得到结果</p>
<p>生产模式再来打包</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211162656438.png" alt="image-20240211162656438"></p>
<p>这样的代码压缩过来的</p>
<h2 id="五大核心"><a href="#五大核心" class="headerlink" title="五大核心"></a>五大核心</h2><p>1.入口（entry），指示webpack从哪个文件开始打包</p>
<p>2.output（输出的位置），指定输出的文件输出到那个地方</p>
<p>3.loader（加载器），webpack只能处理js和json等资源，其他的资源需要使用loader</p>
<p>4.plugins（插件），扩展webpack的功能</p>
<p>5.mode（模式），开发者模式（development）和生产者模式（production）</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>在项目的根目录创建</p>
<p>配置文件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211163311088.png" alt="image-20240211163311088"></p>
<p>没有最初的loader和插件的配置如下</p>
<pre><code class="js">const path = require(&#39;path&#39;)

module.exports = &#123;
    //入口
    entry:&#39;./src/main.js&#39;,//相对路径
    //输出
    output: &#123;
        path: path.resolve(__dirname,&#39;dist&#39;),//输出路径绝对路径，使用path解决__dirname代表当前文件夹目录
        filename: &quot;main.js&quot;,//输出的文件名字
    &#125;,
    //加载器
    module: &#123;
        rules: [
            //loader的配置
        ],
    &#125;
    //插件
    plugins: [
        //插件的位置
    ],
    //模式
    mode: &quot;development&quot;,
&#125;
</code></pre>
<p>这样配置完以后我们的指令就不用写这么多了</p>
<pre><code class="bash">npx webpack
</code></pre>
<p>指令的</p>
<p>没有写配置文件的话还是需要上面复杂的写法</p>
<p>这样执行就ok了</p>
<h2 id="开发模式的作用"><a href="#开发模式的作用" class="headerlink" title="开发模式的作用"></a>开发模式的作用</h2><p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211172818306.png" alt="image-20240211172818306"></p>
<h2 id="处理样式资源"><a href="#处理样式资源" class="headerlink" title="处理样式资源"></a>处理样式资源</h2><h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><p>首先，需要先安装 <code>css-loader</code>：</p>
<pre><code class="console">npm install --save-dev css-loader
npm install style-loader -D
</code></pre>
<p>然后把 loader 引用到你 <code>webpack</code> 的配置中。如下所示：</p>
<p><strong>file.js</strong></p>
<pre><code class="js">import css from &#39;file.css&#39;;然后在入口文件导入css文件
</code></pre>
<p><strong>webpack.config.js</strong></p>
<pre><code class="js">module.exports = &#123;
  module: &#123;
    rules: [
      &#123;
        test: /\.css$/i,
        use: [&#39;style-loader&#39;, &#39;css-loader&#39;],
      &#125;,
    ],
  &#125;,
&#125;;
</code></pre>
<p>然后运行 <code>webpack</code>。</p>
<p>这样就可以</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211191750991.png" alt="image-20240211191750991"></p>
<h3 id="处理less资源"><a href="#处理less资源" class="headerlink" title="处理less资源"></a>处理less资源</h3><p>首先，你需要先安装 <code>less</code> 和 <code>less-loader</code>：</p>
<pre><code class="console">npm install less less-loader --save-dev
</code></pre>
<p>然后将该 loader 添加到 <code>webpack</code> 的配置中去，例如：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="js">module.exports = &#123;
  module: &#123;
    rules: [
      &#123;
        test: /\.less$/i,
        use: [
          // compiles Less to CSS
          &#39;style-loader&#39;,
          &#39;css-loader&#39;,
          &#39;less-loader&#39;,
        ],
      &#125;,
    ],
  &#125;,
&#125;;
</code></pre>
<p>接着使用你习惯的方式运行 <code>webpack</code>。</p>
<p>还有一个注意的点</p>
<p>loader：只能使用一个loader</p>
<p>use：可以使用多个loader，并且从左向右执行</p>
<pre><code class="js">module: &#123;
    rules: [
        &#123;
            test: /\.css$/i,//检测xxx文件以css结尾的文件正则，//执行顺序，从下到上，从左到右
            use: [&#39;style-loader&#39;,//将js中的css通过创建style标签的形式显示在页面，在html中生效
                &#39;css-loader&#39;//将css样式编译成commonjs的模块到js中
            ],
        &#125;,
        &#123;
            test: /\.less$/i,
            use: [
                // compiles Less to CSS
                &#39;style-loader&#39;,
                &#39;css-loader&#39;,
                &#39;less-loader&#39;,//将less编译成css文件
            ],
        &#125;,
        //loader的配置
    ],
&#125;,
</code></pre>
<p>这样就可以实现了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211192540071.png" alt="image-20240211192540071"></p>
<h3 id="处理sass资源"><a href="#处理sass资源" class="headerlink" title="处理sass资源"></a>处理sass资源</h3><p>首先，你需要安装 <code>sass-loader</code>：</p>
<pre><code class="console">npm install sass-loader sass webpack --save-dev
</code></pre>
<p><code>sass-loader</code> 需要预先安装 <a target="_blank" rel="noopener" href="https://github.com/sass/dart-sass">Dart Sass</a> 或 <a target="_blank" rel="noopener" href="https://github.com/sass/node-sass">Node Sass</a>（可以在这两个链接中找到更多的资料）。这可以控制所有依赖的版本， 并自由的选择使用的 Sass 实现。</p>
<p>这样可以控制所有依赖项的版本，并选择要使用的 Sass 实现。</p>
<blockquote>
<p>ℹ️ 我们推荐使用 <a target="_blank" rel="noopener" href="https://github.com/sass/dart-sass">Dart Sass</a>。</p>
</blockquote>
<blockquote>
<p>⚠ <a target="_blank" rel="noopener" href="https://github.com/sass/node-sass">Node Sass</a> 不能与 <a target="_blank" rel="noopener" href="https://classic.yarnpkg.com/en/docs/pnp/">Yarn PnP</a> 特性一起正常工作，并且不支持 <a target="_blank" rel="noopener" href="https://sass-lang.com/documentation/at-rules/use">@use rule</a>。</p>
</blockquote>
<p>将 <code>sass-loader</code> 、<a target="_blank" rel="noopener" href="https://webpack.docschina.org/loaders/css-loader/">css-loader</a> 与 <a target="_blank" rel="noopener" href="https://webpack.docschina.org/loaders/style-loader/">style-loader</a> 进行链式调用，可以将样式以 style 标签的形式插入 DOM 中，或者使用 <a target="_blank" rel="noopener" href="https://webpack.docschina.org/plugins/mini-css-extract-plugin/">mini-css-extract-plugin</a> 将样式输出到独立的文件中。</p>
<p>然后将本 loader 添加到你的 Webpack 配置中。例如：</p>
<p><strong>app.js</strong></p>
<pre><code class="js">import &#39;./style.scss&#39;;
</code></pre>
<p><strong>style.scss</strong></p>
<pre><code class="scss">$body-color: red;

body &#123;
  color: $body-color;
&#125;
</code></pre>
<p><strong>webpack.config.js</strong></p>
<pre><code class="js">module.exports = &#123;
  module: &#123;
    rules: [
      &#123;
        test: /\.s[ac]ss$/i,
        use: [
          // 将 JS 字符串生成为 style 节点
          &#39;style-loader&#39;,
          // 将 CSS 转化成 CommonJS 模块
          &#39;css-loader&#39;,
          // 将 Sass 编译成 CSS
          &#39;sass-loader&#39;,
        ],
      &#125;,
    ],
  &#125;,
&#125;;
</code></pre>
<p>最后通过你喜欢的方式运行 <code>webpack</code>。</p>
<p>实例</p>
<p>准备好两个文件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211193219064.png" alt="image-20240211193219064"></p>
<p>都是sass，但是sass省略{}和；</p>
<p>处理styl资源</p>
<p>首先，你需要安装 <code>style-loader</code>：</p>
<pre><code class="console">npm install --save-dev style-loader
</code></pre>
<p>推荐将 <code>style-loader</code> 与 <a target="_blank" rel="noopener" href="https://webpack.docschina.org/loaders/css-loader/"><code>css-loader</code></a> 一起使用</p>
<p>然后把 loader 添加到你的 <code>webpack</code> 配置中。比如：</p>
<p><strong>style.css</strong></p>
<pre><code class="css">body &#123;
  background: green;
&#125;
</code></pre>
<p><strong>component.js</strong></p>
<pre><code class="js">import &#39;./style.css&#39;;
</code></pre>
<p><strong>webpack.config.js</strong></p>
<pre><code class="js">module.exports = &#123;
  module: &#123;
    rules: [
      &#123;
        test: /\.css$/i,
        use: [&#39;style-loader&#39;, &#39;css-loader&#39;],
      &#125;,
    ],
  &#125;,
&#125;;
</code></pre>
<h2 id="处理图片资源"><a href="#处理图片资源" class="headerlink" title="处理图片资源"></a>处理图片资源</h2><p>小图片一般进行优化</p>
<p>转为base 64的格式</p>
<p>loader这么写</p>
<pre><code class="js">&#123;
    test: /\.(png|jpe?g|gif|webp|svg)/,
    type: &#39;asset&#39;,
    parser: &#123;
        dataUrlCondition: &#123;
            maxSize: 4 * 1024 // 4kb//小于多少的做转为base64
            //优点就是减少请求的数量，缺点就是，体积会更大一点
        &#125;
    &#125;
&#125;
</code></pre>
<p>打包以后</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211195839190.png" alt="image-20240211195839190"></p>
<p>图片也打包了</p>
<p>这样就可以了</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211195917642.png" alt="image-20240211195917642"></p>
<p>小图片转为 base64的作用就是减少服务器的压力</p>
<p>现在有点乱</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211200201882.png" alt="image-20240211200201882"></p>
<p>我们需要对打包的路径进行优化‘</p>
<pre><code class="diff">       generator: &#123;
+         filename: &#39;static/[hash][ext][query]&#39;
+       &#125;
</code></pre>
<pre><code class="js">            &#123;
                test: /\.(png|jpe?g|gif|webp|svg)/,
                type: &#39;asset&#39;,
                parser: &#123;
                    dataUrlCondition: &#123;
                        maxSize: 4 * 1024 // 4kb//小于多少的做转为base64
                        //优点就是减少请求的数量，缺点就是，体积会更大一点
                    &#125;,
                &#125;,
                generator: &#123;
                    //输出的文件名称，hash  生成唯一的哈希，ext文件的扩展名，query图片携带的参数
                    filename: &#39;static/[hash:10][ext][query]&#39;//hash后面+10，意思是只取十位
                &#125;
            &#125;
        ],
    &#125;,
</code></pre>
<p>还有一个</p>
<pre><code class="js">output: &#123;
    path: path.resolve(__dirname,&#39;dist&#39;),//输出路径绝对路径，使用path解决__dirname代表当前文件夹目录
    filename: &quot;main.js&quot;,//入口文件输出的文件名字
    clean: true,//自动清空上次打包的

&#125;,
</code></pre>
<h2 id="处理字体图标"><a href="#处理字体图标" class="headerlink" title="处理字体图标"></a>处理字体图标</h2><p>先在</p>
<p>阿里巴巴上面找到几个图标</p>
<p>放在仓库在下载</p>
<p>使用iconfont的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211204324681.png" alt="image-20240211204324681"></p>
<p>然后打包的loader和图片的差不多，但是有几处改动</p>
<p>代码</p>
<pre><code class="js">            &#123;
                test: /\.(png|jpe?g|gif|webp|svg)/,
                type: &#39;asset&#39;,
                parser: &#123;
                    dataUrlCondition: &#123;
                        maxSize: 4 * 1024 // 4kb//小于多少的做转为base64
                        //优点就是减少请求的数量，缺点就是，体积会更大一点
                    &#125;,
                &#125;,
                generator: &#123;
                    //输出的文件名称，hash  生成唯一的哈希，ext文件的扩展名，query图片携带的参数
                    filename: &#39;static/images/[hash:10][ext][query]&#39;//hash后面+10，意思是只取十位
                &#125;
            &#125;,
            &#123;
                test: /\.(ttf|woff2?)/,
                type: &#39;asset/resource&#39;,
                parser: &#123;
                    dataUrlCondition: &#123;
                        maxSize: 4 * 1024 // 4kb//小于多少的做转为base64
                        //优点就是减少请求的数量，缺点就是，体积会更大一点
                    &#125;,
                &#125;,
                generator: &#123;
                    //输出的文件名称，hash  生成唯一的哈希，ext文件的扩展名，query图片携带的参数
                    filename: &#39;static/media/[hash:10][ext][query]&#39;//hash后面+10，意思是只取十位
                &#125;
            &#125;
</code></pre>
<p>后面的是图标</p>
<h2 id="处理其他的资源"><a href="#处理其他的资源" class="headerlink" title="处理其他的资源"></a>处理其他的资源</h2><p>比如说视频什么的</p>
<p>要是有的话</p>
<p>也不会有很大的改动</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211204616183.png" alt="image-20240211204616183"></p>
<p>就是在处理字体图标的后面添加一些就ok了</p>
<h2 id="处理js资源"><a href="#处理js资源" class="headerlink" title="处理js资源"></a>处理js资源</h2><p>有人可能会问，js 资源 Webpack 不能已经处理了吗，为什么我们还要处理呢？</p>
<p>原因是 Webpack 对 js 处理是有限的，只能编译 js 中 ES 模块化语法，不能编译其他语法，导致 js 不能在 IE 等浏览器运行，所以我们希望做一些兼容性处理。</p>
<p>其次开发中，团队对代码格式是有严格要求的，我们不能由肉眼去检测代码格式，需要使用专业的工具来检测。</p>
<ul>
<li>针对 js 兼容性处理，我们使用 Babel 来完成</li>
<li>针对代码格式，我们使用 Eslint 来完成</li>
</ul>
<p>我们先完成 Eslint，检测代码格式无误后，在由 Babel 做代码兼容性处理</p>
<h3 id="ESlint"><a href="#ESlint" class="headerlink" title="ESlint"></a>ESlint</h3><p>可组装的 JavaScript 和 JSX 检查工具。</p>
<p>这句话意思就是：它是用来检测 js 和 jsx 语法的工具，可以配置各项功能</p>
<p>我们使用 Eslint，关键是写 Eslint 配置文件，里面写上各种 rules 规则，将来运行 Eslint 时就会以写的规则对代码进行检查</p>
<h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件由很多种写法：</p>
<ul>
<li><pre><code>.eslintrc.*
</code></pre>
<p>：新建文件，位于项目根目录</p>
<ul>
<li><code>.eslintrc</code></li>
<li><code>.eslintrc.js</code></li>
<li><code>.eslintrc.json</code></li>
<li>区别在于配置格式不一样</li>
</ul>
</li>
<li><p><code>package.json</code> 中 <code>eslintConfig</code>：不需要创建文件，在原有文件基础上写</p>
</li>
</ul>
<p>ESLint 会查找和自动读取它们，所以以上配置文件只需要存在一个即可</p>
<p>我们以 <code>.eslintrc.js</code> 配置文件为例：</p>
<pre><code class="javascript">module.exports = &#123;
  // 解析选项
  parserOptions: &#123;&#125;,
  // 具体检查规则
  rules: &#123;&#125;,
  // 继承其他规则
  extends: [],
  // ...
  // 其他规则详见：https://eslint.bootcss.com/docs/user-guide/configuring
&#125;;
</code></pre>
<ol>
<li>parserOptions 解析选项</li>
</ol>
<pre><code class="javascript">parserOptions: &#123;
  ecmaVersion: 6, // ES 语法版本
  sourceType: &quot;module&quot;, // ES 模块化
  ecmaFeatures: &#123; // ES 其他特性
    jsx: true // 如果是 React 项目，就需要开启 jsx 语法
  &#125;
&#125;
</code></pre>
<ol>
<li>rules 具体规则</li>
</ol>
<ul>
<li><code>&quot;off&quot;</code> 或 <code>0</code> - 关闭规则</li>
<li><code>&quot;warn&quot;</code> 或 <code>1</code> - 开启规则，使用警告级别的错误：<code>warn</code> (不会导致程序退出)</li>
<li><code>&quot;error&quot;</code> 或 <code>2</code> - 开启规则，使用错误级别的错误：<code>error</code> (当被触发的时候，程序会退出)</li>
</ul>
<pre><code class="javascript">rules: &#123;
  semi: &quot;error&quot;, // 禁止使用分号
  &#39;array-callback-return&#39;: &#39;warn&#39;, // 强制数组方法的回调函数中有 return 语句，否则警告
  &#39;default-case&#39;: [
    &#39;warn&#39;, // 要求 switch 语句中有 default 分支，否则警告
    &#123; commentPattern: &#39;^no default$&#39; &#125; // 允许在最后注释 no default, 就不会有警告了
  ],
  eqeqeq: [
    &#39;warn&#39;, // 强制使用 === 和 !==，否则警告
    &#39;smart&#39; // https://eslint.bootcss.com/docs/rules/eqeqeq#smart 除了少数情况下不会有警告
  ],
&#125;
</code></pre>
<ol>
<li>extends 继承</li>
</ol>
<p>开发中一点点写 rules 规则太费劲了，所以有更好的办法，继承现有的规则。</p>
<p>现有以下较为有名的规则：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://eslint.bootcss.com/docs/rules/">Eslint 官方的规则open in new window</a>：<code>eslint:recommended</code></li>
<li><a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-cli/tree/dev/packages/@vue/cli-plugin-eslint">Vue Cli 官方的规则open in new window</a>：<code>plugin:vue/essential</code></li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/create-react-app/tree/main/packages/eslint-config-react-app">React Cli 官方的规则open in new window</a>：<code>react-app</code></li>
</ul>
<pre><code class="javascript">// 例如在React项目中，我们可以这样写配置
module.exports = &#123;
  extends: [&quot;react-app&quot;],
  rules: &#123;
    // 我们的规则会覆盖掉react-app的规则
    // 所以想要修改规则直接改就是了
    eqeqeq: [&quot;warn&quot;, &quot;smart&quot;],
  &#125;,
&#125;;
</code></pre>
<p>使用教程</p>
<p>先安装</p>
<pre><code class="bash">npm install eslint --save-dev
npm i eslint-webpack-plugin eslint -D
</code></pre>
<p>是一个插件</p>
<p>需要在插件</p>
<p>里面</p>
<pre><code class="js">const &#123;ESLint&#125; = require(&quot;eslint&quot;);
const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);
    
    plugins: [
        //插件的位置
        new ESLintWebpackPlugin(&#123;
            // 指定检查文件的根目录
            context: path.resolve(__dirname, &quot;src&quot;),//哪些文件需要被检查
        &#125;),
    ],
</code></pre>
<p>然后在根目录下</p>
<p>添加eslint的配置文件，内容直接去下面的链接去复制</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211212657093.png" alt="image-20240211212657093"></p>
<p>[<a target="_blank" rel="noopener" href="https://webpack.docschina.org/plugins/eslint-webpack-plugin]">https://webpack.docschina.org/plugins/eslint-webpack-plugin]</a>: </p>
<p>我们写一段不符合规范的代码再去试一试</p>
<p>刚才在配置文件中</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211212859809.png" alt="image-20240211212859809"></p>
<p>不能允许使用var定义变量</p>
<p>vscode里面有一个插件</p>
<p>eslink就可以在编译之前访问你的eslink的配置文件，然后提示你的代码哪里出错</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211213221054.png" alt="image-20240211213221054"></p>
<p>webstorm手动配置EsLink</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211213645544.png" alt="image-20240211213645544"></p>
<p>我们还可以配置不检查的文件</p>
<p>根目录创建</p>
<p>.<strong>eslinkignore</strong></p>
<p>下面写哪些目录不用语法检查</p>
<h3 id="babel的用法"><a href="#babel的用法" class="headerlink" title="babel的用法"></a>babel的用法</h3><p><strong>主要用于将 ES6 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中</strong></p>
<h3 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h3><p>配置文件由很多种写法：</p>
<ul>
<li><pre><code>babel.config.*
</code></pre>
<p>：新建文件，位于项目根目录</p>
<ul>
<li><code>babel.config.js</code></li>
<li><code>babel.config.json</code></li>
</ul>
</li>
<li><pre><code>.babelrc.*
</code></pre>
<p>：新建文件，位于项目根目录</p>
<ul>
<li><code>.babelrc</code></li>
<li><code>.babelrc.js</code></li>
<li><code>.babelrc.json</code></li>
</ul>
</li>
<li><p><code>package.json</code> 中 <code>babel</code>：不需要创建文件，在原有文件基础上写</p>
</li>
</ul>
<p>Babel 会查找和自动读取它们，所以以上配置文件只需要存在一个即可</p>
<h3 id="2-具体配置"><a href="#2-具体配置" class="headerlink" title="#2. 具体配置"></a><a target="_blank" rel="noopener" href="https://xxpromise.gitee.io/webpack5-docs/base/javascript.html#_2-%E5%85%B7%E4%BD%93%E9%85%8D%E7%BD%AE-1">#</a>2. 具体配置</h3><p>我们以 <code>babel.config.js</code> 配置文件为例：</p>
<pre><code class="javascript">module.exports = &#123;
  // 预设
  presets: [],
&#125;;
</code></pre>
<p>1<br>2<br>3<br>4</p>
<ol>
<li>presets 预设</li>
</ol>
<p>简单理解：就是一组 Babel 插件, 扩展 Babel 功能</p>
<ul>
<li><code>@babel/preset-env</code>: 一个智能预设，允许您使用最新的 JavaScript。</li>
<li><code>@babel/preset-react</code>：一个用来编译 React jsx 语法的预设</li>
<li><code>@babel/preset-typescript</code>：一个用来编译 TypeScript 语法的预设</li>
</ul>
<h3 id="3-在-Webpack-中使用"><a href="#3-在-Webpack-中使用" class="headerlink" title="#3. 在 Webpack 中使用"></a><a target="_blank" rel="noopener" href="https://xxpromise.gitee.io/webpack5-docs/base/javascript.html#_3-%E5%9C%A8-webpack-%E4%B8%AD%E4%BD%BF%E7%94%A8-1">#</a>3. 在 Webpack 中使用</h3><p>安装</p>
<pre><code class="bash">npm install -D babel-loader @babel/core @babel/preset-env webpack
</code></pre>
<p>多种写法</p>
<p>第一种</p>
<pre><code class="js">&#123;
    test: /\.m?js$/,
    exclude: /(node_modules|bower_components)/,//排除node_modules的js不处理
    use: &#123;
        loader: &#39;babel-loader&#39;,
        options: &#123;
            presets: [&#39;@babel/preset-env&#39;],
        &#125;,
    &#125;,
&#125;,
</code></pre>
<p>直接复制的</p>
<p>还有</p>
<p>第二种</p>
<pre><code class="js">&#123;
    test: /\.m?js$/,
    exclude: /(node_modules|bower_components)/,//排除node_modules的js不处理
    loader: &#39;babel-loader&#39;,
    // options: &#123;
    //     presets: [&#39;@babel/preset-env&#39;],
    // &#125;,
&#125;,
</code></pre>
<p>然后再</p>
<p>根目录创建babel.config.js</p>
<pre><code class="js">module.exports = &#123;
    presets: [&#39;@babel/preset-env&#39;]//智能预设，能够编译es6的语法
&#125;
</code></pre>
<p>然后在打包</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240211215243331.png" alt="image-20240211215243331"></p>
<p>发现之前使用的箭头函数和三点运算符都被替换了</p>
<h2 id="处理html资源"><a href="#处理html资源" class="headerlink" title="处理html资源"></a>处理html资源</h2><p><strong>HtmlWebpackPlugin</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/jantimon/html-webpack-plugin"><code>HtmlWebpackPlugin</code></a> 简化了 HTML 文件的创建，以便为你的 webpack 包提供服务。这对于那些文件名中包含哈希值，并且哈希值会随着每次编译而改变的 webpack 包特别有用。你可以让该插件为你生成一个 HTML 文件，使用 <a target="_blank" rel="noopener" href="https://lodash.com/docs#template">lodash 模板</a>提供模板，或者使用你自己的 <a target="_blank" rel="noopener" href="https://webpack.docschina.org/loaders">loader</a>。</p>
<p><strong>安装</strong></p>
<pre><code class="bash">npm install --save-dev html-webpack-plugin
</code></pre>
<p><strong>基本用法</strong></p>
<p>该插件将为你生成一个 HTML5 文件， 在 body 中使用 <code>script</code> 标签引入你所有 webpack 生成的 bundle。 只需添加该插件到你的 webpack 配置中，如下所示：</p>
<pre><code class="javascript">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const path = require(&#39;path&#39;);

module.exports = &#123;
  entry: &#39;index.js&#39;,
  output: &#123;
    path: path.resolve(__dirname, &#39;./dist&#39;),
    filename: &#39;index_bundle.js&#39;,
  &#125;,
  plugins: [new HtmlWebpackPlugin()],
&#125;;
</code></pre>
<p>这将会生成一个包含以下内容的 <code>dist/index.html</code> 文件：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;webpack App&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;index_bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果你有多个 webpack 入口，他们都会在已生成 HTML 文件中的 <code>&lt;script&gt;</code> 标签内引入。</p>
<p>如果在 webpack 的输出中有任何 CSS 资源（例如，使用 <a target="_blank" rel="noopener" href="https://webpack.docschina.org/plugins/mini-css-extract-plugin/">MiniCssExtractPlugin</a> 提取的 CSS），那么这些资源也会在 HTML 文件 <code>&lt;head&gt;</code> 元素中的 <code>&lt;link&gt;</code> 标签内引入。</p>
<p><strong>操作</strong></p>
<p>下载以后</p>
<pre><code>const HtmlWebpackPlugin= require(&quot;html-webpack-plugin&quot;)
plugins: [
        //插件的位置
        new HtmlWebpackPlugin(),
        new ESLintWebpackPlugin(&#123;
            // 指定检查文件的根目录
            context: path.resolve(__dirname, &quot;src&quot;),//哪些文件需要被检查
        &#125;),
    ],
</code></pre>
<p>然后在打包</p>
<p>这样打包文件就会有一个html的文件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240213132926601.png" alt="image-20240213132926601"></p>
<p>而且会引入入口文件</p>
<p>但是之前的dom元素没有了</p>
<pre><code class="ts">plugins: [
    //插件的位置
    new HtmlWebpackPlugin(&#123;
        template: path.resolve(__dirname, &quot;public/index.html&quot;),//以public为模板创建
    &#125;),
    new ESLintWebpackPlugin(&#123;
        // 指定检查文件的根目录
        context: path.resolve(__dirname, &quot;src&quot;),//哪些文件需要被检查
    &#125;),
],
</code></pre>
<p>着用就可以把都没元素</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240213133213826.png" alt="image-20240213133213826"></p>
<h2 id="如何自动打包，再更改原先的模板的时候"><a href="#如何自动打包，再更改原先的模板的时候" class="headerlink" title="如何自动打包，再更改原先的模板的时候"></a>如何自动打包，再更改原先的模板的时候</h2><p>之前每次改代码，只有再从新打包以后才能看见效果</p>
<p>就需要自动化</p>
<h3 id="开发服务器-自动化"><a href="#开发服务器-自动化" class="headerlink" title="开发服务器&amp;自动化"></a>开发服务器&amp;自动化</h3><p>每次写完代码都需要手动输入指令才能编译代码，太麻烦了，我们希望一切自动化，就需要使用自动化工具</p>
<h4 id="1-下载包"><a href="#1-下载包" class="headerlink" title="#1. 下载包"></a><a target="_blank" rel="noopener" href="https://xxpromise.gitee.io/webpack5-docs/base/server.html#_1-%E4%B8%8B%E8%BD%BD%E5%8C%85">#</a>1. 下载包</h4><pre><code class="text">npm i webpack-dev-server -D
</code></pre>
<h4 id="2-配置"><a href="#2-配置" class="headerlink" title="#2. 配置"></a><a target="_blank" rel="noopener" href="https://xxpromise.gitee.io/webpack5-docs/base/server.html#_2-%E9%85%8D%E7%BD%AE">#</a>2. 配置</h4><ul>
<li>webpack.config.js</li>
</ul>
<pre><code class="javascript">const path = require(&quot;path&quot;);
const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);

module.exports = &#123;
  entry: &quot;./src/main.js&quot;,
  output: &#123;
    path: path.resolve(__dirname, &quot;dist&quot;),
    filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中
    clean: true, // 自动将上次打包目录资源清空
  &#125;,
  module: &#123;
    rules: [
      &#123;
        // 用来匹配 .css 结尾的文件
        test: /\.css$/,
        // use 数组里面 Loader 执行顺序是从右到左
        use: [&quot;style-loader&quot;, &quot;css-loader&quot;],
      &#125;,
      &#123;
        test: /\.less$/,
        use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;],
      &#125;,
      &#123;
        test: /\.s[ac]ss$/,
        use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;],
      &#125;,
      &#123;
        test: /\.styl$/,
        use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;],
      &#125;,
      &#123;
        test: /\.(png|jpe?g|gif|webp)$/,
        type: &quot;asset&quot;,
        parser: &#123;
          dataUrlCondition: &#123;
            maxSize: 10 * 1024, // 小于10kb的图片会被base64处理
          &#125;,
        &#125;,
        generator: &#123;
          // 将图片文件输出到 static/imgs 目录中
          // 将图片文件命名 [hash:8][ext][query]
          // [hash:8]: hash值取8位
          // [ext]: 使用之前的文件扩展名
          // [query]: 添加之前的query参数
          filename: &quot;static/imgs/[hash:8][ext][query]&quot;,
        &#125;,
      &#125;,
      &#123;
        test: /\.(ttf|woff2?)$/,
        type: &quot;asset/resource&quot;,
        generator: &#123;
          filename: &quot;static/media/[hash:8][ext][query]&quot;,
        &#125;,
      &#125;,
      &#123;
        test: /\.js$/,
        exclude: /node_modules/, // 排除node_modules代码不编译
        loader: &quot;babel-loader&quot;,
      &#125;,
    ],
  &#125;,
  plugins: [
    new ESLintWebpackPlugin(&#123;
      // 指定检查文件的根目录
      context: path.resolve(__dirname, &quot;src&quot;),
    &#125;),
    new HtmlWebpackPlugin(&#123;
      // 以 public/index.html 为模板创建文件
      // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源
      template: path.resolve(__dirname, &quot;public/index.html&quot;),
    &#125;),
  ],
  // 开发服务器
  devServer: &#123;
    host: &quot;localhost&quot;, // 启动服务器域名
    port: &quot;3000&quot;, // 启动服务器端口号
    open: true, // 是否自动打开浏览器
  &#125;,
  mode: &quot;development&quot;,
&#125;;
</code></pre>
<h4 id="3-运行指令"><a href="#3-运行指令" class="headerlink" title="#3. 运行指令"></a><a target="_blank" rel="noopener" href="https://xxpromise.gitee.io/webpack5-docs/base/server.html#_3-%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A4">#</a>3. 运行指令</h4><pre><code class="text">npx webpack serve
</code></pre>
<p><strong>注意运行指令发生了变化</strong></p>
<p>并且当你使用开发服务器时，所有代码都会在内存中编译打包，并不会输出到 dist 目录下。</p>
<p>开发时我们只关心代码能运行，有效果即可，至于代码被编译成什么样子，我们并不需要知道。</p>
<p><strong>他会自动监视src目录下代码的改变，如果发生了改变就会重新打包</strong></p>
<p><strong>以上是开发模式的学习</strong></p>
<p><strong>下面是生产模式的学习</strong></p>
<h1 id="准备生产模式"><a href="#准备生产模式" class="headerlink" title="准备生产模式"></a><strong>准备生产模式</strong></h1><p>这里说一下</p>
<p>把配置文件写在ige文件夹里面</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240213134546821.png" alt="image-20240213134546821"></p>
<p>一个是生产模式</p>
<p>一个是开发模式</p>
<p>生产模式的代码需要更改一下</p>
<p>其中这里的entry不用改</p>
<p>因为这个config运行的位置还是在外面根目录下运行的只是文件的目录做个更改</p>
<p>但是输出的位置 需要</p>
<pre><code>odule.exports = &#123;
    //入口
    entry:&#39;./src/main.js&#39;,//相对路径
    //输出
    output: &#123;
        path: path.resolve(__dirname,&#39;../dist&#39;),//输出路径绝对路径，使用path解决__dirname代表当前文件夹目录
        filename: undefined,//入口文件输出的文件名字,生产模式们没有输出
        clean: true,//自动清空上次打包的

    &#125;,
</code></pre>
<p>运行指令</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240213135149934.png" alt="image-20240213135149934"></p>
<p>这是开发模式的更改</p>
<p>​	我们然后在定义几个指令</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240213140006993.png" alt="image-20240213140006993"></p>
<p>这样就可以使用</p>
<pre><code class="bash">npm run build //启动生产者
npm run start //启动开发者模式
npm run dev
//后面的两个指令可以省略run
</code></pre>
<h2 id="css样式处理"><a href="#css样式处理" class="headerlink" title="css样式处理"></a>css样式处理</h2><p>Css 文件目前被打包到 js 文件中，当 js 文件加载时，会创建一个 style 标签来生成样式</p>
<p>这样对于网站来说，会出现闪屏现象，用户体验不好</p>
<p><strong>我们应该是单独的 Css 文件，通过 link 标签加载性能才好</strong></p>
<p>闪屏是什么？</p>
<p>就是之前的，css是js运行的时候，动态插入的</p>
<p>网速稍微慢一点，js加载就慢，这个css样式一瞬间加载出来</p>
<h4 id="1-下载包-1"><a href="#1-下载包-1" class="headerlink" title="1. 下载包"></a>1. 下载包</h4><pre><code class="text">npm i mini-css-extract-plugin -D
</code></pre>
<h4 id="2-配置-1"><a href="#2-配置-1" class="headerlink" title="#2. 配置"></a><a target="_blank" rel="noopener" href="https://xxpromise.gitee.io/webpack5-docs/base/optimizeCss.html#_2-%E9%85%8D%E7%BD%AE">#</a>2. 配置</h4><ul>
<li>webpack.prod.js</li>
<li>记住把之前使用所有style.loader的地方，都换成插件的名字，因为不需要使用style</li>
</ul>
<pre><code class="javascript">const path = require(&quot;path&quot;);
const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);

module.exports = &#123;
  entry: &quot;./src/main.js&quot;,
  output: &#123;
    path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出
    filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中
    clean: true,
  &#125;,
  module: &#123;
    rules: [
      &#123;
        // 用来匹配 .css 结尾的文件
        test: /\.css$/,
        // use 数组里面 Loader 执行顺序是从右到左
        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;],
      &#125;,
      &#123;
        test: /\.less$/,
        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;less-loader&quot;],
      &#125;,
      &#123;
        test: /\.s[ac]ss$/,
        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;sass-loader&quot;],
      &#125;,
      &#123;
        test: /\.styl$/,
        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;stylus-loader&quot;],
      &#125;,
      &#123;
        test: /\.(png|jpe?g|gif|webp)$/,
        type: &quot;asset&quot;,
        parser: &#123;
          dataUrlCondition: &#123;
            maxSize: 10 * 1024, // 小于10kb的图片会被base64处理
          &#125;,
        &#125;,
        generator: &#123;
          // 将图片文件输出到 static/imgs 目录中
          // 将图片文件命名 [hash:8][ext][query]
          // [hash:8]: hash值取8位
          // [ext]: 使用之前的文件扩展名
          // [query]: 添加之前的query参数
          filename: &quot;static/imgs/[hash:8][ext][query]&quot;,
        &#125;,
      &#125;,
      &#123;
        test: /\.(ttf|woff2?)$/,
        type: &quot;asset/resource&quot;,
        generator: &#123;
          filename: &quot;static/media/[hash:8][ext][query]&quot;,
        &#125;,
      &#125;,
      &#123;
        test: /\.js$/,
        exclude: /node_modules/, // 排除node_modules代码不编译
        loader: &quot;babel-loader&quot;,
      &#125;,
    ],
  &#125;,
  plugins: [
    new ESLintWebpackPlugin(&#123;
      // 指定检查文件的根目录
      context: path.resolve(__dirname, &quot;../src&quot;),
    &#125;),
    new HtmlWebpackPlugin(&#123;
      // 以 public/index.html 为模板创建文件
      // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源
      template: path.resolve(__dirname, &quot;../public/index.html&quot;),
    &#125;),
    // 提取css成单独文件
    new MiniCssExtractPlugin(&#123;
      // 定义输出文件名和目录
      filename: &quot;static/css/main.css&quot;,
    &#125;),
  ],
  // devServer: &#123;
  //   host: &quot;localhost&quot;, // 启动服务器域名
  //   port: &quot;3000&quot;, // 启动服务器端口号
  //   open: true, // 是否自动打开浏览器
  // &#125;,
  mode: &quot;production&quot;,
&#125;;
</code></pre>
<h4 id="3-运行指令-1"><a href="#3-运行指令-1" class="headerlink" title="#3. 运行指令"></a><a target="_blank" rel="noopener" href="https://xxpromise.gitee.io/webpack5-docs/base/optimizeCss.html#_3-%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A4">#</a>3. 运行指令</h4><pre><code class="text">npm run build
</code></pre>
<p>这样以后</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240213142024427.png" alt="image-20240213142024427"></p>
<h2 id="css兼容性的处理"><a href="#css兼容性的处理" class="headerlink" title="css兼容性的处理"></a>css兼容性的处理</h2><h2 id="css压缩"><a href="#css压缩" class="headerlink" title="css压缩"></a>css压缩</h2><ol>
<li><strong>下载包</strong></li>
</ol>
<pre><code class="text">npm i css-minimizer-webpack-plugin -D
</code></pre>
<p><a target="_blank" rel="noopener" href="https://xxpromise.gitee.io/webpack5-docs/base/optimizeCss.html#_2-%E9%85%8D%E7%BD%AE-2">#</a>2. <strong>配置</strong></p>
<ul>
<li>webpack.prod.js</li>
</ul>
<pre><code class="javascript">const path = require(&quot;path&quot;);
const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);
const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);

// 获取处理样式的Loaders
const getStyleLoaders = (preProcessor) =&gt; &#123;
  return [
    MiniCssExtractPlugin.loader,
    &quot;css-loader&quot;,
    &#123;
      loader: &quot;postcss-loader&quot;,
      options: &#123;
        postcssOptions: &#123;
          plugins: [
            &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题
          ],
        &#125;,
      &#125;,
    &#125;,
    preProcessor,
  ].filter(Boolean);
&#125;;

module.exports = &#123;
  entry: &quot;./src/main.js&quot;,
  output: &#123;
    path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出
    filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中
    clean: true,
  &#125;,
  module: &#123;
    rules: [
      &#123;
        // 用来匹配 .css 结尾的文件
        test: /\.css$/,
        // use 数组里面 Loader 执行顺序是从右到左
        use: getStyleLoaders(),
      &#125;,
      &#123;
        test: /\.less$/,
        use: getStyleLoaders(&quot;less-loader&quot;),
      &#125;,
      &#123;
        test: /\.s[ac]ss$/,
        use: getStyleLoaders(&quot;sass-loader&quot;),
      &#125;,
      &#123;
        test: /\.styl$/,
        use: getStyleLoaders(&quot;stylus-loader&quot;),
      &#125;,
      &#123;
        test: /\.(png|jpe?g|gif|webp)$/,
        type: &quot;asset&quot;,
        parser: &#123;
          dataUrlCondition: &#123;
            maxSize: 10 * 1024, // 小于10kb的图片会被base64处理
          &#125;,
        &#125;,
        generator: &#123;
          // 将图片文件输出到 static/imgs 目录中
          // 将图片文件命名 [hash:8][ext][query]
          // [hash:8]: hash值取8位
          // [ext]: 使用之前的文件扩展名
          // [query]: 添加之前的query参数
          filename: &quot;static/imgs/[hash:8][ext][query]&quot;,
        &#125;,
      &#125;,
      &#123;
        test: /\.(ttf|woff2?)$/,
        type: &quot;asset/resource&quot;,
        generator: &#123;
          filename: &quot;static/media/[hash:8][ext][query]&quot;,
        &#125;,
      &#125;,
      &#123;
        test: /\.js$/,
        exclude: /node_modules/, // 排除node_modules代码不编译
        loader: &quot;babel-loader&quot;,
      &#125;,
    ],
  &#125;,
  plugins: [
    new ESLintWebpackPlugin(&#123;
      // 指定检查文件的根目录
      context: path.resolve(__dirname, &quot;../src&quot;),
    &#125;),
    new HtmlWebpackPlugin(&#123;
      // 以 public/index.html 为模板创建文件
      // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源
      template: path.resolve(__dirname, &quot;../public/index.html&quot;),
    &#125;),
    // 提取css成单独文件
    new MiniCssExtractPlugin(&#123;
      // 定义输出文件名和目录
      filename: &quot;static/css/main.css&quot;,
    &#125;),
    // css压缩
    new CssMinimizerPlugin(),
  ],
  // devServer: &#123;
  //   host: &quot;localhost&quot;, // 启动服务器域名
  //   port: &quot;3000&quot;, // 启动服务器端口号
  //   open: true, // 是否自动打开浏览器
  // &#125;,
  mode: &quot;production&quot;,
&#125;;
</code></pre>
<p>3.<strong>运行指令</strong></p>
<pre><code class="text">npm run build
</code></pre>
<h1 id="webpack高级配置"><a href="#webpack高级配置" class="headerlink" title="webpack高级配置"></a>webpack高级配置</h1><h2 id="sourceMap"><a href="#sourceMap" class="headerlink" title="sourceMap"></a>sourceMap</h2><p><a target="_blank" rel="noopener" href="https://xxpromise.gitee.io/webpack5-docs/senior/">介绍 | 尚硅谷 Web 前端之 Webpack5 教程 (gitee.io)</a></p>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 哈哈哈哈哈哈哈重生之我是兵王
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;chenw
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
