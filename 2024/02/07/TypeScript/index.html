
<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8" />
    <title>TypeScript | 哈哈哈哈哈哈哈重生之我是兵王</title>
    <meta name="author" content="chenw" />
    <meta name="description" content="description" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
	<canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
	<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
	<script src="/js/fireworks.min.js"></script>
	<canvas id="background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
	<script src="/js/background.min.js"></script>
	<div id="cursor"></div>
	<link rel="stylesheet" href="/css/cursor.min.css">
	<script src="/js/cursor.min.js"></script>
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>哈哈哈哈哈哈哈重生之我是兵王</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;哈哈哈哈哈哈哈重生之我是兵王</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>TypeScript</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/7
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/typescript/" style="color: #00a596">typescript</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p>摘要</p>
<span id="more"></span>
<p>正文</p>
<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p>哔哩哔哩  李立超</p>
<h2 id="typescript是什么？"><a href="#typescript是什么？" class="headerlink" title="typescript是什么？"></a>typescript是什么？</h2><p>对js进行扩展</p>
<p><strong>让js动态类型的变量，变成静态类类型的变量</strong></p>
<p>引入类型的概念</p>
<p>兼容js的平台</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207101404439.png" alt="image-20240207101404439"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207101425579.png" alt="image-20240207101425579"></p>
<p>先编译为JS在使用js的解析器</p>
<p>取代js不太可能，只能曲线救国</p>
<p>需要安装TS的编译器</p>
<p>TS增加了什么？</p>
<p><strong>支持ES的新特性</strong></p>
<p><strong>增加Es没有的新特性</strong></p>
<p><strong>丰富的的配置选项</strong></p>
<p><strong>类型</strong></p>
<p><strong>强大的开发工具</strong></p>
<p>其实我们时时刻刻都在使用TS</p>
<p>哪些写代码的时候的提示就是TS的结果</p>
<h2 id="环境的搭建"><a href="#环境的搭建" class="headerlink" title="环境的搭建"></a>环境的搭建</h2><p>使用下面的命令进行安装</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207102249030.png" alt="image-20240207102249030"></p>
<p>在使用tsc查看</p>
<p>创建ts文件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207102504965.png" alt="image-20240207102504965"></p>
<p>转换ts为js	</p>
<p>使用</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207102549189.png" alt="image-20240207102549189"></p>
<p>然后目录下就有</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207102634619.png" alt="image-20240207102634619"></p>
<p>js的文件</p>
<h2 id="基本的类型"><a href="#基本的类型" class="headerlink" title="基本的类型"></a>基本的类型</h2><p>使用webstorm</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207102850497.png" alt="image-20240207102850497"></p>
<p>可以给变量声明类型</p>
<p>在js里面这么写没问题</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207103002564.png" alt="image-20240207103002564"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207103106578.png" alt="image-20240207103106578"></p>
<p>指定类型以后就会报错</p>
<p>编译的时候也会报错</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207103251887.png" alt="image-20240207103251887"></p>
<p>但还是会生成js文件的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207103318799.png" alt="image-20240207103318799"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207104147240.png" alt="image-20240207104147240"></p>
<p>不用再写boolean</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207104241988.png" alt="image-20240207104241988"></p>
<p>会自动判断的</p>
<p>就不用加类型声明</p>
<p>给函数的参数定义类型</p>
<p><strong><img src="/TypeScript.assets/image-20240207104606729.png" alt="image-20240207104606729"></strong></p>
<h2 id="TS中的类型"><a href="#TS中的类型" class="headerlink" title="TS中的类型"></a>TS中的类型</h2><p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207104941859.png" alt="image-20240207104941859"></p>
<p><strong>字面量的赋值</strong></p>
<pre><code class="ts">let a:10
a=10
a=11//这里就会报错
</code></pre>
<p>有点像const</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207105144193.png" alt="image-20240207105144193"></p>
<p><strong>可以连接多个类型（联合类型）</strong></p>
<p>​	<strong>any</strong>	</p>
<p>​	</p>
<pre><code class="ts">let d : any
d = 10
d= &#39;hello&#39;
d = true
</code></pre>
<p>就相当于关闭这个类型检测</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207105405587.png" alt="image-20240207105405587"></p>
<p>any<strong>尽量不要使用</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207105602045.png" alt="image-20240207105602045"></p>
<p><strong>unknown</strong></p>
<p>表示未知的变量</p>
<pre><code class="ts">let k = unknown
 e= 10
 e= &#39;hello&#39;
 
</code></pre>
<p>和any的区别</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207105720403.png" alt="image-20240207105720403"></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207105734644.png" alt="image-20240207105734644"></p>
<p>那如果非要赋值的话</p>
<p>就可以这样的 e是unknown</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207105931926.png" alt="image-20240207105931926"></p>
<p><strong>void</strong></p>
<p>函数这里可以指定返回的类型</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207110158333.png" alt="image-20240207110158333"></p>
<p>没有return或者返回null和undefined就可以使用void</p>
<p><strong>never</strong></p>
<p> 表示永远不会返回</p>
<p>必须没有return</p>
<p>一般设置报错函数</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207110417863.png" alt="image-20240207110417863"></p>
<p><strong>object</strong></p>
<pre><code class="ts">let a : object
a = &#123;&#125;
</code></pre>
<p>一般只会指定对象里的属性</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207110650172.png" alt="image-20240207110650172"></p>
<p>指定属性这么写</p>
<pre><code class="ts">let b :&#123;name:string&#125;

b=&#123;name:&#39;hahha&#39;&#125;

</code></pre>
<p>不能多和少<img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207110809535.png" alt="image-20240207110809535"></p>
<p>如果想要可选</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207110842770.png" alt="image-20240207110842770"></p>
<p>如果没有定义但是还想要写这个属性</p>
<pre><code class="ts">let c :&#123;
    name:string
    [propNAme:string]:any//这一行代表propName随便写，表示属性名必须是字符串，值可以是any
&#125;
c=&#123;
    name:&#39;hahah&#39;
    age:18
    gender:&quot;female&quot;
&#125;
</code></pre>
<p>这样就不会报错</p>
<p>Function</p>
<pre><code class="ts">let d = (a:number,b:number)=&gt;number//代表两个参数都是数字，返回值也是数字类型的
d = function (n1,n2)&#123;
    return n1+n2
&#125;
d(10,20)
</code></pre>
<p>语法是这样的</p>
<p><strong>array</strong></p>
<p>数组存储的都是一个类型的</p>
<pre><code class="ts">let e: string[]
e=[&#39;e&#39;.&#39;g&#39;]
//或者
let g:Array&lt;string&gt;
g=[&#39;a&#39;,&#39;s&#39;]
</code></pre>
<p><strong>tuple</strong></p>
<p>扩展的类型元组</p>
<p>就是固定长度的数组</p>
<pre><code class="ts">let k:[string,number,boolean]
k = [&#39;e&#39;,&#39;e&#39;,true]
</code></pre>
<p><strong>enum</strong></p>
<p>新增的枚举</p>
<pre><code class="ts">let i :&#123;
    name:string
    sex:number
&#125;
i = &#123;
    name:&#39;hutut&#39;
    sex:1
&#125;
</code></pre>
<p>有些值处在一定的范围</p>
<p>比如男女的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207112953031.png" alt="image-20240207112953031"></p>
<p>所有的可能获取出来</p>
<pre><code class="ts">enum Gender &#123;//创建枚举的类
    Male=0,
    Female=1
&#125;
let i :&#123;
    name:string
    sex:Gender
&#125;
i = &#123;
    name:&#39;hutut&#39;,
    sex:Gender.Male
&#125;
console.log(i.sex===Gender.Male)
</code></pre>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207113534049.png" alt="image-20240207113534049"></p>
<p><strong>之前类型有|还有&amp;</strong>****</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207113712766.png" alt="image-20240207113712766"></p>
<p>一个变量怎既能是字符串又是数字</p>
<p>这种用法可以在对象里使用</p>
<pre><code class="ts">let i :&#123;name:string&#125; &amp; &#123;age:number&#125;
i=&#123;
    name:&#39;sun&#39;,
    age:18
&#125;
</code></pre>
<p><strong>类型的别名</strong></p>
<pre><code class="ts">let k : 1|2|3|4|5
let i:  1|2|3|4|5//这样写就会复杂
可以这么写
type myType =  1|2|3|4|5
let k : 1|2|3|4|5
let i:  1|2|3|4|5
let g: mytype
g = 5
type mytype1 =string
a : mytype1
a = &#39;aaa&#39;
</code></pre>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><strong>编译选项</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207134220720.png" alt="image-20240207134220720"></p>
<p>这样就可以处于监视的模式</p>
<p>可以编写边编译</p>
<p>然后就可以</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207134349213.png" alt="image-20240207134349213"></p>
<p>自动监视文件的变化</p>
<p>不用手动编译了</p>
<p>使用一个命令	所有的文件都能编译</p>
<p>条件有一个配置文件</p>
<p>新建一个</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207134711566.png" alt="image-20240207134711566"></p>
<p>默认的配置文件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207134749555.png" alt="image-20240207134749555"></p>
<p>在执行</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207134857401.png" alt="image-20240207134857401"></p>
<p>tsc就能编译所有的</p>
<p>再看配置文件</p>
<pre><code class="ts">&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;module&quot;: &quot;commonjs&quot;,
    &quot;target&quot;: &quot;es5&quot;,
    &quot;sourceMap&quot;: true
  &#125;,
  &quot;exclude&quot;: [//和include是相反的，不要编译的文件
    &quot;node_modules&quot;
  ],
  &quot;include&quot;: [//哪些文件应该被编译，里面可以写路径
    &quot;./**/*&quot;//例如:表示当前目录下的所有目录和文件
  ]
&#125;
</code></pre>
<p>但配置文件比较复杂的时候</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207135456819.png" alt="image-20240207135456819"></p>
<p>继承一下就是引入外部的</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207135534115.png" alt="image-20240207135534115"></p>
<p>和include相似，一般用不上</p>
<p><strong>complierOptions</strong>选项</p>
<p>编译器的选项</p>
<pre><code class="ts">
  &quot;compilerOptions&quot;: &#123;
    &quot;module&quot;: &quot;commonjs&quot;,//模块指定模块化	的规范
    &quot;target&quot;: &quot;es5&quot;,//目标指定ts被编译成的版本最新的额话可以
    &quot;sourceMap&quot;: true,
    //&quot;lib&quot;:[]指定项目要使用的库有默认的
  &#125;,
</code></pre>
<p>target接收的值</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207140020072.png" alt="image-20240207140020072"></p>
<p>esnet是最新的</p>
<p>outDir：设置编译玩的js文件放在哪个目录下</p>
<p>outFile：把多个文件编译成一个js文件</p>
<p>allowJs：是否对js文件做编译，默认为false</p>
<p>checkJs：检查js代码符合语法符合规范，默认不检查</p>
<p>removeComment：是否在编译的时候移除注释</p>
<p>noEmit：不生成编译后的js文件</p>
<p>noEmitOnError：如果有错误的话不生成编译后的js文件</p>
<p>alwaysStrict：使用编译后的js严格模式。默认不开</p>
<p>noImplicitAny：检查不允许隐式any类型</p>
<p>noImplicitThis：检查类型不明的this，</p>
<p>strictNullCheck：检查空值，如下图，box1有可能为null</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207142309924.png" alt="image-20240207142309924"></p>
<p>如果想跳过</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207142352087.png" alt="image-20240207142352087"></p>
<p>或者使用问号</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207142426466.png" alt="image-20240207142426466"></p>
<p>strict：所有严格查询的总开关，只要你设置为true，上面都true了</p>
<h2 id="使用webpack打包TS"><a href="#使用webpack打包TS" class="headerlink" title="使用webpack打包TS"></a>使用webpack打包TS</h2><p>​	首先初始化</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207142737593.png" alt="image-20240207142737593"></p>
<p>在下载这几个包</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207144417136.png" alt="image-20240207144417136">)</p>
<p>在新建一个webpack的配置文件</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207144544560.png" alt="image-20240207144544560"></p>
<p>配置文件的代码</p>
<pre><code class="js">const path = require(&#39;path&#39;)
const &#123;tsxRegex&#125; = require(&quot;ts-loader/dist/constants&quot;);
const &#123;tsLoaderSource&#125; = require(&quot;ts-loader/dist/utils&quot;);
//导入 包
//webpack中的 所有配置信息都应该写在module.exports里面
module.exports=&#123;
    //指定入口文件
    entry:&#39;./src/index.ts&#39;,
    //打包文件所在目录
    output:&#123;
        path:path.resolve(__dirname,&#39;dist&#39;),//拼接路径
        filename:&#39;bundle.js&#39;//打包后的文件名称
    &#125;,
    //指定webpack打包时使用的模块
    module:&#123;
        rules:[
            &#123;
                //test规则生效的文件
                test:/\.ts$/,
                //使用的loader
                use:&quot;tsLoader&quot;,
                //要排除 的文件
                exclude:/node-modules/
            &#125;
        ]
    &#125;
&#125;
</code></pre>
<p><strong>学完这个再去学webpck，webpack没有学过，所以看起来有点复杂</strong></p>
<p>然后再去package.json加入脚本build</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207150919604.png" alt="image-20240207150919604"></p>
<p>在运行</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207151810045.png" alt="image-20240207151810045"></p>
<p>失败了学完wbpack再来看看</p>
<p>webpack的先过继续像后面学习</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207153033079.png" alt="image-20240207153033079"></p>
<p><strong>类的简介</strong></p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207153132138.png" alt="image-20240207153132138"></p>
<pre><code class="ts">class Person&#123;
    name:string=&#39;hahha&#39;,
    age=18,
&#125;
const wcc = new Person()
</code></pre>
<p>创建静态属性</p>
<p>不需要实例对象就可以使用的属性</p>
<pre><code class="ts">class Person&#123;
    name:string=&#39;hahha&#39;,
    age=18,
    static job = &#39;cxy&#39;
&#125;
const wcc = new Person()
console.log(Person.job)//直接通过类去读
</code></pre>
<p>直接定义的属性实例属性，通过对象访问</p>
<p>如果前面加上</p>
<p><img src="https://hututu345.oss-cn-beijing.aliyuncs.com/typora/image-20240207154256402.png" alt="image-20240207154256402"></p>
<p>只能读不能修改</p>
<p>定义方法</p>
<pre><code class="ts">class Person&#123;
    name:string=&#39;hahha&#39;
    age=18
    static job = &#39;cxy&#39;
    sayHello()&#123;
        console.log(&quot;hello&quot;)
    &#125;
    
&#125;
const wcc = new Person()
console.log(Person.job)//直接通过类去读
wcc.sayHello()
</code></pre>
<p><strong>构造函数</strong></p>
<pre><code class="ts">class Dog&#123;
    constructor(name:string,age:number)&#123;
        //在new的时候执行
        console.log(this)//表示当前的dog对昂
        this.name = name
        this.age =age
        
        
    &#125;
    bark()&#123;
        alert(&#39;wangwang&#39;)
    &#125;
&#125;
const dog =new Dog(&#39;xiaobai&#39;,18)
console.log(dog)
</code></pre>
<p><strong>继承</strong></p>
<pre><code class="ts">class Animal&#123;
    name:string
    age:number
    constructor(name:string,age:number)&#123;
        //在new的时候执行
        console.log(this)//表示当前的dog对昂
        this.name = name
        this.age =age
    &#125;
    bark()&#123;
        console.log(&#39;动物叫&#39;)
    &#125;
&#125;
class Dog extends Animal&#123;
    tiao()&#123;
        console.log(&quot;tiao&quot;)//独有的方法
    &#125;
&#125;
class Cat extends Animal&#123;
    sayHello()&#123;
        console.log(&#39;miaomioa&#39;)
    &#125;
&#125;
const dog =new Dog(&#39;xiaobai&#39;,18)
console.log(dog)
dog.bark()
const cat =new Cat(&#39;xiaobai&#39;,18)
console.log(cat)
cat.bark()
</code></pre>
<p>都继承了person</p>
<p>好像java</p>
<p>子类定义一样的方法就会覆盖之前的方法</p>
<p><strong>super关键字</strong></p>
<p>就是代表父类</p>
<pre><code class="ts">class Animal&#123;
    name:string
    age:number
    job = &quot;hahah&quot;
    constructor(name:string,age:number)&#123;
        //在new的时候执行
        console.log(this)//表示当前的dog对昂
        this.name = name
        this.age =age
    &#125;
    bark()&#123;
        console.log(&#39;动物叫&#39;)
    &#125;
&#125;
class Dog extends Animal&#123;
    tiao()&#123;
        console.log(&quot;tiao&quot;)//独有的方法
    &#125;
&#125;
class Cat extends Animal&#123;
    sayHello()&#123;
        //console.log(&#39;miaomioa&#39;)
        super.sayHello()
        console.log(super.job)//可以读到父类的的方法和属性
    &#125;
&#125;
const dog =new Dog(&#39;xiaobai&#39;,18)
console.log(dog)
dog.bark()
const cat =new Cat(&#39;xiaobai&#39;,18)
console.log(cat)
cat.bark()
</code></pre>
<p>super关键字可以读到父类的方法和属性</p>
<p>注意：</p>
<p>如果在子类里面在使用构造函数，就会导致父类的构造函数被覆盖</p>
<p>之前子类没有构造函数，他会自己帮你调用父类的构造函数，所以你还想再子类定义一个构造函数就要这么 写</p>
<pre><code class="ts">class Animal&#123;
    name:string
    age:number
    job = &quot;hahah&quot;
    constructor(name:string,age:number)&#123;
        //在new的时候执行
        console.log(this)//表示当前的dog对昂
        this.name = name
        this.age =age
    &#125;
&#125;
class Dog extends Animal&#123;
    sex : string
    constructor(name:string,age:number,sex:string)&#123;
        super(name,age)
        this.sex=sex
    &#125;
&#125;
class Cat extends Animal&#123;

&#125;
const dog =new Dog(&#39;xiaobai&#39;,18)
</code></pre>
<p>这样才可以确定继承的正常进行</p>
<p><strong>抽象类</strong></p>
<p>上述我们使用animals作为父类</p>
<p>那么我们也可以实例化父类</p>
<p>但是我们不希望实例化父类</p>
<p>所以我们就可以把父类定义为抽象类</p>
<p>这样他就实例化不了了		</p>
<pre><code class="ts"> abstract class Animal&#123;
    name:string
    age:number
    constructor(name:string,age:number)&#123;
        this.name = name
        this.age =age
    &#125;
    bark()&#123;
        console.log(&#39;汪汪汪&#39;)
    &#125;
&#125;
class Dog extends Animal&#123;

&#125;
const dog =new Dog(&quot;haha&quot;,180)
console.log(dog)
dog.bark()
 // const person = new Animal()
</code></pre>
<p><strong>抽象类和其他的类区别不大</strong>，只是不能实例对象</p>
<p>避免了类创建对象</p>
<p><strong>抽象方法</strong></p>
<p><strong>在方法之前加入abstract，而且只能定义在抽象类中</strong></p>
<p><strong>而且，子类都要重写这个方法</strong></p>
<pre><code class="ts"> abstract class Animal&#123;
    name:string
    age:number
    constructor(name:string,age:number)&#123;
        this.name = name
        this.age =age
    &#125;
    bark()&#123;
        console.log(&#39;汪汪汪&#39;)
    &#125;
     abstract fn()&#123;
         console.log(‘hahah)
     &#125;
     
&#125;
class Dog extends Animal&#123;
    fn()&#123;
        console.log(&quot;11111&quot;)
    &#125;
&#125;
const dog =new Dog(&quot;haha&quot;,180)
console.log(dog)
dog.bark()
 // const person = new Animal()
</code></pre>
<p>这样的抽象的方法就定义完成了</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a><strong>接口</strong></h2><p>和抽象类相似</p>
<pre><code class="ts">type myType=&#123;//type这里就是那个别名
    name:string
    age:number
    [propName:string]:any
&#125;
const obj:myType=&#123;
    name:&#39;sss&#39;
    age:18 
&#125;
</code></pre>
<p>我们除了使用上面的方法还可以使用接口的方法去定义</p>
<p>接口就是定义一个类或对象的解构</p>
<pre><code class="ts">type myType=&#123;//type这里就是那个别名
    name:string
    age:number
        [propName:string]:any
&#125;
interface myInterface&#123;
    name:string
    age:number
&#125;
const obj:myInterface=&#123;
    name:&#39;sss&#39;,
    age:18
&#125;
</code></pre>
<pre><code class="ts">type myType=&#123;//type这里就是那个别名
    name:string
    age:number
        [propName:string]:any
&#125;
interface myInterface&#123;
    name:string
    age:number
&#125;
interface myInterface&#123;
    sex:string
&#125;
const obj:myInterface=&#123;
    name:&#39;sss&#39;,
    age:18
    sex:&quot;nan&quot;
&#125;
</code></pre>
<p>两个接口可以何和在一起</p>
<p>接口所有的属性都不能有实际的值</p>
<p>接口只定义对象的结构，不考虑实际值</p>
<p>所有的方法都是抽象的</p>
<p>使用如下</p>
<pre><code class="ts">interface myInter&#123;
    name:string
    sayHi():void
&#125;
class person implements myInter&#123;
    name:&#39;huttu&#39;
    sayHi() &#123;
        console.log(&quot;hi&quot;)
    &#125;
&#125;
</code></pre>
<p>接口的作用？</p>
<p>就是对类的限制</p>
<p>这个时ts独有的</p>
<p><strong>属性的封装</strong></p>
<p>属性中的数据被修改是非常危险的</p>
<pre><code class="ts">class Person&#123;
    name:string
    age:number
    constructor(name:string,age:number)&#123;
        this.name = name
        this.age = age
    &#125;
&#125;
const person= new Person(&quot;hah&quot;,17)
person.age=20//容易被修改
</code></pre>
<p><strong>public：可以在任意的位置上读到</strong></p>
<p>当然也可以在子类中使用</p>
<pre><code class="ts">class Person &#123;
    public name:&#39;hahahah&#39;
&#125;
class leifen extends Person &#123;
    console.log(this.name)//这里是可以读到的因为是public
&#125;
</code></pre>
<p><strong>private：只能在类内部修改</strong></p>
<pre><code class="ts">class Person&#123;
    name:string
    private age:number
    constructor(name:string,age:number)&#123;
        this.name = name
        this.age = age//这里就是可以修改的
    &#125;
&#125;
const person= new Person(&quot;hah&quot;,17)
person.age=20//这里就会报错
</code></pre>
<p>如果外部真的想要读到的话</p>
<p>就在类中添加方法</p>
<pre><code class="ts">class Person&#123;
    name:string
    private age:number
    constructor(name:string,age:number)&#123;
        this.name = name
        this.age = age//这里就是可以修改的
    &#125;
    getName()&#123;
        console.log(this.age)
        return this.age
    &#125;
    setName(value:number)&#123;
        this.age=value
    &#125;
&#125;
const person= new Person(&quot;hah&quot;,17)
person.age=20//这里就会报错
person.getName
person.setName(20)
</code></pre>
<p>我们还可做一些限制</p>
<pre><code class="ts">class Person&#123;
    name:string
    private age:number
    constructor(name:string,age:number)&#123;
        this.name = name
        this.age = age//这里就是可以修改的
    &#125;
    getName()&#123;
        console.log(this.age)
        return this.age
    &#125;
    setName(value:number)&#123;
        if(value&gt;0)&#123;
            this.age=value
        &#125;
    &#125;
&#125;
const person= new Person(&quot;hah&quot;,17)
person.age=20//这里就会报错
person.getName
person.setName(20)
</code></pre>
<p>这样定义的总是有些麻烦</p>
<p>在修改值和获取值的时候总是要去调用这些函数</p>
<p>做代理</p>
<pre><code class="ts">class Person&#123;
    name:string
    private age:number
    constructor(name:string,age:number)&#123;
        this.name = name
        this.age = age//这里就是可以修改的
    &#125;
    get _age()&#123;
        return this.age
    &#125;
    set _age(value:number)&#123;
        this.age = value
    &#125;
&#125;
const person= new Person(&quot;hah&quot;,17)
person._age   //hah
person._age = 29
</code></pre>
<p><strong>protected</strong></p>
<p>只能和当前类和当前类的子类可以使用</p>
<pre><code class="ts">class Person &#123; 
    stastic protected name:&#39;hahahah&#39;
&#125;
class leifen extends Person &#123;
    console.log(this.name)//这里是可以读到
&#125;
console.log(Person.name)//这样时读不到的
</code></pre>
<p><strong>简单的写法</strong></p>
<pre><code class="ts">class Person&#123;
    public name:string
    public age:number
    constructor(name:string,age:number)&#123;
        this.name=name
        this.age=age
    &#125;
&#125;
const person =new Person(&#39;hahah&#39;,19)
</code></pre>
<p>可以写成这样，这两个时等价的</p>
<p><strong>语法糖</strong></p>
<pre><code class="ts">class Person&#123;
    constructor(public name:string,public age:number)&#123;
    &#125;
&#125;
const person =new Person(&#39;hahah&#39;,19)
</code></pre>
<p><strong>总结</strong></p>
<p>封装让对象中的类更加安全</p>
<p><strong>泛型</strong></p>
<pre><code class="ts">function fn(a:number):number&#123;
    return a;
&#125;
</code></pre>
<p>如果返回值的类型不确定</p>
<p>泛型就是不确定类型</p>
<pre><code class="ts">function fn&lt;T&gt;(a:T):T&#123;//这个T就是泛型
    return a
&#125;
fn(10)//里面就可以自动推断出类型，不指定泛型，Ts对类型进行推断
fn&lt;string&gt;(&#39;hello&#39;)//手动定义泛型
</code></pre>
<p>泛型可以指定多个</p>
<pre><code class="ts">function fn&lt;T,K&gt;(T,K):T&#123;
    return T
    console.log(&quot;T&quot;)
&#125;
fn(13,&quot;hell0&quot;)
fn&lt;number,string&gt;(13,&quot;hello&quot;)
</code></pre>
<p>还可以指定泛型的范围，有点看不懂了，真是天才  </p>
<pre><code class="ts">interface myInter&#123;
    length:number
&#125;
function fn&lt;T extends myInter&gt;(a:T):number	&#123;
    return a.length
&#125;
fn(&quot;123&quot;)
</code></pre>
<p>解释一下</p>
<p>fn传过去字符123</p>
<p>T就是string的类型，因为继承myInter所以就有指定length方法的值是number，彻底通透明白了</p>
<pre><code>T extends myInter，表示泛型T必须是myInter的实现类（抽象类）
</code></pre>
<p><strong>总结</strong></p>
<p><strong>接口和泛型都是锦上添花的东西</strong></p>
<hr>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 哈哈哈哈哈哈哈重生之我是兵王
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;chenw
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
